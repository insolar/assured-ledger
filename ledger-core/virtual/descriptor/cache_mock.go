package descriptor

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/reference"
)

// CacheMock implements Cache
type CacheMock struct {
	t minimock.Tester

	funcByClassRef          func(ctx context.Context, classRef reference.Global) (c2 Class, c3 Code, err error)
	inspectFuncByClassRef   func(ctx context.Context, classRef reference.Global)
	afterByClassRefCounter  uint64
	beforeByClassRefCounter uint64
	ByClassRefMock          mCacheMockByClassRef

	funcRegisterCallback          func(cb CacheCallbackType)
	inspectFuncRegisterCallback   func(cb CacheCallbackType)
	afterRegisterCallbackCounter  uint64
	beforeRegisterCallbackCounter uint64
	RegisterCallbackMock          mCacheMockRegisterCallback
}

// NewCacheMock returns a mock for Cache
func NewCacheMock(t minimock.Tester) *CacheMock {
	m := &CacheMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ByClassRefMock = mCacheMockByClassRef{mock: m}
	m.ByClassRefMock.callArgs = []*CacheMockByClassRefParams{}

	m.RegisterCallbackMock = mCacheMockRegisterCallback{mock: m}
	m.RegisterCallbackMock.callArgs = []*CacheMockRegisterCallbackParams{}

	return m
}

type mCacheMockByClassRef struct {
	mock               *CacheMock
	defaultExpectation *CacheMockByClassRefExpectation
	expectations       []*CacheMockByClassRefExpectation

	callArgs []*CacheMockByClassRefParams
	mutex    sync.RWMutex
}

// CacheMockByClassRefExpectation specifies expectation struct of the Cache.ByClassRef
type CacheMockByClassRefExpectation struct {
	mock    *CacheMock
	params  *CacheMockByClassRefParams
	results *CacheMockByClassRefResults
	Counter uint64
}

// CacheMockByClassRefParams contains parameters of the Cache.ByClassRef
type CacheMockByClassRefParams struct {
	ctx      context.Context
	classRef reference.Global
}

// CacheMockByClassRefResults contains results of the Cache.ByClassRef
type CacheMockByClassRefResults struct {
	c2  Class
	c3  Code
	err error
}

// Expect sets up expected params for Cache.ByClassRef
func (mmByClassRef *mCacheMockByClassRef) Expect(ctx context.Context, classRef reference.Global) *mCacheMockByClassRef {
	if mmByClassRef.mock.funcByClassRef != nil {
		mmByClassRef.mock.t.Fatalf("CacheMock.ByClassRef mock is already set by Set")
	}

	if mmByClassRef.defaultExpectation == nil {
		mmByClassRef.defaultExpectation = &CacheMockByClassRefExpectation{}
	}

	mmByClassRef.defaultExpectation.params = &CacheMockByClassRefParams{ctx, classRef}
	for _, e := range mmByClassRef.expectations {
		if minimock.Equal(e.params, mmByClassRef.defaultExpectation.params) {
			mmByClassRef.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmByClassRef.defaultExpectation.params)
		}
	}

	return mmByClassRef
}

// Inspect accepts an inspector function that has same arguments as the Cache.ByClassRef
func (mmByClassRef *mCacheMockByClassRef) Inspect(f func(ctx context.Context, classRef reference.Global)) *mCacheMockByClassRef {
	if mmByClassRef.mock.inspectFuncByClassRef != nil {
		mmByClassRef.mock.t.Fatalf("Inspect function is already set for CacheMock.ByClassRef")
	}

	mmByClassRef.mock.inspectFuncByClassRef = f

	return mmByClassRef
}

// Return sets up results that will be returned by Cache.ByClassRef
func (mmByClassRef *mCacheMockByClassRef) Return(c2 Class, c3 Code, err error) *CacheMock {
	if mmByClassRef.mock.funcByClassRef != nil {
		mmByClassRef.mock.t.Fatalf("CacheMock.ByClassRef mock is already set by Set")
	}

	if mmByClassRef.defaultExpectation == nil {
		mmByClassRef.defaultExpectation = &CacheMockByClassRefExpectation{mock: mmByClassRef.mock}
	}
	mmByClassRef.defaultExpectation.results = &CacheMockByClassRefResults{c2, c3, err}
	return mmByClassRef.mock
}

//Set uses given function f to mock the Cache.ByClassRef method
func (mmByClassRef *mCacheMockByClassRef) Set(f func(ctx context.Context, classRef reference.Global) (c2 Class, c3 Code, err error)) *CacheMock {
	if mmByClassRef.defaultExpectation != nil {
		mmByClassRef.mock.t.Fatalf("Default expectation is already set for the Cache.ByClassRef method")
	}

	if len(mmByClassRef.expectations) > 0 {
		mmByClassRef.mock.t.Fatalf("Some expectations are already set for the Cache.ByClassRef method")
	}

	mmByClassRef.mock.funcByClassRef = f
	return mmByClassRef.mock
}

// When sets expectation for the Cache.ByClassRef which will trigger the result defined by the following
// Then helper
func (mmByClassRef *mCacheMockByClassRef) When(ctx context.Context, classRef reference.Global) *CacheMockByClassRefExpectation {
	if mmByClassRef.mock.funcByClassRef != nil {
		mmByClassRef.mock.t.Fatalf("CacheMock.ByClassRef mock is already set by Set")
	}

	expectation := &CacheMockByClassRefExpectation{
		mock:   mmByClassRef.mock,
		params: &CacheMockByClassRefParams{ctx, classRef},
	}
	mmByClassRef.expectations = append(mmByClassRef.expectations, expectation)
	return expectation
}

// Then sets up Cache.ByClassRef return parameters for the expectation previously defined by the When method
func (e *CacheMockByClassRefExpectation) Then(c2 Class, c3 Code, err error) *CacheMock {
	e.results = &CacheMockByClassRefResults{c2, c3, err}
	return e.mock
}

// ByClassRef implements Cache
func (mmByClassRef *CacheMock) ByClassRef(ctx context.Context, classRef reference.Global) (c2 Class, c3 Code, err error) {
	mm_atomic.AddUint64(&mmByClassRef.beforeByClassRefCounter, 1)
	defer mm_atomic.AddUint64(&mmByClassRef.afterByClassRefCounter, 1)

	if mmByClassRef.inspectFuncByClassRef != nil {
		mmByClassRef.inspectFuncByClassRef(ctx, classRef)
	}

	mm_params := &CacheMockByClassRefParams{ctx, classRef}

	// Record call args
	mmByClassRef.ByClassRefMock.mutex.Lock()
	mmByClassRef.ByClassRefMock.callArgs = append(mmByClassRef.ByClassRefMock.callArgs, mm_params)
	mmByClassRef.ByClassRefMock.mutex.Unlock()

	for _, e := range mmByClassRef.ByClassRefMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.c3, e.results.err
		}
	}

	if mmByClassRef.ByClassRefMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmByClassRef.ByClassRefMock.defaultExpectation.Counter, 1)
		mm_want := mmByClassRef.ByClassRefMock.defaultExpectation.params
		mm_got := CacheMockByClassRefParams{ctx, classRef}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmByClassRef.t.Errorf("CacheMock.ByClassRef got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmByClassRef.ByClassRefMock.defaultExpectation.results
		if mm_results == nil {
			mmByClassRef.t.Fatal("No results are set for the CacheMock.ByClassRef")
		}
		return (*mm_results).c2, (*mm_results).c3, (*mm_results).err
	}
	if mmByClassRef.funcByClassRef != nil {
		return mmByClassRef.funcByClassRef(ctx, classRef)
	}
	mmByClassRef.t.Fatalf("Unexpected call to CacheMock.ByClassRef. %v %v", ctx, classRef)
	return
}

// ByClassRefAfterCounter returns a count of finished CacheMock.ByClassRef invocations
func (mmByClassRef *CacheMock) ByClassRefAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmByClassRef.afterByClassRefCounter)
}

// ByClassRefBeforeCounter returns a count of CacheMock.ByClassRef invocations
func (mmByClassRef *CacheMock) ByClassRefBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmByClassRef.beforeByClassRefCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.ByClassRef.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmByClassRef *mCacheMockByClassRef) Calls() []*CacheMockByClassRefParams {
	mmByClassRef.mutex.RLock()

	argCopy := make([]*CacheMockByClassRefParams, len(mmByClassRef.callArgs))
	copy(argCopy, mmByClassRef.callArgs)

	mmByClassRef.mutex.RUnlock()

	return argCopy
}

// MinimockByClassRefDone returns true if the count of the ByClassRef invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockByClassRefDone() bool {
	for _, e := range m.ByClassRefMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ByClassRefMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterByClassRefCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcByClassRef != nil && mm_atomic.LoadUint64(&m.afterByClassRefCounter) < 1 {
		return false
	}
	return true
}

// MinimockByClassRefInspect logs each unmet expectation
func (m *CacheMock) MinimockByClassRefInspect() {
	for _, e := range m.ByClassRefMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.ByClassRef with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ByClassRefMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterByClassRefCounter) < 1 {
		if m.ByClassRefMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.ByClassRef")
		} else {
			m.t.Errorf("Expected call to CacheMock.ByClassRef with params: %#v", *m.ByClassRefMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcByClassRef != nil && mm_atomic.LoadUint64(&m.afterByClassRefCounter) < 1 {
		m.t.Error("Expected call to CacheMock.ByClassRef")
	}
}

type mCacheMockRegisterCallback struct {
	mock               *CacheMock
	defaultExpectation *CacheMockRegisterCallbackExpectation
	expectations       []*CacheMockRegisterCallbackExpectation

	callArgs []*CacheMockRegisterCallbackParams
	mutex    sync.RWMutex
}

// CacheMockRegisterCallbackExpectation specifies expectation struct of the Cache.RegisterCallback
type CacheMockRegisterCallbackExpectation struct {
	mock   *CacheMock
	params *CacheMockRegisterCallbackParams

	Counter uint64
}

// CacheMockRegisterCallbackParams contains parameters of the Cache.RegisterCallback
type CacheMockRegisterCallbackParams struct {
	cb CacheCallbackType
}

// Expect sets up expected params for Cache.RegisterCallback
func (mmRegisterCallback *mCacheMockRegisterCallback) Expect(cb CacheCallbackType) *mCacheMockRegisterCallback {
	if mmRegisterCallback.mock.funcRegisterCallback != nil {
		mmRegisterCallback.mock.t.Fatalf("CacheMock.RegisterCallback mock is already set by Set")
	}

	if mmRegisterCallback.defaultExpectation == nil {
		mmRegisterCallback.defaultExpectation = &CacheMockRegisterCallbackExpectation{}
	}

	mmRegisterCallback.defaultExpectation.params = &CacheMockRegisterCallbackParams{cb}
	for _, e := range mmRegisterCallback.expectations {
		if minimock.Equal(e.params, mmRegisterCallback.defaultExpectation.params) {
			mmRegisterCallback.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterCallback.defaultExpectation.params)
		}
	}

	return mmRegisterCallback
}

// Inspect accepts an inspector function that has same arguments as the Cache.RegisterCallback
func (mmRegisterCallback *mCacheMockRegisterCallback) Inspect(f func(cb CacheCallbackType)) *mCacheMockRegisterCallback {
	if mmRegisterCallback.mock.inspectFuncRegisterCallback != nil {
		mmRegisterCallback.mock.t.Fatalf("Inspect function is already set for CacheMock.RegisterCallback")
	}

	mmRegisterCallback.mock.inspectFuncRegisterCallback = f

	return mmRegisterCallback
}

// Return sets up results that will be returned by Cache.RegisterCallback
func (mmRegisterCallback *mCacheMockRegisterCallback) Return() *CacheMock {
	if mmRegisterCallback.mock.funcRegisterCallback != nil {
		mmRegisterCallback.mock.t.Fatalf("CacheMock.RegisterCallback mock is already set by Set")
	}

	if mmRegisterCallback.defaultExpectation == nil {
		mmRegisterCallback.defaultExpectation = &CacheMockRegisterCallbackExpectation{mock: mmRegisterCallback.mock}
	}

	return mmRegisterCallback.mock
}

//Set uses given function f to mock the Cache.RegisterCallback method
func (mmRegisterCallback *mCacheMockRegisterCallback) Set(f func(cb CacheCallbackType)) *CacheMock {
	if mmRegisterCallback.defaultExpectation != nil {
		mmRegisterCallback.mock.t.Fatalf("Default expectation is already set for the Cache.RegisterCallback method")
	}

	if len(mmRegisterCallback.expectations) > 0 {
		mmRegisterCallback.mock.t.Fatalf("Some expectations are already set for the Cache.RegisterCallback method")
	}

	mmRegisterCallback.mock.funcRegisterCallback = f
	return mmRegisterCallback.mock
}

// RegisterCallback implements Cache
func (mmRegisterCallback *CacheMock) RegisterCallback(cb CacheCallbackType) {
	mm_atomic.AddUint64(&mmRegisterCallback.beforeRegisterCallbackCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterCallback.afterRegisterCallbackCounter, 1)

	if mmRegisterCallback.inspectFuncRegisterCallback != nil {
		mmRegisterCallback.inspectFuncRegisterCallback(cb)
	}

	mm_params := &CacheMockRegisterCallbackParams{cb}

	// Record call args
	mmRegisterCallback.RegisterCallbackMock.mutex.Lock()
	mmRegisterCallback.RegisterCallbackMock.callArgs = append(mmRegisterCallback.RegisterCallbackMock.callArgs, mm_params)
	mmRegisterCallback.RegisterCallbackMock.mutex.Unlock()

	for _, e := range mmRegisterCallback.RegisterCallbackMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmRegisterCallback.RegisterCallbackMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterCallback.RegisterCallbackMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterCallback.RegisterCallbackMock.defaultExpectation.params
		mm_got := CacheMockRegisterCallbackParams{cb}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterCallback.t.Errorf("CacheMock.RegisterCallback got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmRegisterCallback.funcRegisterCallback != nil {
		mmRegisterCallback.funcRegisterCallback(cb)
		return
	}
	mmRegisterCallback.t.Fatalf("Unexpected call to CacheMock.RegisterCallback. %v", cb)

}

// RegisterCallbackAfterCounter returns a count of finished CacheMock.RegisterCallback invocations
func (mmRegisterCallback *CacheMock) RegisterCallbackAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterCallback.afterRegisterCallbackCounter)
}

// RegisterCallbackBeforeCounter returns a count of CacheMock.RegisterCallback invocations
func (mmRegisterCallback *CacheMock) RegisterCallbackBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterCallback.beforeRegisterCallbackCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.RegisterCallback.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterCallback *mCacheMockRegisterCallback) Calls() []*CacheMockRegisterCallbackParams {
	mmRegisterCallback.mutex.RLock()

	argCopy := make([]*CacheMockRegisterCallbackParams, len(mmRegisterCallback.callArgs))
	copy(argCopy, mmRegisterCallback.callArgs)

	mmRegisterCallback.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterCallbackDone returns true if the count of the RegisterCallback invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockRegisterCallbackDone() bool {
	for _, e := range m.RegisterCallbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterCallbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterCallbackCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterCallback != nil && mm_atomic.LoadUint64(&m.afterRegisterCallbackCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterCallbackInspect logs each unmet expectation
func (m *CacheMock) MinimockRegisterCallbackInspect() {
	for _, e := range m.RegisterCallbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.RegisterCallback with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterCallbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterCallbackCounter) < 1 {
		if m.RegisterCallbackMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.RegisterCallback")
		} else {
			m.t.Errorf("Expected call to CacheMock.RegisterCallback with params: %#v", *m.RegisterCallbackMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterCallback != nil && mm_atomic.LoadUint64(&m.afterRegisterCallbackCounter) < 1 {
		m.t.Error("Expected call to CacheMock.RegisterCallback")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CacheMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockByClassRefInspect()

		m.MinimockRegisterCallbackInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CacheMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CacheMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockByClassRefDone() &&
		m.MinimockRegisterCallbackDone()
}
