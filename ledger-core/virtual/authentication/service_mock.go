package authentication

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/insolar/payload"
	"github.com/insolar/assured-ledger/ledger-core/pulse"
	"github.com/insolar/assured-ledger/ledger-core/reference"
)

// ServiceMock implements Service
type ServiceMock struct {
	t minimock.Tester

	funcGetCallDelegationToken          func(outgoing reference.Global, to reference.Global, pn pulse.Number, object reference.Global) (c1 payload.CallDelegationToken)
	inspectFuncGetCallDelegationToken   func(outgoing reference.Global, to reference.Global, pn pulse.Number, object reference.Global)
	afterGetCallDelegationTokenCounter  uint64
	beforeGetCallDelegationTokenCounter uint64
	GetCallDelegationTokenMock          mServiceMockGetCallDelegationToken

	funcHasToSendToken          func(token payload.CallDelegationToken) (b1 bool)
	inspectFuncHasToSendToken   func(token payload.CallDelegationToken)
	afterHasToSendTokenCounter  uint64
	beforeHasToSendTokenCounter uint64
	HasToSendTokenMock          mServiceMockHasToSendToken

	funcIsMessageFromVirtualLegitimate          func(ctx context.Context, payloadObj interface{}, sender reference.Global, pr pulse.Range) (mustReject bool, err error)
	inspectFuncIsMessageFromVirtualLegitimate   func(ctx context.Context, payloadObj interface{}, sender reference.Global, pr pulse.Range)
	afterIsMessageFromVirtualLegitimateCounter  uint64
	beforeIsMessageFromVirtualLegitimateCounter uint64
	IsMessageFromVirtualLegitimateMock          mServiceMockIsMessageFromVirtualLegitimate
}

// NewServiceMock returns a mock for Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetCallDelegationTokenMock = mServiceMockGetCallDelegationToken{mock: m}
	m.GetCallDelegationTokenMock.callArgs = []*ServiceMockGetCallDelegationTokenParams{}

	m.HasToSendTokenMock = mServiceMockHasToSendToken{mock: m}
	m.HasToSendTokenMock.callArgs = []*ServiceMockHasToSendTokenParams{}

	m.IsMessageFromVirtualLegitimateMock = mServiceMockIsMessageFromVirtualLegitimate{mock: m}
	m.IsMessageFromVirtualLegitimateMock.callArgs = []*ServiceMockIsMessageFromVirtualLegitimateParams{}

	return m
}

type mServiceMockGetCallDelegationToken struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetCallDelegationTokenExpectation
	expectations       []*ServiceMockGetCallDelegationTokenExpectation

	callArgs []*ServiceMockGetCallDelegationTokenParams
	mutex    sync.RWMutex
}

// ServiceMockGetCallDelegationTokenExpectation specifies expectation struct of the Service.GetCallDelegationToken
type ServiceMockGetCallDelegationTokenExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockGetCallDelegationTokenParams
	results *ServiceMockGetCallDelegationTokenResults
	Counter uint64
}

// ServiceMockGetCallDelegationTokenParams contains parameters of the Service.GetCallDelegationToken
type ServiceMockGetCallDelegationTokenParams struct {
	outgoing reference.Global
	to       reference.Global
	pn       pulse.Number
	object   reference.Global
}

// ServiceMockGetCallDelegationTokenResults contains results of the Service.GetCallDelegationToken
type ServiceMockGetCallDelegationTokenResults struct {
	c1 payload.CallDelegationToken
}

// Expect sets up expected params for Service.GetCallDelegationToken
func (mmGetCallDelegationToken *mServiceMockGetCallDelegationToken) Expect(outgoing reference.Global, to reference.Global, pn pulse.Number, object reference.Global) *mServiceMockGetCallDelegationToken {
	if mmGetCallDelegationToken.mock.funcGetCallDelegationToken != nil {
		mmGetCallDelegationToken.mock.t.Fatalf("ServiceMock.GetCallDelegationToken mock is already set by Set")
	}

	if mmGetCallDelegationToken.defaultExpectation == nil {
		mmGetCallDelegationToken.defaultExpectation = &ServiceMockGetCallDelegationTokenExpectation{}
	}

	mmGetCallDelegationToken.defaultExpectation.params = &ServiceMockGetCallDelegationTokenParams{outgoing, to, pn, object}
	for _, e := range mmGetCallDelegationToken.expectations {
		if minimock.Equal(e.params, mmGetCallDelegationToken.defaultExpectation.params) {
			mmGetCallDelegationToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCallDelegationToken.defaultExpectation.params)
		}
	}

	return mmGetCallDelegationToken
}

// Inspect accepts an inspector function that has same arguments as the Service.GetCallDelegationToken
func (mmGetCallDelegationToken *mServiceMockGetCallDelegationToken) Inspect(f func(outgoing reference.Global, to reference.Global, pn pulse.Number, object reference.Global)) *mServiceMockGetCallDelegationToken {
	if mmGetCallDelegationToken.mock.inspectFuncGetCallDelegationToken != nil {
		mmGetCallDelegationToken.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetCallDelegationToken")
	}

	mmGetCallDelegationToken.mock.inspectFuncGetCallDelegationToken = f

	return mmGetCallDelegationToken
}

// Return sets up results that will be returned by Service.GetCallDelegationToken
func (mmGetCallDelegationToken *mServiceMockGetCallDelegationToken) Return(c1 payload.CallDelegationToken) *ServiceMock {
	if mmGetCallDelegationToken.mock.funcGetCallDelegationToken != nil {
		mmGetCallDelegationToken.mock.t.Fatalf("ServiceMock.GetCallDelegationToken mock is already set by Set")
	}

	if mmGetCallDelegationToken.defaultExpectation == nil {
		mmGetCallDelegationToken.defaultExpectation = &ServiceMockGetCallDelegationTokenExpectation{mock: mmGetCallDelegationToken.mock}
	}
	mmGetCallDelegationToken.defaultExpectation.results = &ServiceMockGetCallDelegationTokenResults{c1}
	return mmGetCallDelegationToken.mock
}

//Set uses given function f to mock the Service.GetCallDelegationToken method
func (mmGetCallDelegationToken *mServiceMockGetCallDelegationToken) Set(f func(outgoing reference.Global, to reference.Global, pn pulse.Number, object reference.Global) (c1 payload.CallDelegationToken)) *ServiceMock {
	if mmGetCallDelegationToken.defaultExpectation != nil {
		mmGetCallDelegationToken.mock.t.Fatalf("Default expectation is already set for the Service.GetCallDelegationToken method")
	}

	if len(mmGetCallDelegationToken.expectations) > 0 {
		mmGetCallDelegationToken.mock.t.Fatalf("Some expectations are already set for the Service.GetCallDelegationToken method")
	}

	mmGetCallDelegationToken.mock.funcGetCallDelegationToken = f
	return mmGetCallDelegationToken.mock
}

// When sets expectation for the Service.GetCallDelegationToken which will trigger the result defined by the following
// Then helper
func (mmGetCallDelegationToken *mServiceMockGetCallDelegationToken) When(outgoing reference.Global, to reference.Global, pn pulse.Number, object reference.Global) *ServiceMockGetCallDelegationTokenExpectation {
	if mmGetCallDelegationToken.mock.funcGetCallDelegationToken != nil {
		mmGetCallDelegationToken.mock.t.Fatalf("ServiceMock.GetCallDelegationToken mock is already set by Set")
	}

	expectation := &ServiceMockGetCallDelegationTokenExpectation{
		mock:   mmGetCallDelegationToken.mock,
		params: &ServiceMockGetCallDelegationTokenParams{outgoing, to, pn, object},
	}
	mmGetCallDelegationToken.expectations = append(mmGetCallDelegationToken.expectations, expectation)
	return expectation
}

// Then sets up Service.GetCallDelegationToken return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetCallDelegationTokenExpectation) Then(c1 payload.CallDelegationToken) *ServiceMock {
	e.results = &ServiceMockGetCallDelegationTokenResults{c1}
	return e.mock
}

// GetCallDelegationToken implements Service
func (mmGetCallDelegationToken *ServiceMock) GetCallDelegationToken(outgoing reference.Global, to reference.Global, pn pulse.Number, object reference.Global) (c1 payload.CallDelegationToken) {
	mm_atomic.AddUint64(&mmGetCallDelegationToken.beforeGetCallDelegationTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCallDelegationToken.afterGetCallDelegationTokenCounter, 1)

	if mmGetCallDelegationToken.inspectFuncGetCallDelegationToken != nil {
		mmGetCallDelegationToken.inspectFuncGetCallDelegationToken(outgoing, to, pn, object)
	}

	mm_params := &ServiceMockGetCallDelegationTokenParams{outgoing, to, pn, object}

	// Record call args
	mmGetCallDelegationToken.GetCallDelegationTokenMock.mutex.Lock()
	mmGetCallDelegationToken.GetCallDelegationTokenMock.callArgs = append(mmGetCallDelegationToken.GetCallDelegationTokenMock.callArgs, mm_params)
	mmGetCallDelegationToken.GetCallDelegationTokenMock.mutex.Unlock()

	for _, e := range mmGetCallDelegationToken.GetCallDelegationTokenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c1
		}
	}

	if mmGetCallDelegationToken.GetCallDelegationTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCallDelegationToken.GetCallDelegationTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCallDelegationToken.GetCallDelegationTokenMock.defaultExpectation.params
		mm_got := ServiceMockGetCallDelegationTokenParams{outgoing, to, pn, object}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCallDelegationToken.t.Errorf("ServiceMock.GetCallDelegationToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCallDelegationToken.GetCallDelegationTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCallDelegationToken.t.Fatal("No results are set for the ServiceMock.GetCallDelegationToken")
		}
		return (*mm_results).c1
	}
	if mmGetCallDelegationToken.funcGetCallDelegationToken != nil {
		return mmGetCallDelegationToken.funcGetCallDelegationToken(outgoing, to, pn, object)
	}
	mmGetCallDelegationToken.t.Fatalf("Unexpected call to ServiceMock.GetCallDelegationToken. %v %v %v %v", outgoing, to, pn, object)
	return
}

// GetCallDelegationTokenAfterCounter returns a count of finished ServiceMock.GetCallDelegationToken invocations
func (mmGetCallDelegationToken *ServiceMock) GetCallDelegationTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCallDelegationToken.afterGetCallDelegationTokenCounter)
}

// GetCallDelegationTokenBeforeCounter returns a count of ServiceMock.GetCallDelegationToken invocations
func (mmGetCallDelegationToken *ServiceMock) GetCallDelegationTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCallDelegationToken.beforeGetCallDelegationTokenCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetCallDelegationToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCallDelegationToken *mServiceMockGetCallDelegationToken) Calls() []*ServiceMockGetCallDelegationTokenParams {
	mmGetCallDelegationToken.mutex.RLock()

	argCopy := make([]*ServiceMockGetCallDelegationTokenParams, len(mmGetCallDelegationToken.callArgs))
	copy(argCopy, mmGetCallDelegationToken.callArgs)

	mmGetCallDelegationToken.mutex.RUnlock()

	return argCopy
}

// MinimockGetCallDelegationTokenDone returns true if the count of the GetCallDelegationToken invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetCallDelegationTokenDone() bool {
	for _, e := range m.GetCallDelegationTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCallDelegationTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCallDelegationTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCallDelegationToken != nil && mm_atomic.LoadUint64(&m.afterGetCallDelegationTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCallDelegationTokenInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetCallDelegationTokenInspect() {
	for _, e := range m.GetCallDelegationTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetCallDelegationToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCallDelegationTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCallDelegationTokenCounter) < 1 {
		if m.GetCallDelegationTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.GetCallDelegationToken")
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetCallDelegationToken with params: %#v", *m.GetCallDelegationTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCallDelegationToken != nil && mm_atomic.LoadUint64(&m.afterGetCallDelegationTokenCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.GetCallDelegationToken")
	}
}

type mServiceMockHasToSendToken struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockHasToSendTokenExpectation
	expectations       []*ServiceMockHasToSendTokenExpectation

	callArgs []*ServiceMockHasToSendTokenParams
	mutex    sync.RWMutex
}

// ServiceMockHasToSendTokenExpectation specifies expectation struct of the Service.HasToSendToken
type ServiceMockHasToSendTokenExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockHasToSendTokenParams
	results *ServiceMockHasToSendTokenResults
	Counter uint64
}

// ServiceMockHasToSendTokenParams contains parameters of the Service.HasToSendToken
type ServiceMockHasToSendTokenParams struct {
	token payload.CallDelegationToken
}

// ServiceMockHasToSendTokenResults contains results of the Service.HasToSendToken
type ServiceMockHasToSendTokenResults struct {
	b1 bool
}

// Expect sets up expected params for Service.HasToSendToken
func (mmHasToSendToken *mServiceMockHasToSendToken) Expect(token payload.CallDelegationToken) *mServiceMockHasToSendToken {
	if mmHasToSendToken.mock.funcHasToSendToken != nil {
		mmHasToSendToken.mock.t.Fatalf("ServiceMock.HasToSendToken mock is already set by Set")
	}

	if mmHasToSendToken.defaultExpectation == nil {
		mmHasToSendToken.defaultExpectation = &ServiceMockHasToSendTokenExpectation{}
	}

	mmHasToSendToken.defaultExpectation.params = &ServiceMockHasToSendTokenParams{token}
	for _, e := range mmHasToSendToken.expectations {
		if minimock.Equal(e.params, mmHasToSendToken.defaultExpectation.params) {
			mmHasToSendToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHasToSendToken.defaultExpectation.params)
		}
	}

	return mmHasToSendToken
}

// Inspect accepts an inspector function that has same arguments as the Service.HasToSendToken
func (mmHasToSendToken *mServiceMockHasToSendToken) Inspect(f func(token payload.CallDelegationToken)) *mServiceMockHasToSendToken {
	if mmHasToSendToken.mock.inspectFuncHasToSendToken != nil {
		mmHasToSendToken.mock.t.Fatalf("Inspect function is already set for ServiceMock.HasToSendToken")
	}

	mmHasToSendToken.mock.inspectFuncHasToSendToken = f

	return mmHasToSendToken
}

// Return sets up results that will be returned by Service.HasToSendToken
func (mmHasToSendToken *mServiceMockHasToSendToken) Return(b1 bool) *ServiceMock {
	if mmHasToSendToken.mock.funcHasToSendToken != nil {
		mmHasToSendToken.mock.t.Fatalf("ServiceMock.HasToSendToken mock is already set by Set")
	}

	if mmHasToSendToken.defaultExpectation == nil {
		mmHasToSendToken.defaultExpectation = &ServiceMockHasToSendTokenExpectation{mock: mmHasToSendToken.mock}
	}
	mmHasToSendToken.defaultExpectation.results = &ServiceMockHasToSendTokenResults{b1}
	return mmHasToSendToken.mock
}

//Set uses given function f to mock the Service.HasToSendToken method
func (mmHasToSendToken *mServiceMockHasToSendToken) Set(f func(token payload.CallDelegationToken) (b1 bool)) *ServiceMock {
	if mmHasToSendToken.defaultExpectation != nil {
		mmHasToSendToken.mock.t.Fatalf("Default expectation is already set for the Service.HasToSendToken method")
	}

	if len(mmHasToSendToken.expectations) > 0 {
		mmHasToSendToken.mock.t.Fatalf("Some expectations are already set for the Service.HasToSendToken method")
	}

	mmHasToSendToken.mock.funcHasToSendToken = f
	return mmHasToSendToken.mock
}

// When sets expectation for the Service.HasToSendToken which will trigger the result defined by the following
// Then helper
func (mmHasToSendToken *mServiceMockHasToSendToken) When(token payload.CallDelegationToken) *ServiceMockHasToSendTokenExpectation {
	if mmHasToSendToken.mock.funcHasToSendToken != nil {
		mmHasToSendToken.mock.t.Fatalf("ServiceMock.HasToSendToken mock is already set by Set")
	}

	expectation := &ServiceMockHasToSendTokenExpectation{
		mock:   mmHasToSendToken.mock,
		params: &ServiceMockHasToSendTokenParams{token},
	}
	mmHasToSendToken.expectations = append(mmHasToSendToken.expectations, expectation)
	return expectation
}

// Then sets up Service.HasToSendToken return parameters for the expectation previously defined by the When method
func (e *ServiceMockHasToSendTokenExpectation) Then(b1 bool) *ServiceMock {
	e.results = &ServiceMockHasToSendTokenResults{b1}
	return e.mock
}

// HasToSendToken implements Service
func (mmHasToSendToken *ServiceMock) HasToSendToken(token payload.CallDelegationToken) (b1 bool) {
	mm_atomic.AddUint64(&mmHasToSendToken.beforeHasToSendTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmHasToSendToken.afterHasToSendTokenCounter, 1)

	if mmHasToSendToken.inspectFuncHasToSendToken != nil {
		mmHasToSendToken.inspectFuncHasToSendToken(token)
	}

	mm_params := &ServiceMockHasToSendTokenParams{token}

	// Record call args
	mmHasToSendToken.HasToSendTokenMock.mutex.Lock()
	mmHasToSendToken.HasToSendTokenMock.callArgs = append(mmHasToSendToken.HasToSendTokenMock.callArgs, mm_params)
	mmHasToSendToken.HasToSendTokenMock.mutex.Unlock()

	for _, e := range mmHasToSendToken.HasToSendTokenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmHasToSendToken.HasToSendTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHasToSendToken.HasToSendTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmHasToSendToken.HasToSendTokenMock.defaultExpectation.params
		mm_got := ServiceMockHasToSendTokenParams{token}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHasToSendToken.t.Errorf("ServiceMock.HasToSendToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHasToSendToken.HasToSendTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmHasToSendToken.t.Fatal("No results are set for the ServiceMock.HasToSendToken")
		}
		return (*mm_results).b1
	}
	if mmHasToSendToken.funcHasToSendToken != nil {
		return mmHasToSendToken.funcHasToSendToken(token)
	}
	mmHasToSendToken.t.Fatalf("Unexpected call to ServiceMock.HasToSendToken. %v", token)
	return
}

// HasToSendTokenAfterCounter returns a count of finished ServiceMock.HasToSendToken invocations
func (mmHasToSendToken *ServiceMock) HasToSendTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasToSendToken.afterHasToSendTokenCounter)
}

// HasToSendTokenBeforeCounter returns a count of ServiceMock.HasToSendToken invocations
func (mmHasToSendToken *ServiceMock) HasToSendTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasToSendToken.beforeHasToSendTokenCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.HasToSendToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHasToSendToken *mServiceMockHasToSendToken) Calls() []*ServiceMockHasToSendTokenParams {
	mmHasToSendToken.mutex.RLock()

	argCopy := make([]*ServiceMockHasToSendTokenParams, len(mmHasToSendToken.callArgs))
	copy(argCopy, mmHasToSendToken.callArgs)

	mmHasToSendToken.mutex.RUnlock()

	return argCopy
}

// MinimockHasToSendTokenDone returns true if the count of the HasToSendToken invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockHasToSendTokenDone() bool {
	for _, e := range m.HasToSendTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasToSendTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasToSendTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasToSendToken != nil && mm_atomic.LoadUint64(&m.afterHasToSendTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockHasToSendTokenInspect logs each unmet expectation
func (m *ServiceMock) MinimockHasToSendTokenInspect() {
	for _, e := range m.HasToSendTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.HasToSendToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasToSendTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasToSendTokenCounter) < 1 {
		if m.HasToSendTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.HasToSendToken")
		} else {
			m.t.Errorf("Expected call to ServiceMock.HasToSendToken with params: %#v", *m.HasToSendTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasToSendToken != nil && mm_atomic.LoadUint64(&m.afterHasToSendTokenCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.HasToSendToken")
	}
}

type mServiceMockIsMessageFromVirtualLegitimate struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockIsMessageFromVirtualLegitimateExpectation
	expectations       []*ServiceMockIsMessageFromVirtualLegitimateExpectation

	callArgs []*ServiceMockIsMessageFromVirtualLegitimateParams
	mutex    sync.RWMutex
}

// ServiceMockIsMessageFromVirtualLegitimateExpectation specifies expectation struct of the Service.IsMessageFromVirtualLegitimate
type ServiceMockIsMessageFromVirtualLegitimateExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockIsMessageFromVirtualLegitimateParams
	results *ServiceMockIsMessageFromVirtualLegitimateResults
	Counter uint64
}

// ServiceMockIsMessageFromVirtualLegitimateParams contains parameters of the Service.IsMessageFromVirtualLegitimate
type ServiceMockIsMessageFromVirtualLegitimateParams struct {
	ctx        context.Context
	payloadObj interface{}
	sender     reference.Global
	pr         pulse.Range
}

// ServiceMockIsMessageFromVirtualLegitimateResults contains results of the Service.IsMessageFromVirtualLegitimate
type ServiceMockIsMessageFromVirtualLegitimateResults struct {
	mustReject bool
	err        error
}

// Expect sets up expected params for Service.IsMessageFromVirtualLegitimate
func (mmIsMessageFromVirtualLegitimate *mServiceMockIsMessageFromVirtualLegitimate) Expect(ctx context.Context, payloadObj interface{}, sender reference.Global, pr pulse.Range) *mServiceMockIsMessageFromVirtualLegitimate {
	if mmIsMessageFromVirtualLegitimate.mock.funcIsMessageFromVirtualLegitimate != nil {
		mmIsMessageFromVirtualLegitimate.mock.t.Fatalf("ServiceMock.IsMessageFromVirtualLegitimate mock is already set by Set")
	}

	if mmIsMessageFromVirtualLegitimate.defaultExpectation == nil {
		mmIsMessageFromVirtualLegitimate.defaultExpectation = &ServiceMockIsMessageFromVirtualLegitimateExpectation{}
	}

	mmIsMessageFromVirtualLegitimate.defaultExpectation.params = &ServiceMockIsMessageFromVirtualLegitimateParams{ctx, payloadObj, sender, pr}
	for _, e := range mmIsMessageFromVirtualLegitimate.expectations {
		if minimock.Equal(e.params, mmIsMessageFromVirtualLegitimate.defaultExpectation.params) {
			mmIsMessageFromVirtualLegitimate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsMessageFromVirtualLegitimate.defaultExpectation.params)
		}
	}

	return mmIsMessageFromVirtualLegitimate
}

// Inspect accepts an inspector function that has same arguments as the Service.IsMessageFromVirtualLegitimate
func (mmIsMessageFromVirtualLegitimate *mServiceMockIsMessageFromVirtualLegitimate) Inspect(f func(ctx context.Context, payloadObj interface{}, sender reference.Global, pr pulse.Range)) *mServiceMockIsMessageFromVirtualLegitimate {
	if mmIsMessageFromVirtualLegitimate.mock.inspectFuncIsMessageFromVirtualLegitimate != nil {
		mmIsMessageFromVirtualLegitimate.mock.t.Fatalf("Inspect function is already set for ServiceMock.IsMessageFromVirtualLegitimate")
	}

	mmIsMessageFromVirtualLegitimate.mock.inspectFuncIsMessageFromVirtualLegitimate = f

	return mmIsMessageFromVirtualLegitimate
}

// Return sets up results that will be returned by Service.IsMessageFromVirtualLegitimate
func (mmIsMessageFromVirtualLegitimate *mServiceMockIsMessageFromVirtualLegitimate) Return(mustReject bool, err error) *ServiceMock {
	if mmIsMessageFromVirtualLegitimate.mock.funcIsMessageFromVirtualLegitimate != nil {
		mmIsMessageFromVirtualLegitimate.mock.t.Fatalf("ServiceMock.IsMessageFromVirtualLegitimate mock is already set by Set")
	}

	if mmIsMessageFromVirtualLegitimate.defaultExpectation == nil {
		mmIsMessageFromVirtualLegitimate.defaultExpectation = &ServiceMockIsMessageFromVirtualLegitimateExpectation{mock: mmIsMessageFromVirtualLegitimate.mock}
	}
	mmIsMessageFromVirtualLegitimate.defaultExpectation.results = &ServiceMockIsMessageFromVirtualLegitimateResults{mustReject, err}
	return mmIsMessageFromVirtualLegitimate.mock
}

//Set uses given function f to mock the Service.IsMessageFromVirtualLegitimate method
func (mmIsMessageFromVirtualLegitimate *mServiceMockIsMessageFromVirtualLegitimate) Set(f func(ctx context.Context, payloadObj interface{}, sender reference.Global, pr pulse.Range) (mustReject bool, err error)) *ServiceMock {
	if mmIsMessageFromVirtualLegitimate.defaultExpectation != nil {
		mmIsMessageFromVirtualLegitimate.mock.t.Fatalf("Default expectation is already set for the Service.IsMessageFromVirtualLegitimate method")
	}

	if len(mmIsMessageFromVirtualLegitimate.expectations) > 0 {
		mmIsMessageFromVirtualLegitimate.mock.t.Fatalf("Some expectations are already set for the Service.IsMessageFromVirtualLegitimate method")
	}

	mmIsMessageFromVirtualLegitimate.mock.funcIsMessageFromVirtualLegitimate = f
	return mmIsMessageFromVirtualLegitimate.mock
}

// When sets expectation for the Service.IsMessageFromVirtualLegitimate which will trigger the result defined by the following
// Then helper
func (mmIsMessageFromVirtualLegitimate *mServiceMockIsMessageFromVirtualLegitimate) When(ctx context.Context, payloadObj interface{}, sender reference.Global, pr pulse.Range) *ServiceMockIsMessageFromVirtualLegitimateExpectation {
	if mmIsMessageFromVirtualLegitimate.mock.funcIsMessageFromVirtualLegitimate != nil {
		mmIsMessageFromVirtualLegitimate.mock.t.Fatalf("ServiceMock.IsMessageFromVirtualLegitimate mock is already set by Set")
	}

	expectation := &ServiceMockIsMessageFromVirtualLegitimateExpectation{
		mock:   mmIsMessageFromVirtualLegitimate.mock,
		params: &ServiceMockIsMessageFromVirtualLegitimateParams{ctx, payloadObj, sender, pr},
	}
	mmIsMessageFromVirtualLegitimate.expectations = append(mmIsMessageFromVirtualLegitimate.expectations, expectation)
	return expectation
}

// Then sets up Service.IsMessageFromVirtualLegitimate return parameters for the expectation previously defined by the When method
func (e *ServiceMockIsMessageFromVirtualLegitimateExpectation) Then(mustReject bool, err error) *ServiceMock {
	e.results = &ServiceMockIsMessageFromVirtualLegitimateResults{mustReject, err}
	return e.mock
}

// IsMessageFromVirtualLegitimate implements Service
func (mmIsMessageFromVirtualLegitimate *ServiceMock) IsMessageFromVirtualLegitimate(ctx context.Context, payloadObj interface{}, sender reference.Global, pr pulse.Range) (mustReject bool, err error) {
	mm_atomic.AddUint64(&mmIsMessageFromVirtualLegitimate.beforeIsMessageFromVirtualLegitimateCounter, 1)
	defer mm_atomic.AddUint64(&mmIsMessageFromVirtualLegitimate.afterIsMessageFromVirtualLegitimateCounter, 1)

	if mmIsMessageFromVirtualLegitimate.inspectFuncIsMessageFromVirtualLegitimate != nil {
		mmIsMessageFromVirtualLegitimate.inspectFuncIsMessageFromVirtualLegitimate(ctx, payloadObj, sender, pr)
	}

	mm_params := &ServiceMockIsMessageFromVirtualLegitimateParams{ctx, payloadObj, sender, pr}

	// Record call args
	mmIsMessageFromVirtualLegitimate.IsMessageFromVirtualLegitimateMock.mutex.Lock()
	mmIsMessageFromVirtualLegitimate.IsMessageFromVirtualLegitimateMock.callArgs = append(mmIsMessageFromVirtualLegitimate.IsMessageFromVirtualLegitimateMock.callArgs, mm_params)
	mmIsMessageFromVirtualLegitimate.IsMessageFromVirtualLegitimateMock.mutex.Unlock()

	for _, e := range mmIsMessageFromVirtualLegitimate.IsMessageFromVirtualLegitimateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mustReject, e.results.err
		}
	}

	if mmIsMessageFromVirtualLegitimate.IsMessageFromVirtualLegitimateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsMessageFromVirtualLegitimate.IsMessageFromVirtualLegitimateMock.defaultExpectation.Counter, 1)
		mm_want := mmIsMessageFromVirtualLegitimate.IsMessageFromVirtualLegitimateMock.defaultExpectation.params
		mm_got := ServiceMockIsMessageFromVirtualLegitimateParams{ctx, payloadObj, sender, pr}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsMessageFromVirtualLegitimate.t.Errorf("ServiceMock.IsMessageFromVirtualLegitimate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsMessageFromVirtualLegitimate.IsMessageFromVirtualLegitimateMock.defaultExpectation.results
		if mm_results == nil {
			mmIsMessageFromVirtualLegitimate.t.Fatal("No results are set for the ServiceMock.IsMessageFromVirtualLegitimate")
		}
		return (*mm_results).mustReject, (*mm_results).err
	}
	if mmIsMessageFromVirtualLegitimate.funcIsMessageFromVirtualLegitimate != nil {
		return mmIsMessageFromVirtualLegitimate.funcIsMessageFromVirtualLegitimate(ctx, payloadObj, sender, pr)
	}
	mmIsMessageFromVirtualLegitimate.t.Fatalf("Unexpected call to ServiceMock.IsMessageFromVirtualLegitimate. %v %v %v %v", ctx, payloadObj, sender, pr)
	return
}

// IsMessageFromVirtualLegitimateAfterCounter returns a count of finished ServiceMock.IsMessageFromVirtualLegitimate invocations
func (mmIsMessageFromVirtualLegitimate *ServiceMock) IsMessageFromVirtualLegitimateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsMessageFromVirtualLegitimate.afterIsMessageFromVirtualLegitimateCounter)
}

// IsMessageFromVirtualLegitimateBeforeCounter returns a count of ServiceMock.IsMessageFromVirtualLegitimate invocations
func (mmIsMessageFromVirtualLegitimate *ServiceMock) IsMessageFromVirtualLegitimateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsMessageFromVirtualLegitimate.beforeIsMessageFromVirtualLegitimateCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.IsMessageFromVirtualLegitimate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsMessageFromVirtualLegitimate *mServiceMockIsMessageFromVirtualLegitimate) Calls() []*ServiceMockIsMessageFromVirtualLegitimateParams {
	mmIsMessageFromVirtualLegitimate.mutex.RLock()

	argCopy := make([]*ServiceMockIsMessageFromVirtualLegitimateParams, len(mmIsMessageFromVirtualLegitimate.callArgs))
	copy(argCopy, mmIsMessageFromVirtualLegitimate.callArgs)

	mmIsMessageFromVirtualLegitimate.mutex.RUnlock()

	return argCopy
}

// MinimockIsMessageFromVirtualLegitimateDone returns true if the count of the IsMessageFromVirtualLegitimate invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockIsMessageFromVirtualLegitimateDone() bool {
	for _, e := range m.IsMessageFromVirtualLegitimateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsMessageFromVirtualLegitimateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsMessageFromVirtualLegitimateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsMessageFromVirtualLegitimate != nil && mm_atomic.LoadUint64(&m.afterIsMessageFromVirtualLegitimateCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsMessageFromVirtualLegitimateInspect logs each unmet expectation
func (m *ServiceMock) MinimockIsMessageFromVirtualLegitimateInspect() {
	for _, e := range m.IsMessageFromVirtualLegitimateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.IsMessageFromVirtualLegitimate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsMessageFromVirtualLegitimateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsMessageFromVirtualLegitimateCounter) < 1 {
		if m.IsMessageFromVirtualLegitimateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.IsMessageFromVirtualLegitimate")
		} else {
			m.t.Errorf("Expected call to ServiceMock.IsMessageFromVirtualLegitimate with params: %#v", *m.IsMessageFromVirtualLegitimateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsMessageFromVirtualLegitimate != nil && mm_atomic.LoadUint64(&m.afterIsMessageFromVirtualLegitimateCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.IsMessageFromVirtualLegitimate")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetCallDelegationTokenInspect()

		m.MinimockHasToSendTokenInspect()

		m.MinimockIsMessageFromVirtualLegitimateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetCallDelegationTokenDone() &&
		m.MinimockHasToSendTokenDone() &&
		m.MinimockIsMessageFromVirtualLegitimateDone()
}
