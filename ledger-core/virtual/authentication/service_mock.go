package authentication

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/pulse"
	"github.com/insolar/assured-ledger/ledger-core/reference"
	"github.com/insolar/assured-ledger/ledger-core/rms"
)

// ServiceMock implements Service
type ServiceMock struct {
	t minimock.Tester

	funcCheckMessageFromAuthorizedVirtual          func(ctx context.Context, payloadObj interface{}, sender reference.Global, pr pulse.Range) (mustReject bool, err error)
	inspectFuncCheckMessageFromAuthorizedVirtual   func(ctx context.Context, payloadObj interface{}, sender reference.Global, pr pulse.Range)
	afterCheckMessageFromAuthorizedVirtualCounter  uint64
	beforeCheckMessageFromAuthorizedVirtualCounter uint64
	CheckMessageFromAuthorizedVirtualMock          mServiceMockCheckMessageFromAuthorizedVirtual

	funcGetCallDelegationToken          func(outgoing reference.Global, to reference.Global, pn pulse.Number, object reference.Global) (c1 rms.CallDelegationToken)
	inspectFuncGetCallDelegationToken   func(outgoing reference.Global, to reference.Global, pn pulse.Number, object reference.Global)
	afterGetCallDelegationTokenCounter  uint64
	beforeGetCallDelegationTokenCounter uint64
	GetCallDelegationTokenMock          mServiceMockGetCallDelegationToken

	funcHasToSendToken          func(token rms.CallDelegationToken) (b1 bool)
	inspectFuncHasToSendToken   func(token rms.CallDelegationToken)
	afterHasToSendTokenCounter  uint64
	beforeHasToSendTokenCounter uint64
	HasToSendTokenMock          mServiceMockHasToSendToken
}

// NewServiceMock returns a mock for Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckMessageFromAuthorizedVirtualMock = mServiceMockCheckMessageFromAuthorizedVirtual{mock: m}
	m.CheckMessageFromAuthorizedVirtualMock.callArgs = []*ServiceMockCheckMessageFromAuthorizedVirtualParams{}

	m.GetCallDelegationTokenMock = mServiceMockGetCallDelegationToken{mock: m}
	m.GetCallDelegationTokenMock.callArgs = []*ServiceMockGetCallDelegationTokenParams{}

	m.HasToSendTokenMock = mServiceMockHasToSendToken{mock: m}
	m.HasToSendTokenMock.callArgs = []*ServiceMockHasToSendTokenParams{}

	return m
}

type mServiceMockCheckMessageFromAuthorizedVirtual struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockCheckMessageFromAuthorizedVirtualExpectation
	expectations       []*ServiceMockCheckMessageFromAuthorizedVirtualExpectation

	callArgs []*ServiceMockCheckMessageFromAuthorizedVirtualParams
	mutex    sync.RWMutex
}

// ServiceMockCheckMessageFromAuthorizedVirtualExpectation specifies expectation struct of the Service.CheckMessageFromAuthorizedVirtual
type ServiceMockCheckMessageFromAuthorizedVirtualExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockCheckMessageFromAuthorizedVirtualParams
	results *ServiceMockCheckMessageFromAuthorizedVirtualResults
	Counter uint64
}

// ServiceMockCheckMessageFromAuthorizedVirtualParams contains parameters of the Service.CheckMessageFromAuthorizedVirtual
type ServiceMockCheckMessageFromAuthorizedVirtualParams struct {
	ctx        context.Context
	payloadObj interface{}
	sender     reference.Global
	pr         pulse.Range
}

// ServiceMockCheckMessageFromAuthorizedVirtualResults contains results of the Service.CheckMessageFromAuthorizedVirtual
type ServiceMockCheckMessageFromAuthorizedVirtualResults struct {
	mustReject bool
	err        error
}

// Expect sets up expected params for Service.CheckMessageFromAuthorizedVirtual
func (mmCheckMessageFromAuthorizedVirtual *mServiceMockCheckMessageFromAuthorizedVirtual) Expect(ctx context.Context, payloadObj interface{}, sender reference.Global, pr pulse.Range) *mServiceMockCheckMessageFromAuthorizedVirtual {
	if mmCheckMessageFromAuthorizedVirtual.mock.funcCheckMessageFromAuthorizedVirtual != nil {
		mmCheckMessageFromAuthorizedVirtual.mock.t.Fatalf("ServiceMock.CheckMessageFromAuthorizedVirtual mock is already set by Set")
	}

	if mmCheckMessageFromAuthorizedVirtual.defaultExpectation == nil {
		mmCheckMessageFromAuthorizedVirtual.defaultExpectation = &ServiceMockCheckMessageFromAuthorizedVirtualExpectation{}
	}

	mmCheckMessageFromAuthorizedVirtual.defaultExpectation.params = &ServiceMockCheckMessageFromAuthorizedVirtualParams{ctx, payloadObj, sender, pr}
	for _, e := range mmCheckMessageFromAuthorizedVirtual.expectations {
		if minimock.Equal(e.params, mmCheckMessageFromAuthorizedVirtual.defaultExpectation.params) {
			mmCheckMessageFromAuthorizedVirtual.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckMessageFromAuthorizedVirtual.defaultExpectation.params)
		}
	}

	return mmCheckMessageFromAuthorizedVirtual
}

// Inspect accepts an inspector function that has same arguments as the Service.CheckMessageFromAuthorizedVirtual
func (mmCheckMessageFromAuthorizedVirtual *mServiceMockCheckMessageFromAuthorizedVirtual) Inspect(f func(ctx context.Context, payloadObj interface{}, sender reference.Global, pr pulse.Range)) *mServiceMockCheckMessageFromAuthorizedVirtual {
	if mmCheckMessageFromAuthorizedVirtual.mock.inspectFuncCheckMessageFromAuthorizedVirtual != nil {
		mmCheckMessageFromAuthorizedVirtual.mock.t.Fatalf("Inspect function is already set for ServiceMock.CheckMessageFromAuthorizedVirtual")
	}

	mmCheckMessageFromAuthorizedVirtual.mock.inspectFuncCheckMessageFromAuthorizedVirtual = f

	return mmCheckMessageFromAuthorizedVirtual
}

// Return sets up results that will be returned by Service.CheckMessageFromAuthorizedVirtual
func (mmCheckMessageFromAuthorizedVirtual *mServiceMockCheckMessageFromAuthorizedVirtual) Return(mustReject bool, err error) *ServiceMock {
	if mmCheckMessageFromAuthorizedVirtual.mock.funcCheckMessageFromAuthorizedVirtual != nil {
		mmCheckMessageFromAuthorizedVirtual.mock.t.Fatalf("ServiceMock.CheckMessageFromAuthorizedVirtual mock is already set by Set")
	}

	if mmCheckMessageFromAuthorizedVirtual.defaultExpectation == nil {
		mmCheckMessageFromAuthorizedVirtual.defaultExpectation = &ServiceMockCheckMessageFromAuthorizedVirtualExpectation{mock: mmCheckMessageFromAuthorizedVirtual.mock}
	}
	mmCheckMessageFromAuthorizedVirtual.defaultExpectation.results = &ServiceMockCheckMessageFromAuthorizedVirtualResults{mustReject, err}
	return mmCheckMessageFromAuthorizedVirtual.mock
}

//Set uses given function f to mock the Service.CheckMessageFromAuthorizedVirtual method
func (mmCheckMessageFromAuthorizedVirtual *mServiceMockCheckMessageFromAuthorizedVirtual) Set(f func(ctx context.Context, payloadObj interface{}, sender reference.Global, pr pulse.Range) (mustReject bool, err error)) *ServiceMock {
	if mmCheckMessageFromAuthorizedVirtual.defaultExpectation != nil {
		mmCheckMessageFromAuthorizedVirtual.mock.t.Fatalf("Default expectation is already set for the Service.CheckMessageFromAuthorizedVirtual method")
	}

	if len(mmCheckMessageFromAuthorizedVirtual.expectations) > 0 {
		mmCheckMessageFromAuthorizedVirtual.mock.t.Fatalf("Some expectations are already set for the Service.CheckMessageFromAuthorizedVirtual method")
	}

	mmCheckMessageFromAuthorizedVirtual.mock.funcCheckMessageFromAuthorizedVirtual = f
	return mmCheckMessageFromAuthorizedVirtual.mock
}

// When sets expectation for the Service.CheckMessageFromAuthorizedVirtual which will trigger the result defined by the following
// Then helper
func (mmCheckMessageFromAuthorizedVirtual *mServiceMockCheckMessageFromAuthorizedVirtual) When(ctx context.Context, payloadObj interface{}, sender reference.Global, pr pulse.Range) *ServiceMockCheckMessageFromAuthorizedVirtualExpectation {
	if mmCheckMessageFromAuthorizedVirtual.mock.funcCheckMessageFromAuthorizedVirtual != nil {
		mmCheckMessageFromAuthorizedVirtual.mock.t.Fatalf("ServiceMock.CheckMessageFromAuthorizedVirtual mock is already set by Set")
	}

	expectation := &ServiceMockCheckMessageFromAuthorizedVirtualExpectation{
		mock:   mmCheckMessageFromAuthorizedVirtual.mock,
		params: &ServiceMockCheckMessageFromAuthorizedVirtualParams{ctx, payloadObj, sender, pr},
	}
	mmCheckMessageFromAuthorizedVirtual.expectations = append(mmCheckMessageFromAuthorizedVirtual.expectations, expectation)
	return expectation
}

// Then sets up Service.CheckMessageFromAuthorizedVirtual return parameters for the expectation previously defined by the When method
func (e *ServiceMockCheckMessageFromAuthorizedVirtualExpectation) Then(mustReject bool, err error) *ServiceMock {
	e.results = &ServiceMockCheckMessageFromAuthorizedVirtualResults{mustReject, err}
	return e.mock
}

// CheckMessageFromAuthorizedVirtual implements Service
func (mmCheckMessageFromAuthorizedVirtual *ServiceMock) CheckMessageFromAuthorizedVirtual(ctx context.Context, payloadObj interface{}, sender reference.Global, pr pulse.Range) (mustReject bool, err error) {
	mm_atomic.AddUint64(&mmCheckMessageFromAuthorizedVirtual.beforeCheckMessageFromAuthorizedVirtualCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckMessageFromAuthorizedVirtual.afterCheckMessageFromAuthorizedVirtualCounter, 1)

	if mmCheckMessageFromAuthorizedVirtual.inspectFuncCheckMessageFromAuthorizedVirtual != nil {
		mmCheckMessageFromAuthorizedVirtual.inspectFuncCheckMessageFromAuthorizedVirtual(ctx, payloadObj, sender, pr)
	}

	mm_params := &ServiceMockCheckMessageFromAuthorizedVirtualParams{ctx, payloadObj, sender, pr}

	// Record call args
	mmCheckMessageFromAuthorizedVirtual.CheckMessageFromAuthorizedVirtualMock.mutex.Lock()
	mmCheckMessageFromAuthorizedVirtual.CheckMessageFromAuthorizedVirtualMock.callArgs = append(mmCheckMessageFromAuthorizedVirtual.CheckMessageFromAuthorizedVirtualMock.callArgs, mm_params)
	mmCheckMessageFromAuthorizedVirtual.CheckMessageFromAuthorizedVirtualMock.mutex.Unlock()

	for _, e := range mmCheckMessageFromAuthorizedVirtual.CheckMessageFromAuthorizedVirtualMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mustReject, e.results.err
		}
	}

	if mmCheckMessageFromAuthorizedVirtual.CheckMessageFromAuthorizedVirtualMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckMessageFromAuthorizedVirtual.CheckMessageFromAuthorizedVirtualMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckMessageFromAuthorizedVirtual.CheckMessageFromAuthorizedVirtualMock.defaultExpectation.params
		mm_got := ServiceMockCheckMessageFromAuthorizedVirtualParams{ctx, payloadObj, sender, pr}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckMessageFromAuthorizedVirtual.t.Errorf("ServiceMock.CheckMessageFromAuthorizedVirtual got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckMessageFromAuthorizedVirtual.CheckMessageFromAuthorizedVirtualMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckMessageFromAuthorizedVirtual.t.Fatal("No results are set for the ServiceMock.CheckMessageFromAuthorizedVirtual")
		}
		return (*mm_results).mustReject, (*mm_results).err
	}
	if mmCheckMessageFromAuthorizedVirtual.funcCheckMessageFromAuthorizedVirtual != nil {
		return mmCheckMessageFromAuthorizedVirtual.funcCheckMessageFromAuthorizedVirtual(ctx, payloadObj, sender, pr)
	}
	mmCheckMessageFromAuthorizedVirtual.t.Fatalf("Unexpected call to ServiceMock.CheckMessageFromAuthorizedVirtual. %v %v %v %v", ctx, payloadObj, sender, pr)
	return
}

// CheckMessageFromAuthorizedVirtualAfterCounter returns a count of finished ServiceMock.CheckMessageFromAuthorizedVirtual invocations
func (mmCheckMessageFromAuthorizedVirtual *ServiceMock) CheckMessageFromAuthorizedVirtualAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckMessageFromAuthorizedVirtual.afterCheckMessageFromAuthorizedVirtualCounter)
}

// CheckMessageFromAuthorizedVirtualBeforeCounter returns a count of ServiceMock.CheckMessageFromAuthorizedVirtual invocations
func (mmCheckMessageFromAuthorizedVirtual *ServiceMock) CheckMessageFromAuthorizedVirtualBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckMessageFromAuthorizedVirtual.beforeCheckMessageFromAuthorizedVirtualCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CheckMessageFromAuthorizedVirtual.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckMessageFromAuthorizedVirtual *mServiceMockCheckMessageFromAuthorizedVirtual) Calls() []*ServiceMockCheckMessageFromAuthorizedVirtualParams {
	mmCheckMessageFromAuthorizedVirtual.mutex.RLock()

	argCopy := make([]*ServiceMockCheckMessageFromAuthorizedVirtualParams, len(mmCheckMessageFromAuthorizedVirtual.callArgs))
	copy(argCopy, mmCheckMessageFromAuthorizedVirtual.callArgs)

	mmCheckMessageFromAuthorizedVirtual.mutex.RUnlock()

	return argCopy
}

// MinimockCheckMessageFromAuthorizedVirtualDone returns true if the count of the CheckMessageFromAuthorizedVirtual invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCheckMessageFromAuthorizedVirtualDone() bool {
	for _, e := range m.CheckMessageFromAuthorizedVirtualMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckMessageFromAuthorizedVirtualMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckMessageFromAuthorizedVirtualCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckMessageFromAuthorizedVirtual != nil && mm_atomic.LoadUint64(&m.afterCheckMessageFromAuthorizedVirtualCounter) < 1 {
		return false
	}
	return true
}

// MinimockCheckMessageFromAuthorizedVirtualInspect logs each unmet expectation
func (m *ServiceMock) MinimockCheckMessageFromAuthorizedVirtualInspect() {
	for _, e := range m.CheckMessageFromAuthorizedVirtualMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CheckMessageFromAuthorizedVirtual with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckMessageFromAuthorizedVirtualMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckMessageFromAuthorizedVirtualCounter) < 1 {
		if m.CheckMessageFromAuthorizedVirtualMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.CheckMessageFromAuthorizedVirtual")
		} else {
			m.t.Errorf("Expected call to ServiceMock.CheckMessageFromAuthorizedVirtual with params: %#v", *m.CheckMessageFromAuthorizedVirtualMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckMessageFromAuthorizedVirtual != nil && mm_atomic.LoadUint64(&m.afterCheckMessageFromAuthorizedVirtualCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.CheckMessageFromAuthorizedVirtual")
	}
}

type mServiceMockGetCallDelegationToken struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetCallDelegationTokenExpectation
	expectations       []*ServiceMockGetCallDelegationTokenExpectation

	callArgs []*ServiceMockGetCallDelegationTokenParams
	mutex    sync.RWMutex
}

// ServiceMockGetCallDelegationTokenExpectation specifies expectation struct of the Service.GetCallDelegationToken
type ServiceMockGetCallDelegationTokenExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockGetCallDelegationTokenParams
	results *ServiceMockGetCallDelegationTokenResults
	Counter uint64
}

// ServiceMockGetCallDelegationTokenParams contains parameters of the Service.GetCallDelegationToken
type ServiceMockGetCallDelegationTokenParams struct {
	outgoing reference.Global
	to       reference.Global
	pn       pulse.Number
	object   reference.Global
}

// ServiceMockGetCallDelegationTokenResults contains results of the Service.GetCallDelegationToken
type ServiceMockGetCallDelegationTokenResults struct {
	c1 rms.CallDelegationToken
}

// Expect sets up expected params for Service.GetCallDelegationToken
func (mmGetCallDelegationToken *mServiceMockGetCallDelegationToken) Expect(outgoing reference.Global, to reference.Global, pn pulse.Number, object reference.Global) *mServiceMockGetCallDelegationToken {
	if mmGetCallDelegationToken.mock.funcGetCallDelegationToken != nil {
		mmGetCallDelegationToken.mock.t.Fatalf("ServiceMock.GetCallDelegationToken mock is already set by Set")
	}

	if mmGetCallDelegationToken.defaultExpectation == nil {
		mmGetCallDelegationToken.defaultExpectation = &ServiceMockGetCallDelegationTokenExpectation{}
	}

	mmGetCallDelegationToken.defaultExpectation.params = &ServiceMockGetCallDelegationTokenParams{outgoing, to, pn, object}
	for _, e := range mmGetCallDelegationToken.expectations {
		if minimock.Equal(e.params, mmGetCallDelegationToken.defaultExpectation.params) {
			mmGetCallDelegationToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCallDelegationToken.defaultExpectation.params)
		}
	}

	return mmGetCallDelegationToken
}

// Inspect accepts an inspector function that has same arguments as the Service.GetCallDelegationToken
func (mmGetCallDelegationToken *mServiceMockGetCallDelegationToken) Inspect(f func(outgoing reference.Global, to reference.Global, pn pulse.Number, object reference.Global)) *mServiceMockGetCallDelegationToken {
	if mmGetCallDelegationToken.mock.inspectFuncGetCallDelegationToken != nil {
		mmGetCallDelegationToken.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetCallDelegationToken")
	}

	mmGetCallDelegationToken.mock.inspectFuncGetCallDelegationToken = f

	return mmGetCallDelegationToken
}

// Return sets up results that will be returned by Service.GetCallDelegationToken
func (mmGetCallDelegationToken *mServiceMockGetCallDelegationToken) Return(c1 rms.CallDelegationToken) *ServiceMock {
	if mmGetCallDelegationToken.mock.funcGetCallDelegationToken != nil {
		mmGetCallDelegationToken.mock.t.Fatalf("ServiceMock.GetCallDelegationToken mock is already set by Set")
	}

	if mmGetCallDelegationToken.defaultExpectation == nil {
		mmGetCallDelegationToken.defaultExpectation = &ServiceMockGetCallDelegationTokenExpectation{mock: mmGetCallDelegationToken.mock}
	}
	mmGetCallDelegationToken.defaultExpectation.results = &ServiceMockGetCallDelegationTokenResults{c1}
	return mmGetCallDelegationToken.mock
}

//Set uses given function f to mock the Service.GetCallDelegationToken method
func (mmGetCallDelegationToken *mServiceMockGetCallDelegationToken) Set(f func(outgoing reference.Global, to reference.Global, pn pulse.Number, object reference.Global) (c1 rms.CallDelegationToken)) *ServiceMock {
	if mmGetCallDelegationToken.defaultExpectation != nil {
		mmGetCallDelegationToken.mock.t.Fatalf("Default expectation is already set for the Service.GetCallDelegationToken method")
	}

	if len(mmGetCallDelegationToken.expectations) > 0 {
		mmGetCallDelegationToken.mock.t.Fatalf("Some expectations are already set for the Service.GetCallDelegationToken method")
	}

	mmGetCallDelegationToken.mock.funcGetCallDelegationToken = f
	return mmGetCallDelegationToken.mock
}

// When sets expectation for the Service.GetCallDelegationToken which will trigger the result defined by the following
// Then helper
func (mmGetCallDelegationToken *mServiceMockGetCallDelegationToken) When(outgoing reference.Global, to reference.Global, pn pulse.Number, object reference.Global) *ServiceMockGetCallDelegationTokenExpectation {
	if mmGetCallDelegationToken.mock.funcGetCallDelegationToken != nil {
		mmGetCallDelegationToken.mock.t.Fatalf("ServiceMock.GetCallDelegationToken mock is already set by Set")
	}

	expectation := &ServiceMockGetCallDelegationTokenExpectation{
		mock:   mmGetCallDelegationToken.mock,
		params: &ServiceMockGetCallDelegationTokenParams{outgoing, to, pn, object},
	}
	mmGetCallDelegationToken.expectations = append(mmGetCallDelegationToken.expectations, expectation)
	return expectation
}

// Then sets up Service.GetCallDelegationToken return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetCallDelegationTokenExpectation) Then(c1 rms.CallDelegationToken) *ServiceMock {
	e.results = &ServiceMockGetCallDelegationTokenResults{c1}
	return e.mock
}

// GetCallDelegationToken implements Service
func (mmGetCallDelegationToken *ServiceMock) GetCallDelegationToken(outgoing reference.Global, to reference.Global, pn pulse.Number, object reference.Global) (c1 rms.CallDelegationToken) {
	mm_atomic.AddUint64(&mmGetCallDelegationToken.beforeGetCallDelegationTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCallDelegationToken.afterGetCallDelegationTokenCounter, 1)

	if mmGetCallDelegationToken.inspectFuncGetCallDelegationToken != nil {
		mmGetCallDelegationToken.inspectFuncGetCallDelegationToken(outgoing, to, pn, object)
	}

	mm_params := &ServiceMockGetCallDelegationTokenParams{outgoing, to, pn, object}

	// Record call args
	mmGetCallDelegationToken.GetCallDelegationTokenMock.mutex.Lock()
	mmGetCallDelegationToken.GetCallDelegationTokenMock.callArgs = append(mmGetCallDelegationToken.GetCallDelegationTokenMock.callArgs, mm_params)
	mmGetCallDelegationToken.GetCallDelegationTokenMock.mutex.Unlock()

	for _, e := range mmGetCallDelegationToken.GetCallDelegationTokenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c1
		}
	}

	if mmGetCallDelegationToken.GetCallDelegationTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCallDelegationToken.GetCallDelegationTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCallDelegationToken.GetCallDelegationTokenMock.defaultExpectation.params
		mm_got := ServiceMockGetCallDelegationTokenParams{outgoing, to, pn, object}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCallDelegationToken.t.Errorf("ServiceMock.GetCallDelegationToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCallDelegationToken.GetCallDelegationTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCallDelegationToken.t.Fatal("No results are set for the ServiceMock.GetCallDelegationToken")
		}
		return (*mm_results).c1
	}
	if mmGetCallDelegationToken.funcGetCallDelegationToken != nil {
		return mmGetCallDelegationToken.funcGetCallDelegationToken(outgoing, to, pn, object)
	}
	mmGetCallDelegationToken.t.Fatalf("Unexpected call to ServiceMock.GetCallDelegationToken. %v %v %v %v", outgoing, to, pn, object)
	return
}

// GetCallDelegationTokenAfterCounter returns a count of finished ServiceMock.GetCallDelegationToken invocations
func (mmGetCallDelegationToken *ServiceMock) GetCallDelegationTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCallDelegationToken.afterGetCallDelegationTokenCounter)
}

// GetCallDelegationTokenBeforeCounter returns a count of ServiceMock.GetCallDelegationToken invocations
func (mmGetCallDelegationToken *ServiceMock) GetCallDelegationTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCallDelegationToken.beforeGetCallDelegationTokenCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetCallDelegationToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCallDelegationToken *mServiceMockGetCallDelegationToken) Calls() []*ServiceMockGetCallDelegationTokenParams {
	mmGetCallDelegationToken.mutex.RLock()

	argCopy := make([]*ServiceMockGetCallDelegationTokenParams, len(mmGetCallDelegationToken.callArgs))
	copy(argCopy, mmGetCallDelegationToken.callArgs)

	mmGetCallDelegationToken.mutex.RUnlock()

	return argCopy
}

// MinimockGetCallDelegationTokenDone returns true if the count of the GetCallDelegationToken invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetCallDelegationTokenDone() bool {
	for _, e := range m.GetCallDelegationTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCallDelegationTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCallDelegationTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCallDelegationToken != nil && mm_atomic.LoadUint64(&m.afterGetCallDelegationTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCallDelegationTokenInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetCallDelegationTokenInspect() {
	for _, e := range m.GetCallDelegationTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetCallDelegationToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCallDelegationTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCallDelegationTokenCounter) < 1 {
		if m.GetCallDelegationTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.GetCallDelegationToken")
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetCallDelegationToken with params: %#v", *m.GetCallDelegationTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCallDelegationToken != nil && mm_atomic.LoadUint64(&m.afterGetCallDelegationTokenCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.GetCallDelegationToken")
	}
}

type mServiceMockHasToSendToken struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockHasToSendTokenExpectation
	expectations       []*ServiceMockHasToSendTokenExpectation

	callArgs []*ServiceMockHasToSendTokenParams
	mutex    sync.RWMutex
}

// ServiceMockHasToSendTokenExpectation specifies expectation struct of the Service.HasToSendToken
type ServiceMockHasToSendTokenExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockHasToSendTokenParams
	results *ServiceMockHasToSendTokenResults
	Counter uint64
}

// ServiceMockHasToSendTokenParams contains parameters of the Service.HasToSendToken
type ServiceMockHasToSendTokenParams struct {
	token rms.CallDelegationToken
}

// ServiceMockHasToSendTokenResults contains results of the Service.HasToSendToken
type ServiceMockHasToSendTokenResults struct {
	b1 bool
}

// Expect sets up expected params for Service.HasToSendToken
func (mmHasToSendToken *mServiceMockHasToSendToken) Expect(token rms.CallDelegationToken) *mServiceMockHasToSendToken {
	if mmHasToSendToken.mock.funcHasToSendToken != nil {
		mmHasToSendToken.mock.t.Fatalf("ServiceMock.HasToSendToken mock is already set by Set")
	}

	if mmHasToSendToken.defaultExpectation == nil {
		mmHasToSendToken.defaultExpectation = &ServiceMockHasToSendTokenExpectation{}
	}

	mmHasToSendToken.defaultExpectation.params = &ServiceMockHasToSendTokenParams{token}
	for _, e := range mmHasToSendToken.expectations {
		if minimock.Equal(e.params, mmHasToSendToken.defaultExpectation.params) {
			mmHasToSendToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHasToSendToken.defaultExpectation.params)
		}
	}

	return mmHasToSendToken
}

// Inspect accepts an inspector function that has same arguments as the Service.HasToSendToken
func (mmHasToSendToken *mServiceMockHasToSendToken) Inspect(f func(token rms.CallDelegationToken)) *mServiceMockHasToSendToken {
	if mmHasToSendToken.mock.inspectFuncHasToSendToken != nil {
		mmHasToSendToken.mock.t.Fatalf("Inspect function is already set for ServiceMock.HasToSendToken")
	}

	mmHasToSendToken.mock.inspectFuncHasToSendToken = f

	return mmHasToSendToken
}

// Return sets up results that will be returned by Service.HasToSendToken
func (mmHasToSendToken *mServiceMockHasToSendToken) Return(b1 bool) *ServiceMock {
	if mmHasToSendToken.mock.funcHasToSendToken != nil {
		mmHasToSendToken.mock.t.Fatalf("ServiceMock.HasToSendToken mock is already set by Set")
	}

	if mmHasToSendToken.defaultExpectation == nil {
		mmHasToSendToken.defaultExpectation = &ServiceMockHasToSendTokenExpectation{mock: mmHasToSendToken.mock}
	}
	mmHasToSendToken.defaultExpectation.results = &ServiceMockHasToSendTokenResults{b1}
	return mmHasToSendToken.mock
}

//Set uses given function f to mock the Service.HasToSendToken method
func (mmHasToSendToken *mServiceMockHasToSendToken) Set(f func(token rms.CallDelegationToken) (b1 bool)) *ServiceMock {
	if mmHasToSendToken.defaultExpectation != nil {
		mmHasToSendToken.mock.t.Fatalf("Default expectation is already set for the Service.HasToSendToken method")
	}

	if len(mmHasToSendToken.expectations) > 0 {
		mmHasToSendToken.mock.t.Fatalf("Some expectations are already set for the Service.HasToSendToken method")
	}

	mmHasToSendToken.mock.funcHasToSendToken = f
	return mmHasToSendToken.mock
}

// When sets expectation for the Service.HasToSendToken which will trigger the result defined by the following
// Then helper
func (mmHasToSendToken *mServiceMockHasToSendToken) When(token rms.CallDelegationToken) *ServiceMockHasToSendTokenExpectation {
	if mmHasToSendToken.mock.funcHasToSendToken != nil {
		mmHasToSendToken.mock.t.Fatalf("ServiceMock.HasToSendToken mock is already set by Set")
	}

	expectation := &ServiceMockHasToSendTokenExpectation{
		mock:   mmHasToSendToken.mock,
		params: &ServiceMockHasToSendTokenParams{token},
	}
	mmHasToSendToken.expectations = append(mmHasToSendToken.expectations, expectation)
	return expectation
}

// Then sets up Service.HasToSendToken return parameters for the expectation previously defined by the When method
func (e *ServiceMockHasToSendTokenExpectation) Then(b1 bool) *ServiceMock {
	e.results = &ServiceMockHasToSendTokenResults{b1}
	return e.mock
}

// HasToSendToken implements Service
func (mmHasToSendToken *ServiceMock) HasToSendToken(token rms.CallDelegationToken) (b1 bool) {
	mm_atomic.AddUint64(&mmHasToSendToken.beforeHasToSendTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmHasToSendToken.afterHasToSendTokenCounter, 1)

	if mmHasToSendToken.inspectFuncHasToSendToken != nil {
		mmHasToSendToken.inspectFuncHasToSendToken(token)
	}

	mm_params := &ServiceMockHasToSendTokenParams{token}

	// Record call args
	mmHasToSendToken.HasToSendTokenMock.mutex.Lock()
	mmHasToSendToken.HasToSendTokenMock.callArgs = append(mmHasToSendToken.HasToSendTokenMock.callArgs, mm_params)
	mmHasToSendToken.HasToSendTokenMock.mutex.Unlock()

	for _, e := range mmHasToSendToken.HasToSendTokenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmHasToSendToken.HasToSendTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHasToSendToken.HasToSendTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmHasToSendToken.HasToSendTokenMock.defaultExpectation.params
		mm_got := ServiceMockHasToSendTokenParams{token}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHasToSendToken.t.Errorf("ServiceMock.HasToSendToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHasToSendToken.HasToSendTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmHasToSendToken.t.Fatal("No results are set for the ServiceMock.HasToSendToken")
		}
		return (*mm_results).b1
	}
	if mmHasToSendToken.funcHasToSendToken != nil {
		return mmHasToSendToken.funcHasToSendToken(token)
	}
	mmHasToSendToken.t.Fatalf("Unexpected call to ServiceMock.HasToSendToken. %v", token)
	return
}

// HasToSendTokenAfterCounter returns a count of finished ServiceMock.HasToSendToken invocations
func (mmHasToSendToken *ServiceMock) HasToSendTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasToSendToken.afterHasToSendTokenCounter)
}

// HasToSendTokenBeforeCounter returns a count of ServiceMock.HasToSendToken invocations
func (mmHasToSendToken *ServiceMock) HasToSendTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasToSendToken.beforeHasToSendTokenCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.HasToSendToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHasToSendToken *mServiceMockHasToSendToken) Calls() []*ServiceMockHasToSendTokenParams {
	mmHasToSendToken.mutex.RLock()

	argCopy := make([]*ServiceMockHasToSendTokenParams, len(mmHasToSendToken.callArgs))
	copy(argCopy, mmHasToSendToken.callArgs)

	mmHasToSendToken.mutex.RUnlock()

	return argCopy
}

// MinimockHasToSendTokenDone returns true if the count of the HasToSendToken invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockHasToSendTokenDone() bool {
	for _, e := range m.HasToSendTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasToSendTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasToSendTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasToSendToken != nil && mm_atomic.LoadUint64(&m.afterHasToSendTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockHasToSendTokenInspect logs each unmet expectation
func (m *ServiceMock) MinimockHasToSendTokenInspect() {
	for _, e := range m.HasToSendTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.HasToSendToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasToSendTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasToSendTokenCounter) < 1 {
		if m.HasToSendTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.HasToSendToken")
		} else {
			m.t.Errorf("Expected call to ServiceMock.HasToSendToken with params: %#v", *m.HasToSendTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasToSendToken != nil && mm_atomic.LoadUint64(&m.afterHasToSendTokenCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.HasToSendToken")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCheckMessageFromAuthorizedVirtualInspect()

		m.MinimockGetCallDelegationTokenInspect()

		m.MinimockHasToSendTokenInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckMessageFromAuthorizedVirtualDone() &&
		m.MinimockGetCallDelegationTokenDone() &&
		m.MinimockHasToSendTokenDone()
}
