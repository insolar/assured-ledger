package object

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/conveyor/smachine"
	"github.com/insolar/assured-ledger/ledger-core/reference"
)

// CatalogMock implements Catalog
type CatalogMock struct {
	t minimock.Tester

	funcCreate          func(e1 smachine.ExecutionContext, objectReference reference.Global) (s1 SharedStateAccessor)
	inspectFuncCreate   func(e1 smachine.ExecutionContext, objectReference reference.Global)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mCatalogMockCreate

	funcGet          func(e1 smachine.ExecutionContext, objectReference reference.Global) (s1 SharedStateAccessor)
	inspectFuncGet   func(e1 smachine.ExecutionContext, objectReference reference.Global)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mCatalogMockGet

	funcGetOrCreate          func(e1 smachine.ExecutionContext, objectReference reference.Global) (s1 SharedStateAccessor)
	inspectFuncGetOrCreate   func(e1 smachine.ExecutionContext, objectReference reference.Global)
	afterGetOrCreateCounter  uint64
	beforeGetOrCreateCounter uint64
	GetOrCreateMock          mCatalogMockGetOrCreate

	funcTryGet          func(e1 smachine.ExecutionContext, objectReference reference.Global) (s1 SharedStateAccessor, b1 bool)
	inspectFuncTryGet   func(e1 smachine.ExecutionContext, objectReference reference.Global)
	afterTryGetCounter  uint64
	beforeTryGetCounter uint64
	TryGetMock          mCatalogMockTryGet
}

// NewCatalogMock returns a mock for Catalog
func NewCatalogMock(t minimock.Tester) *CatalogMock {
	m := &CatalogMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mCatalogMockCreate{mock: m}
	m.CreateMock.callArgs = []*CatalogMockCreateParams{}

	m.GetMock = mCatalogMockGet{mock: m}
	m.GetMock.callArgs = []*CatalogMockGetParams{}

	m.GetOrCreateMock = mCatalogMockGetOrCreate{mock: m}
	m.GetOrCreateMock.callArgs = []*CatalogMockGetOrCreateParams{}

	m.TryGetMock = mCatalogMockTryGet{mock: m}
	m.TryGetMock.callArgs = []*CatalogMockTryGetParams{}

	return m
}

type mCatalogMockCreate struct {
	mock               *CatalogMock
	defaultExpectation *CatalogMockCreateExpectation
	expectations       []*CatalogMockCreateExpectation

	callArgs []*CatalogMockCreateParams
	mutex    sync.RWMutex
}

// CatalogMockCreateExpectation specifies expectation struct of the Catalog.Create
type CatalogMockCreateExpectation struct {
	mock    *CatalogMock
	params  *CatalogMockCreateParams
	results *CatalogMockCreateResults
	Counter uint64
}

// CatalogMockCreateParams contains parameters of the Catalog.Create
type CatalogMockCreateParams struct {
	e1              smachine.ExecutionContext
	objectReference reference.Global
}

// CatalogMockCreateResults contains results of the Catalog.Create
type CatalogMockCreateResults struct {
	s1 SharedStateAccessor
}

// Expect sets up expected params for Catalog.Create
func (mmCreate *mCatalogMockCreate) Expect(e1 smachine.ExecutionContext, objectReference reference.Global) *mCatalogMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CatalogMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &CatalogMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &CatalogMockCreateParams{e1, objectReference}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the Catalog.Create
func (mmCreate *mCatalogMockCreate) Inspect(f func(e1 smachine.ExecutionContext, objectReference reference.Global)) *mCatalogMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for CatalogMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by Catalog.Create
func (mmCreate *mCatalogMockCreate) Return(s1 SharedStateAccessor) *CatalogMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CatalogMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &CatalogMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &CatalogMockCreateResults{s1}
	return mmCreate.mock
}

//Set uses given function f to mock the Catalog.Create method
func (mmCreate *mCatalogMockCreate) Set(f func(e1 smachine.ExecutionContext, objectReference reference.Global) (s1 SharedStateAccessor)) *CatalogMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the Catalog.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the Catalog.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the Catalog.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mCatalogMockCreate) When(e1 smachine.ExecutionContext, objectReference reference.Global) *CatalogMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CatalogMock.Create mock is already set by Set")
	}

	expectation := &CatalogMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &CatalogMockCreateParams{e1, objectReference},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up Catalog.Create return parameters for the expectation previously defined by the When method
func (e *CatalogMockCreateExpectation) Then(s1 SharedStateAccessor) *CatalogMock {
	e.results = &CatalogMockCreateResults{s1}
	return e.mock
}

// Create implements Catalog
func (mmCreate *CatalogMock) Create(e1 smachine.ExecutionContext, objectReference reference.Global) (s1 SharedStateAccessor) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(e1, objectReference)
	}

	mm_params := &CatalogMockCreateParams{e1, objectReference}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := CatalogMockCreateParams{e1, objectReference}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("CatalogMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the CatalogMock.Create")
		}
		return (*mm_results).s1
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(e1, objectReference)
	}
	mmCreate.t.Fatalf("Unexpected call to CatalogMock.Create. %v %v", e1, objectReference)
	return
}

// CreateAfterCounter returns a count of finished CatalogMock.Create invocations
func (mmCreate *CatalogMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of CatalogMock.Create invocations
func (mmCreate *CatalogMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to CatalogMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mCatalogMockCreate) Calls() []*CatalogMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*CatalogMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *CatalogMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *CatalogMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CatalogMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CatalogMock.Create")
		} else {
			m.t.Errorf("Expected call to CatalogMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to CatalogMock.Create")
	}
}

type mCatalogMockGet struct {
	mock               *CatalogMock
	defaultExpectation *CatalogMockGetExpectation
	expectations       []*CatalogMockGetExpectation

	callArgs []*CatalogMockGetParams
	mutex    sync.RWMutex
}

// CatalogMockGetExpectation specifies expectation struct of the Catalog.Get
type CatalogMockGetExpectation struct {
	mock    *CatalogMock
	params  *CatalogMockGetParams
	results *CatalogMockGetResults
	Counter uint64
}

// CatalogMockGetParams contains parameters of the Catalog.Get
type CatalogMockGetParams struct {
	e1              smachine.ExecutionContext
	objectReference reference.Global
}

// CatalogMockGetResults contains results of the Catalog.Get
type CatalogMockGetResults struct {
	s1 SharedStateAccessor
}

// Expect sets up expected params for Catalog.Get
func (mmGet *mCatalogMockGet) Expect(e1 smachine.ExecutionContext, objectReference reference.Global) *mCatalogMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CatalogMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CatalogMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &CatalogMockGetParams{e1, objectReference}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Catalog.Get
func (mmGet *mCatalogMockGet) Inspect(f func(e1 smachine.ExecutionContext, objectReference reference.Global)) *mCatalogMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for CatalogMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Catalog.Get
func (mmGet *mCatalogMockGet) Return(s1 SharedStateAccessor) *CatalogMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CatalogMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CatalogMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &CatalogMockGetResults{s1}
	return mmGet.mock
}

//Set uses given function f to mock the Catalog.Get method
func (mmGet *mCatalogMockGet) Set(f func(e1 smachine.ExecutionContext, objectReference reference.Global) (s1 SharedStateAccessor)) *CatalogMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Catalog.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Catalog.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the Catalog.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mCatalogMockGet) When(e1 smachine.ExecutionContext, objectReference reference.Global) *CatalogMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CatalogMock.Get mock is already set by Set")
	}

	expectation := &CatalogMockGetExpectation{
		mock:   mmGet.mock,
		params: &CatalogMockGetParams{e1, objectReference},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Catalog.Get return parameters for the expectation previously defined by the When method
func (e *CatalogMockGetExpectation) Then(s1 SharedStateAccessor) *CatalogMock {
	e.results = &CatalogMockGetResults{s1}
	return e.mock
}

// Get implements Catalog
func (mmGet *CatalogMock) Get(e1 smachine.ExecutionContext, objectReference reference.Global) (s1 SharedStateAccessor) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(e1, objectReference)
	}

	mm_params := &CatalogMockGetParams{e1, objectReference}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := CatalogMockGetParams{e1, objectReference}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("CatalogMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the CatalogMock.Get")
		}
		return (*mm_results).s1
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(e1, objectReference)
	}
	mmGet.t.Fatalf("Unexpected call to CatalogMock.Get. %v %v", e1, objectReference)
	return
}

// GetAfterCounter returns a count of finished CatalogMock.Get invocations
func (mmGet *CatalogMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of CatalogMock.Get invocations
func (mmGet *CatalogMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to CatalogMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mCatalogMockGet) Calls() []*CatalogMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*CatalogMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *CatalogMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *CatalogMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CatalogMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CatalogMock.Get")
		} else {
			m.t.Errorf("Expected call to CatalogMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to CatalogMock.Get")
	}
}

type mCatalogMockGetOrCreate struct {
	mock               *CatalogMock
	defaultExpectation *CatalogMockGetOrCreateExpectation
	expectations       []*CatalogMockGetOrCreateExpectation

	callArgs []*CatalogMockGetOrCreateParams
	mutex    sync.RWMutex
}

// CatalogMockGetOrCreateExpectation specifies expectation struct of the Catalog.GetOrCreate
type CatalogMockGetOrCreateExpectation struct {
	mock    *CatalogMock
	params  *CatalogMockGetOrCreateParams
	results *CatalogMockGetOrCreateResults
	Counter uint64
}

// CatalogMockGetOrCreateParams contains parameters of the Catalog.GetOrCreate
type CatalogMockGetOrCreateParams struct {
	e1              smachine.ExecutionContext
	objectReference reference.Global
}

// CatalogMockGetOrCreateResults contains results of the Catalog.GetOrCreate
type CatalogMockGetOrCreateResults struct {
	s1 SharedStateAccessor
}

// Expect sets up expected params for Catalog.GetOrCreate
func (mmGetOrCreate *mCatalogMockGetOrCreate) Expect(e1 smachine.ExecutionContext, objectReference reference.Global) *mCatalogMockGetOrCreate {
	if mmGetOrCreate.mock.funcGetOrCreate != nil {
		mmGetOrCreate.mock.t.Fatalf("CatalogMock.GetOrCreate mock is already set by Set")
	}

	if mmGetOrCreate.defaultExpectation == nil {
		mmGetOrCreate.defaultExpectation = &CatalogMockGetOrCreateExpectation{}
	}

	mmGetOrCreate.defaultExpectation.params = &CatalogMockGetOrCreateParams{e1, objectReference}
	for _, e := range mmGetOrCreate.expectations {
		if minimock.Equal(e.params, mmGetOrCreate.defaultExpectation.params) {
			mmGetOrCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrCreate.defaultExpectation.params)
		}
	}

	return mmGetOrCreate
}

// Inspect accepts an inspector function that has same arguments as the Catalog.GetOrCreate
func (mmGetOrCreate *mCatalogMockGetOrCreate) Inspect(f func(e1 smachine.ExecutionContext, objectReference reference.Global)) *mCatalogMockGetOrCreate {
	if mmGetOrCreate.mock.inspectFuncGetOrCreate != nil {
		mmGetOrCreate.mock.t.Fatalf("Inspect function is already set for CatalogMock.GetOrCreate")
	}

	mmGetOrCreate.mock.inspectFuncGetOrCreate = f

	return mmGetOrCreate
}

// Return sets up results that will be returned by Catalog.GetOrCreate
func (mmGetOrCreate *mCatalogMockGetOrCreate) Return(s1 SharedStateAccessor) *CatalogMock {
	if mmGetOrCreate.mock.funcGetOrCreate != nil {
		mmGetOrCreate.mock.t.Fatalf("CatalogMock.GetOrCreate mock is already set by Set")
	}

	if mmGetOrCreate.defaultExpectation == nil {
		mmGetOrCreate.defaultExpectation = &CatalogMockGetOrCreateExpectation{mock: mmGetOrCreate.mock}
	}
	mmGetOrCreate.defaultExpectation.results = &CatalogMockGetOrCreateResults{s1}
	return mmGetOrCreate.mock
}

//Set uses given function f to mock the Catalog.GetOrCreate method
func (mmGetOrCreate *mCatalogMockGetOrCreate) Set(f func(e1 smachine.ExecutionContext, objectReference reference.Global) (s1 SharedStateAccessor)) *CatalogMock {
	if mmGetOrCreate.defaultExpectation != nil {
		mmGetOrCreate.mock.t.Fatalf("Default expectation is already set for the Catalog.GetOrCreate method")
	}

	if len(mmGetOrCreate.expectations) > 0 {
		mmGetOrCreate.mock.t.Fatalf("Some expectations are already set for the Catalog.GetOrCreate method")
	}

	mmGetOrCreate.mock.funcGetOrCreate = f
	return mmGetOrCreate.mock
}

// When sets expectation for the Catalog.GetOrCreate which will trigger the result defined by the following
// Then helper
func (mmGetOrCreate *mCatalogMockGetOrCreate) When(e1 smachine.ExecutionContext, objectReference reference.Global) *CatalogMockGetOrCreateExpectation {
	if mmGetOrCreate.mock.funcGetOrCreate != nil {
		mmGetOrCreate.mock.t.Fatalf("CatalogMock.GetOrCreate mock is already set by Set")
	}

	expectation := &CatalogMockGetOrCreateExpectation{
		mock:   mmGetOrCreate.mock,
		params: &CatalogMockGetOrCreateParams{e1, objectReference},
	}
	mmGetOrCreate.expectations = append(mmGetOrCreate.expectations, expectation)
	return expectation
}

// Then sets up Catalog.GetOrCreate return parameters for the expectation previously defined by the When method
func (e *CatalogMockGetOrCreateExpectation) Then(s1 SharedStateAccessor) *CatalogMock {
	e.results = &CatalogMockGetOrCreateResults{s1}
	return e.mock
}

// GetOrCreate implements Catalog
func (mmGetOrCreate *CatalogMock) GetOrCreate(e1 smachine.ExecutionContext, objectReference reference.Global) (s1 SharedStateAccessor) {
	mm_atomic.AddUint64(&mmGetOrCreate.beforeGetOrCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrCreate.afterGetOrCreateCounter, 1)

	if mmGetOrCreate.inspectFuncGetOrCreate != nil {
		mmGetOrCreate.inspectFuncGetOrCreate(e1, objectReference)
	}

	mm_params := &CatalogMockGetOrCreateParams{e1, objectReference}

	// Record call args
	mmGetOrCreate.GetOrCreateMock.mutex.Lock()
	mmGetOrCreate.GetOrCreateMock.callArgs = append(mmGetOrCreate.GetOrCreateMock.callArgs, mm_params)
	mmGetOrCreate.GetOrCreateMock.mutex.Unlock()

	for _, e := range mmGetOrCreate.GetOrCreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmGetOrCreate.GetOrCreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrCreate.GetOrCreateMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrCreate.GetOrCreateMock.defaultExpectation.params
		mm_got := CatalogMockGetOrCreateParams{e1, objectReference}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrCreate.t.Errorf("CatalogMock.GetOrCreate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrCreate.GetOrCreateMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrCreate.t.Fatal("No results are set for the CatalogMock.GetOrCreate")
		}
		return (*mm_results).s1
	}
	if mmGetOrCreate.funcGetOrCreate != nil {
		return mmGetOrCreate.funcGetOrCreate(e1, objectReference)
	}
	mmGetOrCreate.t.Fatalf("Unexpected call to CatalogMock.GetOrCreate. %v %v", e1, objectReference)
	return
}

// GetOrCreateAfterCounter returns a count of finished CatalogMock.GetOrCreate invocations
func (mmGetOrCreate *CatalogMock) GetOrCreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrCreate.afterGetOrCreateCounter)
}

// GetOrCreateBeforeCounter returns a count of CatalogMock.GetOrCreate invocations
func (mmGetOrCreate *CatalogMock) GetOrCreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrCreate.beforeGetOrCreateCounter)
}

// Calls returns a list of arguments used in each call to CatalogMock.GetOrCreate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrCreate *mCatalogMockGetOrCreate) Calls() []*CatalogMockGetOrCreateParams {
	mmGetOrCreate.mutex.RLock()

	argCopy := make([]*CatalogMockGetOrCreateParams, len(mmGetOrCreate.callArgs))
	copy(argCopy, mmGetOrCreate.callArgs)

	mmGetOrCreate.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrCreateDone returns true if the count of the GetOrCreate invocations corresponds
// the number of defined expectations
func (m *CatalogMock) MinimockGetOrCreateDone() bool {
	for _, e := range m.GetOrCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrCreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrCreate != nil && mm_atomic.LoadUint64(&m.afterGetOrCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOrCreateInspect logs each unmet expectation
func (m *CatalogMock) MinimockGetOrCreateInspect() {
	for _, e := range m.GetOrCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CatalogMock.GetOrCreate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrCreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrCreateCounter) < 1 {
		if m.GetOrCreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CatalogMock.GetOrCreate")
		} else {
			m.t.Errorf("Expected call to CatalogMock.GetOrCreate with params: %#v", *m.GetOrCreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrCreate != nil && mm_atomic.LoadUint64(&m.afterGetOrCreateCounter) < 1 {
		m.t.Error("Expected call to CatalogMock.GetOrCreate")
	}
}

type mCatalogMockTryGet struct {
	mock               *CatalogMock
	defaultExpectation *CatalogMockTryGetExpectation
	expectations       []*CatalogMockTryGetExpectation

	callArgs []*CatalogMockTryGetParams
	mutex    sync.RWMutex
}

// CatalogMockTryGetExpectation specifies expectation struct of the Catalog.TryGet
type CatalogMockTryGetExpectation struct {
	mock    *CatalogMock
	params  *CatalogMockTryGetParams
	results *CatalogMockTryGetResults
	Counter uint64
}

// CatalogMockTryGetParams contains parameters of the Catalog.TryGet
type CatalogMockTryGetParams struct {
	e1              smachine.ExecutionContext
	objectReference reference.Global
}

// CatalogMockTryGetResults contains results of the Catalog.TryGet
type CatalogMockTryGetResults struct {
	s1 SharedStateAccessor
	b1 bool
}

// Expect sets up expected params for Catalog.TryGet
func (mmTryGet *mCatalogMockTryGet) Expect(e1 smachine.ExecutionContext, objectReference reference.Global) *mCatalogMockTryGet {
	if mmTryGet.mock.funcTryGet != nil {
		mmTryGet.mock.t.Fatalf("CatalogMock.TryGet mock is already set by Set")
	}

	if mmTryGet.defaultExpectation == nil {
		mmTryGet.defaultExpectation = &CatalogMockTryGetExpectation{}
	}

	mmTryGet.defaultExpectation.params = &CatalogMockTryGetParams{e1, objectReference}
	for _, e := range mmTryGet.expectations {
		if minimock.Equal(e.params, mmTryGet.defaultExpectation.params) {
			mmTryGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTryGet.defaultExpectation.params)
		}
	}

	return mmTryGet
}

// Inspect accepts an inspector function that has same arguments as the Catalog.TryGet
func (mmTryGet *mCatalogMockTryGet) Inspect(f func(e1 smachine.ExecutionContext, objectReference reference.Global)) *mCatalogMockTryGet {
	if mmTryGet.mock.inspectFuncTryGet != nil {
		mmTryGet.mock.t.Fatalf("Inspect function is already set for CatalogMock.TryGet")
	}

	mmTryGet.mock.inspectFuncTryGet = f

	return mmTryGet
}

// Return sets up results that will be returned by Catalog.TryGet
func (mmTryGet *mCatalogMockTryGet) Return(s1 SharedStateAccessor, b1 bool) *CatalogMock {
	if mmTryGet.mock.funcTryGet != nil {
		mmTryGet.mock.t.Fatalf("CatalogMock.TryGet mock is already set by Set")
	}

	if mmTryGet.defaultExpectation == nil {
		mmTryGet.defaultExpectation = &CatalogMockTryGetExpectation{mock: mmTryGet.mock}
	}
	mmTryGet.defaultExpectation.results = &CatalogMockTryGetResults{s1, b1}
	return mmTryGet.mock
}

//Set uses given function f to mock the Catalog.TryGet method
func (mmTryGet *mCatalogMockTryGet) Set(f func(e1 smachine.ExecutionContext, objectReference reference.Global) (s1 SharedStateAccessor, b1 bool)) *CatalogMock {
	if mmTryGet.defaultExpectation != nil {
		mmTryGet.mock.t.Fatalf("Default expectation is already set for the Catalog.TryGet method")
	}

	if len(mmTryGet.expectations) > 0 {
		mmTryGet.mock.t.Fatalf("Some expectations are already set for the Catalog.TryGet method")
	}

	mmTryGet.mock.funcTryGet = f
	return mmTryGet.mock
}

// When sets expectation for the Catalog.TryGet which will trigger the result defined by the following
// Then helper
func (mmTryGet *mCatalogMockTryGet) When(e1 smachine.ExecutionContext, objectReference reference.Global) *CatalogMockTryGetExpectation {
	if mmTryGet.mock.funcTryGet != nil {
		mmTryGet.mock.t.Fatalf("CatalogMock.TryGet mock is already set by Set")
	}

	expectation := &CatalogMockTryGetExpectation{
		mock:   mmTryGet.mock,
		params: &CatalogMockTryGetParams{e1, objectReference},
	}
	mmTryGet.expectations = append(mmTryGet.expectations, expectation)
	return expectation
}

// Then sets up Catalog.TryGet return parameters for the expectation previously defined by the When method
func (e *CatalogMockTryGetExpectation) Then(s1 SharedStateAccessor, b1 bool) *CatalogMock {
	e.results = &CatalogMockTryGetResults{s1, b1}
	return e.mock
}

// TryGet implements Catalog
func (mmTryGet *CatalogMock) TryGet(e1 smachine.ExecutionContext, objectReference reference.Global) (s1 SharedStateAccessor, b1 bool) {
	mm_atomic.AddUint64(&mmTryGet.beforeTryGetCounter, 1)
	defer mm_atomic.AddUint64(&mmTryGet.afterTryGetCounter, 1)

	if mmTryGet.inspectFuncTryGet != nil {
		mmTryGet.inspectFuncTryGet(e1, objectReference)
	}

	mm_params := &CatalogMockTryGetParams{e1, objectReference}

	// Record call args
	mmTryGet.TryGetMock.mutex.Lock()
	mmTryGet.TryGetMock.callArgs = append(mmTryGet.TryGetMock.callArgs, mm_params)
	mmTryGet.TryGetMock.mutex.Unlock()

	for _, e := range mmTryGet.TryGetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.b1
		}
	}

	if mmTryGet.TryGetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTryGet.TryGetMock.defaultExpectation.Counter, 1)
		mm_want := mmTryGet.TryGetMock.defaultExpectation.params
		mm_got := CatalogMockTryGetParams{e1, objectReference}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTryGet.t.Errorf("CatalogMock.TryGet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTryGet.TryGetMock.defaultExpectation.results
		if mm_results == nil {
			mmTryGet.t.Fatal("No results are set for the CatalogMock.TryGet")
		}
		return (*mm_results).s1, (*mm_results).b1
	}
	if mmTryGet.funcTryGet != nil {
		return mmTryGet.funcTryGet(e1, objectReference)
	}
	mmTryGet.t.Fatalf("Unexpected call to CatalogMock.TryGet. %v %v", e1, objectReference)
	return
}

// TryGetAfterCounter returns a count of finished CatalogMock.TryGet invocations
func (mmTryGet *CatalogMock) TryGetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTryGet.afterTryGetCounter)
}

// TryGetBeforeCounter returns a count of CatalogMock.TryGet invocations
func (mmTryGet *CatalogMock) TryGetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTryGet.beforeTryGetCounter)
}

// Calls returns a list of arguments used in each call to CatalogMock.TryGet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTryGet *mCatalogMockTryGet) Calls() []*CatalogMockTryGetParams {
	mmTryGet.mutex.RLock()

	argCopy := make([]*CatalogMockTryGetParams, len(mmTryGet.callArgs))
	copy(argCopy, mmTryGet.callArgs)

	mmTryGet.mutex.RUnlock()

	return argCopy
}

// MinimockTryGetDone returns true if the count of the TryGet invocations corresponds
// the number of defined expectations
func (m *CatalogMock) MinimockTryGetDone() bool {
	for _, e := range m.TryGetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TryGetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTryGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTryGet != nil && mm_atomic.LoadUint64(&m.afterTryGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockTryGetInspect logs each unmet expectation
func (m *CatalogMock) MinimockTryGetInspect() {
	for _, e := range m.TryGetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CatalogMock.TryGet with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TryGetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTryGetCounter) < 1 {
		if m.TryGetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CatalogMock.TryGet")
		} else {
			m.t.Errorf("Expected call to CatalogMock.TryGet with params: %#v", *m.TryGetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTryGet != nil && mm_atomic.LoadUint64(&m.afterTryGetCounter) < 1 {
		m.t.Error("Expected call to CatalogMock.TryGet")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CatalogMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockGetInspect()

		m.MinimockGetOrCreateInspect()

		m.MinimockTryGetInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CatalogMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CatalogMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetOrCreateDone() &&
		m.MinimockTryGetDone()
}
