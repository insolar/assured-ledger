package cryptkit

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/v2/vanilla/longbits"
)

// SignatureKeyHolderMock implements SignatureKeyHolder
type SignatureKeyHolderMock struct {
	t minimock.Tester

	funcAsByteString          func() (b1 longbits.ByteString)
	inspectFuncAsByteString   func()
	afterAsByteStringCounter  uint64
	beforeAsByteStringCounter uint64
	AsByteStringMock          mSignatureKeyHolderMockAsByteString

	funcCopyTo          func(p []byte) (i1 int)
	inspectFuncCopyTo   func(p []byte)
	afterCopyToCounter  uint64
	beforeCopyToCounter uint64
	CopyToMock          mSignatureKeyHolderMockCopyTo

	funcEquals          func(other SignatureKeyHolder) (b1 bool)
	inspectFuncEquals   func(other SignatureKeyHolder)
	afterEqualsCounter  uint64
	beforeEqualsCounter uint64
	EqualsMock          mSignatureKeyHolderMockEquals

	funcFixedByteSize          func() (i1 int)
	inspectFuncFixedByteSize   func()
	afterFixedByteSizeCounter  uint64
	beforeFixedByteSizeCounter uint64
	FixedByteSizeMock          mSignatureKeyHolderMockFixedByteSize

	funcFoldToUint64          func() (u1 uint64)
	inspectFuncFoldToUint64   func()
	afterFoldToUint64Counter  uint64
	beforeFoldToUint64Counter uint64
	FoldToUint64Mock          mSignatureKeyHolderMockFoldToUint64

	funcGetSignatureKeyMethod          func() (s1 SignatureMethod)
	inspectFuncGetSignatureKeyMethod   func()
	afterGetSignatureKeyMethodCounter  uint64
	beforeGetSignatureKeyMethodCounter uint64
	GetSignatureKeyMethodMock          mSignatureKeyHolderMockGetSignatureKeyMethod

	funcGetSignatureKeyType          func() (s1 SignatureKeyType)
	inspectFuncGetSignatureKeyType   func()
	afterGetSignatureKeyTypeCounter  uint64
	beforeGetSignatureKeyTypeCounter uint64
	GetSignatureKeyTypeMock          mSignatureKeyHolderMockGetSignatureKeyType

	funcGetSigningMethod          func() (s1 SigningMethod)
	inspectFuncGetSigningMethod   func()
	afterGetSigningMethodCounter  uint64
	beforeGetSigningMethodCounter uint64
	GetSigningMethodMock          mSignatureKeyHolderMockGetSigningMethod

	funcWriteTo          func(w io.Writer) (n int64, err error)
	inspectFuncWriteTo   func(w io.Writer)
	afterWriteToCounter  uint64
	beforeWriteToCounter uint64
	WriteToMock          mSignatureKeyHolderMockWriteTo
}

// NewSignatureKeyHolderMock returns a mock for SignatureKeyHolder
func NewSignatureKeyHolderMock(t minimock.Tester) *SignatureKeyHolderMock {
	m := &SignatureKeyHolderMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AsByteStringMock = mSignatureKeyHolderMockAsByteString{mock: m}

	m.CopyToMock = mSignatureKeyHolderMockCopyTo{mock: m}
	m.CopyToMock.callArgs = []*SignatureKeyHolderMockCopyToParams{}

	m.EqualsMock = mSignatureKeyHolderMockEquals{mock: m}
	m.EqualsMock.callArgs = []*SignatureKeyHolderMockEqualsParams{}

	m.FixedByteSizeMock = mSignatureKeyHolderMockFixedByteSize{mock: m}

	m.FoldToUint64Mock = mSignatureKeyHolderMockFoldToUint64{mock: m}

	m.GetSignatureKeyMethodMock = mSignatureKeyHolderMockGetSignatureKeyMethod{mock: m}

	m.GetSignatureKeyTypeMock = mSignatureKeyHolderMockGetSignatureKeyType{mock: m}

	m.GetSigningMethodMock = mSignatureKeyHolderMockGetSigningMethod{mock: m}

	m.WriteToMock = mSignatureKeyHolderMockWriteTo{mock: m}
	m.WriteToMock.callArgs = []*SignatureKeyHolderMockWriteToParams{}

	return m
}

type mSignatureKeyHolderMockAsByteString struct {
	mock               *SignatureKeyHolderMock
	defaultExpectation *SignatureKeyHolderMockAsByteStringExpectation
	expectations       []*SignatureKeyHolderMockAsByteStringExpectation
}

// SignatureKeyHolderMockAsByteStringExpectation specifies expectation struct of the SignatureKeyHolder.AsByteString
type SignatureKeyHolderMockAsByteStringExpectation struct {
	mock *SignatureKeyHolderMock

	results *SignatureKeyHolderMockAsByteStringResults
	Counter uint64
}

// SignatureKeyHolderMockAsByteStringResults contains results of the SignatureKeyHolder.AsByteString
type SignatureKeyHolderMockAsByteStringResults struct {
	b1 longbits.ByteString
}

// Expect sets up expected params for SignatureKeyHolder.AsByteString
func (mmAsByteString *mSignatureKeyHolderMockAsByteString) Expect() *mSignatureKeyHolderMockAsByteString {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("SignatureKeyHolderMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &SignatureKeyHolderMockAsByteStringExpectation{}
	}

	return mmAsByteString
}

// Inspect accepts an inspector function that has same arguments as the SignatureKeyHolder.AsByteString
func (mmAsByteString *mSignatureKeyHolderMockAsByteString) Inspect(f func()) *mSignatureKeyHolderMockAsByteString {
	if mmAsByteString.mock.inspectFuncAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("Inspect function is already set for SignatureKeyHolderMock.AsByteString")
	}

	mmAsByteString.mock.inspectFuncAsByteString = f

	return mmAsByteString
}

// Return sets up results that will be returned by SignatureKeyHolder.AsByteString
func (mmAsByteString *mSignatureKeyHolderMockAsByteString) Return(b1 longbits.ByteString) *SignatureKeyHolderMock {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("SignatureKeyHolderMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &SignatureKeyHolderMockAsByteStringExpectation{mock: mmAsByteString.mock}
	}
	mmAsByteString.defaultExpectation.results = &SignatureKeyHolderMockAsByteStringResults{b1}
	return mmAsByteString.mock
}

//Set uses given function f to mock the SignatureKeyHolder.AsByteString method
func (mmAsByteString *mSignatureKeyHolderMockAsByteString) Set(f func() (b1 longbits.ByteString)) *SignatureKeyHolderMock {
	if mmAsByteString.defaultExpectation != nil {
		mmAsByteString.mock.t.Fatalf("Default expectation is already set for the SignatureKeyHolder.AsByteString method")
	}

	if len(mmAsByteString.expectations) > 0 {
		mmAsByteString.mock.t.Fatalf("Some expectations are already set for the SignatureKeyHolder.AsByteString method")
	}

	mmAsByteString.mock.funcAsByteString = f
	return mmAsByteString.mock
}

// AsByteString implements SignatureKeyHolder
func (mmAsByteString *SignatureKeyHolderMock) AsByteString() (b1 longbits.ByteString) {
	mm_atomic.AddUint64(&mmAsByteString.beforeAsByteStringCounter, 1)
	defer mm_atomic.AddUint64(&mmAsByteString.afterAsByteStringCounter, 1)

	if mmAsByteString.inspectFuncAsByteString != nil {
		mmAsByteString.inspectFuncAsByteString()
	}

	if mmAsByteString.AsByteStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsByteString.AsByteStringMock.defaultExpectation.Counter, 1)

		mm_results := mmAsByteString.AsByteStringMock.defaultExpectation.results
		if mm_results == nil {
			mmAsByteString.t.Fatal("No results are set for the SignatureKeyHolderMock.AsByteString")
		}
		return (*mm_results).b1
	}
	if mmAsByteString.funcAsByteString != nil {
		return mmAsByteString.funcAsByteString()
	}
	mmAsByteString.t.Fatalf("Unexpected call to SignatureKeyHolderMock.AsByteString.")
	return
}

// AsByteStringAfterCounter returns a count of finished SignatureKeyHolderMock.AsByteString invocations
func (mmAsByteString *SignatureKeyHolderMock) AsByteStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.afterAsByteStringCounter)
}

// AsByteStringBeforeCounter returns a count of SignatureKeyHolderMock.AsByteString invocations
func (mmAsByteString *SignatureKeyHolderMock) AsByteStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.beforeAsByteStringCounter)
}

// MinimockAsByteStringDone returns true if the count of the AsByteString invocations corresponds
// the number of defined expectations
func (m *SignatureKeyHolderMock) MinimockAsByteStringDone() bool {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsByteStringInspect logs each unmet expectation
func (m *SignatureKeyHolderMock) MinimockAsByteStringInspect() {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureKeyHolderMock.AsByteString")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.AsByteString")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.AsByteString")
	}
}

type mSignatureKeyHolderMockCopyTo struct {
	mock               *SignatureKeyHolderMock
	defaultExpectation *SignatureKeyHolderMockCopyToExpectation
	expectations       []*SignatureKeyHolderMockCopyToExpectation

	callArgs []*SignatureKeyHolderMockCopyToParams
	mutex    sync.RWMutex
}

// SignatureKeyHolderMockCopyToExpectation specifies expectation struct of the SignatureKeyHolder.CopyTo
type SignatureKeyHolderMockCopyToExpectation struct {
	mock    *SignatureKeyHolderMock
	params  *SignatureKeyHolderMockCopyToParams
	results *SignatureKeyHolderMockCopyToResults
	Counter uint64
}

// SignatureKeyHolderMockCopyToParams contains parameters of the SignatureKeyHolder.CopyTo
type SignatureKeyHolderMockCopyToParams struct {
	p []byte
}

// SignatureKeyHolderMockCopyToResults contains results of the SignatureKeyHolder.CopyTo
type SignatureKeyHolderMockCopyToResults struct {
	i1 int
}

// Expect sets up expected params for SignatureKeyHolder.CopyTo
func (mmCopyTo *mSignatureKeyHolderMockCopyTo) Expect(p []byte) *mSignatureKeyHolderMockCopyTo {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("SignatureKeyHolderMock.CopyTo mock is already set by Set")
	}

	if mmCopyTo.defaultExpectation == nil {
		mmCopyTo.defaultExpectation = &SignatureKeyHolderMockCopyToExpectation{}
	}

	mmCopyTo.defaultExpectation.params = &SignatureKeyHolderMockCopyToParams{p}
	for _, e := range mmCopyTo.expectations {
		if minimock.Equal(e.params, mmCopyTo.defaultExpectation.params) {
			mmCopyTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCopyTo.defaultExpectation.params)
		}
	}

	return mmCopyTo
}

// Inspect accepts an inspector function that has same arguments as the SignatureKeyHolder.CopyTo
func (mmCopyTo *mSignatureKeyHolderMockCopyTo) Inspect(f func(p []byte)) *mSignatureKeyHolderMockCopyTo {
	if mmCopyTo.mock.inspectFuncCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("Inspect function is already set for SignatureKeyHolderMock.CopyTo")
	}

	mmCopyTo.mock.inspectFuncCopyTo = f

	return mmCopyTo
}

// Return sets up results that will be returned by SignatureKeyHolder.CopyTo
func (mmCopyTo *mSignatureKeyHolderMockCopyTo) Return(i1 int) *SignatureKeyHolderMock {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("SignatureKeyHolderMock.CopyTo mock is already set by Set")
	}

	if mmCopyTo.defaultExpectation == nil {
		mmCopyTo.defaultExpectation = &SignatureKeyHolderMockCopyToExpectation{mock: mmCopyTo.mock}
	}
	mmCopyTo.defaultExpectation.results = &SignatureKeyHolderMockCopyToResults{i1}
	return mmCopyTo.mock
}

//Set uses given function f to mock the SignatureKeyHolder.CopyTo method
func (mmCopyTo *mSignatureKeyHolderMockCopyTo) Set(f func(p []byte) (i1 int)) *SignatureKeyHolderMock {
	if mmCopyTo.defaultExpectation != nil {
		mmCopyTo.mock.t.Fatalf("Default expectation is already set for the SignatureKeyHolder.CopyTo method")
	}

	if len(mmCopyTo.expectations) > 0 {
		mmCopyTo.mock.t.Fatalf("Some expectations are already set for the SignatureKeyHolder.CopyTo method")
	}

	mmCopyTo.mock.funcCopyTo = f
	return mmCopyTo.mock
}

// When sets expectation for the SignatureKeyHolder.CopyTo which will trigger the result defined by the following
// Then helper
func (mmCopyTo *mSignatureKeyHolderMockCopyTo) When(p []byte) *SignatureKeyHolderMockCopyToExpectation {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("SignatureKeyHolderMock.CopyTo mock is already set by Set")
	}

	expectation := &SignatureKeyHolderMockCopyToExpectation{
		mock:   mmCopyTo.mock,
		params: &SignatureKeyHolderMockCopyToParams{p},
	}
	mmCopyTo.expectations = append(mmCopyTo.expectations, expectation)
	return expectation
}

// Then sets up SignatureKeyHolder.CopyTo return parameters for the expectation previously defined by the When method
func (e *SignatureKeyHolderMockCopyToExpectation) Then(i1 int) *SignatureKeyHolderMock {
	e.results = &SignatureKeyHolderMockCopyToResults{i1}
	return e.mock
}

// CopyTo implements SignatureKeyHolder
func (mmCopyTo *SignatureKeyHolderMock) CopyTo(p []byte) (i1 int) {
	mm_atomic.AddUint64(&mmCopyTo.beforeCopyToCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyTo.afterCopyToCounter, 1)

	if mmCopyTo.inspectFuncCopyTo != nil {
		mmCopyTo.inspectFuncCopyTo(p)
	}

	mm_params := &SignatureKeyHolderMockCopyToParams{p}

	// Record call args
	mmCopyTo.CopyToMock.mutex.Lock()
	mmCopyTo.CopyToMock.callArgs = append(mmCopyTo.CopyToMock.callArgs, mm_params)
	mmCopyTo.CopyToMock.mutex.Unlock()

	for _, e := range mmCopyTo.CopyToMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1
		}
	}

	if mmCopyTo.CopyToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyTo.CopyToMock.defaultExpectation.Counter, 1)
		mm_want := mmCopyTo.CopyToMock.defaultExpectation.params
		mm_got := SignatureKeyHolderMockCopyToParams{p}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCopyTo.t.Errorf("SignatureKeyHolderMock.CopyTo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCopyTo.CopyToMock.defaultExpectation.results
		if mm_results == nil {
			mmCopyTo.t.Fatal("No results are set for the SignatureKeyHolderMock.CopyTo")
		}
		return (*mm_results).i1
	}
	if mmCopyTo.funcCopyTo != nil {
		return mmCopyTo.funcCopyTo(p)
	}
	mmCopyTo.t.Fatalf("Unexpected call to SignatureKeyHolderMock.CopyTo. %v", p)
	return
}

// CopyToAfterCounter returns a count of finished SignatureKeyHolderMock.CopyTo invocations
func (mmCopyTo *SignatureKeyHolderMock) CopyToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyTo.afterCopyToCounter)
}

// CopyToBeforeCounter returns a count of SignatureKeyHolderMock.CopyTo invocations
func (mmCopyTo *SignatureKeyHolderMock) CopyToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyTo.beforeCopyToCounter)
}

// Calls returns a list of arguments used in each call to SignatureKeyHolderMock.CopyTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCopyTo *mSignatureKeyHolderMockCopyTo) Calls() []*SignatureKeyHolderMockCopyToParams {
	mmCopyTo.mutex.RLock()

	argCopy := make([]*SignatureKeyHolderMockCopyToParams, len(mmCopyTo.callArgs))
	copy(argCopy, mmCopyTo.callArgs)

	mmCopyTo.mutex.RUnlock()

	return argCopy
}

// MinimockCopyToDone returns true if the count of the CopyTo invocations corresponds
// the number of defined expectations
func (m *SignatureKeyHolderMock) MinimockCopyToDone() bool {
	for _, e := range m.CopyToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyTo != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyToInspect logs each unmet expectation
func (m *SignatureKeyHolderMock) MinimockCopyToInspect() {
	for _, e := range m.CopyToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SignatureKeyHolderMock.CopyTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		if m.CopyToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SignatureKeyHolderMock.CopyTo")
		} else {
			m.t.Errorf("Expected call to SignatureKeyHolderMock.CopyTo with params: %#v", *m.CopyToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyTo != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.CopyTo")
	}
}

type mSignatureKeyHolderMockEquals struct {
	mock               *SignatureKeyHolderMock
	defaultExpectation *SignatureKeyHolderMockEqualsExpectation
	expectations       []*SignatureKeyHolderMockEqualsExpectation

	callArgs []*SignatureKeyHolderMockEqualsParams
	mutex    sync.RWMutex
}

// SignatureKeyHolderMockEqualsExpectation specifies expectation struct of the SignatureKeyHolder.Equals
type SignatureKeyHolderMockEqualsExpectation struct {
	mock    *SignatureKeyHolderMock
	params  *SignatureKeyHolderMockEqualsParams
	results *SignatureKeyHolderMockEqualsResults
	Counter uint64
}

// SignatureKeyHolderMockEqualsParams contains parameters of the SignatureKeyHolder.Equals
type SignatureKeyHolderMockEqualsParams struct {
	other SignatureKeyHolder
}

// SignatureKeyHolderMockEqualsResults contains results of the SignatureKeyHolder.Equals
type SignatureKeyHolderMockEqualsResults struct {
	b1 bool
}

// Expect sets up expected params for SignatureKeyHolder.Equals
func (mmEquals *mSignatureKeyHolderMockEquals) Expect(other SignatureKeyHolder) *mSignatureKeyHolderMockEquals {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("SignatureKeyHolderMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &SignatureKeyHolderMockEqualsExpectation{}
	}

	mmEquals.defaultExpectation.params = &SignatureKeyHolderMockEqualsParams{other}
	for _, e := range mmEquals.expectations {
		if minimock.Equal(e.params, mmEquals.defaultExpectation.params) {
			mmEquals.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEquals.defaultExpectation.params)
		}
	}

	return mmEquals
}

// Inspect accepts an inspector function that has same arguments as the SignatureKeyHolder.Equals
func (mmEquals *mSignatureKeyHolderMockEquals) Inspect(f func(other SignatureKeyHolder)) *mSignatureKeyHolderMockEquals {
	if mmEquals.mock.inspectFuncEquals != nil {
		mmEquals.mock.t.Fatalf("Inspect function is already set for SignatureKeyHolderMock.Equals")
	}

	mmEquals.mock.inspectFuncEquals = f

	return mmEquals
}

// Return sets up results that will be returned by SignatureKeyHolder.Equals
func (mmEquals *mSignatureKeyHolderMockEquals) Return(b1 bool) *SignatureKeyHolderMock {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("SignatureKeyHolderMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &SignatureKeyHolderMockEqualsExpectation{mock: mmEquals.mock}
	}
	mmEquals.defaultExpectation.results = &SignatureKeyHolderMockEqualsResults{b1}
	return mmEquals.mock
}

//Set uses given function f to mock the SignatureKeyHolder.Equals method
func (mmEquals *mSignatureKeyHolderMockEquals) Set(f func(other SignatureKeyHolder) (b1 bool)) *SignatureKeyHolderMock {
	if mmEquals.defaultExpectation != nil {
		mmEquals.mock.t.Fatalf("Default expectation is already set for the SignatureKeyHolder.Equals method")
	}

	if len(mmEquals.expectations) > 0 {
		mmEquals.mock.t.Fatalf("Some expectations are already set for the SignatureKeyHolder.Equals method")
	}

	mmEquals.mock.funcEquals = f
	return mmEquals.mock
}

// When sets expectation for the SignatureKeyHolder.Equals which will trigger the result defined by the following
// Then helper
func (mmEquals *mSignatureKeyHolderMockEquals) When(other SignatureKeyHolder) *SignatureKeyHolderMockEqualsExpectation {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("SignatureKeyHolderMock.Equals mock is already set by Set")
	}

	expectation := &SignatureKeyHolderMockEqualsExpectation{
		mock:   mmEquals.mock,
		params: &SignatureKeyHolderMockEqualsParams{other},
	}
	mmEquals.expectations = append(mmEquals.expectations, expectation)
	return expectation
}

// Then sets up SignatureKeyHolder.Equals return parameters for the expectation previously defined by the When method
func (e *SignatureKeyHolderMockEqualsExpectation) Then(b1 bool) *SignatureKeyHolderMock {
	e.results = &SignatureKeyHolderMockEqualsResults{b1}
	return e.mock
}

// Equals implements SignatureKeyHolder
func (mmEquals *SignatureKeyHolderMock) Equals(other SignatureKeyHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmEquals.beforeEqualsCounter, 1)
	defer mm_atomic.AddUint64(&mmEquals.afterEqualsCounter, 1)

	if mmEquals.inspectFuncEquals != nil {
		mmEquals.inspectFuncEquals(other)
	}

	mm_params := &SignatureKeyHolderMockEqualsParams{other}

	// Record call args
	mmEquals.EqualsMock.mutex.Lock()
	mmEquals.EqualsMock.callArgs = append(mmEquals.EqualsMock.callArgs, mm_params)
	mmEquals.EqualsMock.mutex.Unlock()

	for _, e := range mmEquals.EqualsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmEquals.EqualsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEquals.EqualsMock.defaultExpectation.Counter, 1)
		mm_want := mmEquals.EqualsMock.defaultExpectation.params
		mm_got := SignatureKeyHolderMockEqualsParams{other}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEquals.t.Errorf("SignatureKeyHolderMock.Equals got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEquals.EqualsMock.defaultExpectation.results
		if mm_results == nil {
			mmEquals.t.Fatal("No results are set for the SignatureKeyHolderMock.Equals")
		}
		return (*mm_results).b1
	}
	if mmEquals.funcEquals != nil {
		return mmEquals.funcEquals(other)
	}
	mmEquals.t.Fatalf("Unexpected call to SignatureKeyHolderMock.Equals. %v", other)
	return
}

// EqualsAfterCounter returns a count of finished SignatureKeyHolderMock.Equals invocations
func (mmEquals *SignatureKeyHolderMock) EqualsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.afterEqualsCounter)
}

// EqualsBeforeCounter returns a count of SignatureKeyHolderMock.Equals invocations
func (mmEquals *SignatureKeyHolderMock) EqualsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.beforeEqualsCounter)
}

// Calls returns a list of arguments used in each call to SignatureKeyHolderMock.Equals.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEquals *mSignatureKeyHolderMockEquals) Calls() []*SignatureKeyHolderMockEqualsParams {
	mmEquals.mutex.RLock()

	argCopy := make([]*SignatureKeyHolderMockEqualsParams, len(mmEquals.callArgs))
	copy(argCopy, mmEquals.callArgs)

	mmEquals.mutex.RUnlock()

	return argCopy
}

// MinimockEqualsDone returns true if the count of the Equals invocations corresponds
// the number of defined expectations
func (m *SignatureKeyHolderMock) MinimockEqualsDone() bool {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	return true
}

// MinimockEqualsInspect logs each unmet expectation
func (m *SignatureKeyHolderMock) MinimockEqualsInspect() {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SignatureKeyHolderMock.Equals with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		if m.EqualsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SignatureKeyHolderMock.Equals")
		} else {
			m.t.Errorf("Expected call to SignatureKeyHolderMock.Equals with params: %#v", *m.EqualsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.Equals")
	}
}

type mSignatureKeyHolderMockFixedByteSize struct {
	mock               *SignatureKeyHolderMock
	defaultExpectation *SignatureKeyHolderMockFixedByteSizeExpectation
	expectations       []*SignatureKeyHolderMockFixedByteSizeExpectation
}

// SignatureKeyHolderMockFixedByteSizeExpectation specifies expectation struct of the SignatureKeyHolder.FixedByteSize
type SignatureKeyHolderMockFixedByteSizeExpectation struct {
	mock *SignatureKeyHolderMock

	results *SignatureKeyHolderMockFixedByteSizeResults
	Counter uint64
}

// SignatureKeyHolderMockFixedByteSizeResults contains results of the SignatureKeyHolder.FixedByteSize
type SignatureKeyHolderMockFixedByteSizeResults struct {
	i1 int
}

// Expect sets up expected params for SignatureKeyHolder.FixedByteSize
func (mmFixedByteSize *mSignatureKeyHolderMockFixedByteSize) Expect() *mSignatureKeyHolderMockFixedByteSize {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("SignatureKeyHolderMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &SignatureKeyHolderMockFixedByteSizeExpectation{}
	}

	return mmFixedByteSize
}

// Inspect accepts an inspector function that has same arguments as the SignatureKeyHolder.FixedByteSize
func (mmFixedByteSize *mSignatureKeyHolderMockFixedByteSize) Inspect(f func()) *mSignatureKeyHolderMockFixedByteSize {
	if mmFixedByteSize.mock.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("Inspect function is already set for SignatureKeyHolderMock.FixedByteSize")
	}

	mmFixedByteSize.mock.inspectFuncFixedByteSize = f

	return mmFixedByteSize
}

// Return sets up results that will be returned by SignatureKeyHolder.FixedByteSize
func (mmFixedByteSize *mSignatureKeyHolderMockFixedByteSize) Return(i1 int) *SignatureKeyHolderMock {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("SignatureKeyHolderMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &SignatureKeyHolderMockFixedByteSizeExpectation{mock: mmFixedByteSize.mock}
	}
	mmFixedByteSize.defaultExpectation.results = &SignatureKeyHolderMockFixedByteSizeResults{i1}
	return mmFixedByteSize.mock
}

//Set uses given function f to mock the SignatureKeyHolder.FixedByteSize method
func (mmFixedByteSize *mSignatureKeyHolderMockFixedByteSize) Set(f func() (i1 int)) *SignatureKeyHolderMock {
	if mmFixedByteSize.defaultExpectation != nil {
		mmFixedByteSize.mock.t.Fatalf("Default expectation is already set for the SignatureKeyHolder.FixedByteSize method")
	}

	if len(mmFixedByteSize.expectations) > 0 {
		mmFixedByteSize.mock.t.Fatalf("Some expectations are already set for the SignatureKeyHolder.FixedByteSize method")
	}

	mmFixedByteSize.mock.funcFixedByteSize = f
	return mmFixedByteSize.mock
}

// FixedByteSize implements SignatureKeyHolder
func (mmFixedByteSize *SignatureKeyHolderMock) FixedByteSize() (i1 int) {
	mm_atomic.AddUint64(&mmFixedByteSize.beforeFixedByteSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmFixedByteSize.afterFixedByteSizeCounter, 1)

	if mmFixedByteSize.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.inspectFuncFixedByteSize()
	}

	if mmFixedByteSize.FixedByteSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFixedByteSize.FixedByteSizeMock.defaultExpectation.Counter, 1)

		mm_results := mmFixedByteSize.FixedByteSizeMock.defaultExpectation.results
		if mm_results == nil {
			mmFixedByteSize.t.Fatal("No results are set for the SignatureKeyHolderMock.FixedByteSize")
		}
		return (*mm_results).i1
	}
	if mmFixedByteSize.funcFixedByteSize != nil {
		return mmFixedByteSize.funcFixedByteSize()
	}
	mmFixedByteSize.t.Fatalf("Unexpected call to SignatureKeyHolderMock.FixedByteSize.")
	return
}

// FixedByteSizeAfterCounter returns a count of finished SignatureKeyHolderMock.FixedByteSize invocations
func (mmFixedByteSize *SignatureKeyHolderMock) FixedByteSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.afterFixedByteSizeCounter)
}

// FixedByteSizeBeforeCounter returns a count of SignatureKeyHolderMock.FixedByteSize invocations
func (mmFixedByteSize *SignatureKeyHolderMock) FixedByteSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.beforeFixedByteSizeCounter)
}

// MinimockFixedByteSizeDone returns true if the count of the FixedByteSize invocations corresponds
// the number of defined expectations
func (m *SignatureKeyHolderMock) MinimockFixedByteSizeDone() bool {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockFixedByteSizeInspect logs each unmet expectation
func (m *SignatureKeyHolderMock) MinimockFixedByteSizeInspect() {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureKeyHolderMock.FixedByteSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.FixedByteSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.FixedByteSize")
	}
}

type mSignatureKeyHolderMockFoldToUint64 struct {
	mock               *SignatureKeyHolderMock
	defaultExpectation *SignatureKeyHolderMockFoldToUint64Expectation
	expectations       []*SignatureKeyHolderMockFoldToUint64Expectation
}

// SignatureKeyHolderMockFoldToUint64Expectation specifies expectation struct of the SignatureKeyHolder.FoldToUint64
type SignatureKeyHolderMockFoldToUint64Expectation struct {
	mock *SignatureKeyHolderMock

	results *SignatureKeyHolderMockFoldToUint64Results
	Counter uint64
}

// SignatureKeyHolderMockFoldToUint64Results contains results of the SignatureKeyHolder.FoldToUint64
type SignatureKeyHolderMockFoldToUint64Results struct {
	u1 uint64
}

// Expect sets up expected params for SignatureKeyHolder.FoldToUint64
func (mmFoldToUint64 *mSignatureKeyHolderMockFoldToUint64) Expect() *mSignatureKeyHolderMockFoldToUint64 {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("SignatureKeyHolderMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &SignatureKeyHolderMockFoldToUint64Expectation{}
	}

	return mmFoldToUint64
}

// Inspect accepts an inspector function that has same arguments as the SignatureKeyHolder.FoldToUint64
func (mmFoldToUint64 *mSignatureKeyHolderMockFoldToUint64) Inspect(f func()) *mSignatureKeyHolderMockFoldToUint64 {
	if mmFoldToUint64.mock.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("Inspect function is already set for SignatureKeyHolderMock.FoldToUint64")
	}

	mmFoldToUint64.mock.inspectFuncFoldToUint64 = f

	return mmFoldToUint64
}

// Return sets up results that will be returned by SignatureKeyHolder.FoldToUint64
func (mmFoldToUint64 *mSignatureKeyHolderMockFoldToUint64) Return(u1 uint64) *SignatureKeyHolderMock {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("SignatureKeyHolderMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &SignatureKeyHolderMockFoldToUint64Expectation{mock: mmFoldToUint64.mock}
	}
	mmFoldToUint64.defaultExpectation.results = &SignatureKeyHolderMockFoldToUint64Results{u1}
	return mmFoldToUint64.mock
}

//Set uses given function f to mock the SignatureKeyHolder.FoldToUint64 method
func (mmFoldToUint64 *mSignatureKeyHolderMockFoldToUint64) Set(f func() (u1 uint64)) *SignatureKeyHolderMock {
	if mmFoldToUint64.defaultExpectation != nil {
		mmFoldToUint64.mock.t.Fatalf("Default expectation is already set for the SignatureKeyHolder.FoldToUint64 method")
	}

	if len(mmFoldToUint64.expectations) > 0 {
		mmFoldToUint64.mock.t.Fatalf("Some expectations are already set for the SignatureKeyHolder.FoldToUint64 method")
	}

	mmFoldToUint64.mock.funcFoldToUint64 = f
	return mmFoldToUint64.mock
}

// FoldToUint64 implements SignatureKeyHolder
func (mmFoldToUint64 *SignatureKeyHolderMock) FoldToUint64() (u1 uint64) {
	mm_atomic.AddUint64(&mmFoldToUint64.beforeFoldToUint64Counter, 1)
	defer mm_atomic.AddUint64(&mmFoldToUint64.afterFoldToUint64Counter, 1)

	if mmFoldToUint64.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.inspectFuncFoldToUint64()
	}

	if mmFoldToUint64.FoldToUint64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFoldToUint64.FoldToUint64Mock.defaultExpectation.Counter, 1)

		mm_results := mmFoldToUint64.FoldToUint64Mock.defaultExpectation.results
		if mm_results == nil {
			mmFoldToUint64.t.Fatal("No results are set for the SignatureKeyHolderMock.FoldToUint64")
		}
		return (*mm_results).u1
	}
	if mmFoldToUint64.funcFoldToUint64 != nil {
		return mmFoldToUint64.funcFoldToUint64()
	}
	mmFoldToUint64.t.Fatalf("Unexpected call to SignatureKeyHolderMock.FoldToUint64.")
	return
}

// FoldToUint64AfterCounter returns a count of finished SignatureKeyHolderMock.FoldToUint64 invocations
func (mmFoldToUint64 *SignatureKeyHolderMock) FoldToUint64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.afterFoldToUint64Counter)
}

// FoldToUint64BeforeCounter returns a count of SignatureKeyHolderMock.FoldToUint64 invocations
func (mmFoldToUint64 *SignatureKeyHolderMock) FoldToUint64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.beforeFoldToUint64Counter)
}

// MinimockFoldToUint64Done returns true if the count of the FoldToUint64 invocations corresponds
// the number of defined expectations
func (m *SignatureKeyHolderMock) MinimockFoldToUint64Done() bool {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	return true
}

// MinimockFoldToUint64Inspect logs each unmet expectation
func (m *SignatureKeyHolderMock) MinimockFoldToUint64Inspect() {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureKeyHolderMock.FoldToUint64")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.FoldToUint64")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.FoldToUint64")
	}
}

type mSignatureKeyHolderMockGetSignatureKeyMethod struct {
	mock               *SignatureKeyHolderMock
	defaultExpectation *SignatureKeyHolderMockGetSignatureKeyMethodExpectation
	expectations       []*SignatureKeyHolderMockGetSignatureKeyMethodExpectation
}

// SignatureKeyHolderMockGetSignatureKeyMethodExpectation specifies expectation struct of the SignatureKeyHolder.GetSignatureKeyMethod
type SignatureKeyHolderMockGetSignatureKeyMethodExpectation struct {
	mock *SignatureKeyHolderMock

	results *SignatureKeyHolderMockGetSignatureKeyMethodResults
	Counter uint64
}

// SignatureKeyHolderMockGetSignatureKeyMethodResults contains results of the SignatureKeyHolder.GetSignatureKeyMethod
type SignatureKeyHolderMockGetSignatureKeyMethodResults struct {
	s1 SignatureMethod
}

// Expect sets up expected params for SignatureKeyHolder.GetSignatureKeyMethod
func (mmGetSignatureKeyMethod *mSignatureKeyHolderMockGetSignatureKeyMethod) Expect() *mSignatureKeyHolderMockGetSignatureKeyMethod {
	if mmGetSignatureKeyMethod.mock.funcGetSignatureKeyMethod != nil {
		mmGetSignatureKeyMethod.mock.t.Fatalf("SignatureKeyHolderMock.GetSignatureKeyMethod mock is already set by Set")
	}

	if mmGetSignatureKeyMethod.defaultExpectation == nil {
		mmGetSignatureKeyMethod.defaultExpectation = &SignatureKeyHolderMockGetSignatureKeyMethodExpectation{}
	}

	return mmGetSignatureKeyMethod
}

// Inspect accepts an inspector function that has same arguments as the SignatureKeyHolder.GetSignatureKeyMethod
func (mmGetSignatureKeyMethod *mSignatureKeyHolderMockGetSignatureKeyMethod) Inspect(f func()) *mSignatureKeyHolderMockGetSignatureKeyMethod {
	if mmGetSignatureKeyMethod.mock.inspectFuncGetSignatureKeyMethod != nil {
		mmGetSignatureKeyMethod.mock.t.Fatalf("Inspect function is already set for SignatureKeyHolderMock.GetSignatureKeyMethod")
	}

	mmGetSignatureKeyMethod.mock.inspectFuncGetSignatureKeyMethod = f

	return mmGetSignatureKeyMethod
}

// Return sets up results that will be returned by SignatureKeyHolder.GetSignatureKeyMethod
func (mmGetSignatureKeyMethod *mSignatureKeyHolderMockGetSignatureKeyMethod) Return(s1 SignatureMethod) *SignatureKeyHolderMock {
	if mmGetSignatureKeyMethod.mock.funcGetSignatureKeyMethod != nil {
		mmGetSignatureKeyMethod.mock.t.Fatalf("SignatureKeyHolderMock.GetSignatureKeyMethod mock is already set by Set")
	}

	if mmGetSignatureKeyMethod.defaultExpectation == nil {
		mmGetSignatureKeyMethod.defaultExpectation = &SignatureKeyHolderMockGetSignatureKeyMethodExpectation{mock: mmGetSignatureKeyMethod.mock}
	}
	mmGetSignatureKeyMethod.defaultExpectation.results = &SignatureKeyHolderMockGetSignatureKeyMethodResults{s1}
	return mmGetSignatureKeyMethod.mock
}

//Set uses given function f to mock the SignatureKeyHolder.GetSignatureKeyMethod method
func (mmGetSignatureKeyMethod *mSignatureKeyHolderMockGetSignatureKeyMethod) Set(f func() (s1 SignatureMethod)) *SignatureKeyHolderMock {
	if mmGetSignatureKeyMethod.defaultExpectation != nil {
		mmGetSignatureKeyMethod.mock.t.Fatalf("Default expectation is already set for the SignatureKeyHolder.GetSignatureKeyMethod method")
	}

	if len(mmGetSignatureKeyMethod.expectations) > 0 {
		mmGetSignatureKeyMethod.mock.t.Fatalf("Some expectations are already set for the SignatureKeyHolder.GetSignatureKeyMethod method")
	}

	mmGetSignatureKeyMethod.mock.funcGetSignatureKeyMethod = f
	return mmGetSignatureKeyMethod.mock
}

// GetSignatureKeyMethod implements SignatureKeyHolder
func (mmGetSignatureKeyMethod *SignatureKeyHolderMock) GetSignatureKeyMethod() (s1 SignatureMethod) {
	mm_atomic.AddUint64(&mmGetSignatureKeyMethod.beforeGetSignatureKeyMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSignatureKeyMethod.afterGetSignatureKeyMethodCounter, 1)

	if mmGetSignatureKeyMethod.inspectFuncGetSignatureKeyMethod != nil {
		mmGetSignatureKeyMethod.inspectFuncGetSignatureKeyMethod()
	}

	if mmGetSignatureKeyMethod.GetSignatureKeyMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSignatureKeyMethod.GetSignatureKeyMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetSignatureKeyMethod.GetSignatureKeyMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSignatureKeyMethod.t.Fatal("No results are set for the SignatureKeyHolderMock.GetSignatureKeyMethod")
		}
		return (*mm_results).s1
	}
	if mmGetSignatureKeyMethod.funcGetSignatureKeyMethod != nil {
		return mmGetSignatureKeyMethod.funcGetSignatureKeyMethod()
	}
	mmGetSignatureKeyMethod.t.Fatalf("Unexpected call to SignatureKeyHolderMock.GetSignatureKeyMethod.")
	return
}

// GetSignatureKeyMethodAfterCounter returns a count of finished SignatureKeyHolderMock.GetSignatureKeyMethod invocations
func (mmGetSignatureKeyMethod *SignatureKeyHolderMock) GetSignatureKeyMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureKeyMethod.afterGetSignatureKeyMethodCounter)
}

// GetSignatureKeyMethodBeforeCounter returns a count of SignatureKeyHolderMock.GetSignatureKeyMethod invocations
func (mmGetSignatureKeyMethod *SignatureKeyHolderMock) GetSignatureKeyMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureKeyMethod.beforeGetSignatureKeyMethodCounter)
}

// MinimockGetSignatureKeyMethodDone returns true if the count of the GetSignatureKeyMethod invocations corresponds
// the number of defined expectations
func (m *SignatureKeyHolderMock) MinimockGetSignatureKeyMethodDone() bool {
	for _, e := range m.GetSignatureKeyMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureKeyMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureKeyMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureKeyMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignatureKeyMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSignatureKeyMethodInspect logs each unmet expectation
func (m *SignatureKeyHolderMock) MinimockGetSignatureKeyMethodInspect() {
	for _, e := range m.GetSignatureKeyMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureKeyHolderMock.GetSignatureKeyMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureKeyMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureKeyMethodCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.GetSignatureKeyMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureKeyMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignatureKeyMethodCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.GetSignatureKeyMethod")
	}
}

type mSignatureKeyHolderMockGetSignatureKeyType struct {
	mock               *SignatureKeyHolderMock
	defaultExpectation *SignatureKeyHolderMockGetSignatureKeyTypeExpectation
	expectations       []*SignatureKeyHolderMockGetSignatureKeyTypeExpectation
}

// SignatureKeyHolderMockGetSignatureKeyTypeExpectation specifies expectation struct of the SignatureKeyHolder.GetSignatureKeyType
type SignatureKeyHolderMockGetSignatureKeyTypeExpectation struct {
	mock *SignatureKeyHolderMock

	results *SignatureKeyHolderMockGetSignatureKeyTypeResults
	Counter uint64
}

// SignatureKeyHolderMockGetSignatureKeyTypeResults contains results of the SignatureKeyHolder.GetSignatureKeyType
type SignatureKeyHolderMockGetSignatureKeyTypeResults struct {
	s1 SignatureKeyType
}

// Expect sets up expected params for SignatureKeyHolder.GetSignatureKeyType
func (mmGetSignatureKeyType *mSignatureKeyHolderMockGetSignatureKeyType) Expect() *mSignatureKeyHolderMockGetSignatureKeyType {
	if mmGetSignatureKeyType.mock.funcGetSignatureKeyType != nil {
		mmGetSignatureKeyType.mock.t.Fatalf("SignatureKeyHolderMock.GetSignatureKeyType mock is already set by Set")
	}

	if mmGetSignatureKeyType.defaultExpectation == nil {
		mmGetSignatureKeyType.defaultExpectation = &SignatureKeyHolderMockGetSignatureKeyTypeExpectation{}
	}

	return mmGetSignatureKeyType
}

// Inspect accepts an inspector function that has same arguments as the SignatureKeyHolder.GetSignatureKeyType
func (mmGetSignatureKeyType *mSignatureKeyHolderMockGetSignatureKeyType) Inspect(f func()) *mSignatureKeyHolderMockGetSignatureKeyType {
	if mmGetSignatureKeyType.mock.inspectFuncGetSignatureKeyType != nil {
		mmGetSignatureKeyType.mock.t.Fatalf("Inspect function is already set for SignatureKeyHolderMock.GetSignatureKeyType")
	}

	mmGetSignatureKeyType.mock.inspectFuncGetSignatureKeyType = f

	return mmGetSignatureKeyType
}

// Return sets up results that will be returned by SignatureKeyHolder.GetSignatureKeyType
func (mmGetSignatureKeyType *mSignatureKeyHolderMockGetSignatureKeyType) Return(s1 SignatureKeyType) *SignatureKeyHolderMock {
	if mmGetSignatureKeyType.mock.funcGetSignatureKeyType != nil {
		mmGetSignatureKeyType.mock.t.Fatalf("SignatureKeyHolderMock.GetSignatureKeyType mock is already set by Set")
	}

	if mmGetSignatureKeyType.defaultExpectation == nil {
		mmGetSignatureKeyType.defaultExpectation = &SignatureKeyHolderMockGetSignatureKeyTypeExpectation{mock: mmGetSignatureKeyType.mock}
	}
	mmGetSignatureKeyType.defaultExpectation.results = &SignatureKeyHolderMockGetSignatureKeyTypeResults{s1}
	return mmGetSignatureKeyType.mock
}

//Set uses given function f to mock the SignatureKeyHolder.GetSignatureKeyType method
func (mmGetSignatureKeyType *mSignatureKeyHolderMockGetSignatureKeyType) Set(f func() (s1 SignatureKeyType)) *SignatureKeyHolderMock {
	if mmGetSignatureKeyType.defaultExpectation != nil {
		mmGetSignatureKeyType.mock.t.Fatalf("Default expectation is already set for the SignatureKeyHolder.GetSignatureKeyType method")
	}

	if len(mmGetSignatureKeyType.expectations) > 0 {
		mmGetSignatureKeyType.mock.t.Fatalf("Some expectations are already set for the SignatureKeyHolder.GetSignatureKeyType method")
	}

	mmGetSignatureKeyType.mock.funcGetSignatureKeyType = f
	return mmGetSignatureKeyType.mock
}

// GetSignatureKeyType implements SignatureKeyHolder
func (mmGetSignatureKeyType *SignatureKeyHolderMock) GetSignatureKeyType() (s1 SignatureKeyType) {
	mm_atomic.AddUint64(&mmGetSignatureKeyType.beforeGetSignatureKeyTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSignatureKeyType.afterGetSignatureKeyTypeCounter, 1)

	if mmGetSignatureKeyType.inspectFuncGetSignatureKeyType != nil {
		mmGetSignatureKeyType.inspectFuncGetSignatureKeyType()
	}

	if mmGetSignatureKeyType.GetSignatureKeyTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSignatureKeyType.GetSignatureKeyTypeMock.defaultExpectation.Counter, 1)

		mm_results := mmGetSignatureKeyType.GetSignatureKeyTypeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSignatureKeyType.t.Fatal("No results are set for the SignatureKeyHolderMock.GetSignatureKeyType")
		}
		return (*mm_results).s1
	}
	if mmGetSignatureKeyType.funcGetSignatureKeyType != nil {
		return mmGetSignatureKeyType.funcGetSignatureKeyType()
	}
	mmGetSignatureKeyType.t.Fatalf("Unexpected call to SignatureKeyHolderMock.GetSignatureKeyType.")
	return
}

// GetSignatureKeyTypeAfterCounter returns a count of finished SignatureKeyHolderMock.GetSignatureKeyType invocations
func (mmGetSignatureKeyType *SignatureKeyHolderMock) GetSignatureKeyTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureKeyType.afterGetSignatureKeyTypeCounter)
}

// GetSignatureKeyTypeBeforeCounter returns a count of SignatureKeyHolderMock.GetSignatureKeyType invocations
func (mmGetSignatureKeyType *SignatureKeyHolderMock) GetSignatureKeyTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureKeyType.beforeGetSignatureKeyTypeCounter)
}

// MinimockGetSignatureKeyTypeDone returns true if the count of the GetSignatureKeyType invocations corresponds
// the number of defined expectations
func (m *SignatureKeyHolderMock) MinimockGetSignatureKeyTypeDone() bool {
	for _, e := range m.GetSignatureKeyTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureKeyTypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureKeyTypeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureKeyType != nil && mm_atomic.LoadUint64(&m.afterGetSignatureKeyTypeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSignatureKeyTypeInspect logs each unmet expectation
func (m *SignatureKeyHolderMock) MinimockGetSignatureKeyTypeInspect() {
	for _, e := range m.GetSignatureKeyTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureKeyHolderMock.GetSignatureKeyType")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureKeyTypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureKeyTypeCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.GetSignatureKeyType")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureKeyType != nil && mm_atomic.LoadUint64(&m.afterGetSignatureKeyTypeCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.GetSignatureKeyType")
	}
}

type mSignatureKeyHolderMockGetSigningMethod struct {
	mock               *SignatureKeyHolderMock
	defaultExpectation *SignatureKeyHolderMockGetSigningMethodExpectation
	expectations       []*SignatureKeyHolderMockGetSigningMethodExpectation
}

// SignatureKeyHolderMockGetSigningMethodExpectation specifies expectation struct of the SignatureKeyHolder.GetSigningMethod
type SignatureKeyHolderMockGetSigningMethodExpectation struct {
	mock *SignatureKeyHolderMock

	results *SignatureKeyHolderMockGetSigningMethodResults
	Counter uint64
}

// SignatureKeyHolderMockGetSigningMethodResults contains results of the SignatureKeyHolder.GetSigningMethod
type SignatureKeyHolderMockGetSigningMethodResults struct {
	s1 SigningMethod
}

// Expect sets up expected params for SignatureKeyHolder.GetSigningMethod
func (mmGetSigningMethod *mSignatureKeyHolderMockGetSigningMethod) Expect() *mSignatureKeyHolderMockGetSigningMethod {
	if mmGetSigningMethod.mock.funcGetSigningMethod != nil {
		mmGetSigningMethod.mock.t.Fatalf("SignatureKeyHolderMock.GetSigningMethod mock is already set by Set")
	}

	if mmGetSigningMethod.defaultExpectation == nil {
		mmGetSigningMethod.defaultExpectation = &SignatureKeyHolderMockGetSigningMethodExpectation{}
	}

	return mmGetSigningMethod
}

// Inspect accepts an inspector function that has same arguments as the SignatureKeyHolder.GetSigningMethod
func (mmGetSigningMethod *mSignatureKeyHolderMockGetSigningMethod) Inspect(f func()) *mSignatureKeyHolderMockGetSigningMethod {
	if mmGetSigningMethod.mock.inspectFuncGetSigningMethod != nil {
		mmGetSigningMethod.mock.t.Fatalf("Inspect function is already set for SignatureKeyHolderMock.GetSigningMethod")
	}

	mmGetSigningMethod.mock.inspectFuncGetSigningMethod = f

	return mmGetSigningMethod
}

// Return sets up results that will be returned by SignatureKeyHolder.GetSigningMethod
func (mmGetSigningMethod *mSignatureKeyHolderMockGetSigningMethod) Return(s1 SigningMethod) *SignatureKeyHolderMock {
	if mmGetSigningMethod.mock.funcGetSigningMethod != nil {
		mmGetSigningMethod.mock.t.Fatalf("SignatureKeyHolderMock.GetSigningMethod mock is already set by Set")
	}

	if mmGetSigningMethod.defaultExpectation == nil {
		mmGetSigningMethod.defaultExpectation = &SignatureKeyHolderMockGetSigningMethodExpectation{mock: mmGetSigningMethod.mock}
	}
	mmGetSigningMethod.defaultExpectation.results = &SignatureKeyHolderMockGetSigningMethodResults{s1}
	return mmGetSigningMethod.mock
}

//Set uses given function f to mock the SignatureKeyHolder.GetSigningMethod method
func (mmGetSigningMethod *mSignatureKeyHolderMockGetSigningMethod) Set(f func() (s1 SigningMethod)) *SignatureKeyHolderMock {
	if mmGetSigningMethod.defaultExpectation != nil {
		mmGetSigningMethod.mock.t.Fatalf("Default expectation is already set for the SignatureKeyHolder.GetSigningMethod method")
	}

	if len(mmGetSigningMethod.expectations) > 0 {
		mmGetSigningMethod.mock.t.Fatalf("Some expectations are already set for the SignatureKeyHolder.GetSigningMethod method")
	}

	mmGetSigningMethod.mock.funcGetSigningMethod = f
	return mmGetSigningMethod.mock
}

// GetSigningMethod implements SignatureKeyHolder
func (mmGetSigningMethod *SignatureKeyHolderMock) GetSigningMethod() (s1 SigningMethod) {
	mm_atomic.AddUint64(&mmGetSigningMethod.beforeGetSigningMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSigningMethod.afterGetSigningMethodCounter, 1)

	if mmGetSigningMethod.inspectFuncGetSigningMethod != nil {
		mmGetSigningMethod.inspectFuncGetSigningMethod()
	}

	if mmGetSigningMethod.GetSigningMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSigningMethod.GetSigningMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetSigningMethod.GetSigningMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSigningMethod.t.Fatal("No results are set for the SignatureKeyHolderMock.GetSigningMethod")
		}
		return (*mm_results).s1
	}
	if mmGetSigningMethod.funcGetSigningMethod != nil {
		return mmGetSigningMethod.funcGetSigningMethod()
	}
	mmGetSigningMethod.t.Fatalf("Unexpected call to SignatureKeyHolderMock.GetSigningMethod.")
	return
}

// GetSigningMethodAfterCounter returns a count of finished SignatureKeyHolderMock.GetSigningMethod invocations
func (mmGetSigningMethod *SignatureKeyHolderMock) GetSigningMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSigningMethod.afterGetSigningMethodCounter)
}

// GetSigningMethodBeforeCounter returns a count of SignatureKeyHolderMock.GetSigningMethod invocations
func (mmGetSigningMethod *SignatureKeyHolderMock) GetSigningMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSigningMethod.beforeGetSigningMethodCounter)
}

// MinimockGetSigningMethodDone returns true if the count of the GetSigningMethod invocations corresponds
// the number of defined expectations
func (m *SignatureKeyHolderMock) MinimockGetSigningMethodDone() bool {
	for _, e := range m.GetSigningMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSigningMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSigningMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSigningMethod != nil && mm_atomic.LoadUint64(&m.afterGetSigningMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSigningMethodInspect logs each unmet expectation
func (m *SignatureKeyHolderMock) MinimockGetSigningMethodInspect() {
	for _, e := range m.GetSigningMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureKeyHolderMock.GetSigningMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSigningMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSigningMethodCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.GetSigningMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSigningMethod != nil && mm_atomic.LoadUint64(&m.afterGetSigningMethodCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.GetSigningMethod")
	}
}

type mSignatureKeyHolderMockWriteTo struct {
	mock               *SignatureKeyHolderMock
	defaultExpectation *SignatureKeyHolderMockWriteToExpectation
	expectations       []*SignatureKeyHolderMockWriteToExpectation

	callArgs []*SignatureKeyHolderMockWriteToParams
	mutex    sync.RWMutex
}

// SignatureKeyHolderMockWriteToExpectation specifies expectation struct of the SignatureKeyHolder.WriteTo
type SignatureKeyHolderMockWriteToExpectation struct {
	mock    *SignatureKeyHolderMock
	params  *SignatureKeyHolderMockWriteToParams
	results *SignatureKeyHolderMockWriteToResults
	Counter uint64
}

// SignatureKeyHolderMockWriteToParams contains parameters of the SignatureKeyHolder.WriteTo
type SignatureKeyHolderMockWriteToParams struct {
	w io.Writer
}

// SignatureKeyHolderMockWriteToResults contains results of the SignatureKeyHolder.WriteTo
type SignatureKeyHolderMockWriteToResults struct {
	n   int64
	err error
}

// Expect sets up expected params for SignatureKeyHolder.WriteTo
func (mmWriteTo *mSignatureKeyHolderMockWriteTo) Expect(w io.Writer) *mSignatureKeyHolderMockWriteTo {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("SignatureKeyHolderMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &SignatureKeyHolderMockWriteToExpectation{}
	}

	mmWriteTo.defaultExpectation.params = &SignatureKeyHolderMockWriteToParams{w}
	for _, e := range mmWriteTo.expectations {
		if minimock.Equal(e.params, mmWriteTo.defaultExpectation.params) {
			mmWriteTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteTo.defaultExpectation.params)
		}
	}

	return mmWriteTo
}

// Inspect accepts an inspector function that has same arguments as the SignatureKeyHolder.WriteTo
func (mmWriteTo *mSignatureKeyHolderMockWriteTo) Inspect(f func(w io.Writer)) *mSignatureKeyHolderMockWriteTo {
	if mmWriteTo.mock.inspectFuncWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("Inspect function is already set for SignatureKeyHolderMock.WriteTo")
	}

	mmWriteTo.mock.inspectFuncWriteTo = f

	return mmWriteTo
}

// Return sets up results that will be returned by SignatureKeyHolder.WriteTo
func (mmWriteTo *mSignatureKeyHolderMockWriteTo) Return(n int64, err error) *SignatureKeyHolderMock {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("SignatureKeyHolderMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &SignatureKeyHolderMockWriteToExpectation{mock: mmWriteTo.mock}
	}
	mmWriteTo.defaultExpectation.results = &SignatureKeyHolderMockWriteToResults{n, err}
	return mmWriteTo.mock
}

//Set uses given function f to mock the SignatureKeyHolder.WriteTo method
func (mmWriteTo *mSignatureKeyHolderMockWriteTo) Set(f func(w io.Writer) (n int64, err error)) *SignatureKeyHolderMock {
	if mmWriteTo.defaultExpectation != nil {
		mmWriteTo.mock.t.Fatalf("Default expectation is already set for the SignatureKeyHolder.WriteTo method")
	}

	if len(mmWriteTo.expectations) > 0 {
		mmWriteTo.mock.t.Fatalf("Some expectations are already set for the SignatureKeyHolder.WriteTo method")
	}

	mmWriteTo.mock.funcWriteTo = f
	return mmWriteTo.mock
}

// When sets expectation for the SignatureKeyHolder.WriteTo which will trigger the result defined by the following
// Then helper
func (mmWriteTo *mSignatureKeyHolderMockWriteTo) When(w io.Writer) *SignatureKeyHolderMockWriteToExpectation {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("SignatureKeyHolderMock.WriteTo mock is already set by Set")
	}

	expectation := &SignatureKeyHolderMockWriteToExpectation{
		mock:   mmWriteTo.mock,
		params: &SignatureKeyHolderMockWriteToParams{w},
	}
	mmWriteTo.expectations = append(mmWriteTo.expectations, expectation)
	return expectation
}

// Then sets up SignatureKeyHolder.WriteTo return parameters for the expectation previously defined by the When method
func (e *SignatureKeyHolderMockWriteToExpectation) Then(n int64, err error) *SignatureKeyHolderMock {
	e.results = &SignatureKeyHolderMockWriteToResults{n, err}
	return e.mock
}

// WriteTo implements SignatureKeyHolder
func (mmWriteTo *SignatureKeyHolderMock) WriteTo(w io.Writer) (n int64, err error) {
	mm_atomic.AddUint64(&mmWriteTo.beforeWriteToCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteTo.afterWriteToCounter, 1)

	if mmWriteTo.inspectFuncWriteTo != nil {
		mmWriteTo.inspectFuncWriteTo(w)
	}

	mm_params := &SignatureKeyHolderMockWriteToParams{w}

	// Record call args
	mmWriteTo.WriteToMock.mutex.Lock()
	mmWriteTo.WriteToMock.callArgs = append(mmWriteTo.WriteToMock.callArgs, mm_params)
	mmWriteTo.WriteToMock.mutex.Unlock()

	for _, e := range mmWriteTo.WriteToMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWriteTo.WriteToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteTo.WriteToMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteTo.WriteToMock.defaultExpectation.params
		mm_got := SignatureKeyHolderMockWriteToParams{w}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteTo.t.Errorf("SignatureKeyHolderMock.WriteTo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWriteTo.WriteToMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteTo.t.Fatal("No results are set for the SignatureKeyHolderMock.WriteTo")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmWriteTo.funcWriteTo != nil {
		return mmWriteTo.funcWriteTo(w)
	}
	mmWriteTo.t.Fatalf("Unexpected call to SignatureKeyHolderMock.WriteTo. %v", w)
	return
}

// WriteToAfterCounter returns a count of finished SignatureKeyHolderMock.WriteTo invocations
func (mmWriteTo *SignatureKeyHolderMock) WriteToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.afterWriteToCounter)
}

// WriteToBeforeCounter returns a count of SignatureKeyHolderMock.WriteTo invocations
func (mmWriteTo *SignatureKeyHolderMock) WriteToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.beforeWriteToCounter)
}

// Calls returns a list of arguments used in each call to SignatureKeyHolderMock.WriteTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteTo *mSignatureKeyHolderMockWriteTo) Calls() []*SignatureKeyHolderMockWriteToParams {
	mmWriteTo.mutex.RLock()

	argCopy := make([]*SignatureKeyHolderMockWriteToParams, len(mmWriteTo.callArgs))
	copy(argCopy, mmWriteTo.callArgs)

	mmWriteTo.mutex.RUnlock()

	return argCopy
}

// MinimockWriteToDone returns true if the count of the WriteTo invocations corresponds
// the number of defined expectations
func (m *SignatureKeyHolderMock) MinimockWriteToDone() bool {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteToInspect logs each unmet expectation
func (m *SignatureKeyHolderMock) MinimockWriteToInspect() {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SignatureKeyHolderMock.WriteTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		if m.WriteToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SignatureKeyHolderMock.WriteTo")
		} else {
			m.t.Errorf("Expected call to SignatureKeyHolderMock.WriteTo with params: %#v", *m.WriteToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.WriteTo")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SignatureKeyHolderMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAsByteStringInspect()

		m.MinimockCopyToInspect()

		m.MinimockEqualsInspect()

		m.MinimockFixedByteSizeInspect()

		m.MinimockFoldToUint64Inspect()

		m.MinimockGetSignatureKeyMethodInspect()

		m.MinimockGetSignatureKeyTypeInspect()

		m.MinimockGetSigningMethodInspect()

		m.MinimockWriteToInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SignatureKeyHolderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SignatureKeyHolderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAsByteStringDone() &&
		m.MinimockCopyToDone() &&
		m.MinimockEqualsDone() &&
		m.MinimockFixedByteSizeDone() &&
		m.MinimockFoldToUint64Done() &&
		m.MinimockGetSignatureKeyMethodDone() &&
		m.MinimockGetSignatureKeyTypeDone() &&
		m.MinimockGetSigningMethodDone() &&
		m.MinimockWriteToDone()
}
