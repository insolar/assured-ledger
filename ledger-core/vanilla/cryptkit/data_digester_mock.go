package cryptkit

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// DataDigesterMock implements DataDigester
type DataDigesterMock struct {
	t minimock.Tester

	funcDigestBytes          func(ba1 []byte) (d1 Digest)
	inspectFuncDigestBytes   func(ba1 []byte)
	afterDigestBytesCounter  uint64
	beforeDigestBytesCounter uint64
	DigestBytesMock          mDataDigesterMockDigestBytes

	funcDigestData          func(r1 io.Reader) (d1 Digest)
	inspectFuncDigestData   func(r1 io.Reader)
	afterDigestDataCounter  uint64
	beforeDigestDataCounter uint64
	DigestDataMock          mDataDigesterMockDigestData

	funcGetDigestMethod          func() (d1 DigestMethod)
	inspectFuncGetDigestMethod   func()
	afterGetDigestMethodCounter  uint64
	beforeGetDigestMethodCounter uint64
	GetDigestMethodMock          mDataDigesterMockGetDigestMethod

	funcGetDigestSize          func() (i1 int)
	inspectFuncGetDigestSize   func()
	afterGetDigestSizeCounter  uint64
	beforeGetDigestSizeCounter uint64
	GetDigestSizeMock          mDataDigesterMockGetDigestSize

	funcNewHasher          func() (d1 DigestHasher)
	inspectFuncNewHasher   func()
	afterNewHasherCounter  uint64
	beforeNewHasherCounter uint64
	NewHasherMock          mDataDigesterMockNewHasher
}

// NewDataDigesterMock returns a mock for DataDigester
func NewDataDigesterMock(t minimock.Tester) *DataDigesterMock {
	m := &DataDigesterMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DigestBytesMock = mDataDigesterMockDigestBytes{mock: m}
	m.DigestBytesMock.callArgs = []*DataDigesterMockDigestBytesParams{}

	m.DigestDataMock = mDataDigesterMockDigestData{mock: m}
	m.DigestDataMock.callArgs = []*DataDigesterMockDigestDataParams{}

	m.GetDigestMethodMock = mDataDigesterMockGetDigestMethod{mock: m}

	m.GetDigestSizeMock = mDataDigesterMockGetDigestSize{mock: m}

	m.NewHasherMock = mDataDigesterMockNewHasher{mock: m}

	return m
}

type mDataDigesterMockDigestBytes struct {
	mock               *DataDigesterMock
	defaultExpectation *DataDigesterMockDigestBytesExpectation
	expectations       []*DataDigesterMockDigestBytesExpectation

	callArgs []*DataDigesterMockDigestBytesParams
	mutex    sync.RWMutex
}

// DataDigesterMockDigestBytesExpectation specifies expectation struct of the DataDigester.DigestBytes
type DataDigesterMockDigestBytesExpectation struct {
	mock    *DataDigesterMock
	params  *DataDigesterMockDigestBytesParams
	results *DataDigesterMockDigestBytesResults
	Counter uint64
}

// DataDigesterMockDigestBytesParams contains parameters of the DataDigester.DigestBytes
type DataDigesterMockDigestBytesParams struct {
	ba1 []byte
}

// DataDigesterMockDigestBytesResults contains results of the DataDigester.DigestBytes
type DataDigesterMockDigestBytesResults struct {
	d1 Digest
}

// Expect sets up expected params for DataDigester.DigestBytes
func (mmDigestBytes *mDataDigesterMockDigestBytes) Expect(ba1 []byte) *mDataDigesterMockDigestBytes {
	if mmDigestBytes.mock.funcDigestBytes != nil {
		mmDigestBytes.mock.t.Fatalf("DataDigesterMock.DigestBytes mock is already set by Set")
	}

	if mmDigestBytes.defaultExpectation == nil {
		mmDigestBytes.defaultExpectation = &DataDigesterMockDigestBytesExpectation{}
	}

	mmDigestBytes.defaultExpectation.params = &DataDigesterMockDigestBytesParams{ba1}
	for _, e := range mmDigestBytes.expectations {
		if minimock.Equal(e.params, mmDigestBytes.defaultExpectation.params) {
			mmDigestBytes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDigestBytes.defaultExpectation.params)
		}
	}

	return mmDigestBytes
}

// Inspect accepts an inspector function that has same arguments as the DataDigester.DigestBytes
func (mmDigestBytes *mDataDigesterMockDigestBytes) Inspect(f func(ba1 []byte)) *mDataDigesterMockDigestBytes {
	if mmDigestBytes.mock.inspectFuncDigestBytes != nil {
		mmDigestBytes.mock.t.Fatalf("Inspect function is already set for DataDigesterMock.DigestBytes")
	}

	mmDigestBytes.mock.inspectFuncDigestBytes = f

	return mmDigestBytes
}

// Return sets up results that will be returned by DataDigester.DigestBytes
func (mmDigestBytes *mDataDigesterMockDigestBytes) Return(d1 Digest) *DataDigesterMock {
	if mmDigestBytes.mock.funcDigestBytes != nil {
		mmDigestBytes.mock.t.Fatalf("DataDigesterMock.DigestBytes mock is already set by Set")
	}

	if mmDigestBytes.defaultExpectation == nil {
		mmDigestBytes.defaultExpectation = &DataDigesterMockDigestBytesExpectation{mock: mmDigestBytes.mock}
	}
	mmDigestBytes.defaultExpectation.results = &DataDigesterMockDigestBytesResults{d1}
	return mmDigestBytes.mock
}

//Set uses given function f to mock the DataDigester.DigestBytes method
func (mmDigestBytes *mDataDigesterMockDigestBytes) Set(f func(ba1 []byte) (d1 Digest)) *DataDigesterMock {
	if mmDigestBytes.defaultExpectation != nil {
		mmDigestBytes.mock.t.Fatalf("Default expectation is already set for the DataDigester.DigestBytes method")
	}

	if len(mmDigestBytes.expectations) > 0 {
		mmDigestBytes.mock.t.Fatalf("Some expectations are already set for the DataDigester.DigestBytes method")
	}

	mmDigestBytes.mock.funcDigestBytes = f
	return mmDigestBytes.mock
}

// When sets expectation for the DataDigester.DigestBytes which will trigger the result defined by the following
// Then helper
func (mmDigestBytes *mDataDigesterMockDigestBytes) When(ba1 []byte) *DataDigesterMockDigestBytesExpectation {
	if mmDigestBytes.mock.funcDigestBytes != nil {
		mmDigestBytes.mock.t.Fatalf("DataDigesterMock.DigestBytes mock is already set by Set")
	}

	expectation := &DataDigesterMockDigestBytesExpectation{
		mock:   mmDigestBytes.mock,
		params: &DataDigesterMockDigestBytesParams{ba1},
	}
	mmDigestBytes.expectations = append(mmDigestBytes.expectations, expectation)
	return expectation
}

// Then sets up DataDigester.DigestBytes return parameters for the expectation previously defined by the When method
func (e *DataDigesterMockDigestBytesExpectation) Then(d1 Digest) *DataDigesterMock {
	e.results = &DataDigesterMockDigestBytesResults{d1}
	return e.mock
}

// DigestBytes implements DataDigester
func (mmDigestBytes *DataDigesterMock) DigestBytes(ba1 []byte) (d1 Digest) {
	mm_atomic.AddUint64(&mmDigestBytes.beforeDigestBytesCounter, 1)
	defer mm_atomic.AddUint64(&mmDigestBytes.afterDigestBytesCounter, 1)

	if mmDigestBytes.inspectFuncDigestBytes != nil {
		mmDigestBytes.inspectFuncDigestBytes(ba1)
	}

	mm_params := &DataDigesterMockDigestBytesParams{ba1}

	// Record call args
	mmDigestBytes.DigestBytesMock.mutex.Lock()
	mmDigestBytes.DigestBytesMock.callArgs = append(mmDigestBytes.DigestBytesMock.callArgs, mm_params)
	mmDigestBytes.DigestBytesMock.mutex.Unlock()

	for _, e := range mmDigestBytes.DigestBytesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.d1
		}
	}

	if mmDigestBytes.DigestBytesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDigestBytes.DigestBytesMock.defaultExpectation.Counter, 1)
		mm_want := mmDigestBytes.DigestBytesMock.defaultExpectation.params
		mm_got := DataDigesterMockDigestBytesParams{ba1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDigestBytes.t.Errorf("DataDigesterMock.DigestBytes got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDigestBytes.DigestBytesMock.defaultExpectation.results
		if mm_results == nil {
			mmDigestBytes.t.Fatal("No results are set for the DataDigesterMock.DigestBytes")
		}
		return (*mm_results).d1
	}
	if mmDigestBytes.funcDigestBytes != nil {
		return mmDigestBytes.funcDigestBytes(ba1)
	}
	mmDigestBytes.t.Fatalf("Unexpected call to DataDigesterMock.DigestBytes. %v", ba1)
	return
}

// DigestBytesAfterCounter returns a count of finished DataDigesterMock.DigestBytes invocations
func (mmDigestBytes *DataDigesterMock) DigestBytesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDigestBytes.afterDigestBytesCounter)
}

// DigestBytesBeforeCounter returns a count of DataDigesterMock.DigestBytes invocations
func (mmDigestBytes *DataDigesterMock) DigestBytesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDigestBytes.beforeDigestBytesCounter)
}

// Calls returns a list of arguments used in each call to DataDigesterMock.DigestBytes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDigestBytes *mDataDigesterMockDigestBytes) Calls() []*DataDigesterMockDigestBytesParams {
	mmDigestBytes.mutex.RLock()

	argCopy := make([]*DataDigesterMockDigestBytesParams, len(mmDigestBytes.callArgs))
	copy(argCopy, mmDigestBytes.callArgs)

	mmDigestBytes.mutex.RUnlock()

	return argCopy
}

// MinimockDigestBytesDone returns true if the count of the DigestBytes invocations corresponds
// the number of defined expectations
func (m *DataDigesterMock) MinimockDigestBytesDone() bool {
	for _, e := range m.DigestBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DigestBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDigestBytesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDigestBytes != nil && mm_atomic.LoadUint64(&m.afterDigestBytesCounter) < 1 {
		return false
	}
	return true
}

// MinimockDigestBytesInspect logs each unmet expectation
func (m *DataDigesterMock) MinimockDigestBytesInspect() {
	for _, e := range m.DigestBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DataDigesterMock.DigestBytes with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DigestBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDigestBytesCounter) < 1 {
		if m.DigestBytesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DataDigesterMock.DigestBytes")
		} else {
			m.t.Errorf("Expected call to DataDigesterMock.DigestBytes with params: %#v", *m.DigestBytesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDigestBytes != nil && mm_atomic.LoadUint64(&m.afterDigestBytesCounter) < 1 {
		m.t.Error("Expected call to DataDigesterMock.DigestBytes")
	}
}

type mDataDigesterMockDigestData struct {
	mock               *DataDigesterMock
	defaultExpectation *DataDigesterMockDigestDataExpectation
	expectations       []*DataDigesterMockDigestDataExpectation

	callArgs []*DataDigesterMockDigestDataParams
	mutex    sync.RWMutex
}

// DataDigesterMockDigestDataExpectation specifies expectation struct of the DataDigester.DigestData
type DataDigesterMockDigestDataExpectation struct {
	mock    *DataDigesterMock
	params  *DataDigesterMockDigestDataParams
	results *DataDigesterMockDigestDataResults
	Counter uint64
}

// DataDigesterMockDigestDataParams contains parameters of the DataDigester.DigestData
type DataDigesterMockDigestDataParams struct {
	r1 io.Reader
}

// DataDigesterMockDigestDataResults contains results of the DataDigester.DigestData
type DataDigesterMockDigestDataResults struct {
	d1 Digest
}

// Expect sets up expected params for DataDigester.DigestData
func (mmDigestData *mDataDigesterMockDigestData) Expect(r1 io.Reader) *mDataDigesterMockDigestData {
	if mmDigestData.mock.funcDigestData != nil {
		mmDigestData.mock.t.Fatalf("DataDigesterMock.DigestData mock is already set by Set")
	}

	if mmDigestData.defaultExpectation == nil {
		mmDigestData.defaultExpectation = &DataDigesterMockDigestDataExpectation{}
	}

	mmDigestData.defaultExpectation.params = &DataDigesterMockDigestDataParams{r1}
	for _, e := range mmDigestData.expectations {
		if minimock.Equal(e.params, mmDigestData.defaultExpectation.params) {
			mmDigestData.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDigestData.defaultExpectation.params)
		}
	}

	return mmDigestData
}

// Inspect accepts an inspector function that has same arguments as the DataDigester.DigestData
func (mmDigestData *mDataDigesterMockDigestData) Inspect(f func(r1 io.Reader)) *mDataDigesterMockDigestData {
	if mmDigestData.mock.inspectFuncDigestData != nil {
		mmDigestData.mock.t.Fatalf("Inspect function is already set for DataDigesterMock.DigestData")
	}

	mmDigestData.mock.inspectFuncDigestData = f

	return mmDigestData
}

// Return sets up results that will be returned by DataDigester.DigestData
func (mmDigestData *mDataDigesterMockDigestData) Return(d1 Digest) *DataDigesterMock {
	if mmDigestData.mock.funcDigestData != nil {
		mmDigestData.mock.t.Fatalf("DataDigesterMock.DigestData mock is already set by Set")
	}

	if mmDigestData.defaultExpectation == nil {
		mmDigestData.defaultExpectation = &DataDigesterMockDigestDataExpectation{mock: mmDigestData.mock}
	}
	mmDigestData.defaultExpectation.results = &DataDigesterMockDigestDataResults{d1}
	return mmDigestData.mock
}

//Set uses given function f to mock the DataDigester.DigestData method
func (mmDigestData *mDataDigesterMockDigestData) Set(f func(r1 io.Reader) (d1 Digest)) *DataDigesterMock {
	if mmDigestData.defaultExpectation != nil {
		mmDigestData.mock.t.Fatalf("Default expectation is already set for the DataDigester.DigestData method")
	}

	if len(mmDigestData.expectations) > 0 {
		mmDigestData.mock.t.Fatalf("Some expectations are already set for the DataDigester.DigestData method")
	}

	mmDigestData.mock.funcDigestData = f
	return mmDigestData.mock
}

// When sets expectation for the DataDigester.DigestData which will trigger the result defined by the following
// Then helper
func (mmDigestData *mDataDigesterMockDigestData) When(r1 io.Reader) *DataDigesterMockDigestDataExpectation {
	if mmDigestData.mock.funcDigestData != nil {
		mmDigestData.mock.t.Fatalf("DataDigesterMock.DigestData mock is already set by Set")
	}

	expectation := &DataDigesterMockDigestDataExpectation{
		mock:   mmDigestData.mock,
		params: &DataDigesterMockDigestDataParams{r1},
	}
	mmDigestData.expectations = append(mmDigestData.expectations, expectation)
	return expectation
}

// Then sets up DataDigester.DigestData return parameters for the expectation previously defined by the When method
func (e *DataDigesterMockDigestDataExpectation) Then(d1 Digest) *DataDigesterMock {
	e.results = &DataDigesterMockDigestDataResults{d1}
	return e.mock
}

// DigestData implements DataDigester
func (mmDigestData *DataDigesterMock) DigestData(r1 io.Reader) (d1 Digest) {
	mm_atomic.AddUint64(&mmDigestData.beforeDigestDataCounter, 1)
	defer mm_atomic.AddUint64(&mmDigestData.afterDigestDataCounter, 1)

	if mmDigestData.inspectFuncDigestData != nil {
		mmDigestData.inspectFuncDigestData(r1)
	}

	mm_params := &DataDigesterMockDigestDataParams{r1}

	// Record call args
	mmDigestData.DigestDataMock.mutex.Lock()
	mmDigestData.DigestDataMock.callArgs = append(mmDigestData.DigestDataMock.callArgs, mm_params)
	mmDigestData.DigestDataMock.mutex.Unlock()

	for _, e := range mmDigestData.DigestDataMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.d1
		}
	}

	if mmDigestData.DigestDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDigestData.DigestDataMock.defaultExpectation.Counter, 1)
		mm_want := mmDigestData.DigestDataMock.defaultExpectation.params
		mm_got := DataDigesterMockDigestDataParams{r1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDigestData.t.Errorf("DataDigesterMock.DigestData got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDigestData.DigestDataMock.defaultExpectation.results
		if mm_results == nil {
			mmDigestData.t.Fatal("No results are set for the DataDigesterMock.DigestData")
		}
		return (*mm_results).d1
	}
	if mmDigestData.funcDigestData != nil {
		return mmDigestData.funcDigestData(r1)
	}
	mmDigestData.t.Fatalf("Unexpected call to DataDigesterMock.DigestData. %v", r1)
	return
}

// DigestDataAfterCounter returns a count of finished DataDigesterMock.DigestData invocations
func (mmDigestData *DataDigesterMock) DigestDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDigestData.afterDigestDataCounter)
}

// DigestDataBeforeCounter returns a count of DataDigesterMock.DigestData invocations
func (mmDigestData *DataDigesterMock) DigestDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDigestData.beforeDigestDataCounter)
}

// Calls returns a list of arguments used in each call to DataDigesterMock.DigestData.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDigestData *mDataDigesterMockDigestData) Calls() []*DataDigesterMockDigestDataParams {
	mmDigestData.mutex.RLock()

	argCopy := make([]*DataDigesterMockDigestDataParams, len(mmDigestData.callArgs))
	copy(argCopy, mmDigestData.callArgs)

	mmDigestData.mutex.RUnlock()

	return argCopy
}

// MinimockDigestDataDone returns true if the count of the DigestData invocations corresponds
// the number of defined expectations
func (m *DataDigesterMock) MinimockDigestDataDone() bool {
	for _, e := range m.DigestDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DigestDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDigestDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDigestData != nil && mm_atomic.LoadUint64(&m.afterDigestDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockDigestDataInspect logs each unmet expectation
func (m *DataDigesterMock) MinimockDigestDataInspect() {
	for _, e := range m.DigestDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DataDigesterMock.DigestData with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DigestDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDigestDataCounter) < 1 {
		if m.DigestDataMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DataDigesterMock.DigestData")
		} else {
			m.t.Errorf("Expected call to DataDigesterMock.DigestData with params: %#v", *m.DigestDataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDigestData != nil && mm_atomic.LoadUint64(&m.afterDigestDataCounter) < 1 {
		m.t.Error("Expected call to DataDigesterMock.DigestData")
	}
}

type mDataDigesterMockGetDigestMethod struct {
	mock               *DataDigesterMock
	defaultExpectation *DataDigesterMockGetDigestMethodExpectation
	expectations       []*DataDigesterMockGetDigestMethodExpectation
}

// DataDigesterMockGetDigestMethodExpectation specifies expectation struct of the DataDigester.GetDigestMethod
type DataDigesterMockGetDigestMethodExpectation struct {
	mock *DataDigesterMock

	results *DataDigesterMockGetDigestMethodResults
	Counter uint64
}

// DataDigesterMockGetDigestMethodResults contains results of the DataDigester.GetDigestMethod
type DataDigesterMockGetDigestMethodResults struct {
	d1 DigestMethod
}

// Expect sets up expected params for DataDigester.GetDigestMethod
func (mmGetDigestMethod *mDataDigesterMockGetDigestMethod) Expect() *mDataDigesterMockGetDigestMethod {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("DataDigesterMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &DataDigesterMockGetDigestMethodExpectation{}
	}

	return mmGetDigestMethod
}

// Inspect accepts an inspector function that has same arguments as the DataDigester.GetDigestMethod
func (mmGetDigestMethod *mDataDigesterMockGetDigestMethod) Inspect(f func()) *mDataDigesterMockGetDigestMethod {
	if mmGetDigestMethod.mock.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("Inspect function is already set for DataDigesterMock.GetDigestMethod")
	}

	mmGetDigestMethod.mock.inspectFuncGetDigestMethod = f

	return mmGetDigestMethod
}

// Return sets up results that will be returned by DataDigester.GetDigestMethod
func (mmGetDigestMethod *mDataDigesterMockGetDigestMethod) Return(d1 DigestMethod) *DataDigesterMock {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("DataDigesterMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &DataDigesterMockGetDigestMethodExpectation{mock: mmGetDigestMethod.mock}
	}
	mmGetDigestMethod.defaultExpectation.results = &DataDigesterMockGetDigestMethodResults{d1}
	return mmGetDigestMethod.mock
}

//Set uses given function f to mock the DataDigester.GetDigestMethod method
func (mmGetDigestMethod *mDataDigesterMockGetDigestMethod) Set(f func() (d1 DigestMethod)) *DataDigesterMock {
	if mmGetDigestMethod.defaultExpectation != nil {
		mmGetDigestMethod.mock.t.Fatalf("Default expectation is already set for the DataDigester.GetDigestMethod method")
	}

	if len(mmGetDigestMethod.expectations) > 0 {
		mmGetDigestMethod.mock.t.Fatalf("Some expectations are already set for the DataDigester.GetDigestMethod method")
	}

	mmGetDigestMethod.mock.funcGetDigestMethod = f
	return mmGetDigestMethod.mock
}

// GetDigestMethod implements DataDigester
func (mmGetDigestMethod *DataDigesterMock) GetDigestMethod() (d1 DigestMethod) {
	mm_atomic.AddUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestMethod.afterGetDigestMethodCounter, 1)

	if mmGetDigestMethod.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.inspectFuncGetDigestMethod()
	}

	if mmGetDigestMethod.GetDigestMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDigestMethod.t.Fatal("No results are set for the DataDigesterMock.GetDigestMethod")
		}
		return (*mm_results).d1
	}
	if mmGetDigestMethod.funcGetDigestMethod != nil {
		return mmGetDigestMethod.funcGetDigestMethod()
	}
	mmGetDigestMethod.t.Fatalf("Unexpected call to DataDigesterMock.GetDigestMethod.")
	return
}

// GetDigestMethodAfterCounter returns a count of finished DataDigesterMock.GetDigestMethod invocations
func (mmGetDigestMethod *DataDigesterMock) GetDigestMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.afterGetDigestMethodCounter)
}

// GetDigestMethodBeforeCounter returns a count of DataDigesterMock.GetDigestMethod invocations
func (mmGetDigestMethod *DataDigesterMock) GetDigestMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter)
}

// MinimockGetDigestMethodDone returns true if the count of the GetDigestMethod invocations corresponds
// the number of defined expectations
func (m *DataDigesterMock) MinimockGetDigestMethodDone() bool {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestMethodInspect logs each unmet expectation
func (m *DataDigesterMock) MinimockGetDigestMethodInspect() {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DataDigesterMock.GetDigestMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to DataDigesterMock.GetDigestMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to DataDigesterMock.GetDigestMethod")
	}
}

type mDataDigesterMockGetDigestSize struct {
	mock               *DataDigesterMock
	defaultExpectation *DataDigesterMockGetDigestSizeExpectation
	expectations       []*DataDigesterMockGetDigestSizeExpectation
}

// DataDigesterMockGetDigestSizeExpectation specifies expectation struct of the DataDigester.GetDigestSize
type DataDigesterMockGetDigestSizeExpectation struct {
	mock *DataDigesterMock

	results *DataDigesterMockGetDigestSizeResults
	Counter uint64
}

// DataDigesterMockGetDigestSizeResults contains results of the DataDigester.GetDigestSize
type DataDigesterMockGetDigestSizeResults struct {
	i1 int
}

// Expect sets up expected params for DataDigester.GetDigestSize
func (mmGetDigestSize *mDataDigesterMockGetDigestSize) Expect() *mDataDigesterMockGetDigestSize {
	if mmGetDigestSize.mock.funcGetDigestSize != nil {
		mmGetDigestSize.mock.t.Fatalf("DataDigesterMock.GetDigestSize mock is already set by Set")
	}

	if mmGetDigestSize.defaultExpectation == nil {
		mmGetDigestSize.defaultExpectation = &DataDigesterMockGetDigestSizeExpectation{}
	}

	return mmGetDigestSize
}

// Inspect accepts an inspector function that has same arguments as the DataDigester.GetDigestSize
func (mmGetDigestSize *mDataDigesterMockGetDigestSize) Inspect(f func()) *mDataDigesterMockGetDigestSize {
	if mmGetDigestSize.mock.inspectFuncGetDigestSize != nil {
		mmGetDigestSize.mock.t.Fatalf("Inspect function is already set for DataDigesterMock.GetDigestSize")
	}

	mmGetDigestSize.mock.inspectFuncGetDigestSize = f

	return mmGetDigestSize
}

// Return sets up results that will be returned by DataDigester.GetDigestSize
func (mmGetDigestSize *mDataDigesterMockGetDigestSize) Return(i1 int) *DataDigesterMock {
	if mmGetDigestSize.mock.funcGetDigestSize != nil {
		mmGetDigestSize.mock.t.Fatalf("DataDigesterMock.GetDigestSize mock is already set by Set")
	}

	if mmGetDigestSize.defaultExpectation == nil {
		mmGetDigestSize.defaultExpectation = &DataDigesterMockGetDigestSizeExpectation{mock: mmGetDigestSize.mock}
	}
	mmGetDigestSize.defaultExpectation.results = &DataDigesterMockGetDigestSizeResults{i1}
	return mmGetDigestSize.mock
}

//Set uses given function f to mock the DataDigester.GetDigestSize method
func (mmGetDigestSize *mDataDigesterMockGetDigestSize) Set(f func() (i1 int)) *DataDigesterMock {
	if mmGetDigestSize.defaultExpectation != nil {
		mmGetDigestSize.mock.t.Fatalf("Default expectation is already set for the DataDigester.GetDigestSize method")
	}

	if len(mmGetDigestSize.expectations) > 0 {
		mmGetDigestSize.mock.t.Fatalf("Some expectations are already set for the DataDigester.GetDigestSize method")
	}

	mmGetDigestSize.mock.funcGetDigestSize = f
	return mmGetDigestSize.mock
}

// GetDigestSize implements DataDigester
func (mmGetDigestSize *DataDigesterMock) GetDigestSize() (i1 int) {
	mm_atomic.AddUint64(&mmGetDigestSize.beforeGetDigestSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestSize.afterGetDigestSizeCounter, 1)

	if mmGetDigestSize.inspectFuncGetDigestSize != nil {
		mmGetDigestSize.inspectFuncGetDigestSize()
	}

	if mmGetDigestSize.GetDigestSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestSize.GetDigestSizeMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDigestSize.GetDigestSizeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDigestSize.t.Fatal("No results are set for the DataDigesterMock.GetDigestSize")
		}
		return (*mm_results).i1
	}
	if mmGetDigestSize.funcGetDigestSize != nil {
		return mmGetDigestSize.funcGetDigestSize()
	}
	mmGetDigestSize.t.Fatalf("Unexpected call to DataDigesterMock.GetDigestSize.")
	return
}

// GetDigestSizeAfterCounter returns a count of finished DataDigesterMock.GetDigestSize invocations
func (mmGetDigestSize *DataDigesterMock) GetDigestSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestSize.afterGetDigestSizeCounter)
}

// GetDigestSizeBeforeCounter returns a count of DataDigesterMock.GetDigestSize invocations
func (mmGetDigestSize *DataDigesterMock) GetDigestSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestSize.beforeGetDigestSizeCounter)
}

// MinimockGetDigestSizeDone returns true if the count of the GetDigestSize invocations corresponds
// the number of defined expectations
func (m *DataDigesterMock) MinimockGetDigestSizeDone() bool {
	for _, e := range m.GetDigestSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestSize != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestSizeInspect logs each unmet expectation
func (m *DataDigesterMock) MinimockGetDigestSizeInspect() {
	for _, e := range m.GetDigestSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DataDigesterMock.GetDigestSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		m.t.Error("Expected call to DataDigesterMock.GetDigestSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestSize != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		m.t.Error("Expected call to DataDigesterMock.GetDigestSize")
	}
}

type mDataDigesterMockNewHasher struct {
	mock               *DataDigesterMock
	defaultExpectation *DataDigesterMockNewHasherExpectation
	expectations       []*DataDigesterMockNewHasherExpectation
}

// DataDigesterMockNewHasherExpectation specifies expectation struct of the DataDigester.NewHasher
type DataDigesterMockNewHasherExpectation struct {
	mock *DataDigesterMock

	results *DataDigesterMockNewHasherResults
	Counter uint64
}

// DataDigesterMockNewHasherResults contains results of the DataDigester.NewHasher
type DataDigesterMockNewHasherResults struct {
	d1 DigestHasher
}

// Expect sets up expected params for DataDigester.NewHasher
func (mmNewHasher *mDataDigesterMockNewHasher) Expect() *mDataDigesterMockNewHasher {
	if mmNewHasher.mock.funcNewHasher != nil {
		mmNewHasher.mock.t.Fatalf("DataDigesterMock.NewHasher mock is already set by Set")
	}

	if mmNewHasher.defaultExpectation == nil {
		mmNewHasher.defaultExpectation = &DataDigesterMockNewHasherExpectation{}
	}

	return mmNewHasher
}

// Inspect accepts an inspector function that has same arguments as the DataDigester.NewHasher
func (mmNewHasher *mDataDigesterMockNewHasher) Inspect(f func()) *mDataDigesterMockNewHasher {
	if mmNewHasher.mock.inspectFuncNewHasher != nil {
		mmNewHasher.mock.t.Fatalf("Inspect function is already set for DataDigesterMock.NewHasher")
	}

	mmNewHasher.mock.inspectFuncNewHasher = f

	return mmNewHasher
}

// Return sets up results that will be returned by DataDigester.NewHasher
func (mmNewHasher *mDataDigesterMockNewHasher) Return(d1 DigestHasher) *DataDigesterMock {
	if mmNewHasher.mock.funcNewHasher != nil {
		mmNewHasher.mock.t.Fatalf("DataDigesterMock.NewHasher mock is already set by Set")
	}

	if mmNewHasher.defaultExpectation == nil {
		mmNewHasher.defaultExpectation = &DataDigesterMockNewHasherExpectation{mock: mmNewHasher.mock}
	}
	mmNewHasher.defaultExpectation.results = &DataDigesterMockNewHasherResults{d1}
	return mmNewHasher.mock
}

//Set uses given function f to mock the DataDigester.NewHasher method
func (mmNewHasher *mDataDigesterMockNewHasher) Set(f func() (d1 DigestHasher)) *DataDigesterMock {
	if mmNewHasher.defaultExpectation != nil {
		mmNewHasher.mock.t.Fatalf("Default expectation is already set for the DataDigester.NewHasher method")
	}

	if len(mmNewHasher.expectations) > 0 {
		mmNewHasher.mock.t.Fatalf("Some expectations are already set for the DataDigester.NewHasher method")
	}

	mmNewHasher.mock.funcNewHasher = f
	return mmNewHasher.mock
}

// NewHasher implements DataDigester
func (mmNewHasher *DataDigesterMock) NewHasher() (d1 DigestHasher) {
	mm_atomic.AddUint64(&mmNewHasher.beforeNewHasherCounter, 1)
	defer mm_atomic.AddUint64(&mmNewHasher.afterNewHasherCounter, 1)

	if mmNewHasher.inspectFuncNewHasher != nil {
		mmNewHasher.inspectFuncNewHasher()
	}

	if mmNewHasher.NewHasherMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewHasher.NewHasherMock.defaultExpectation.Counter, 1)

		mm_results := mmNewHasher.NewHasherMock.defaultExpectation.results
		if mm_results == nil {
			mmNewHasher.t.Fatal("No results are set for the DataDigesterMock.NewHasher")
		}
		return (*mm_results).d1
	}
	if mmNewHasher.funcNewHasher != nil {
		return mmNewHasher.funcNewHasher()
	}
	mmNewHasher.t.Fatalf("Unexpected call to DataDigesterMock.NewHasher.")
	return
}

// NewHasherAfterCounter returns a count of finished DataDigesterMock.NewHasher invocations
func (mmNewHasher *DataDigesterMock) NewHasherAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewHasher.afterNewHasherCounter)
}

// NewHasherBeforeCounter returns a count of DataDigesterMock.NewHasher invocations
func (mmNewHasher *DataDigesterMock) NewHasherBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewHasher.beforeNewHasherCounter)
}

// MinimockNewHasherDone returns true if the count of the NewHasher invocations corresponds
// the number of defined expectations
func (m *DataDigesterMock) MinimockNewHasherDone() bool {
	for _, e := range m.NewHasherMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewHasherMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewHasherCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewHasher != nil && mm_atomic.LoadUint64(&m.afterNewHasherCounter) < 1 {
		return false
	}
	return true
}

// MinimockNewHasherInspect logs each unmet expectation
func (m *DataDigesterMock) MinimockNewHasherInspect() {
	for _, e := range m.NewHasherMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DataDigesterMock.NewHasher")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewHasherMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewHasherCounter) < 1 {
		m.t.Error("Expected call to DataDigesterMock.NewHasher")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewHasher != nil && mm_atomic.LoadUint64(&m.afterNewHasherCounter) < 1 {
		m.t.Error("Expected call to DataDigesterMock.NewHasher")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DataDigesterMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDigestBytesInspect()

		m.MinimockDigestDataInspect()

		m.MinimockGetDigestMethodInspect()

		m.MinimockGetDigestSizeInspect()

		m.MinimockNewHasherInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DataDigesterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DataDigesterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDigestBytesDone() &&
		m.MinimockDigestDataDone() &&
		m.MinimockGetDigestMethodDone() &&
		m.MinimockGetDigestSizeDone() &&
		m.MinimockNewHasherDone()
}
