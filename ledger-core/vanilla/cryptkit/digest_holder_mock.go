package cryptkit

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/vanilla/longbits"
)

// DigestHolderMock implements DigestHolder
type DigestHolderMock struct {
	t minimock.Tester

	funcAsByteString          func() (b1 longbits.ByteString)
	inspectFuncAsByteString   func()
	afterAsByteStringCounter  uint64
	beforeAsByteStringCounter uint64
	AsByteStringMock          mDigestHolderMockAsByteString

	funcCopyTo          func(p []byte) (i1 int)
	inspectFuncCopyTo   func(p []byte)
	afterCopyToCounter  uint64
	beforeCopyToCounter uint64
	CopyToMock          mDigestHolderMockCopyTo

	funcEquals          func(other DigestHolder) (b1 bool)
	inspectFuncEquals   func(other DigestHolder)
	afterEqualsCounter  uint64
	beforeEqualsCounter uint64
	EqualsMock          mDigestHolderMockEquals

	funcFixedByteSize          func() (i1 int)
	inspectFuncFixedByteSize   func()
	afterFixedByteSizeCounter  uint64
	beforeFixedByteSizeCounter uint64
	FixedByteSizeMock          mDigestHolderMockFixedByteSize

	funcFoldToUint64          func() (u1 uint64)
	inspectFuncFoldToUint64   func()
	afterFoldToUint64Counter  uint64
	beforeFoldToUint64Counter uint64
	FoldToUint64Mock          mDigestHolderMockFoldToUint64

	funcGetDigestMethod          func() (d1 DigestMethod)
	inspectFuncGetDigestMethod   func()
	afterGetDigestMethodCounter  uint64
	beforeGetDigestMethodCounter uint64
	GetDigestMethodMock          mDigestHolderMockGetDigestMethod

	funcSignWith          func(signer DigestSigner) (s1 SignedDigestHolder)
	inspectFuncSignWith   func(signer DigestSigner)
	afterSignWithCounter  uint64
	beforeSignWithCounter uint64
	SignWithMock          mDigestHolderMockSignWith

	funcWriteTo          func(w io.Writer) (n int64, err error)
	inspectFuncWriteTo   func(w io.Writer)
	afterWriteToCounter  uint64
	beforeWriteToCounter uint64
	WriteToMock          mDigestHolderMockWriteTo
}

// NewDigestHolderMock returns a mock for DigestHolder
func NewDigestHolderMock(t minimock.Tester) *DigestHolderMock {
	m := &DigestHolderMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AsByteStringMock = mDigestHolderMockAsByteString{mock: m}

	m.CopyToMock = mDigestHolderMockCopyTo{mock: m}
	m.CopyToMock.callArgs = []*DigestHolderMockCopyToParams{}

	m.EqualsMock = mDigestHolderMockEquals{mock: m}
	m.EqualsMock.callArgs = []*DigestHolderMockEqualsParams{}

	m.FixedByteSizeMock = mDigestHolderMockFixedByteSize{mock: m}

	m.FoldToUint64Mock = mDigestHolderMockFoldToUint64{mock: m}

	m.GetDigestMethodMock = mDigestHolderMockGetDigestMethod{mock: m}

	m.SignWithMock = mDigestHolderMockSignWith{mock: m}
	m.SignWithMock.callArgs = []*DigestHolderMockSignWithParams{}

	m.WriteToMock = mDigestHolderMockWriteTo{mock: m}
	m.WriteToMock.callArgs = []*DigestHolderMockWriteToParams{}

	return m
}

type mDigestHolderMockAsByteString struct {
	mock               *DigestHolderMock
	defaultExpectation *DigestHolderMockAsByteStringExpectation
	expectations       []*DigestHolderMockAsByteStringExpectation
}

// DigestHolderMockAsByteStringExpectation specifies expectation struct of the DigestHolder.AsByteString
type DigestHolderMockAsByteStringExpectation struct {
	mock *DigestHolderMock

	results *DigestHolderMockAsByteStringResults
	Counter uint64
}

// DigestHolderMockAsByteStringResults contains results of the DigestHolder.AsByteString
type DigestHolderMockAsByteStringResults struct {
	b1 longbits.ByteString
}

// Expect sets up expected params for DigestHolder.AsByteString
func (mmAsByteString *mDigestHolderMockAsByteString) Expect() *mDigestHolderMockAsByteString {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("DigestHolderMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &DigestHolderMockAsByteStringExpectation{}
	}

	return mmAsByteString
}

// Inspect accepts an inspector function that has same arguments as the DigestHolder.AsByteString
func (mmAsByteString *mDigestHolderMockAsByteString) Inspect(f func()) *mDigestHolderMockAsByteString {
	if mmAsByteString.mock.inspectFuncAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("Inspect function is already set for DigestHolderMock.AsByteString")
	}

	mmAsByteString.mock.inspectFuncAsByteString = f

	return mmAsByteString
}

// Return sets up results that will be returned by DigestHolder.AsByteString
func (mmAsByteString *mDigestHolderMockAsByteString) Return(b1 longbits.ByteString) *DigestHolderMock {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("DigestHolderMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &DigestHolderMockAsByteStringExpectation{mock: mmAsByteString.mock}
	}
	mmAsByteString.defaultExpectation.results = &DigestHolderMockAsByteStringResults{b1}
	return mmAsByteString.mock
}

//Set uses given function f to mock the DigestHolder.AsByteString method
func (mmAsByteString *mDigestHolderMockAsByteString) Set(f func() (b1 longbits.ByteString)) *DigestHolderMock {
	if mmAsByteString.defaultExpectation != nil {
		mmAsByteString.mock.t.Fatalf("Default expectation is already set for the DigestHolder.AsByteString method")
	}

	if len(mmAsByteString.expectations) > 0 {
		mmAsByteString.mock.t.Fatalf("Some expectations are already set for the DigestHolder.AsByteString method")
	}

	mmAsByteString.mock.funcAsByteString = f
	return mmAsByteString.mock
}

// AsByteString implements DigestHolder
func (mmAsByteString *DigestHolderMock) AsByteString() (b1 longbits.ByteString) {
	mm_atomic.AddUint64(&mmAsByteString.beforeAsByteStringCounter, 1)
	defer mm_atomic.AddUint64(&mmAsByteString.afterAsByteStringCounter, 1)

	if mmAsByteString.inspectFuncAsByteString != nil {
		mmAsByteString.inspectFuncAsByteString()
	}

	if mmAsByteString.AsByteStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsByteString.AsByteStringMock.defaultExpectation.Counter, 1)

		mm_results := mmAsByteString.AsByteStringMock.defaultExpectation.results
		if mm_results == nil {
			mmAsByteString.t.Fatal("No results are set for the DigestHolderMock.AsByteString")
		}
		return (*mm_results).b1
	}
	if mmAsByteString.funcAsByteString != nil {
		return mmAsByteString.funcAsByteString()
	}
	mmAsByteString.t.Fatalf("Unexpected call to DigestHolderMock.AsByteString.")
	return
}

// AsByteStringAfterCounter returns a count of finished DigestHolderMock.AsByteString invocations
func (mmAsByteString *DigestHolderMock) AsByteStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.afterAsByteStringCounter)
}

// AsByteStringBeforeCounter returns a count of DigestHolderMock.AsByteString invocations
func (mmAsByteString *DigestHolderMock) AsByteStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.beforeAsByteStringCounter)
}

// MinimockAsByteStringDone returns true if the count of the AsByteString invocations corresponds
// the number of defined expectations
func (m *DigestHolderMock) MinimockAsByteStringDone() bool {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsByteStringInspect logs each unmet expectation
func (m *DigestHolderMock) MinimockAsByteStringInspect() {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DigestHolderMock.AsByteString")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.AsByteString")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.AsByteString")
	}
}

type mDigestHolderMockCopyTo struct {
	mock               *DigestHolderMock
	defaultExpectation *DigestHolderMockCopyToExpectation
	expectations       []*DigestHolderMockCopyToExpectation

	callArgs []*DigestHolderMockCopyToParams
	mutex    sync.RWMutex
}

// DigestHolderMockCopyToExpectation specifies expectation struct of the DigestHolder.CopyTo
type DigestHolderMockCopyToExpectation struct {
	mock    *DigestHolderMock
	params  *DigestHolderMockCopyToParams
	results *DigestHolderMockCopyToResults
	Counter uint64
}

// DigestHolderMockCopyToParams contains parameters of the DigestHolder.CopyTo
type DigestHolderMockCopyToParams struct {
	p []byte
}

// DigestHolderMockCopyToResults contains results of the DigestHolder.CopyTo
type DigestHolderMockCopyToResults struct {
	i1 int
}

// Expect sets up expected params for DigestHolder.CopyTo
func (mmCopyTo *mDigestHolderMockCopyTo) Expect(p []byte) *mDigestHolderMockCopyTo {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("DigestHolderMock.CopyTo mock is already set by Set")
	}

	if mmCopyTo.defaultExpectation == nil {
		mmCopyTo.defaultExpectation = &DigestHolderMockCopyToExpectation{}
	}

	mmCopyTo.defaultExpectation.params = &DigestHolderMockCopyToParams{p}
	for _, e := range mmCopyTo.expectations {
		if minimock.Equal(e.params, mmCopyTo.defaultExpectation.params) {
			mmCopyTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCopyTo.defaultExpectation.params)
		}
	}

	return mmCopyTo
}

// Inspect accepts an inspector function that has same arguments as the DigestHolder.CopyTo
func (mmCopyTo *mDigestHolderMockCopyTo) Inspect(f func(p []byte)) *mDigestHolderMockCopyTo {
	if mmCopyTo.mock.inspectFuncCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("Inspect function is already set for DigestHolderMock.CopyTo")
	}

	mmCopyTo.mock.inspectFuncCopyTo = f

	return mmCopyTo
}

// Return sets up results that will be returned by DigestHolder.CopyTo
func (mmCopyTo *mDigestHolderMockCopyTo) Return(i1 int) *DigestHolderMock {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("DigestHolderMock.CopyTo mock is already set by Set")
	}

	if mmCopyTo.defaultExpectation == nil {
		mmCopyTo.defaultExpectation = &DigestHolderMockCopyToExpectation{mock: mmCopyTo.mock}
	}
	mmCopyTo.defaultExpectation.results = &DigestHolderMockCopyToResults{i1}
	return mmCopyTo.mock
}

//Set uses given function f to mock the DigestHolder.CopyTo method
func (mmCopyTo *mDigestHolderMockCopyTo) Set(f func(p []byte) (i1 int)) *DigestHolderMock {
	if mmCopyTo.defaultExpectation != nil {
		mmCopyTo.mock.t.Fatalf("Default expectation is already set for the DigestHolder.CopyTo method")
	}

	if len(mmCopyTo.expectations) > 0 {
		mmCopyTo.mock.t.Fatalf("Some expectations are already set for the DigestHolder.CopyTo method")
	}

	mmCopyTo.mock.funcCopyTo = f
	return mmCopyTo.mock
}

// When sets expectation for the DigestHolder.CopyTo which will trigger the result defined by the following
// Then helper
func (mmCopyTo *mDigestHolderMockCopyTo) When(p []byte) *DigestHolderMockCopyToExpectation {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("DigestHolderMock.CopyTo mock is already set by Set")
	}

	expectation := &DigestHolderMockCopyToExpectation{
		mock:   mmCopyTo.mock,
		params: &DigestHolderMockCopyToParams{p},
	}
	mmCopyTo.expectations = append(mmCopyTo.expectations, expectation)
	return expectation
}

// Then sets up DigestHolder.CopyTo return parameters for the expectation previously defined by the When method
func (e *DigestHolderMockCopyToExpectation) Then(i1 int) *DigestHolderMock {
	e.results = &DigestHolderMockCopyToResults{i1}
	return e.mock
}

// CopyTo implements DigestHolder
func (mmCopyTo *DigestHolderMock) CopyTo(p []byte) (i1 int) {
	mm_atomic.AddUint64(&mmCopyTo.beforeCopyToCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyTo.afterCopyToCounter, 1)

	if mmCopyTo.inspectFuncCopyTo != nil {
		mmCopyTo.inspectFuncCopyTo(p)
	}

	mm_params := &DigestHolderMockCopyToParams{p}

	// Record call args
	mmCopyTo.CopyToMock.mutex.Lock()
	mmCopyTo.CopyToMock.callArgs = append(mmCopyTo.CopyToMock.callArgs, mm_params)
	mmCopyTo.CopyToMock.mutex.Unlock()

	for _, e := range mmCopyTo.CopyToMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1
		}
	}

	if mmCopyTo.CopyToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyTo.CopyToMock.defaultExpectation.Counter, 1)
		mm_want := mmCopyTo.CopyToMock.defaultExpectation.params
		mm_got := DigestHolderMockCopyToParams{p}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCopyTo.t.Errorf("DigestHolderMock.CopyTo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCopyTo.CopyToMock.defaultExpectation.results
		if mm_results == nil {
			mmCopyTo.t.Fatal("No results are set for the DigestHolderMock.CopyTo")
		}
		return (*mm_results).i1
	}
	if mmCopyTo.funcCopyTo != nil {
		return mmCopyTo.funcCopyTo(p)
	}
	mmCopyTo.t.Fatalf("Unexpected call to DigestHolderMock.CopyTo. %v", p)
	return
}

// CopyToAfterCounter returns a count of finished DigestHolderMock.CopyTo invocations
func (mmCopyTo *DigestHolderMock) CopyToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyTo.afterCopyToCounter)
}

// CopyToBeforeCounter returns a count of DigestHolderMock.CopyTo invocations
func (mmCopyTo *DigestHolderMock) CopyToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyTo.beforeCopyToCounter)
}

// Calls returns a list of arguments used in each call to DigestHolderMock.CopyTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCopyTo *mDigestHolderMockCopyTo) Calls() []*DigestHolderMockCopyToParams {
	mmCopyTo.mutex.RLock()

	argCopy := make([]*DigestHolderMockCopyToParams, len(mmCopyTo.callArgs))
	copy(argCopy, mmCopyTo.callArgs)

	mmCopyTo.mutex.RUnlock()

	return argCopy
}

// MinimockCopyToDone returns true if the count of the CopyTo invocations corresponds
// the number of defined expectations
func (m *DigestHolderMock) MinimockCopyToDone() bool {
	for _, e := range m.CopyToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyTo != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyToInspect logs each unmet expectation
func (m *DigestHolderMock) MinimockCopyToInspect() {
	for _, e := range m.CopyToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DigestHolderMock.CopyTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		if m.CopyToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DigestHolderMock.CopyTo")
		} else {
			m.t.Errorf("Expected call to DigestHolderMock.CopyTo with params: %#v", *m.CopyToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyTo != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.CopyTo")
	}
}

type mDigestHolderMockEquals struct {
	mock               *DigestHolderMock
	defaultExpectation *DigestHolderMockEqualsExpectation
	expectations       []*DigestHolderMockEqualsExpectation

	callArgs []*DigestHolderMockEqualsParams
	mutex    sync.RWMutex
}

// DigestHolderMockEqualsExpectation specifies expectation struct of the DigestHolder.Equals
type DigestHolderMockEqualsExpectation struct {
	mock    *DigestHolderMock
	params  *DigestHolderMockEqualsParams
	results *DigestHolderMockEqualsResults
	Counter uint64
}

// DigestHolderMockEqualsParams contains parameters of the DigestHolder.Equals
type DigestHolderMockEqualsParams struct {
	other DigestHolder
}

// DigestHolderMockEqualsResults contains results of the DigestHolder.Equals
type DigestHolderMockEqualsResults struct {
	b1 bool
}

// Expect sets up expected params for DigestHolder.Equals
func (mmEquals *mDigestHolderMockEquals) Expect(other DigestHolder) *mDigestHolderMockEquals {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("DigestHolderMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &DigestHolderMockEqualsExpectation{}
	}

	mmEquals.defaultExpectation.params = &DigestHolderMockEqualsParams{other}
	for _, e := range mmEquals.expectations {
		if minimock.Equal(e.params, mmEquals.defaultExpectation.params) {
			mmEquals.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEquals.defaultExpectation.params)
		}
	}

	return mmEquals
}

// Inspect accepts an inspector function that has same arguments as the DigestHolder.Equals
func (mmEquals *mDigestHolderMockEquals) Inspect(f func(other DigestHolder)) *mDigestHolderMockEquals {
	if mmEquals.mock.inspectFuncEquals != nil {
		mmEquals.mock.t.Fatalf("Inspect function is already set for DigestHolderMock.Equals")
	}

	mmEquals.mock.inspectFuncEquals = f

	return mmEquals
}

// Return sets up results that will be returned by DigestHolder.Equals
func (mmEquals *mDigestHolderMockEquals) Return(b1 bool) *DigestHolderMock {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("DigestHolderMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &DigestHolderMockEqualsExpectation{mock: mmEquals.mock}
	}
	mmEquals.defaultExpectation.results = &DigestHolderMockEqualsResults{b1}
	return mmEquals.mock
}

//Set uses given function f to mock the DigestHolder.Equals method
func (mmEquals *mDigestHolderMockEquals) Set(f func(other DigestHolder) (b1 bool)) *DigestHolderMock {
	if mmEquals.defaultExpectation != nil {
		mmEquals.mock.t.Fatalf("Default expectation is already set for the DigestHolder.Equals method")
	}

	if len(mmEquals.expectations) > 0 {
		mmEquals.mock.t.Fatalf("Some expectations are already set for the DigestHolder.Equals method")
	}

	mmEquals.mock.funcEquals = f
	return mmEquals.mock
}

// When sets expectation for the DigestHolder.Equals which will trigger the result defined by the following
// Then helper
func (mmEquals *mDigestHolderMockEquals) When(other DigestHolder) *DigestHolderMockEqualsExpectation {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("DigestHolderMock.Equals mock is already set by Set")
	}

	expectation := &DigestHolderMockEqualsExpectation{
		mock:   mmEquals.mock,
		params: &DigestHolderMockEqualsParams{other},
	}
	mmEquals.expectations = append(mmEquals.expectations, expectation)
	return expectation
}

// Then sets up DigestHolder.Equals return parameters for the expectation previously defined by the When method
func (e *DigestHolderMockEqualsExpectation) Then(b1 bool) *DigestHolderMock {
	e.results = &DigestHolderMockEqualsResults{b1}
	return e.mock
}

// Equals implements DigestHolder
func (mmEquals *DigestHolderMock) Equals(other DigestHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmEquals.beforeEqualsCounter, 1)
	defer mm_atomic.AddUint64(&mmEquals.afterEqualsCounter, 1)

	if mmEquals.inspectFuncEquals != nil {
		mmEquals.inspectFuncEquals(other)
	}

	mm_params := &DigestHolderMockEqualsParams{other}

	// Record call args
	mmEquals.EqualsMock.mutex.Lock()
	mmEquals.EqualsMock.callArgs = append(mmEquals.EqualsMock.callArgs, mm_params)
	mmEquals.EqualsMock.mutex.Unlock()

	for _, e := range mmEquals.EqualsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmEquals.EqualsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEquals.EqualsMock.defaultExpectation.Counter, 1)
		mm_want := mmEquals.EqualsMock.defaultExpectation.params
		mm_got := DigestHolderMockEqualsParams{other}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEquals.t.Errorf("DigestHolderMock.Equals got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEquals.EqualsMock.defaultExpectation.results
		if mm_results == nil {
			mmEquals.t.Fatal("No results are set for the DigestHolderMock.Equals")
		}
		return (*mm_results).b1
	}
	if mmEquals.funcEquals != nil {
		return mmEquals.funcEquals(other)
	}
	mmEquals.t.Fatalf("Unexpected call to DigestHolderMock.Equals. %v", other)
	return
}

// EqualsAfterCounter returns a count of finished DigestHolderMock.Equals invocations
func (mmEquals *DigestHolderMock) EqualsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.afterEqualsCounter)
}

// EqualsBeforeCounter returns a count of DigestHolderMock.Equals invocations
func (mmEquals *DigestHolderMock) EqualsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.beforeEqualsCounter)
}

// Calls returns a list of arguments used in each call to DigestHolderMock.Equals.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEquals *mDigestHolderMockEquals) Calls() []*DigestHolderMockEqualsParams {
	mmEquals.mutex.RLock()

	argCopy := make([]*DigestHolderMockEqualsParams, len(mmEquals.callArgs))
	copy(argCopy, mmEquals.callArgs)

	mmEquals.mutex.RUnlock()

	return argCopy
}

// MinimockEqualsDone returns true if the count of the Equals invocations corresponds
// the number of defined expectations
func (m *DigestHolderMock) MinimockEqualsDone() bool {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	return true
}

// MinimockEqualsInspect logs each unmet expectation
func (m *DigestHolderMock) MinimockEqualsInspect() {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DigestHolderMock.Equals with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		if m.EqualsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DigestHolderMock.Equals")
		} else {
			m.t.Errorf("Expected call to DigestHolderMock.Equals with params: %#v", *m.EqualsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.Equals")
	}
}

type mDigestHolderMockFixedByteSize struct {
	mock               *DigestHolderMock
	defaultExpectation *DigestHolderMockFixedByteSizeExpectation
	expectations       []*DigestHolderMockFixedByteSizeExpectation
}

// DigestHolderMockFixedByteSizeExpectation specifies expectation struct of the DigestHolder.FixedByteSize
type DigestHolderMockFixedByteSizeExpectation struct {
	mock *DigestHolderMock

	results *DigestHolderMockFixedByteSizeResults
	Counter uint64
}

// DigestHolderMockFixedByteSizeResults contains results of the DigestHolder.FixedByteSize
type DigestHolderMockFixedByteSizeResults struct {
	i1 int
}

// Expect sets up expected params for DigestHolder.FixedByteSize
func (mmFixedByteSize *mDigestHolderMockFixedByteSize) Expect() *mDigestHolderMockFixedByteSize {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("DigestHolderMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &DigestHolderMockFixedByteSizeExpectation{}
	}

	return mmFixedByteSize
}

// Inspect accepts an inspector function that has same arguments as the DigestHolder.FixedByteSize
func (mmFixedByteSize *mDigestHolderMockFixedByteSize) Inspect(f func()) *mDigestHolderMockFixedByteSize {
	if mmFixedByteSize.mock.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("Inspect function is already set for DigestHolderMock.FixedByteSize")
	}

	mmFixedByteSize.mock.inspectFuncFixedByteSize = f

	return mmFixedByteSize
}

// Return sets up results that will be returned by DigestHolder.FixedByteSize
func (mmFixedByteSize *mDigestHolderMockFixedByteSize) Return(i1 int) *DigestHolderMock {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("DigestHolderMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &DigestHolderMockFixedByteSizeExpectation{mock: mmFixedByteSize.mock}
	}
	mmFixedByteSize.defaultExpectation.results = &DigestHolderMockFixedByteSizeResults{i1}
	return mmFixedByteSize.mock
}

//Set uses given function f to mock the DigestHolder.FixedByteSize method
func (mmFixedByteSize *mDigestHolderMockFixedByteSize) Set(f func() (i1 int)) *DigestHolderMock {
	if mmFixedByteSize.defaultExpectation != nil {
		mmFixedByteSize.mock.t.Fatalf("Default expectation is already set for the DigestHolder.FixedByteSize method")
	}

	if len(mmFixedByteSize.expectations) > 0 {
		mmFixedByteSize.mock.t.Fatalf("Some expectations are already set for the DigestHolder.FixedByteSize method")
	}

	mmFixedByteSize.mock.funcFixedByteSize = f
	return mmFixedByteSize.mock
}

// FixedByteSize implements DigestHolder
func (mmFixedByteSize *DigestHolderMock) FixedByteSize() (i1 int) {
	mm_atomic.AddUint64(&mmFixedByteSize.beforeFixedByteSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmFixedByteSize.afterFixedByteSizeCounter, 1)

	if mmFixedByteSize.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.inspectFuncFixedByteSize()
	}

	if mmFixedByteSize.FixedByteSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFixedByteSize.FixedByteSizeMock.defaultExpectation.Counter, 1)

		mm_results := mmFixedByteSize.FixedByteSizeMock.defaultExpectation.results
		if mm_results == nil {
			mmFixedByteSize.t.Fatal("No results are set for the DigestHolderMock.FixedByteSize")
		}
		return (*mm_results).i1
	}
	if mmFixedByteSize.funcFixedByteSize != nil {
		return mmFixedByteSize.funcFixedByteSize()
	}
	mmFixedByteSize.t.Fatalf("Unexpected call to DigestHolderMock.FixedByteSize.")
	return
}

// FixedByteSizeAfterCounter returns a count of finished DigestHolderMock.FixedByteSize invocations
func (mmFixedByteSize *DigestHolderMock) FixedByteSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.afterFixedByteSizeCounter)
}

// FixedByteSizeBeforeCounter returns a count of DigestHolderMock.FixedByteSize invocations
func (mmFixedByteSize *DigestHolderMock) FixedByteSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.beforeFixedByteSizeCounter)
}

// MinimockFixedByteSizeDone returns true if the count of the FixedByteSize invocations corresponds
// the number of defined expectations
func (m *DigestHolderMock) MinimockFixedByteSizeDone() bool {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockFixedByteSizeInspect logs each unmet expectation
func (m *DigestHolderMock) MinimockFixedByteSizeInspect() {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DigestHolderMock.FixedByteSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.FixedByteSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.FixedByteSize")
	}
}

type mDigestHolderMockFoldToUint64 struct {
	mock               *DigestHolderMock
	defaultExpectation *DigestHolderMockFoldToUint64Expectation
	expectations       []*DigestHolderMockFoldToUint64Expectation
}

// DigestHolderMockFoldToUint64Expectation specifies expectation struct of the DigestHolder.FoldToUint64
type DigestHolderMockFoldToUint64Expectation struct {
	mock *DigestHolderMock

	results *DigestHolderMockFoldToUint64Results
	Counter uint64
}

// DigestHolderMockFoldToUint64Results contains results of the DigestHolder.FoldToUint64
type DigestHolderMockFoldToUint64Results struct {
	u1 uint64
}

// Expect sets up expected params for DigestHolder.FoldToUint64
func (mmFoldToUint64 *mDigestHolderMockFoldToUint64) Expect() *mDigestHolderMockFoldToUint64 {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("DigestHolderMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &DigestHolderMockFoldToUint64Expectation{}
	}

	return mmFoldToUint64
}

// Inspect accepts an inspector function that has same arguments as the DigestHolder.FoldToUint64
func (mmFoldToUint64 *mDigestHolderMockFoldToUint64) Inspect(f func()) *mDigestHolderMockFoldToUint64 {
	if mmFoldToUint64.mock.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("Inspect function is already set for DigestHolderMock.FoldToUint64")
	}

	mmFoldToUint64.mock.inspectFuncFoldToUint64 = f

	return mmFoldToUint64
}

// Return sets up results that will be returned by DigestHolder.FoldToUint64
func (mmFoldToUint64 *mDigestHolderMockFoldToUint64) Return(u1 uint64) *DigestHolderMock {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("DigestHolderMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &DigestHolderMockFoldToUint64Expectation{mock: mmFoldToUint64.mock}
	}
	mmFoldToUint64.defaultExpectation.results = &DigestHolderMockFoldToUint64Results{u1}
	return mmFoldToUint64.mock
}

//Set uses given function f to mock the DigestHolder.FoldToUint64 method
func (mmFoldToUint64 *mDigestHolderMockFoldToUint64) Set(f func() (u1 uint64)) *DigestHolderMock {
	if mmFoldToUint64.defaultExpectation != nil {
		mmFoldToUint64.mock.t.Fatalf("Default expectation is already set for the DigestHolder.FoldToUint64 method")
	}

	if len(mmFoldToUint64.expectations) > 0 {
		mmFoldToUint64.mock.t.Fatalf("Some expectations are already set for the DigestHolder.FoldToUint64 method")
	}

	mmFoldToUint64.mock.funcFoldToUint64 = f
	return mmFoldToUint64.mock
}

// FoldToUint64 implements DigestHolder
func (mmFoldToUint64 *DigestHolderMock) FoldToUint64() (u1 uint64) {
	mm_atomic.AddUint64(&mmFoldToUint64.beforeFoldToUint64Counter, 1)
	defer mm_atomic.AddUint64(&mmFoldToUint64.afterFoldToUint64Counter, 1)

	if mmFoldToUint64.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.inspectFuncFoldToUint64()
	}

	if mmFoldToUint64.FoldToUint64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFoldToUint64.FoldToUint64Mock.defaultExpectation.Counter, 1)

		mm_results := mmFoldToUint64.FoldToUint64Mock.defaultExpectation.results
		if mm_results == nil {
			mmFoldToUint64.t.Fatal("No results are set for the DigestHolderMock.FoldToUint64")
		}
		return (*mm_results).u1
	}
	if mmFoldToUint64.funcFoldToUint64 != nil {
		return mmFoldToUint64.funcFoldToUint64()
	}
	mmFoldToUint64.t.Fatalf("Unexpected call to DigestHolderMock.FoldToUint64.")
	return
}

// FoldToUint64AfterCounter returns a count of finished DigestHolderMock.FoldToUint64 invocations
func (mmFoldToUint64 *DigestHolderMock) FoldToUint64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.afterFoldToUint64Counter)
}

// FoldToUint64BeforeCounter returns a count of DigestHolderMock.FoldToUint64 invocations
func (mmFoldToUint64 *DigestHolderMock) FoldToUint64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.beforeFoldToUint64Counter)
}

// MinimockFoldToUint64Done returns true if the count of the FoldToUint64 invocations corresponds
// the number of defined expectations
func (m *DigestHolderMock) MinimockFoldToUint64Done() bool {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	return true
}

// MinimockFoldToUint64Inspect logs each unmet expectation
func (m *DigestHolderMock) MinimockFoldToUint64Inspect() {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DigestHolderMock.FoldToUint64")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.FoldToUint64")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.FoldToUint64")
	}
}

type mDigestHolderMockGetDigestMethod struct {
	mock               *DigestHolderMock
	defaultExpectation *DigestHolderMockGetDigestMethodExpectation
	expectations       []*DigestHolderMockGetDigestMethodExpectation
}

// DigestHolderMockGetDigestMethodExpectation specifies expectation struct of the DigestHolder.GetDigestMethod
type DigestHolderMockGetDigestMethodExpectation struct {
	mock *DigestHolderMock

	results *DigestHolderMockGetDigestMethodResults
	Counter uint64
}

// DigestHolderMockGetDigestMethodResults contains results of the DigestHolder.GetDigestMethod
type DigestHolderMockGetDigestMethodResults struct {
	d1 DigestMethod
}

// Expect sets up expected params for DigestHolder.GetDigestMethod
func (mmGetDigestMethod *mDigestHolderMockGetDigestMethod) Expect() *mDigestHolderMockGetDigestMethod {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("DigestHolderMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &DigestHolderMockGetDigestMethodExpectation{}
	}

	return mmGetDigestMethod
}

// Inspect accepts an inspector function that has same arguments as the DigestHolder.GetDigestMethod
func (mmGetDigestMethod *mDigestHolderMockGetDigestMethod) Inspect(f func()) *mDigestHolderMockGetDigestMethod {
	if mmGetDigestMethod.mock.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("Inspect function is already set for DigestHolderMock.GetDigestMethod")
	}

	mmGetDigestMethod.mock.inspectFuncGetDigestMethod = f

	return mmGetDigestMethod
}

// Return sets up results that will be returned by DigestHolder.GetDigestMethod
func (mmGetDigestMethod *mDigestHolderMockGetDigestMethod) Return(d1 DigestMethod) *DigestHolderMock {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("DigestHolderMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &DigestHolderMockGetDigestMethodExpectation{mock: mmGetDigestMethod.mock}
	}
	mmGetDigestMethod.defaultExpectation.results = &DigestHolderMockGetDigestMethodResults{d1}
	return mmGetDigestMethod.mock
}

//Set uses given function f to mock the DigestHolder.GetDigestMethod method
func (mmGetDigestMethod *mDigestHolderMockGetDigestMethod) Set(f func() (d1 DigestMethod)) *DigestHolderMock {
	if mmGetDigestMethod.defaultExpectation != nil {
		mmGetDigestMethod.mock.t.Fatalf("Default expectation is already set for the DigestHolder.GetDigestMethod method")
	}

	if len(mmGetDigestMethod.expectations) > 0 {
		mmGetDigestMethod.mock.t.Fatalf("Some expectations are already set for the DigestHolder.GetDigestMethod method")
	}

	mmGetDigestMethod.mock.funcGetDigestMethod = f
	return mmGetDigestMethod.mock
}

// GetDigestMethod implements DigestHolder
func (mmGetDigestMethod *DigestHolderMock) GetDigestMethod() (d1 DigestMethod) {
	mm_atomic.AddUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestMethod.afterGetDigestMethodCounter, 1)

	if mmGetDigestMethod.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.inspectFuncGetDigestMethod()
	}

	if mmGetDigestMethod.GetDigestMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDigestMethod.t.Fatal("No results are set for the DigestHolderMock.GetDigestMethod")
		}
		return (*mm_results).d1
	}
	if mmGetDigestMethod.funcGetDigestMethod != nil {
		return mmGetDigestMethod.funcGetDigestMethod()
	}
	mmGetDigestMethod.t.Fatalf("Unexpected call to DigestHolderMock.GetDigestMethod.")
	return
}

// GetDigestMethodAfterCounter returns a count of finished DigestHolderMock.GetDigestMethod invocations
func (mmGetDigestMethod *DigestHolderMock) GetDigestMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.afterGetDigestMethodCounter)
}

// GetDigestMethodBeforeCounter returns a count of DigestHolderMock.GetDigestMethod invocations
func (mmGetDigestMethod *DigestHolderMock) GetDigestMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter)
}

// MinimockGetDigestMethodDone returns true if the count of the GetDigestMethod invocations corresponds
// the number of defined expectations
func (m *DigestHolderMock) MinimockGetDigestMethodDone() bool {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestMethodInspect logs each unmet expectation
func (m *DigestHolderMock) MinimockGetDigestMethodInspect() {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DigestHolderMock.GetDigestMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.GetDigestMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.GetDigestMethod")
	}
}

type mDigestHolderMockSignWith struct {
	mock               *DigestHolderMock
	defaultExpectation *DigestHolderMockSignWithExpectation
	expectations       []*DigestHolderMockSignWithExpectation

	callArgs []*DigestHolderMockSignWithParams
	mutex    sync.RWMutex
}

// DigestHolderMockSignWithExpectation specifies expectation struct of the DigestHolder.SignWith
type DigestHolderMockSignWithExpectation struct {
	mock    *DigestHolderMock
	params  *DigestHolderMockSignWithParams
	results *DigestHolderMockSignWithResults
	Counter uint64
}

// DigestHolderMockSignWithParams contains parameters of the DigestHolder.SignWith
type DigestHolderMockSignWithParams struct {
	signer DigestSigner
}

// DigestHolderMockSignWithResults contains results of the DigestHolder.SignWith
type DigestHolderMockSignWithResults struct {
	s1 SignedDigestHolder
}

// Expect sets up expected params for DigestHolder.SignWith
func (mmSignWith *mDigestHolderMockSignWith) Expect(signer DigestSigner) *mDigestHolderMockSignWith {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("DigestHolderMock.SignWith mock is already set by Set")
	}

	if mmSignWith.defaultExpectation == nil {
		mmSignWith.defaultExpectation = &DigestHolderMockSignWithExpectation{}
	}

	mmSignWith.defaultExpectation.params = &DigestHolderMockSignWithParams{signer}
	for _, e := range mmSignWith.expectations {
		if minimock.Equal(e.params, mmSignWith.defaultExpectation.params) {
			mmSignWith.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSignWith.defaultExpectation.params)
		}
	}

	return mmSignWith
}

// Inspect accepts an inspector function that has same arguments as the DigestHolder.SignWith
func (mmSignWith *mDigestHolderMockSignWith) Inspect(f func(signer DigestSigner)) *mDigestHolderMockSignWith {
	if mmSignWith.mock.inspectFuncSignWith != nil {
		mmSignWith.mock.t.Fatalf("Inspect function is already set for DigestHolderMock.SignWith")
	}

	mmSignWith.mock.inspectFuncSignWith = f

	return mmSignWith
}

// Return sets up results that will be returned by DigestHolder.SignWith
func (mmSignWith *mDigestHolderMockSignWith) Return(s1 SignedDigestHolder) *DigestHolderMock {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("DigestHolderMock.SignWith mock is already set by Set")
	}

	if mmSignWith.defaultExpectation == nil {
		mmSignWith.defaultExpectation = &DigestHolderMockSignWithExpectation{mock: mmSignWith.mock}
	}
	mmSignWith.defaultExpectation.results = &DigestHolderMockSignWithResults{s1}
	return mmSignWith.mock
}

//Set uses given function f to mock the DigestHolder.SignWith method
func (mmSignWith *mDigestHolderMockSignWith) Set(f func(signer DigestSigner) (s1 SignedDigestHolder)) *DigestHolderMock {
	if mmSignWith.defaultExpectation != nil {
		mmSignWith.mock.t.Fatalf("Default expectation is already set for the DigestHolder.SignWith method")
	}

	if len(mmSignWith.expectations) > 0 {
		mmSignWith.mock.t.Fatalf("Some expectations are already set for the DigestHolder.SignWith method")
	}

	mmSignWith.mock.funcSignWith = f
	return mmSignWith.mock
}

// When sets expectation for the DigestHolder.SignWith which will trigger the result defined by the following
// Then helper
func (mmSignWith *mDigestHolderMockSignWith) When(signer DigestSigner) *DigestHolderMockSignWithExpectation {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("DigestHolderMock.SignWith mock is already set by Set")
	}

	expectation := &DigestHolderMockSignWithExpectation{
		mock:   mmSignWith.mock,
		params: &DigestHolderMockSignWithParams{signer},
	}
	mmSignWith.expectations = append(mmSignWith.expectations, expectation)
	return expectation
}

// Then sets up DigestHolder.SignWith return parameters for the expectation previously defined by the When method
func (e *DigestHolderMockSignWithExpectation) Then(s1 SignedDigestHolder) *DigestHolderMock {
	e.results = &DigestHolderMockSignWithResults{s1}
	return e.mock
}

// SignWith implements DigestHolder
func (mmSignWith *DigestHolderMock) SignWith(signer DigestSigner) (s1 SignedDigestHolder) {
	mm_atomic.AddUint64(&mmSignWith.beforeSignWithCounter, 1)
	defer mm_atomic.AddUint64(&mmSignWith.afterSignWithCounter, 1)

	if mmSignWith.inspectFuncSignWith != nil {
		mmSignWith.inspectFuncSignWith(signer)
	}

	mm_params := &DigestHolderMockSignWithParams{signer}

	// Record call args
	mmSignWith.SignWithMock.mutex.Lock()
	mmSignWith.SignWithMock.callArgs = append(mmSignWith.SignWithMock.callArgs, mm_params)
	mmSignWith.SignWithMock.mutex.Unlock()

	for _, e := range mmSignWith.SignWithMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSignWith.SignWithMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSignWith.SignWithMock.defaultExpectation.Counter, 1)
		mm_want := mmSignWith.SignWithMock.defaultExpectation.params
		mm_got := DigestHolderMockSignWithParams{signer}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSignWith.t.Errorf("DigestHolderMock.SignWith got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSignWith.SignWithMock.defaultExpectation.results
		if mm_results == nil {
			mmSignWith.t.Fatal("No results are set for the DigestHolderMock.SignWith")
		}
		return (*mm_results).s1
	}
	if mmSignWith.funcSignWith != nil {
		return mmSignWith.funcSignWith(signer)
	}
	mmSignWith.t.Fatalf("Unexpected call to DigestHolderMock.SignWith. %v", signer)
	return
}

// SignWithAfterCounter returns a count of finished DigestHolderMock.SignWith invocations
func (mmSignWith *DigestHolderMock) SignWithAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignWith.afterSignWithCounter)
}

// SignWithBeforeCounter returns a count of DigestHolderMock.SignWith invocations
func (mmSignWith *DigestHolderMock) SignWithBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignWith.beforeSignWithCounter)
}

// Calls returns a list of arguments used in each call to DigestHolderMock.SignWith.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSignWith *mDigestHolderMockSignWith) Calls() []*DigestHolderMockSignWithParams {
	mmSignWith.mutex.RLock()

	argCopy := make([]*DigestHolderMockSignWithParams, len(mmSignWith.callArgs))
	copy(argCopy, mmSignWith.callArgs)

	mmSignWith.mutex.RUnlock()

	return argCopy
}

// MinimockSignWithDone returns true if the count of the SignWith invocations corresponds
// the number of defined expectations
func (m *DigestHolderMock) MinimockSignWithDone() bool {
	for _, e := range m.SignWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignWith != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		return false
	}
	return true
}

// MinimockSignWithInspect logs each unmet expectation
func (m *DigestHolderMock) MinimockSignWithInspect() {
	for _, e := range m.SignWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DigestHolderMock.SignWith with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		if m.SignWithMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DigestHolderMock.SignWith")
		} else {
			m.t.Errorf("Expected call to DigestHolderMock.SignWith with params: %#v", *m.SignWithMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignWith != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.SignWith")
	}
}

type mDigestHolderMockWriteTo struct {
	mock               *DigestHolderMock
	defaultExpectation *DigestHolderMockWriteToExpectation
	expectations       []*DigestHolderMockWriteToExpectation

	callArgs []*DigestHolderMockWriteToParams
	mutex    sync.RWMutex
}

// DigestHolderMockWriteToExpectation specifies expectation struct of the DigestHolder.WriteTo
type DigestHolderMockWriteToExpectation struct {
	mock    *DigestHolderMock
	params  *DigestHolderMockWriteToParams
	results *DigestHolderMockWriteToResults
	Counter uint64
}

// DigestHolderMockWriteToParams contains parameters of the DigestHolder.WriteTo
type DigestHolderMockWriteToParams struct {
	w io.Writer
}

// DigestHolderMockWriteToResults contains results of the DigestHolder.WriteTo
type DigestHolderMockWriteToResults struct {
	n   int64
	err error
}

// Expect sets up expected params for DigestHolder.WriteTo
func (mmWriteTo *mDigestHolderMockWriteTo) Expect(w io.Writer) *mDigestHolderMockWriteTo {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("DigestHolderMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &DigestHolderMockWriteToExpectation{}
	}

	mmWriteTo.defaultExpectation.params = &DigestHolderMockWriteToParams{w}
	for _, e := range mmWriteTo.expectations {
		if minimock.Equal(e.params, mmWriteTo.defaultExpectation.params) {
			mmWriteTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteTo.defaultExpectation.params)
		}
	}

	return mmWriteTo
}

// Inspect accepts an inspector function that has same arguments as the DigestHolder.WriteTo
func (mmWriteTo *mDigestHolderMockWriteTo) Inspect(f func(w io.Writer)) *mDigestHolderMockWriteTo {
	if mmWriteTo.mock.inspectFuncWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("Inspect function is already set for DigestHolderMock.WriteTo")
	}

	mmWriteTo.mock.inspectFuncWriteTo = f

	return mmWriteTo
}

// Return sets up results that will be returned by DigestHolder.WriteTo
func (mmWriteTo *mDigestHolderMockWriteTo) Return(n int64, err error) *DigestHolderMock {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("DigestHolderMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &DigestHolderMockWriteToExpectation{mock: mmWriteTo.mock}
	}
	mmWriteTo.defaultExpectation.results = &DigestHolderMockWriteToResults{n, err}
	return mmWriteTo.mock
}

//Set uses given function f to mock the DigestHolder.WriteTo method
func (mmWriteTo *mDigestHolderMockWriteTo) Set(f func(w io.Writer) (n int64, err error)) *DigestHolderMock {
	if mmWriteTo.defaultExpectation != nil {
		mmWriteTo.mock.t.Fatalf("Default expectation is already set for the DigestHolder.WriteTo method")
	}

	if len(mmWriteTo.expectations) > 0 {
		mmWriteTo.mock.t.Fatalf("Some expectations are already set for the DigestHolder.WriteTo method")
	}

	mmWriteTo.mock.funcWriteTo = f
	return mmWriteTo.mock
}

// When sets expectation for the DigestHolder.WriteTo which will trigger the result defined by the following
// Then helper
func (mmWriteTo *mDigestHolderMockWriteTo) When(w io.Writer) *DigestHolderMockWriteToExpectation {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("DigestHolderMock.WriteTo mock is already set by Set")
	}

	expectation := &DigestHolderMockWriteToExpectation{
		mock:   mmWriteTo.mock,
		params: &DigestHolderMockWriteToParams{w},
	}
	mmWriteTo.expectations = append(mmWriteTo.expectations, expectation)
	return expectation
}

// Then sets up DigestHolder.WriteTo return parameters for the expectation previously defined by the When method
func (e *DigestHolderMockWriteToExpectation) Then(n int64, err error) *DigestHolderMock {
	e.results = &DigestHolderMockWriteToResults{n, err}
	return e.mock
}

// WriteTo implements DigestHolder
func (mmWriteTo *DigestHolderMock) WriteTo(w io.Writer) (n int64, err error) {
	mm_atomic.AddUint64(&mmWriteTo.beforeWriteToCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteTo.afterWriteToCounter, 1)

	if mmWriteTo.inspectFuncWriteTo != nil {
		mmWriteTo.inspectFuncWriteTo(w)
	}

	mm_params := &DigestHolderMockWriteToParams{w}

	// Record call args
	mmWriteTo.WriteToMock.mutex.Lock()
	mmWriteTo.WriteToMock.callArgs = append(mmWriteTo.WriteToMock.callArgs, mm_params)
	mmWriteTo.WriteToMock.mutex.Unlock()

	for _, e := range mmWriteTo.WriteToMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWriteTo.WriteToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteTo.WriteToMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteTo.WriteToMock.defaultExpectation.params
		mm_got := DigestHolderMockWriteToParams{w}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteTo.t.Errorf("DigestHolderMock.WriteTo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWriteTo.WriteToMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteTo.t.Fatal("No results are set for the DigestHolderMock.WriteTo")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmWriteTo.funcWriteTo != nil {
		return mmWriteTo.funcWriteTo(w)
	}
	mmWriteTo.t.Fatalf("Unexpected call to DigestHolderMock.WriteTo. %v", w)
	return
}

// WriteToAfterCounter returns a count of finished DigestHolderMock.WriteTo invocations
func (mmWriteTo *DigestHolderMock) WriteToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.afterWriteToCounter)
}

// WriteToBeforeCounter returns a count of DigestHolderMock.WriteTo invocations
func (mmWriteTo *DigestHolderMock) WriteToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.beforeWriteToCounter)
}

// Calls returns a list of arguments used in each call to DigestHolderMock.WriteTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteTo *mDigestHolderMockWriteTo) Calls() []*DigestHolderMockWriteToParams {
	mmWriteTo.mutex.RLock()

	argCopy := make([]*DigestHolderMockWriteToParams, len(mmWriteTo.callArgs))
	copy(argCopy, mmWriteTo.callArgs)

	mmWriteTo.mutex.RUnlock()

	return argCopy
}

// MinimockWriteToDone returns true if the count of the WriteTo invocations corresponds
// the number of defined expectations
func (m *DigestHolderMock) MinimockWriteToDone() bool {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteToInspect logs each unmet expectation
func (m *DigestHolderMock) MinimockWriteToInspect() {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DigestHolderMock.WriteTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		if m.WriteToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DigestHolderMock.WriteTo")
		} else {
			m.t.Errorf("Expected call to DigestHolderMock.WriteTo with params: %#v", *m.WriteToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.WriteTo")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DigestHolderMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAsByteStringInspect()

		m.MinimockCopyToInspect()

		m.MinimockEqualsInspect()

		m.MinimockFixedByteSizeInspect()

		m.MinimockFoldToUint64Inspect()

		m.MinimockGetDigestMethodInspect()

		m.MinimockSignWithInspect()

		m.MinimockWriteToInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DigestHolderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DigestHolderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAsByteStringDone() &&
		m.MinimockCopyToDone() &&
		m.MinimockEqualsDone() &&
		m.MinimockFixedByteSizeDone() &&
		m.MinimockFoldToUint64Done() &&
		m.MinimockGetDigestMethodDone() &&
		m.MinimockSignWithDone() &&
		m.MinimockWriteToDone()
}
