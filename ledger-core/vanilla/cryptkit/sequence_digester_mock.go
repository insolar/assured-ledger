package cryptkit

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/vanilla/longbits"
)

// SequenceDigesterMock implements SequenceDigester
type SequenceDigesterMock struct {
	t minimock.Tester

	funcAddNext          func(digest longbits.FoldableReader)
	inspectFuncAddNext   func(digest longbits.FoldableReader)
	afterAddNextCounter  uint64
	beforeAddNextCounter uint64
	AddNextMock          mSequenceDigesterMockAddNext

	funcFinishSequence          func() (d1 Digest)
	inspectFuncFinishSequence   func()
	afterFinishSequenceCounter  uint64
	beforeFinishSequenceCounter uint64
	FinishSequenceMock          mSequenceDigesterMockFinishSequence

	funcGetDigestMethod          func() (d1 DigestMethod)
	inspectFuncGetDigestMethod   func()
	afterGetDigestMethodCounter  uint64
	beforeGetDigestMethodCounter uint64
	GetDigestMethodMock          mSequenceDigesterMockGetDigestMethod

	funcGetDigestSize          func() (i1 int)
	inspectFuncGetDigestSize   func()
	afterGetDigestSizeCounter  uint64
	beforeGetDigestSizeCounter uint64
	GetDigestSizeMock          mSequenceDigesterMockGetDigestSize
}

// NewSequenceDigesterMock returns a mock for SequenceDigester
func NewSequenceDigesterMock(t minimock.Tester) *SequenceDigesterMock {
	m := &SequenceDigesterMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddNextMock = mSequenceDigesterMockAddNext{mock: m}
	m.AddNextMock.callArgs = []*SequenceDigesterMockAddNextParams{}

	m.FinishSequenceMock = mSequenceDigesterMockFinishSequence{mock: m}

	m.GetDigestMethodMock = mSequenceDigesterMockGetDigestMethod{mock: m}

	m.GetDigestSizeMock = mSequenceDigesterMockGetDigestSize{mock: m}

	return m
}

type mSequenceDigesterMockAddNext struct {
	mock               *SequenceDigesterMock
	defaultExpectation *SequenceDigesterMockAddNextExpectation
	expectations       []*SequenceDigesterMockAddNextExpectation

	callArgs []*SequenceDigesterMockAddNextParams
	mutex    sync.RWMutex
}

// SequenceDigesterMockAddNextExpectation specifies expectation struct of the SequenceDigester.AddNext
type SequenceDigesterMockAddNextExpectation struct {
	mock   *SequenceDigesterMock
	params *SequenceDigesterMockAddNextParams

	Counter uint64
}

// SequenceDigesterMockAddNextParams contains parameters of the SequenceDigester.AddNext
type SequenceDigesterMockAddNextParams struct {
	digest longbits.FoldableReader
}

// Expect sets up expected params for SequenceDigester.AddNext
func (mmAddNext *mSequenceDigesterMockAddNext) Expect(digest longbits.FoldableReader) *mSequenceDigesterMockAddNext {
	if mmAddNext.mock.funcAddNext != nil {
		mmAddNext.mock.t.Fatalf("SequenceDigesterMock.AddNext mock is already set by Set")
	}

	if mmAddNext.defaultExpectation == nil {
		mmAddNext.defaultExpectation = &SequenceDigesterMockAddNextExpectation{}
	}

	mmAddNext.defaultExpectation.params = &SequenceDigesterMockAddNextParams{digest}
	for _, e := range mmAddNext.expectations {
		if minimock.Equal(e.params, mmAddNext.defaultExpectation.params) {
			mmAddNext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddNext.defaultExpectation.params)
		}
	}

	return mmAddNext
}

// Inspect accepts an inspector function that has same arguments as the SequenceDigester.AddNext
func (mmAddNext *mSequenceDigesterMockAddNext) Inspect(f func(digest longbits.FoldableReader)) *mSequenceDigesterMockAddNext {
	if mmAddNext.mock.inspectFuncAddNext != nil {
		mmAddNext.mock.t.Fatalf("Inspect function is already set for SequenceDigesterMock.AddNext")
	}

	mmAddNext.mock.inspectFuncAddNext = f

	return mmAddNext
}

// Return sets up results that will be returned by SequenceDigester.AddNext
func (mmAddNext *mSequenceDigesterMockAddNext) Return() *SequenceDigesterMock {
	if mmAddNext.mock.funcAddNext != nil {
		mmAddNext.mock.t.Fatalf("SequenceDigesterMock.AddNext mock is already set by Set")
	}

	if mmAddNext.defaultExpectation == nil {
		mmAddNext.defaultExpectation = &SequenceDigesterMockAddNextExpectation{mock: mmAddNext.mock}
	}

	return mmAddNext.mock
}

//Set uses given function f to mock the SequenceDigester.AddNext method
func (mmAddNext *mSequenceDigesterMockAddNext) Set(f func(digest longbits.FoldableReader)) *SequenceDigesterMock {
	if mmAddNext.defaultExpectation != nil {
		mmAddNext.mock.t.Fatalf("Default expectation is already set for the SequenceDigester.AddNext method")
	}

	if len(mmAddNext.expectations) > 0 {
		mmAddNext.mock.t.Fatalf("Some expectations are already set for the SequenceDigester.AddNext method")
	}

	mmAddNext.mock.funcAddNext = f
	return mmAddNext.mock
}

// AddNext implements SequenceDigester
func (mmAddNext *SequenceDigesterMock) AddNext(digest longbits.FoldableReader) {
	mm_atomic.AddUint64(&mmAddNext.beforeAddNextCounter, 1)
	defer mm_atomic.AddUint64(&mmAddNext.afterAddNextCounter, 1)

	if mmAddNext.inspectFuncAddNext != nil {
		mmAddNext.inspectFuncAddNext(digest)
	}

	mm_params := &SequenceDigesterMockAddNextParams{digest}

	// Record call args
	mmAddNext.AddNextMock.mutex.Lock()
	mmAddNext.AddNextMock.callArgs = append(mmAddNext.AddNextMock.callArgs, mm_params)
	mmAddNext.AddNextMock.mutex.Unlock()

	for _, e := range mmAddNext.AddNextMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddNext.AddNextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddNext.AddNextMock.defaultExpectation.Counter, 1)
		mm_want := mmAddNext.AddNextMock.defaultExpectation.params
		mm_got := SequenceDigesterMockAddNextParams{digest}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddNext.t.Errorf("SequenceDigesterMock.AddNext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddNext.funcAddNext != nil {
		mmAddNext.funcAddNext(digest)
		return
	}
	mmAddNext.t.Fatalf("Unexpected call to SequenceDigesterMock.AddNext. %v", digest)

}

// AddNextAfterCounter returns a count of finished SequenceDigesterMock.AddNext invocations
func (mmAddNext *SequenceDigesterMock) AddNextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddNext.afterAddNextCounter)
}

// AddNextBeforeCounter returns a count of SequenceDigesterMock.AddNext invocations
func (mmAddNext *SequenceDigesterMock) AddNextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddNext.beforeAddNextCounter)
}

// Calls returns a list of arguments used in each call to SequenceDigesterMock.AddNext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddNext *mSequenceDigesterMockAddNext) Calls() []*SequenceDigesterMockAddNextParams {
	mmAddNext.mutex.RLock()

	argCopy := make([]*SequenceDigesterMockAddNextParams, len(mmAddNext.callArgs))
	copy(argCopy, mmAddNext.callArgs)

	mmAddNext.mutex.RUnlock()

	return argCopy
}

// MinimockAddNextDone returns true if the count of the AddNext invocations corresponds
// the number of defined expectations
func (m *SequenceDigesterMock) MinimockAddNextDone() bool {
	for _, e := range m.AddNextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddNextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddNextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddNext != nil && mm_atomic.LoadUint64(&m.afterAddNextCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddNextInspect logs each unmet expectation
func (m *SequenceDigesterMock) MinimockAddNextInspect() {
	for _, e := range m.AddNextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SequenceDigesterMock.AddNext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddNextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddNextCounter) < 1 {
		if m.AddNextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SequenceDigesterMock.AddNext")
		} else {
			m.t.Errorf("Expected call to SequenceDigesterMock.AddNext with params: %#v", *m.AddNextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddNext != nil && mm_atomic.LoadUint64(&m.afterAddNextCounter) < 1 {
		m.t.Error("Expected call to SequenceDigesterMock.AddNext")
	}
}

type mSequenceDigesterMockFinishSequence struct {
	mock               *SequenceDigesterMock
	defaultExpectation *SequenceDigesterMockFinishSequenceExpectation
	expectations       []*SequenceDigesterMockFinishSequenceExpectation
}

// SequenceDigesterMockFinishSequenceExpectation specifies expectation struct of the SequenceDigester.FinishSequence
type SequenceDigesterMockFinishSequenceExpectation struct {
	mock *SequenceDigesterMock

	results *SequenceDigesterMockFinishSequenceResults
	Counter uint64
}

// SequenceDigesterMockFinishSequenceResults contains results of the SequenceDigester.FinishSequence
type SequenceDigesterMockFinishSequenceResults struct {
	d1 Digest
}

// Expect sets up expected params for SequenceDigester.FinishSequence
func (mmFinishSequence *mSequenceDigesterMockFinishSequence) Expect() *mSequenceDigesterMockFinishSequence {
	if mmFinishSequence.mock.funcFinishSequence != nil {
		mmFinishSequence.mock.t.Fatalf("SequenceDigesterMock.FinishSequence mock is already set by Set")
	}

	if mmFinishSequence.defaultExpectation == nil {
		mmFinishSequence.defaultExpectation = &SequenceDigesterMockFinishSequenceExpectation{}
	}

	return mmFinishSequence
}

// Inspect accepts an inspector function that has same arguments as the SequenceDigester.FinishSequence
func (mmFinishSequence *mSequenceDigesterMockFinishSequence) Inspect(f func()) *mSequenceDigesterMockFinishSequence {
	if mmFinishSequence.mock.inspectFuncFinishSequence != nil {
		mmFinishSequence.mock.t.Fatalf("Inspect function is already set for SequenceDigesterMock.FinishSequence")
	}

	mmFinishSequence.mock.inspectFuncFinishSequence = f

	return mmFinishSequence
}

// Return sets up results that will be returned by SequenceDigester.FinishSequence
func (mmFinishSequence *mSequenceDigesterMockFinishSequence) Return(d1 Digest) *SequenceDigesterMock {
	if mmFinishSequence.mock.funcFinishSequence != nil {
		mmFinishSequence.mock.t.Fatalf("SequenceDigesterMock.FinishSequence mock is already set by Set")
	}

	if mmFinishSequence.defaultExpectation == nil {
		mmFinishSequence.defaultExpectation = &SequenceDigesterMockFinishSequenceExpectation{mock: mmFinishSequence.mock}
	}
	mmFinishSequence.defaultExpectation.results = &SequenceDigesterMockFinishSequenceResults{d1}
	return mmFinishSequence.mock
}

//Set uses given function f to mock the SequenceDigester.FinishSequence method
func (mmFinishSequence *mSequenceDigesterMockFinishSequence) Set(f func() (d1 Digest)) *SequenceDigesterMock {
	if mmFinishSequence.defaultExpectation != nil {
		mmFinishSequence.mock.t.Fatalf("Default expectation is already set for the SequenceDigester.FinishSequence method")
	}

	if len(mmFinishSequence.expectations) > 0 {
		mmFinishSequence.mock.t.Fatalf("Some expectations are already set for the SequenceDigester.FinishSequence method")
	}

	mmFinishSequence.mock.funcFinishSequence = f
	return mmFinishSequence.mock
}

// FinishSequence implements SequenceDigester
func (mmFinishSequence *SequenceDigesterMock) FinishSequence() (d1 Digest) {
	mm_atomic.AddUint64(&mmFinishSequence.beforeFinishSequenceCounter, 1)
	defer mm_atomic.AddUint64(&mmFinishSequence.afterFinishSequenceCounter, 1)

	if mmFinishSequence.inspectFuncFinishSequence != nil {
		mmFinishSequence.inspectFuncFinishSequence()
	}

	if mmFinishSequence.FinishSequenceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFinishSequence.FinishSequenceMock.defaultExpectation.Counter, 1)

		mm_results := mmFinishSequence.FinishSequenceMock.defaultExpectation.results
		if mm_results == nil {
			mmFinishSequence.t.Fatal("No results are set for the SequenceDigesterMock.FinishSequence")
		}
		return (*mm_results).d1
	}
	if mmFinishSequence.funcFinishSequence != nil {
		return mmFinishSequence.funcFinishSequence()
	}
	mmFinishSequence.t.Fatalf("Unexpected call to SequenceDigesterMock.FinishSequence.")
	return
}

// FinishSequenceAfterCounter returns a count of finished SequenceDigesterMock.FinishSequence invocations
func (mmFinishSequence *SequenceDigesterMock) FinishSequenceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFinishSequence.afterFinishSequenceCounter)
}

// FinishSequenceBeforeCounter returns a count of SequenceDigesterMock.FinishSequence invocations
func (mmFinishSequence *SequenceDigesterMock) FinishSequenceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFinishSequence.beforeFinishSequenceCounter)
}

// MinimockFinishSequenceDone returns true if the count of the FinishSequence invocations corresponds
// the number of defined expectations
func (m *SequenceDigesterMock) MinimockFinishSequenceDone() bool {
	for _, e := range m.FinishSequenceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FinishSequenceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFinishSequenceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFinishSequence != nil && mm_atomic.LoadUint64(&m.afterFinishSequenceCounter) < 1 {
		return false
	}
	return true
}

// MinimockFinishSequenceInspect logs each unmet expectation
func (m *SequenceDigesterMock) MinimockFinishSequenceInspect() {
	for _, e := range m.FinishSequenceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SequenceDigesterMock.FinishSequence")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FinishSequenceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFinishSequenceCounter) < 1 {
		m.t.Error("Expected call to SequenceDigesterMock.FinishSequence")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFinishSequence != nil && mm_atomic.LoadUint64(&m.afterFinishSequenceCounter) < 1 {
		m.t.Error("Expected call to SequenceDigesterMock.FinishSequence")
	}
}

type mSequenceDigesterMockGetDigestMethod struct {
	mock               *SequenceDigesterMock
	defaultExpectation *SequenceDigesterMockGetDigestMethodExpectation
	expectations       []*SequenceDigesterMockGetDigestMethodExpectation
}

// SequenceDigesterMockGetDigestMethodExpectation specifies expectation struct of the SequenceDigester.GetDigestMethod
type SequenceDigesterMockGetDigestMethodExpectation struct {
	mock *SequenceDigesterMock

	results *SequenceDigesterMockGetDigestMethodResults
	Counter uint64
}

// SequenceDigesterMockGetDigestMethodResults contains results of the SequenceDigester.GetDigestMethod
type SequenceDigesterMockGetDigestMethodResults struct {
	d1 DigestMethod
}

// Expect sets up expected params for SequenceDigester.GetDigestMethod
func (mmGetDigestMethod *mSequenceDigesterMockGetDigestMethod) Expect() *mSequenceDigesterMockGetDigestMethod {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("SequenceDigesterMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &SequenceDigesterMockGetDigestMethodExpectation{}
	}

	return mmGetDigestMethod
}

// Inspect accepts an inspector function that has same arguments as the SequenceDigester.GetDigestMethod
func (mmGetDigestMethod *mSequenceDigesterMockGetDigestMethod) Inspect(f func()) *mSequenceDigesterMockGetDigestMethod {
	if mmGetDigestMethod.mock.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("Inspect function is already set for SequenceDigesterMock.GetDigestMethod")
	}

	mmGetDigestMethod.mock.inspectFuncGetDigestMethod = f

	return mmGetDigestMethod
}

// Return sets up results that will be returned by SequenceDigester.GetDigestMethod
func (mmGetDigestMethod *mSequenceDigesterMockGetDigestMethod) Return(d1 DigestMethod) *SequenceDigesterMock {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("SequenceDigesterMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &SequenceDigesterMockGetDigestMethodExpectation{mock: mmGetDigestMethod.mock}
	}
	mmGetDigestMethod.defaultExpectation.results = &SequenceDigesterMockGetDigestMethodResults{d1}
	return mmGetDigestMethod.mock
}

//Set uses given function f to mock the SequenceDigester.GetDigestMethod method
func (mmGetDigestMethod *mSequenceDigesterMockGetDigestMethod) Set(f func() (d1 DigestMethod)) *SequenceDigesterMock {
	if mmGetDigestMethod.defaultExpectation != nil {
		mmGetDigestMethod.mock.t.Fatalf("Default expectation is already set for the SequenceDigester.GetDigestMethod method")
	}

	if len(mmGetDigestMethod.expectations) > 0 {
		mmGetDigestMethod.mock.t.Fatalf("Some expectations are already set for the SequenceDigester.GetDigestMethod method")
	}

	mmGetDigestMethod.mock.funcGetDigestMethod = f
	return mmGetDigestMethod.mock
}

// GetDigestMethod implements SequenceDigester
func (mmGetDigestMethod *SequenceDigesterMock) GetDigestMethod() (d1 DigestMethod) {
	mm_atomic.AddUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestMethod.afterGetDigestMethodCounter, 1)

	if mmGetDigestMethod.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.inspectFuncGetDigestMethod()
	}

	if mmGetDigestMethod.GetDigestMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDigestMethod.t.Fatal("No results are set for the SequenceDigesterMock.GetDigestMethod")
		}
		return (*mm_results).d1
	}
	if mmGetDigestMethod.funcGetDigestMethod != nil {
		return mmGetDigestMethod.funcGetDigestMethod()
	}
	mmGetDigestMethod.t.Fatalf("Unexpected call to SequenceDigesterMock.GetDigestMethod.")
	return
}

// GetDigestMethodAfterCounter returns a count of finished SequenceDigesterMock.GetDigestMethod invocations
func (mmGetDigestMethod *SequenceDigesterMock) GetDigestMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.afterGetDigestMethodCounter)
}

// GetDigestMethodBeforeCounter returns a count of SequenceDigesterMock.GetDigestMethod invocations
func (mmGetDigestMethod *SequenceDigesterMock) GetDigestMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter)
}

// MinimockGetDigestMethodDone returns true if the count of the GetDigestMethod invocations corresponds
// the number of defined expectations
func (m *SequenceDigesterMock) MinimockGetDigestMethodDone() bool {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestMethodInspect logs each unmet expectation
func (m *SequenceDigesterMock) MinimockGetDigestMethodInspect() {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SequenceDigesterMock.GetDigestMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to SequenceDigesterMock.GetDigestMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to SequenceDigesterMock.GetDigestMethod")
	}
}

type mSequenceDigesterMockGetDigestSize struct {
	mock               *SequenceDigesterMock
	defaultExpectation *SequenceDigesterMockGetDigestSizeExpectation
	expectations       []*SequenceDigesterMockGetDigestSizeExpectation
}

// SequenceDigesterMockGetDigestSizeExpectation specifies expectation struct of the SequenceDigester.GetDigestSize
type SequenceDigesterMockGetDigestSizeExpectation struct {
	mock *SequenceDigesterMock

	results *SequenceDigesterMockGetDigestSizeResults
	Counter uint64
}

// SequenceDigesterMockGetDigestSizeResults contains results of the SequenceDigester.GetDigestSize
type SequenceDigesterMockGetDigestSizeResults struct {
	i1 int
}

// Expect sets up expected params for SequenceDigester.GetDigestSize
func (mmGetDigestSize *mSequenceDigesterMockGetDigestSize) Expect() *mSequenceDigesterMockGetDigestSize {
	if mmGetDigestSize.mock.funcGetDigestSize != nil {
		mmGetDigestSize.mock.t.Fatalf("SequenceDigesterMock.GetDigestSize mock is already set by Set")
	}

	if mmGetDigestSize.defaultExpectation == nil {
		mmGetDigestSize.defaultExpectation = &SequenceDigesterMockGetDigestSizeExpectation{}
	}

	return mmGetDigestSize
}

// Inspect accepts an inspector function that has same arguments as the SequenceDigester.GetDigestSize
func (mmGetDigestSize *mSequenceDigesterMockGetDigestSize) Inspect(f func()) *mSequenceDigesterMockGetDigestSize {
	if mmGetDigestSize.mock.inspectFuncGetDigestSize != nil {
		mmGetDigestSize.mock.t.Fatalf("Inspect function is already set for SequenceDigesterMock.GetDigestSize")
	}

	mmGetDigestSize.mock.inspectFuncGetDigestSize = f

	return mmGetDigestSize
}

// Return sets up results that will be returned by SequenceDigester.GetDigestSize
func (mmGetDigestSize *mSequenceDigesterMockGetDigestSize) Return(i1 int) *SequenceDigesterMock {
	if mmGetDigestSize.mock.funcGetDigestSize != nil {
		mmGetDigestSize.mock.t.Fatalf("SequenceDigesterMock.GetDigestSize mock is already set by Set")
	}

	if mmGetDigestSize.defaultExpectation == nil {
		mmGetDigestSize.defaultExpectation = &SequenceDigesterMockGetDigestSizeExpectation{mock: mmGetDigestSize.mock}
	}
	mmGetDigestSize.defaultExpectation.results = &SequenceDigesterMockGetDigestSizeResults{i1}
	return mmGetDigestSize.mock
}

//Set uses given function f to mock the SequenceDigester.GetDigestSize method
func (mmGetDigestSize *mSequenceDigesterMockGetDigestSize) Set(f func() (i1 int)) *SequenceDigesterMock {
	if mmGetDigestSize.defaultExpectation != nil {
		mmGetDigestSize.mock.t.Fatalf("Default expectation is already set for the SequenceDigester.GetDigestSize method")
	}

	if len(mmGetDigestSize.expectations) > 0 {
		mmGetDigestSize.mock.t.Fatalf("Some expectations are already set for the SequenceDigester.GetDigestSize method")
	}

	mmGetDigestSize.mock.funcGetDigestSize = f
	return mmGetDigestSize.mock
}

// GetDigestSize implements SequenceDigester
func (mmGetDigestSize *SequenceDigesterMock) GetDigestSize() (i1 int) {
	mm_atomic.AddUint64(&mmGetDigestSize.beforeGetDigestSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestSize.afterGetDigestSizeCounter, 1)

	if mmGetDigestSize.inspectFuncGetDigestSize != nil {
		mmGetDigestSize.inspectFuncGetDigestSize()
	}

	if mmGetDigestSize.GetDigestSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestSize.GetDigestSizeMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDigestSize.GetDigestSizeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDigestSize.t.Fatal("No results are set for the SequenceDigesterMock.GetDigestSize")
		}
		return (*mm_results).i1
	}
	if mmGetDigestSize.funcGetDigestSize != nil {
		return mmGetDigestSize.funcGetDigestSize()
	}
	mmGetDigestSize.t.Fatalf("Unexpected call to SequenceDigesterMock.GetDigestSize.")
	return
}

// GetDigestSizeAfterCounter returns a count of finished SequenceDigesterMock.GetDigestSize invocations
func (mmGetDigestSize *SequenceDigesterMock) GetDigestSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestSize.afterGetDigestSizeCounter)
}

// GetDigestSizeBeforeCounter returns a count of SequenceDigesterMock.GetDigestSize invocations
func (mmGetDigestSize *SequenceDigesterMock) GetDigestSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestSize.beforeGetDigestSizeCounter)
}

// MinimockGetDigestSizeDone returns true if the count of the GetDigestSize invocations corresponds
// the number of defined expectations
func (m *SequenceDigesterMock) MinimockGetDigestSizeDone() bool {
	for _, e := range m.GetDigestSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestSize != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestSizeInspect logs each unmet expectation
func (m *SequenceDigesterMock) MinimockGetDigestSizeInspect() {
	for _, e := range m.GetDigestSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SequenceDigesterMock.GetDigestSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		m.t.Error("Expected call to SequenceDigesterMock.GetDigestSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestSize != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		m.t.Error("Expected call to SequenceDigesterMock.GetDigestSize")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SequenceDigesterMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddNextInspect()

		m.MinimockFinishSequenceInspect()

		m.MinimockGetDigestMethodInspect()

		m.MinimockGetDigestSizeInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SequenceDigesterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SequenceDigesterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddNextDone() &&
		m.MinimockFinishSequenceDone() &&
		m.MinimockGetDigestMethodDone() &&
		m.MinimockGetDigestSizeDone()
}
