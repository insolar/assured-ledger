package cryptkit

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// SignatureVerifierMock implements SignatureVerifier
type SignatureVerifierMock struct {
	t minimock.Tester

	funcGetDefaultSigningMethod          func() (s1 SigningMethod)
	inspectFuncGetDefaultSigningMethod   func()
	afterGetDefaultSigningMethodCounter  uint64
	beforeGetDefaultSigningMethodCounter uint64
	GetDefaultSigningMethodMock          mSignatureVerifierMockGetDefaultSigningMethod

	funcIsDigestMethodSupported          func(m DigestMethod) (b1 bool)
	inspectFuncIsDigestMethodSupported   func(m DigestMethod)
	afterIsDigestMethodSupportedCounter  uint64
	beforeIsDigestMethodSupportedCounter uint64
	IsDigestMethodSupportedMock          mSignatureVerifierMockIsDigestMethodSupported

	funcIsSigningMethodSupported          func(m SigningMethod) (b1 bool)
	inspectFuncIsSigningMethodSupported   func(m SigningMethod)
	afterIsSigningMethodSupportedCounter  uint64
	beforeIsSigningMethodSupportedCounter uint64
	IsSigningMethodSupportedMock          mSignatureVerifierMockIsSigningMethodSupported

	funcIsValidDataSignature          func(data io.Reader, signature SignatureHolder) (b1 bool)
	inspectFuncIsValidDataSignature   func(data io.Reader, signature SignatureHolder)
	afterIsValidDataSignatureCounter  uint64
	beforeIsValidDataSignatureCounter uint64
	IsValidDataSignatureMock          mSignatureVerifierMockIsValidDataSignature

	funcIsValidDigestSignature          func(digest DigestHolder, signature SignatureHolder) (b1 bool)
	inspectFuncIsValidDigestSignature   func(digest DigestHolder, signature SignatureHolder)
	afterIsValidDigestSignatureCounter  uint64
	beforeIsValidDigestSignatureCounter uint64
	IsValidDigestSignatureMock          mSignatureVerifierMockIsValidDigestSignature
}

// NewSignatureVerifierMock returns a mock for SignatureVerifier
func NewSignatureVerifierMock(t minimock.Tester) *SignatureVerifierMock {
	m := &SignatureVerifierMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetDefaultSigningMethodMock = mSignatureVerifierMockGetDefaultSigningMethod{mock: m}

	m.IsDigestMethodSupportedMock = mSignatureVerifierMockIsDigestMethodSupported{mock: m}
	m.IsDigestMethodSupportedMock.callArgs = []*SignatureVerifierMockIsDigestMethodSupportedParams{}

	m.IsSigningMethodSupportedMock = mSignatureVerifierMockIsSigningMethodSupported{mock: m}
	m.IsSigningMethodSupportedMock.callArgs = []*SignatureVerifierMockIsSigningMethodSupportedParams{}

	m.IsValidDataSignatureMock = mSignatureVerifierMockIsValidDataSignature{mock: m}
	m.IsValidDataSignatureMock.callArgs = []*SignatureVerifierMockIsValidDataSignatureParams{}

	m.IsValidDigestSignatureMock = mSignatureVerifierMockIsValidDigestSignature{mock: m}
	m.IsValidDigestSignatureMock.callArgs = []*SignatureVerifierMockIsValidDigestSignatureParams{}

	return m
}

type mSignatureVerifierMockGetDefaultSigningMethod struct {
	mock               *SignatureVerifierMock
	defaultExpectation *SignatureVerifierMockGetDefaultSigningMethodExpectation
	expectations       []*SignatureVerifierMockGetDefaultSigningMethodExpectation
}

// SignatureVerifierMockGetDefaultSigningMethodExpectation specifies expectation struct of the SignatureVerifier.GetDefaultSigningMethod
type SignatureVerifierMockGetDefaultSigningMethodExpectation struct {
	mock *SignatureVerifierMock

	results *SignatureVerifierMockGetDefaultSigningMethodResults
	Counter uint64
}

// SignatureVerifierMockGetDefaultSigningMethodResults contains results of the SignatureVerifier.GetDefaultSigningMethod
type SignatureVerifierMockGetDefaultSigningMethodResults struct {
	s1 SigningMethod
}

// Expect sets up expected params for SignatureVerifier.GetDefaultSigningMethod
func (mmGetDefaultSigningMethod *mSignatureVerifierMockGetDefaultSigningMethod) Expect() *mSignatureVerifierMockGetDefaultSigningMethod {
	if mmGetDefaultSigningMethod.mock.funcGetDefaultSigningMethod != nil {
		mmGetDefaultSigningMethod.mock.t.Fatalf("SignatureVerifierMock.GetDefaultSigningMethod mock is already set by Set")
	}

	if mmGetDefaultSigningMethod.defaultExpectation == nil {
		mmGetDefaultSigningMethod.defaultExpectation = &SignatureVerifierMockGetDefaultSigningMethodExpectation{}
	}

	return mmGetDefaultSigningMethod
}

// Inspect accepts an inspector function that has same arguments as the SignatureVerifier.GetDefaultSigningMethod
func (mmGetDefaultSigningMethod *mSignatureVerifierMockGetDefaultSigningMethod) Inspect(f func()) *mSignatureVerifierMockGetDefaultSigningMethod {
	if mmGetDefaultSigningMethod.mock.inspectFuncGetDefaultSigningMethod != nil {
		mmGetDefaultSigningMethod.mock.t.Fatalf("Inspect function is already set for SignatureVerifierMock.GetDefaultSigningMethod")
	}

	mmGetDefaultSigningMethod.mock.inspectFuncGetDefaultSigningMethod = f

	return mmGetDefaultSigningMethod
}

// Return sets up results that will be returned by SignatureVerifier.GetDefaultSigningMethod
func (mmGetDefaultSigningMethod *mSignatureVerifierMockGetDefaultSigningMethod) Return(s1 SigningMethod) *SignatureVerifierMock {
	if mmGetDefaultSigningMethod.mock.funcGetDefaultSigningMethod != nil {
		mmGetDefaultSigningMethod.mock.t.Fatalf("SignatureVerifierMock.GetDefaultSigningMethod mock is already set by Set")
	}

	if mmGetDefaultSigningMethod.defaultExpectation == nil {
		mmGetDefaultSigningMethod.defaultExpectation = &SignatureVerifierMockGetDefaultSigningMethodExpectation{mock: mmGetDefaultSigningMethod.mock}
	}
	mmGetDefaultSigningMethod.defaultExpectation.results = &SignatureVerifierMockGetDefaultSigningMethodResults{s1}
	return mmGetDefaultSigningMethod.mock
}

//Set uses given function f to mock the SignatureVerifier.GetDefaultSigningMethod method
func (mmGetDefaultSigningMethod *mSignatureVerifierMockGetDefaultSigningMethod) Set(f func() (s1 SigningMethod)) *SignatureVerifierMock {
	if mmGetDefaultSigningMethod.defaultExpectation != nil {
		mmGetDefaultSigningMethod.mock.t.Fatalf("Default expectation is already set for the SignatureVerifier.GetDefaultSigningMethod method")
	}

	if len(mmGetDefaultSigningMethod.expectations) > 0 {
		mmGetDefaultSigningMethod.mock.t.Fatalf("Some expectations are already set for the SignatureVerifier.GetDefaultSigningMethod method")
	}

	mmGetDefaultSigningMethod.mock.funcGetDefaultSigningMethod = f
	return mmGetDefaultSigningMethod.mock
}

// GetDefaultSigningMethod implements SignatureVerifier
func (mmGetDefaultSigningMethod *SignatureVerifierMock) GetDefaultSigningMethod() (s1 SigningMethod) {
	mm_atomic.AddUint64(&mmGetDefaultSigningMethod.beforeGetDefaultSigningMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDefaultSigningMethod.afterGetDefaultSigningMethodCounter, 1)

	if mmGetDefaultSigningMethod.inspectFuncGetDefaultSigningMethod != nil {
		mmGetDefaultSigningMethod.inspectFuncGetDefaultSigningMethod()
	}

	if mmGetDefaultSigningMethod.GetDefaultSigningMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDefaultSigningMethod.GetDefaultSigningMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDefaultSigningMethod.GetDefaultSigningMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDefaultSigningMethod.t.Fatal("No results are set for the SignatureVerifierMock.GetDefaultSigningMethod")
		}
		return (*mm_results).s1
	}
	if mmGetDefaultSigningMethod.funcGetDefaultSigningMethod != nil {
		return mmGetDefaultSigningMethod.funcGetDefaultSigningMethod()
	}
	mmGetDefaultSigningMethod.t.Fatalf("Unexpected call to SignatureVerifierMock.GetDefaultSigningMethod.")
	return
}

// GetDefaultSigningMethodAfterCounter returns a count of finished SignatureVerifierMock.GetDefaultSigningMethod invocations
func (mmGetDefaultSigningMethod *SignatureVerifierMock) GetDefaultSigningMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDefaultSigningMethod.afterGetDefaultSigningMethodCounter)
}

// GetDefaultSigningMethodBeforeCounter returns a count of SignatureVerifierMock.GetDefaultSigningMethod invocations
func (mmGetDefaultSigningMethod *SignatureVerifierMock) GetDefaultSigningMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDefaultSigningMethod.beforeGetDefaultSigningMethodCounter)
}

// MinimockGetDefaultSigningMethodDone returns true if the count of the GetDefaultSigningMethod invocations corresponds
// the number of defined expectations
func (m *SignatureVerifierMock) MinimockGetDefaultSigningMethodDone() bool {
	for _, e := range m.GetDefaultSigningMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDefaultSigningMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDefaultSigningMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDefaultSigningMethod != nil && mm_atomic.LoadUint64(&m.afterGetDefaultSigningMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDefaultSigningMethodInspect logs each unmet expectation
func (m *SignatureVerifierMock) MinimockGetDefaultSigningMethodInspect() {
	for _, e := range m.GetDefaultSigningMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureVerifierMock.GetDefaultSigningMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDefaultSigningMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDefaultSigningMethodCounter) < 1 {
		m.t.Error("Expected call to SignatureVerifierMock.GetDefaultSigningMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDefaultSigningMethod != nil && mm_atomic.LoadUint64(&m.afterGetDefaultSigningMethodCounter) < 1 {
		m.t.Error("Expected call to SignatureVerifierMock.GetDefaultSigningMethod")
	}
}

type mSignatureVerifierMockIsDigestMethodSupported struct {
	mock               *SignatureVerifierMock
	defaultExpectation *SignatureVerifierMockIsDigestMethodSupportedExpectation
	expectations       []*SignatureVerifierMockIsDigestMethodSupportedExpectation

	callArgs []*SignatureVerifierMockIsDigestMethodSupportedParams
	mutex    sync.RWMutex
}

// SignatureVerifierMockIsDigestMethodSupportedExpectation specifies expectation struct of the SignatureVerifier.IsDigestMethodSupported
type SignatureVerifierMockIsDigestMethodSupportedExpectation struct {
	mock    *SignatureVerifierMock
	params  *SignatureVerifierMockIsDigestMethodSupportedParams
	results *SignatureVerifierMockIsDigestMethodSupportedResults
	Counter uint64
}

// SignatureVerifierMockIsDigestMethodSupportedParams contains parameters of the SignatureVerifier.IsDigestMethodSupported
type SignatureVerifierMockIsDigestMethodSupportedParams struct {
	m DigestMethod
}

// SignatureVerifierMockIsDigestMethodSupportedResults contains results of the SignatureVerifier.IsDigestMethodSupported
type SignatureVerifierMockIsDigestMethodSupportedResults struct {
	b1 bool
}

// Expect sets up expected params for SignatureVerifier.IsDigestMethodSupported
func (mmIsDigestMethodSupported *mSignatureVerifierMockIsDigestMethodSupported) Expect(m DigestMethod) *mSignatureVerifierMockIsDigestMethodSupported {
	if mmIsDigestMethodSupported.mock.funcIsDigestMethodSupported != nil {
		mmIsDigestMethodSupported.mock.t.Fatalf("SignatureVerifierMock.IsDigestMethodSupported mock is already set by Set")
	}

	if mmIsDigestMethodSupported.defaultExpectation == nil {
		mmIsDigestMethodSupported.defaultExpectation = &SignatureVerifierMockIsDigestMethodSupportedExpectation{}
	}

	mmIsDigestMethodSupported.defaultExpectation.params = &SignatureVerifierMockIsDigestMethodSupportedParams{m}
	for _, e := range mmIsDigestMethodSupported.expectations {
		if minimock.Equal(e.params, mmIsDigestMethodSupported.defaultExpectation.params) {
			mmIsDigestMethodSupported.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsDigestMethodSupported.defaultExpectation.params)
		}
	}

	return mmIsDigestMethodSupported
}

// Inspect accepts an inspector function that has same arguments as the SignatureVerifier.IsDigestMethodSupported
func (mmIsDigestMethodSupported *mSignatureVerifierMockIsDigestMethodSupported) Inspect(f func(m DigestMethod)) *mSignatureVerifierMockIsDigestMethodSupported {
	if mmIsDigestMethodSupported.mock.inspectFuncIsDigestMethodSupported != nil {
		mmIsDigestMethodSupported.mock.t.Fatalf("Inspect function is already set for SignatureVerifierMock.IsDigestMethodSupported")
	}

	mmIsDigestMethodSupported.mock.inspectFuncIsDigestMethodSupported = f

	return mmIsDigestMethodSupported
}

// Return sets up results that will be returned by SignatureVerifier.IsDigestMethodSupported
func (mmIsDigestMethodSupported *mSignatureVerifierMockIsDigestMethodSupported) Return(b1 bool) *SignatureVerifierMock {
	if mmIsDigestMethodSupported.mock.funcIsDigestMethodSupported != nil {
		mmIsDigestMethodSupported.mock.t.Fatalf("SignatureVerifierMock.IsDigestMethodSupported mock is already set by Set")
	}

	if mmIsDigestMethodSupported.defaultExpectation == nil {
		mmIsDigestMethodSupported.defaultExpectation = &SignatureVerifierMockIsDigestMethodSupportedExpectation{mock: mmIsDigestMethodSupported.mock}
	}
	mmIsDigestMethodSupported.defaultExpectation.results = &SignatureVerifierMockIsDigestMethodSupportedResults{b1}
	return mmIsDigestMethodSupported.mock
}

//Set uses given function f to mock the SignatureVerifier.IsDigestMethodSupported method
func (mmIsDigestMethodSupported *mSignatureVerifierMockIsDigestMethodSupported) Set(f func(m DigestMethod) (b1 bool)) *SignatureVerifierMock {
	if mmIsDigestMethodSupported.defaultExpectation != nil {
		mmIsDigestMethodSupported.mock.t.Fatalf("Default expectation is already set for the SignatureVerifier.IsDigestMethodSupported method")
	}

	if len(mmIsDigestMethodSupported.expectations) > 0 {
		mmIsDigestMethodSupported.mock.t.Fatalf("Some expectations are already set for the SignatureVerifier.IsDigestMethodSupported method")
	}

	mmIsDigestMethodSupported.mock.funcIsDigestMethodSupported = f
	return mmIsDigestMethodSupported.mock
}

// When sets expectation for the SignatureVerifier.IsDigestMethodSupported which will trigger the result defined by the following
// Then helper
func (mmIsDigestMethodSupported *mSignatureVerifierMockIsDigestMethodSupported) When(m DigestMethod) *SignatureVerifierMockIsDigestMethodSupportedExpectation {
	if mmIsDigestMethodSupported.mock.funcIsDigestMethodSupported != nil {
		mmIsDigestMethodSupported.mock.t.Fatalf("SignatureVerifierMock.IsDigestMethodSupported mock is already set by Set")
	}

	expectation := &SignatureVerifierMockIsDigestMethodSupportedExpectation{
		mock:   mmIsDigestMethodSupported.mock,
		params: &SignatureVerifierMockIsDigestMethodSupportedParams{m},
	}
	mmIsDigestMethodSupported.expectations = append(mmIsDigestMethodSupported.expectations, expectation)
	return expectation
}

// Then sets up SignatureVerifier.IsDigestMethodSupported return parameters for the expectation previously defined by the When method
func (e *SignatureVerifierMockIsDigestMethodSupportedExpectation) Then(b1 bool) *SignatureVerifierMock {
	e.results = &SignatureVerifierMockIsDigestMethodSupportedResults{b1}
	return e.mock
}

// IsDigestMethodSupported implements SignatureVerifier
func (mmIsDigestMethodSupported *SignatureVerifierMock) IsDigestMethodSupported(m DigestMethod) (b1 bool) {
	mm_atomic.AddUint64(&mmIsDigestMethodSupported.beforeIsDigestMethodSupportedCounter, 1)
	defer mm_atomic.AddUint64(&mmIsDigestMethodSupported.afterIsDigestMethodSupportedCounter, 1)

	if mmIsDigestMethodSupported.inspectFuncIsDigestMethodSupported != nil {
		mmIsDigestMethodSupported.inspectFuncIsDigestMethodSupported(m)
	}

	mm_params := &SignatureVerifierMockIsDigestMethodSupportedParams{m}

	// Record call args
	mmIsDigestMethodSupported.IsDigestMethodSupportedMock.mutex.Lock()
	mmIsDigestMethodSupported.IsDigestMethodSupportedMock.callArgs = append(mmIsDigestMethodSupported.IsDigestMethodSupportedMock.callArgs, mm_params)
	mmIsDigestMethodSupported.IsDigestMethodSupportedMock.mutex.Unlock()

	for _, e := range mmIsDigestMethodSupported.IsDigestMethodSupportedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsDigestMethodSupported.IsDigestMethodSupportedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsDigestMethodSupported.IsDigestMethodSupportedMock.defaultExpectation.Counter, 1)
		mm_want := mmIsDigestMethodSupported.IsDigestMethodSupportedMock.defaultExpectation.params
		mm_got := SignatureVerifierMockIsDigestMethodSupportedParams{m}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsDigestMethodSupported.t.Errorf("SignatureVerifierMock.IsDigestMethodSupported got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsDigestMethodSupported.IsDigestMethodSupportedMock.defaultExpectation.results
		if mm_results == nil {
			mmIsDigestMethodSupported.t.Fatal("No results are set for the SignatureVerifierMock.IsDigestMethodSupported")
		}
		return (*mm_results).b1
	}
	if mmIsDigestMethodSupported.funcIsDigestMethodSupported != nil {
		return mmIsDigestMethodSupported.funcIsDigestMethodSupported(m)
	}
	mmIsDigestMethodSupported.t.Fatalf("Unexpected call to SignatureVerifierMock.IsDigestMethodSupported. %v", m)
	return
}

// IsDigestMethodSupportedAfterCounter returns a count of finished SignatureVerifierMock.IsDigestMethodSupported invocations
func (mmIsDigestMethodSupported *SignatureVerifierMock) IsDigestMethodSupportedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsDigestMethodSupported.afterIsDigestMethodSupportedCounter)
}

// IsDigestMethodSupportedBeforeCounter returns a count of SignatureVerifierMock.IsDigestMethodSupported invocations
func (mmIsDigestMethodSupported *SignatureVerifierMock) IsDigestMethodSupportedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsDigestMethodSupported.beforeIsDigestMethodSupportedCounter)
}

// Calls returns a list of arguments used in each call to SignatureVerifierMock.IsDigestMethodSupported.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsDigestMethodSupported *mSignatureVerifierMockIsDigestMethodSupported) Calls() []*SignatureVerifierMockIsDigestMethodSupportedParams {
	mmIsDigestMethodSupported.mutex.RLock()

	argCopy := make([]*SignatureVerifierMockIsDigestMethodSupportedParams, len(mmIsDigestMethodSupported.callArgs))
	copy(argCopy, mmIsDigestMethodSupported.callArgs)

	mmIsDigestMethodSupported.mutex.RUnlock()

	return argCopy
}

// MinimockIsDigestMethodSupportedDone returns true if the count of the IsDigestMethodSupported invocations corresponds
// the number of defined expectations
func (m *SignatureVerifierMock) MinimockIsDigestMethodSupportedDone() bool {
	for _, e := range m.IsDigestMethodSupportedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsDigestMethodSupportedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsDigestMethodSupportedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsDigestMethodSupported != nil && mm_atomic.LoadUint64(&m.afterIsDigestMethodSupportedCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsDigestMethodSupportedInspect logs each unmet expectation
func (m *SignatureVerifierMock) MinimockIsDigestMethodSupportedInspect() {
	for _, e := range m.IsDigestMethodSupportedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SignatureVerifierMock.IsDigestMethodSupported with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsDigestMethodSupportedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsDigestMethodSupportedCounter) < 1 {
		if m.IsDigestMethodSupportedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SignatureVerifierMock.IsDigestMethodSupported")
		} else {
			m.t.Errorf("Expected call to SignatureVerifierMock.IsDigestMethodSupported with params: %#v", *m.IsDigestMethodSupportedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsDigestMethodSupported != nil && mm_atomic.LoadUint64(&m.afterIsDigestMethodSupportedCounter) < 1 {
		m.t.Error("Expected call to SignatureVerifierMock.IsDigestMethodSupported")
	}
}

type mSignatureVerifierMockIsSigningMethodSupported struct {
	mock               *SignatureVerifierMock
	defaultExpectation *SignatureVerifierMockIsSigningMethodSupportedExpectation
	expectations       []*SignatureVerifierMockIsSigningMethodSupportedExpectation

	callArgs []*SignatureVerifierMockIsSigningMethodSupportedParams
	mutex    sync.RWMutex
}

// SignatureVerifierMockIsSigningMethodSupportedExpectation specifies expectation struct of the SignatureVerifier.IsSigningMethodSupported
type SignatureVerifierMockIsSigningMethodSupportedExpectation struct {
	mock    *SignatureVerifierMock
	params  *SignatureVerifierMockIsSigningMethodSupportedParams
	results *SignatureVerifierMockIsSigningMethodSupportedResults
	Counter uint64
}

// SignatureVerifierMockIsSigningMethodSupportedParams contains parameters of the SignatureVerifier.IsSigningMethodSupported
type SignatureVerifierMockIsSigningMethodSupportedParams struct {
	m SigningMethod
}

// SignatureVerifierMockIsSigningMethodSupportedResults contains results of the SignatureVerifier.IsSigningMethodSupported
type SignatureVerifierMockIsSigningMethodSupportedResults struct {
	b1 bool
}

// Expect sets up expected params for SignatureVerifier.IsSigningMethodSupported
func (mmIsSigningMethodSupported *mSignatureVerifierMockIsSigningMethodSupported) Expect(m SigningMethod) *mSignatureVerifierMockIsSigningMethodSupported {
	if mmIsSigningMethodSupported.mock.funcIsSigningMethodSupported != nil {
		mmIsSigningMethodSupported.mock.t.Fatalf("SignatureVerifierMock.IsSigningMethodSupported mock is already set by Set")
	}

	if mmIsSigningMethodSupported.defaultExpectation == nil {
		mmIsSigningMethodSupported.defaultExpectation = &SignatureVerifierMockIsSigningMethodSupportedExpectation{}
	}

	mmIsSigningMethodSupported.defaultExpectation.params = &SignatureVerifierMockIsSigningMethodSupportedParams{m}
	for _, e := range mmIsSigningMethodSupported.expectations {
		if minimock.Equal(e.params, mmIsSigningMethodSupported.defaultExpectation.params) {
			mmIsSigningMethodSupported.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsSigningMethodSupported.defaultExpectation.params)
		}
	}

	return mmIsSigningMethodSupported
}

// Inspect accepts an inspector function that has same arguments as the SignatureVerifier.IsSigningMethodSupported
func (mmIsSigningMethodSupported *mSignatureVerifierMockIsSigningMethodSupported) Inspect(f func(m SigningMethod)) *mSignatureVerifierMockIsSigningMethodSupported {
	if mmIsSigningMethodSupported.mock.inspectFuncIsSigningMethodSupported != nil {
		mmIsSigningMethodSupported.mock.t.Fatalf("Inspect function is already set for SignatureVerifierMock.IsSigningMethodSupported")
	}

	mmIsSigningMethodSupported.mock.inspectFuncIsSigningMethodSupported = f

	return mmIsSigningMethodSupported
}

// Return sets up results that will be returned by SignatureVerifier.IsSigningMethodSupported
func (mmIsSigningMethodSupported *mSignatureVerifierMockIsSigningMethodSupported) Return(b1 bool) *SignatureVerifierMock {
	if mmIsSigningMethodSupported.mock.funcIsSigningMethodSupported != nil {
		mmIsSigningMethodSupported.mock.t.Fatalf("SignatureVerifierMock.IsSigningMethodSupported mock is already set by Set")
	}

	if mmIsSigningMethodSupported.defaultExpectation == nil {
		mmIsSigningMethodSupported.defaultExpectation = &SignatureVerifierMockIsSigningMethodSupportedExpectation{mock: mmIsSigningMethodSupported.mock}
	}
	mmIsSigningMethodSupported.defaultExpectation.results = &SignatureVerifierMockIsSigningMethodSupportedResults{b1}
	return mmIsSigningMethodSupported.mock
}

//Set uses given function f to mock the SignatureVerifier.IsSigningMethodSupported method
func (mmIsSigningMethodSupported *mSignatureVerifierMockIsSigningMethodSupported) Set(f func(m SigningMethod) (b1 bool)) *SignatureVerifierMock {
	if mmIsSigningMethodSupported.defaultExpectation != nil {
		mmIsSigningMethodSupported.mock.t.Fatalf("Default expectation is already set for the SignatureVerifier.IsSigningMethodSupported method")
	}

	if len(mmIsSigningMethodSupported.expectations) > 0 {
		mmIsSigningMethodSupported.mock.t.Fatalf("Some expectations are already set for the SignatureVerifier.IsSigningMethodSupported method")
	}

	mmIsSigningMethodSupported.mock.funcIsSigningMethodSupported = f
	return mmIsSigningMethodSupported.mock
}

// When sets expectation for the SignatureVerifier.IsSigningMethodSupported which will trigger the result defined by the following
// Then helper
func (mmIsSigningMethodSupported *mSignatureVerifierMockIsSigningMethodSupported) When(m SigningMethod) *SignatureVerifierMockIsSigningMethodSupportedExpectation {
	if mmIsSigningMethodSupported.mock.funcIsSigningMethodSupported != nil {
		mmIsSigningMethodSupported.mock.t.Fatalf("SignatureVerifierMock.IsSigningMethodSupported mock is already set by Set")
	}

	expectation := &SignatureVerifierMockIsSigningMethodSupportedExpectation{
		mock:   mmIsSigningMethodSupported.mock,
		params: &SignatureVerifierMockIsSigningMethodSupportedParams{m},
	}
	mmIsSigningMethodSupported.expectations = append(mmIsSigningMethodSupported.expectations, expectation)
	return expectation
}

// Then sets up SignatureVerifier.IsSigningMethodSupported return parameters for the expectation previously defined by the When method
func (e *SignatureVerifierMockIsSigningMethodSupportedExpectation) Then(b1 bool) *SignatureVerifierMock {
	e.results = &SignatureVerifierMockIsSigningMethodSupportedResults{b1}
	return e.mock
}

// IsSigningMethodSupported implements SignatureVerifier
func (mmIsSigningMethodSupported *SignatureVerifierMock) IsSigningMethodSupported(m SigningMethod) (b1 bool) {
	mm_atomic.AddUint64(&mmIsSigningMethodSupported.beforeIsSigningMethodSupportedCounter, 1)
	defer mm_atomic.AddUint64(&mmIsSigningMethodSupported.afterIsSigningMethodSupportedCounter, 1)

	if mmIsSigningMethodSupported.inspectFuncIsSigningMethodSupported != nil {
		mmIsSigningMethodSupported.inspectFuncIsSigningMethodSupported(m)
	}

	mm_params := &SignatureVerifierMockIsSigningMethodSupportedParams{m}

	// Record call args
	mmIsSigningMethodSupported.IsSigningMethodSupportedMock.mutex.Lock()
	mmIsSigningMethodSupported.IsSigningMethodSupportedMock.callArgs = append(mmIsSigningMethodSupported.IsSigningMethodSupportedMock.callArgs, mm_params)
	mmIsSigningMethodSupported.IsSigningMethodSupportedMock.mutex.Unlock()

	for _, e := range mmIsSigningMethodSupported.IsSigningMethodSupportedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsSigningMethodSupported.IsSigningMethodSupportedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsSigningMethodSupported.IsSigningMethodSupportedMock.defaultExpectation.Counter, 1)
		mm_want := mmIsSigningMethodSupported.IsSigningMethodSupportedMock.defaultExpectation.params
		mm_got := SignatureVerifierMockIsSigningMethodSupportedParams{m}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsSigningMethodSupported.t.Errorf("SignatureVerifierMock.IsSigningMethodSupported got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsSigningMethodSupported.IsSigningMethodSupportedMock.defaultExpectation.results
		if mm_results == nil {
			mmIsSigningMethodSupported.t.Fatal("No results are set for the SignatureVerifierMock.IsSigningMethodSupported")
		}
		return (*mm_results).b1
	}
	if mmIsSigningMethodSupported.funcIsSigningMethodSupported != nil {
		return mmIsSigningMethodSupported.funcIsSigningMethodSupported(m)
	}
	mmIsSigningMethodSupported.t.Fatalf("Unexpected call to SignatureVerifierMock.IsSigningMethodSupported. %v", m)
	return
}

// IsSigningMethodSupportedAfterCounter returns a count of finished SignatureVerifierMock.IsSigningMethodSupported invocations
func (mmIsSigningMethodSupported *SignatureVerifierMock) IsSigningMethodSupportedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsSigningMethodSupported.afterIsSigningMethodSupportedCounter)
}

// IsSigningMethodSupportedBeforeCounter returns a count of SignatureVerifierMock.IsSigningMethodSupported invocations
func (mmIsSigningMethodSupported *SignatureVerifierMock) IsSigningMethodSupportedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsSigningMethodSupported.beforeIsSigningMethodSupportedCounter)
}

// Calls returns a list of arguments used in each call to SignatureVerifierMock.IsSigningMethodSupported.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsSigningMethodSupported *mSignatureVerifierMockIsSigningMethodSupported) Calls() []*SignatureVerifierMockIsSigningMethodSupportedParams {
	mmIsSigningMethodSupported.mutex.RLock()

	argCopy := make([]*SignatureVerifierMockIsSigningMethodSupportedParams, len(mmIsSigningMethodSupported.callArgs))
	copy(argCopy, mmIsSigningMethodSupported.callArgs)

	mmIsSigningMethodSupported.mutex.RUnlock()

	return argCopy
}

// MinimockIsSigningMethodSupportedDone returns true if the count of the IsSigningMethodSupported invocations corresponds
// the number of defined expectations
func (m *SignatureVerifierMock) MinimockIsSigningMethodSupportedDone() bool {
	for _, e := range m.IsSigningMethodSupportedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsSigningMethodSupportedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsSigningMethodSupportedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsSigningMethodSupported != nil && mm_atomic.LoadUint64(&m.afterIsSigningMethodSupportedCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsSigningMethodSupportedInspect logs each unmet expectation
func (m *SignatureVerifierMock) MinimockIsSigningMethodSupportedInspect() {
	for _, e := range m.IsSigningMethodSupportedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SignatureVerifierMock.IsSigningMethodSupported with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsSigningMethodSupportedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsSigningMethodSupportedCounter) < 1 {
		if m.IsSigningMethodSupportedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SignatureVerifierMock.IsSigningMethodSupported")
		} else {
			m.t.Errorf("Expected call to SignatureVerifierMock.IsSigningMethodSupported with params: %#v", *m.IsSigningMethodSupportedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsSigningMethodSupported != nil && mm_atomic.LoadUint64(&m.afterIsSigningMethodSupportedCounter) < 1 {
		m.t.Error("Expected call to SignatureVerifierMock.IsSigningMethodSupported")
	}
}

type mSignatureVerifierMockIsValidDataSignature struct {
	mock               *SignatureVerifierMock
	defaultExpectation *SignatureVerifierMockIsValidDataSignatureExpectation
	expectations       []*SignatureVerifierMockIsValidDataSignatureExpectation

	callArgs []*SignatureVerifierMockIsValidDataSignatureParams
	mutex    sync.RWMutex
}

// SignatureVerifierMockIsValidDataSignatureExpectation specifies expectation struct of the SignatureVerifier.IsValidDataSignature
type SignatureVerifierMockIsValidDataSignatureExpectation struct {
	mock    *SignatureVerifierMock
	params  *SignatureVerifierMockIsValidDataSignatureParams
	results *SignatureVerifierMockIsValidDataSignatureResults
	Counter uint64
}

// SignatureVerifierMockIsValidDataSignatureParams contains parameters of the SignatureVerifier.IsValidDataSignature
type SignatureVerifierMockIsValidDataSignatureParams struct {
	data      io.Reader
	signature SignatureHolder
}

// SignatureVerifierMockIsValidDataSignatureResults contains results of the SignatureVerifier.IsValidDataSignature
type SignatureVerifierMockIsValidDataSignatureResults struct {
	b1 bool
}

// Expect sets up expected params for SignatureVerifier.IsValidDataSignature
func (mmIsValidDataSignature *mSignatureVerifierMockIsValidDataSignature) Expect(data io.Reader, signature SignatureHolder) *mSignatureVerifierMockIsValidDataSignature {
	if mmIsValidDataSignature.mock.funcIsValidDataSignature != nil {
		mmIsValidDataSignature.mock.t.Fatalf("SignatureVerifierMock.IsValidDataSignature mock is already set by Set")
	}

	if mmIsValidDataSignature.defaultExpectation == nil {
		mmIsValidDataSignature.defaultExpectation = &SignatureVerifierMockIsValidDataSignatureExpectation{}
	}

	mmIsValidDataSignature.defaultExpectation.params = &SignatureVerifierMockIsValidDataSignatureParams{data, signature}
	for _, e := range mmIsValidDataSignature.expectations {
		if minimock.Equal(e.params, mmIsValidDataSignature.defaultExpectation.params) {
			mmIsValidDataSignature.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsValidDataSignature.defaultExpectation.params)
		}
	}

	return mmIsValidDataSignature
}

// Inspect accepts an inspector function that has same arguments as the SignatureVerifier.IsValidDataSignature
func (mmIsValidDataSignature *mSignatureVerifierMockIsValidDataSignature) Inspect(f func(data io.Reader, signature SignatureHolder)) *mSignatureVerifierMockIsValidDataSignature {
	if mmIsValidDataSignature.mock.inspectFuncIsValidDataSignature != nil {
		mmIsValidDataSignature.mock.t.Fatalf("Inspect function is already set for SignatureVerifierMock.IsValidDataSignature")
	}

	mmIsValidDataSignature.mock.inspectFuncIsValidDataSignature = f

	return mmIsValidDataSignature
}

// Return sets up results that will be returned by SignatureVerifier.IsValidDataSignature
func (mmIsValidDataSignature *mSignatureVerifierMockIsValidDataSignature) Return(b1 bool) *SignatureVerifierMock {
	if mmIsValidDataSignature.mock.funcIsValidDataSignature != nil {
		mmIsValidDataSignature.mock.t.Fatalf("SignatureVerifierMock.IsValidDataSignature mock is already set by Set")
	}

	if mmIsValidDataSignature.defaultExpectation == nil {
		mmIsValidDataSignature.defaultExpectation = &SignatureVerifierMockIsValidDataSignatureExpectation{mock: mmIsValidDataSignature.mock}
	}
	mmIsValidDataSignature.defaultExpectation.results = &SignatureVerifierMockIsValidDataSignatureResults{b1}
	return mmIsValidDataSignature.mock
}

//Set uses given function f to mock the SignatureVerifier.IsValidDataSignature method
func (mmIsValidDataSignature *mSignatureVerifierMockIsValidDataSignature) Set(f func(data io.Reader, signature SignatureHolder) (b1 bool)) *SignatureVerifierMock {
	if mmIsValidDataSignature.defaultExpectation != nil {
		mmIsValidDataSignature.mock.t.Fatalf("Default expectation is already set for the SignatureVerifier.IsValidDataSignature method")
	}

	if len(mmIsValidDataSignature.expectations) > 0 {
		mmIsValidDataSignature.mock.t.Fatalf("Some expectations are already set for the SignatureVerifier.IsValidDataSignature method")
	}

	mmIsValidDataSignature.mock.funcIsValidDataSignature = f
	return mmIsValidDataSignature.mock
}

// When sets expectation for the SignatureVerifier.IsValidDataSignature which will trigger the result defined by the following
// Then helper
func (mmIsValidDataSignature *mSignatureVerifierMockIsValidDataSignature) When(data io.Reader, signature SignatureHolder) *SignatureVerifierMockIsValidDataSignatureExpectation {
	if mmIsValidDataSignature.mock.funcIsValidDataSignature != nil {
		mmIsValidDataSignature.mock.t.Fatalf("SignatureVerifierMock.IsValidDataSignature mock is already set by Set")
	}

	expectation := &SignatureVerifierMockIsValidDataSignatureExpectation{
		mock:   mmIsValidDataSignature.mock,
		params: &SignatureVerifierMockIsValidDataSignatureParams{data, signature},
	}
	mmIsValidDataSignature.expectations = append(mmIsValidDataSignature.expectations, expectation)
	return expectation
}

// Then sets up SignatureVerifier.IsValidDataSignature return parameters for the expectation previously defined by the When method
func (e *SignatureVerifierMockIsValidDataSignatureExpectation) Then(b1 bool) *SignatureVerifierMock {
	e.results = &SignatureVerifierMockIsValidDataSignatureResults{b1}
	return e.mock
}

// IsValidDataSignature implements SignatureVerifier
func (mmIsValidDataSignature *SignatureVerifierMock) IsValidDataSignature(data io.Reader, signature SignatureHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmIsValidDataSignature.beforeIsValidDataSignatureCounter, 1)
	defer mm_atomic.AddUint64(&mmIsValidDataSignature.afterIsValidDataSignatureCounter, 1)

	if mmIsValidDataSignature.inspectFuncIsValidDataSignature != nil {
		mmIsValidDataSignature.inspectFuncIsValidDataSignature(data, signature)
	}

	mm_params := &SignatureVerifierMockIsValidDataSignatureParams{data, signature}

	// Record call args
	mmIsValidDataSignature.IsValidDataSignatureMock.mutex.Lock()
	mmIsValidDataSignature.IsValidDataSignatureMock.callArgs = append(mmIsValidDataSignature.IsValidDataSignatureMock.callArgs, mm_params)
	mmIsValidDataSignature.IsValidDataSignatureMock.mutex.Unlock()

	for _, e := range mmIsValidDataSignature.IsValidDataSignatureMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsValidDataSignature.IsValidDataSignatureMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsValidDataSignature.IsValidDataSignatureMock.defaultExpectation.Counter, 1)
		mm_want := mmIsValidDataSignature.IsValidDataSignatureMock.defaultExpectation.params
		mm_got := SignatureVerifierMockIsValidDataSignatureParams{data, signature}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsValidDataSignature.t.Errorf("SignatureVerifierMock.IsValidDataSignature got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsValidDataSignature.IsValidDataSignatureMock.defaultExpectation.results
		if mm_results == nil {
			mmIsValidDataSignature.t.Fatal("No results are set for the SignatureVerifierMock.IsValidDataSignature")
		}
		return (*mm_results).b1
	}
	if mmIsValidDataSignature.funcIsValidDataSignature != nil {
		return mmIsValidDataSignature.funcIsValidDataSignature(data, signature)
	}
	mmIsValidDataSignature.t.Fatalf("Unexpected call to SignatureVerifierMock.IsValidDataSignature. %v %v", data, signature)
	return
}

// IsValidDataSignatureAfterCounter returns a count of finished SignatureVerifierMock.IsValidDataSignature invocations
func (mmIsValidDataSignature *SignatureVerifierMock) IsValidDataSignatureAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsValidDataSignature.afterIsValidDataSignatureCounter)
}

// IsValidDataSignatureBeforeCounter returns a count of SignatureVerifierMock.IsValidDataSignature invocations
func (mmIsValidDataSignature *SignatureVerifierMock) IsValidDataSignatureBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsValidDataSignature.beforeIsValidDataSignatureCounter)
}

// Calls returns a list of arguments used in each call to SignatureVerifierMock.IsValidDataSignature.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsValidDataSignature *mSignatureVerifierMockIsValidDataSignature) Calls() []*SignatureVerifierMockIsValidDataSignatureParams {
	mmIsValidDataSignature.mutex.RLock()

	argCopy := make([]*SignatureVerifierMockIsValidDataSignatureParams, len(mmIsValidDataSignature.callArgs))
	copy(argCopy, mmIsValidDataSignature.callArgs)

	mmIsValidDataSignature.mutex.RUnlock()

	return argCopy
}

// MinimockIsValidDataSignatureDone returns true if the count of the IsValidDataSignature invocations corresponds
// the number of defined expectations
func (m *SignatureVerifierMock) MinimockIsValidDataSignatureDone() bool {
	for _, e := range m.IsValidDataSignatureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsValidDataSignatureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsValidDataSignatureCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsValidDataSignature != nil && mm_atomic.LoadUint64(&m.afterIsValidDataSignatureCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsValidDataSignatureInspect logs each unmet expectation
func (m *SignatureVerifierMock) MinimockIsValidDataSignatureInspect() {
	for _, e := range m.IsValidDataSignatureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SignatureVerifierMock.IsValidDataSignature with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsValidDataSignatureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsValidDataSignatureCounter) < 1 {
		if m.IsValidDataSignatureMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SignatureVerifierMock.IsValidDataSignature")
		} else {
			m.t.Errorf("Expected call to SignatureVerifierMock.IsValidDataSignature with params: %#v", *m.IsValidDataSignatureMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsValidDataSignature != nil && mm_atomic.LoadUint64(&m.afterIsValidDataSignatureCounter) < 1 {
		m.t.Error("Expected call to SignatureVerifierMock.IsValidDataSignature")
	}
}

type mSignatureVerifierMockIsValidDigestSignature struct {
	mock               *SignatureVerifierMock
	defaultExpectation *SignatureVerifierMockIsValidDigestSignatureExpectation
	expectations       []*SignatureVerifierMockIsValidDigestSignatureExpectation

	callArgs []*SignatureVerifierMockIsValidDigestSignatureParams
	mutex    sync.RWMutex
}

// SignatureVerifierMockIsValidDigestSignatureExpectation specifies expectation struct of the SignatureVerifier.IsValidDigestSignature
type SignatureVerifierMockIsValidDigestSignatureExpectation struct {
	mock    *SignatureVerifierMock
	params  *SignatureVerifierMockIsValidDigestSignatureParams
	results *SignatureVerifierMockIsValidDigestSignatureResults
	Counter uint64
}

// SignatureVerifierMockIsValidDigestSignatureParams contains parameters of the SignatureVerifier.IsValidDigestSignature
type SignatureVerifierMockIsValidDigestSignatureParams struct {
	digest    DigestHolder
	signature SignatureHolder
}

// SignatureVerifierMockIsValidDigestSignatureResults contains results of the SignatureVerifier.IsValidDigestSignature
type SignatureVerifierMockIsValidDigestSignatureResults struct {
	b1 bool
}

// Expect sets up expected params for SignatureVerifier.IsValidDigestSignature
func (mmIsValidDigestSignature *mSignatureVerifierMockIsValidDigestSignature) Expect(digest DigestHolder, signature SignatureHolder) *mSignatureVerifierMockIsValidDigestSignature {
	if mmIsValidDigestSignature.mock.funcIsValidDigestSignature != nil {
		mmIsValidDigestSignature.mock.t.Fatalf("SignatureVerifierMock.IsValidDigestSignature mock is already set by Set")
	}

	if mmIsValidDigestSignature.defaultExpectation == nil {
		mmIsValidDigestSignature.defaultExpectation = &SignatureVerifierMockIsValidDigestSignatureExpectation{}
	}

	mmIsValidDigestSignature.defaultExpectation.params = &SignatureVerifierMockIsValidDigestSignatureParams{digest, signature}
	for _, e := range mmIsValidDigestSignature.expectations {
		if minimock.Equal(e.params, mmIsValidDigestSignature.defaultExpectation.params) {
			mmIsValidDigestSignature.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsValidDigestSignature.defaultExpectation.params)
		}
	}

	return mmIsValidDigestSignature
}

// Inspect accepts an inspector function that has same arguments as the SignatureVerifier.IsValidDigestSignature
func (mmIsValidDigestSignature *mSignatureVerifierMockIsValidDigestSignature) Inspect(f func(digest DigestHolder, signature SignatureHolder)) *mSignatureVerifierMockIsValidDigestSignature {
	if mmIsValidDigestSignature.mock.inspectFuncIsValidDigestSignature != nil {
		mmIsValidDigestSignature.mock.t.Fatalf("Inspect function is already set for SignatureVerifierMock.IsValidDigestSignature")
	}

	mmIsValidDigestSignature.mock.inspectFuncIsValidDigestSignature = f

	return mmIsValidDigestSignature
}

// Return sets up results that will be returned by SignatureVerifier.IsValidDigestSignature
func (mmIsValidDigestSignature *mSignatureVerifierMockIsValidDigestSignature) Return(b1 bool) *SignatureVerifierMock {
	if mmIsValidDigestSignature.mock.funcIsValidDigestSignature != nil {
		mmIsValidDigestSignature.mock.t.Fatalf("SignatureVerifierMock.IsValidDigestSignature mock is already set by Set")
	}

	if mmIsValidDigestSignature.defaultExpectation == nil {
		mmIsValidDigestSignature.defaultExpectation = &SignatureVerifierMockIsValidDigestSignatureExpectation{mock: mmIsValidDigestSignature.mock}
	}
	mmIsValidDigestSignature.defaultExpectation.results = &SignatureVerifierMockIsValidDigestSignatureResults{b1}
	return mmIsValidDigestSignature.mock
}

//Set uses given function f to mock the SignatureVerifier.IsValidDigestSignature method
func (mmIsValidDigestSignature *mSignatureVerifierMockIsValidDigestSignature) Set(f func(digest DigestHolder, signature SignatureHolder) (b1 bool)) *SignatureVerifierMock {
	if mmIsValidDigestSignature.defaultExpectation != nil {
		mmIsValidDigestSignature.mock.t.Fatalf("Default expectation is already set for the SignatureVerifier.IsValidDigestSignature method")
	}

	if len(mmIsValidDigestSignature.expectations) > 0 {
		mmIsValidDigestSignature.mock.t.Fatalf("Some expectations are already set for the SignatureVerifier.IsValidDigestSignature method")
	}

	mmIsValidDigestSignature.mock.funcIsValidDigestSignature = f
	return mmIsValidDigestSignature.mock
}

// When sets expectation for the SignatureVerifier.IsValidDigestSignature which will trigger the result defined by the following
// Then helper
func (mmIsValidDigestSignature *mSignatureVerifierMockIsValidDigestSignature) When(digest DigestHolder, signature SignatureHolder) *SignatureVerifierMockIsValidDigestSignatureExpectation {
	if mmIsValidDigestSignature.mock.funcIsValidDigestSignature != nil {
		mmIsValidDigestSignature.mock.t.Fatalf("SignatureVerifierMock.IsValidDigestSignature mock is already set by Set")
	}

	expectation := &SignatureVerifierMockIsValidDigestSignatureExpectation{
		mock:   mmIsValidDigestSignature.mock,
		params: &SignatureVerifierMockIsValidDigestSignatureParams{digest, signature},
	}
	mmIsValidDigestSignature.expectations = append(mmIsValidDigestSignature.expectations, expectation)
	return expectation
}

// Then sets up SignatureVerifier.IsValidDigestSignature return parameters for the expectation previously defined by the When method
func (e *SignatureVerifierMockIsValidDigestSignatureExpectation) Then(b1 bool) *SignatureVerifierMock {
	e.results = &SignatureVerifierMockIsValidDigestSignatureResults{b1}
	return e.mock
}

// IsValidDigestSignature implements SignatureVerifier
func (mmIsValidDigestSignature *SignatureVerifierMock) IsValidDigestSignature(digest DigestHolder, signature SignatureHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmIsValidDigestSignature.beforeIsValidDigestSignatureCounter, 1)
	defer mm_atomic.AddUint64(&mmIsValidDigestSignature.afterIsValidDigestSignatureCounter, 1)

	if mmIsValidDigestSignature.inspectFuncIsValidDigestSignature != nil {
		mmIsValidDigestSignature.inspectFuncIsValidDigestSignature(digest, signature)
	}

	mm_params := &SignatureVerifierMockIsValidDigestSignatureParams{digest, signature}

	// Record call args
	mmIsValidDigestSignature.IsValidDigestSignatureMock.mutex.Lock()
	mmIsValidDigestSignature.IsValidDigestSignatureMock.callArgs = append(mmIsValidDigestSignature.IsValidDigestSignatureMock.callArgs, mm_params)
	mmIsValidDigestSignature.IsValidDigestSignatureMock.mutex.Unlock()

	for _, e := range mmIsValidDigestSignature.IsValidDigestSignatureMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsValidDigestSignature.IsValidDigestSignatureMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsValidDigestSignature.IsValidDigestSignatureMock.defaultExpectation.Counter, 1)
		mm_want := mmIsValidDigestSignature.IsValidDigestSignatureMock.defaultExpectation.params
		mm_got := SignatureVerifierMockIsValidDigestSignatureParams{digest, signature}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsValidDigestSignature.t.Errorf("SignatureVerifierMock.IsValidDigestSignature got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsValidDigestSignature.IsValidDigestSignatureMock.defaultExpectation.results
		if mm_results == nil {
			mmIsValidDigestSignature.t.Fatal("No results are set for the SignatureVerifierMock.IsValidDigestSignature")
		}
		return (*mm_results).b1
	}
	if mmIsValidDigestSignature.funcIsValidDigestSignature != nil {
		return mmIsValidDigestSignature.funcIsValidDigestSignature(digest, signature)
	}
	mmIsValidDigestSignature.t.Fatalf("Unexpected call to SignatureVerifierMock.IsValidDigestSignature. %v %v", digest, signature)
	return
}

// IsValidDigestSignatureAfterCounter returns a count of finished SignatureVerifierMock.IsValidDigestSignature invocations
func (mmIsValidDigestSignature *SignatureVerifierMock) IsValidDigestSignatureAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsValidDigestSignature.afterIsValidDigestSignatureCounter)
}

// IsValidDigestSignatureBeforeCounter returns a count of SignatureVerifierMock.IsValidDigestSignature invocations
func (mmIsValidDigestSignature *SignatureVerifierMock) IsValidDigestSignatureBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsValidDigestSignature.beforeIsValidDigestSignatureCounter)
}

// Calls returns a list of arguments used in each call to SignatureVerifierMock.IsValidDigestSignature.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsValidDigestSignature *mSignatureVerifierMockIsValidDigestSignature) Calls() []*SignatureVerifierMockIsValidDigestSignatureParams {
	mmIsValidDigestSignature.mutex.RLock()

	argCopy := make([]*SignatureVerifierMockIsValidDigestSignatureParams, len(mmIsValidDigestSignature.callArgs))
	copy(argCopy, mmIsValidDigestSignature.callArgs)

	mmIsValidDigestSignature.mutex.RUnlock()

	return argCopy
}

// MinimockIsValidDigestSignatureDone returns true if the count of the IsValidDigestSignature invocations corresponds
// the number of defined expectations
func (m *SignatureVerifierMock) MinimockIsValidDigestSignatureDone() bool {
	for _, e := range m.IsValidDigestSignatureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsValidDigestSignatureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsValidDigestSignatureCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsValidDigestSignature != nil && mm_atomic.LoadUint64(&m.afterIsValidDigestSignatureCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsValidDigestSignatureInspect logs each unmet expectation
func (m *SignatureVerifierMock) MinimockIsValidDigestSignatureInspect() {
	for _, e := range m.IsValidDigestSignatureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SignatureVerifierMock.IsValidDigestSignature with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsValidDigestSignatureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsValidDigestSignatureCounter) < 1 {
		if m.IsValidDigestSignatureMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SignatureVerifierMock.IsValidDigestSignature")
		} else {
			m.t.Errorf("Expected call to SignatureVerifierMock.IsValidDigestSignature with params: %#v", *m.IsValidDigestSignatureMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsValidDigestSignature != nil && mm_atomic.LoadUint64(&m.afterIsValidDigestSignatureCounter) < 1 {
		m.t.Error("Expected call to SignatureVerifierMock.IsValidDigestSignature")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SignatureVerifierMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetDefaultSigningMethodInspect()

		m.MinimockIsDigestMethodSupportedInspect()

		m.MinimockIsSigningMethodSupportedInspect()

		m.MinimockIsValidDataSignatureInspect()

		m.MinimockIsValidDigestSignatureInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SignatureVerifierMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SignatureVerifierMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetDefaultSigningMethodDone() &&
		m.MinimockIsDigestMethodSupportedDone() &&
		m.MinimockIsSigningMethodSupportedDone() &&
		m.MinimockIsValidDataSignatureDone() &&
		m.MinimockIsValidDigestSignatureDone()
}
