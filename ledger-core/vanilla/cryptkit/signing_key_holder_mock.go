package cryptkit

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/vanilla/longbits"
)

// SigningKeyHolderMock implements SigningKeyHolder
type SigningKeyHolderMock struct {
	t minimock.Tester

	funcAsByteString          func() (b1 longbits.ByteString)
	inspectFuncAsByteString   func()
	afterAsByteStringCounter  uint64
	beforeAsByteStringCounter uint64
	AsByteStringMock          mSigningKeyHolderMockAsByteString

	funcCopyTo          func(p []byte) (i1 int)
	inspectFuncCopyTo   func(p []byte)
	afterCopyToCounter  uint64
	beforeCopyToCounter uint64
	CopyToMock          mSigningKeyHolderMockCopyTo

	funcEquals          func(other SigningKeyHolder) (b1 bool)
	inspectFuncEquals   func(other SigningKeyHolder)
	afterEqualsCounter  uint64
	beforeEqualsCounter uint64
	EqualsMock          mSigningKeyHolderMockEquals

	funcFixedByteSize          func() (i1 int)
	inspectFuncFixedByteSize   func()
	afterFixedByteSizeCounter  uint64
	beforeFixedByteSizeCounter uint64
	FixedByteSizeMock          mSigningKeyHolderMockFixedByteSize

	funcFoldToUint64          func() (u1 uint64)
	inspectFuncFoldToUint64   func()
	afterFoldToUint64Counter  uint64
	beforeFoldToUint64Counter uint64
	FoldToUint64Mock          mSigningKeyHolderMockFoldToUint64

	funcGetSigningKeyType          func() (s1 SigningKeyType)
	inspectFuncGetSigningKeyType   func()
	afterGetSigningKeyTypeCounter  uint64
	beforeGetSigningKeyTypeCounter uint64
	GetSigningKeyTypeMock          mSigningKeyHolderMockGetSigningKeyType

	funcGetSigningMethod          func() (s1 SigningMethod)
	inspectFuncGetSigningMethod   func()
	afterGetSigningMethodCounter  uint64
	beforeGetSigningMethodCounter uint64
	GetSigningMethodMock          mSigningKeyHolderMockGetSigningMethod

	funcWriteTo          func(w io.Writer) (n int64, err error)
	inspectFuncWriteTo   func(w io.Writer)
	afterWriteToCounter  uint64
	beforeWriteToCounter uint64
	WriteToMock          mSigningKeyHolderMockWriteTo
}

// NewSigningKeyHolderMock returns a mock for SigningKeyHolder
func NewSigningKeyHolderMock(t minimock.Tester) *SigningKeyHolderMock {
	m := &SigningKeyHolderMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AsByteStringMock = mSigningKeyHolderMockAsByteString{mock: m}

	m.CopyToMock = mSigningKeyHolderMockCopyTo{mock: m}
	m.CopyToMock.callArgs = []*SigningKeyHolderMockCopyToParams{}

	m.EqualsMock = mSigningKeyHolderMockEquals{mock: m}
	m.EqualsMock.callArgs = []*SigningKeyHolderMockEqualsParams{}

	m.FixedByteSizeMock = mSigningKeyHolderMockFixedByteSize{mock: m}

	m.FoldToUint64Mock = mSigningKeyHolderMockFoldToUint64{mock: m}

	m.GetSigningKeyTypeMock = mSigningKeyHolderMockGetSigningKeyType{mock: m}

	m.GetSigningMethodMock = mSigningKeyHolderMockGetSigningMethod{mock: m}

	m.WriteToMock = mSigningKeyHolderMockWriteTo{mock: m}
	m.WriteToMock.callArgs = []*SigningKeyHolderMockWriteToParams{}

	return m
}

type mSigningKeyHolderMockAsByteString struct {
	mock               *SigningKeyHolderMock
	defaultExpectation *SigningKeyHolderMockAsByteStringExpectation
	expectations       []*SigningKeyHolderMockAsByteStringExpectation
}

// SigningKeyHolderMockAsByteStringExpectation specifies expectation struct of the SigningKeyHolder.AsByteString
type SigningKeyHolderMockAsByteStringExpectation struct {
	mock *SigningKeyHolderMock

	results *SigningKeyHolderMockAsByteStringResults
	Counter uint64
}

// SigningKeyHolderMockAsByteStringResults contains results of the SigningKeyHolder.AsByteString
type SigningKeyHolderMockAsByteStringResults struct {
	b1 longbits.ByteString
}

// Expect sets up expected params for SigningKeyHolder.AsByteString
func (mmAsByteString *mSigningKeyHolderMockAsByteString) Expect() *mSigningKeyHolderMockAsByteString {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("SigningKeyHolderMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &SigningKeyHolderMockAsByteStringExpectation{}
	}

	return mmAsByteString
}

// Inspect accepts an inspector function that has same arguments as the SigningKeyHolder.AsByteString
func (mmAsByteString *mSigningKeyHolderMockAsByteString) Inspect(f func()) *mSigningKeyHolderMockAsByteString {
	if mmAsByteString.mock.inspectFuncAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("Inspect function is already set for SigningKeyHolderMock.AsByteString")
	}

	mmAsByteString.mock.inspectFuncAsByteString = f

	return mmAsByteString
}

// Return sets up results that will be returned by SigningKeyHolder.AsByteString
func (mmAsByteString *mSigningKeyHolderMockAsByteString) Return(b1 longbits.ByteString) *SigningKeyHolderMock {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("SigningKeyHolderMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &SigningKeyHolderMockAsByteStringExpectation{mock: mmAsByteString.mock}
	}
	mmAsByteString.defaultExpectation.results = &SigningKeyHolderMockAsByteStringResults{b1}
	return mmAsByteString.mock
}

//Set uses given function f to mock the SigningKeyHolder.AsByteString method
func (mmAsByteString *mSigningKeyHolderMockAsByteString) Set(f func() (b1 longbits.ByteString)) *SigningKeyHolderMock {
	if mmAsByteString.defaultExpectation != nil {
		mmAsByteString.mock.t.Fatalf("Default expectation is already set for the SigningKeyHolder.AsByteString method")
	}

	if len(mmAsByteString.expectations) > 0 {
		mmAsByteString.mock.t.Fatalf("Some expectations are already set for the SigningKeyHolder.AsByteString method")
	}

	mmAsByteString.mock.funcAsByteString = f
	return mmAsByteString.mock
}

// AsByteString implements SigningKeyHolder
func (mmAsByteString *SigningKeyHolderMock) AsByteString() (b1 longbits.ByteString) {
	mm_atomic.AddUint64(&mmAsByteString.beforeAsByteStringCounter, 1)
	defer mm_atomic.AddUint64(&mmAsByteString.afterAsByteStringCounter, 1)

	if mmAsByteString.inspectFuncAsByteString != nil {
		mmAsByteString.inspectFuncAsByteString()
	}

	if mmAsByteString.AsByteStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsByteString.AsByteStringMock.defaultExpectation.Counter, 1)

		mm_results := mmAsByteString.AsByteStringMock.defaultExpectation.results
		if mm_results == nil {
			mmAsByteString.t.Fatal("No results are set for the SigningKeyHolderMock.AsByteString")
		}
		return (*mm_results).b1
	}
	if mmAsByteString.funcAsByteString != nil {
		return mmAsByteString.funcAsByteString()
	}
	mmAsByteString.t.Fatalf("Unexpected call to SigningKeyHolderMock.AsByteString.")
	return
}

// AsByteStringAfterCounter returns a count of finished SigningKeyHolderMock.AsByteString invocations
func (mmAsByteString *SigningKeyHolderMock) AsByteStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.afterAsByteStringCounter)
}

// AsByteStringBeforeCounter returns a count of SigningKeyHolderMock.AsByteString invocations
func (mmAsByteString *SigningKeyHolderMock) AsByteStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.beforeAsByteStringCounter)
}

// MinimockAsByteStringDone returns true if the count of the AsByteString invocations corresponds
// the number of defined expectations
func (m *SigningKeyHolderMock) MinimockAsByteStringDone() bool {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsByteStringInspect logs each unmet expectation
func (m *SigningKeyHolderMock) MinimockAsByteStringInspect() {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SigningKeyHolderMock.AsByteString")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to SigningKeyHolderMock.AsByteString")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to SigningKeyHolderMock.AsByteString")
	}
}

type mSigningKeyHolderMockCopyTo struct {
	mock               *SigningKeyHolderMock
	defaultExpectation *SigningKeyHolderMockCopyToExpectation
	expectations       []*SigningKeyHolderMockCopyToExpectation

	callArgs []*SigningKeyHolderMockCopyToParams
	mutex    sync.RWMutex
}

// SigningKeyHolderMockCopyToExpectation specifies expectation struct of the SigningKeyHolder.CopyTo
type SigningKeyHolderMockCopyToExpectation struct {
	mock    *SigningKeyHolderMock
	params  *SigningKeyHolderMockCopyToParams
	results *SigningKeyHolderMockCopyToResults
	Counter uint64
}

// SigningKeyHolderMockCopyToParams contains parameters of the SigningKeyHolder.CopyTo
type SigningKeyHolderMockCopyToParams struct {
	p []byte
}

// SigningKeyHolderMockCopyToResults contains results of the SigningKeyHolder.CopyTo
type SigningKeyHolderMockCopyToResults struct {
	i1 int
}

// Expect sets up expected params for SigningKeyHolder.CopyTo
func (mmCopyTo *mSigningKeyHolderMockCopyTo) Expect(p []byte) *mSigningKeyHolderMockCopyTo {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("SigningKeyHolderMock.CopyTo mock is already set by Set")
	}

	if mmCopyTo.defaultExpectation == nil {
		mmCopyTo.defaultExpectation = &SigningKeyHolderMockCopyToExpectation{}
	}

	mmCopyTo.defaultExpectation.params = &SigningKeyHolderMockCopyToParams{p}
	for _, e := range mmCopyTo.expectations {
		if minimock.Equal(e.params, mmCopyTo.defaultExpectation.params) {
			mmCopyTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCopyTo.defaultExpectation.params)
		}
	}

	return mmCopyTo
}

// Inspect accepts an inspector function that has same arguments as the SigningKeyHolder.CopyTo
func (mmCopyTo *mSigningKeyHolderMockCopyTo) Inspect(f func(p []byte)) *mSigningKeyHolderMockCopyTo {
	if mmCopyTo.mock.inspectFuncCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("Inspect function is already set for SigningKeyHolderMock.CopyTo")
	}

	mmCopyTo.mock.inspectFuncCopyTo = f

	return mmCopyTo
}

// Return sets up results that will be returned by SigningKeyHolder.CopyTo
func (mmCopyTo *mSigningKeyHolderMockCopyTo) Return(i1 int) *SigningKeyHolderMock {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("SigningKeyHolderMock.CopyTo mock is already set by Set")
	}

	if mmCopyTo.defaultExpectation == nil {
		mmCopyTo.defaultExpectation = &SigningKeyHolderMockCopyToExpectation{mock: mmCopyTo.mock}
	}
	mmCopyTo.defaultExpectation.results = &SigningKeyHolderMockCopyToResults{i1}
	return mmCopyTo.mock
}

//Set uses given function f to mock the SigningKeyHolder.CopyTo method
func (mmCopyTo *mSigningKeyHolderMockCopyTo) Set(f func(p []byte) (i1 int)) *SigningKeyHolderMock {
	if mmCopyTo.defaultExpectation != nil {
		mmCopyTo.mock.t.Fatalf("Default expectation is already set for the SigningKeyHolder.CopyTo method")
	}

	if len(mmCopyTo.expectations) > 0 {
		mmCopyTo.mock.t.Fatalf("Some expectations are already set for the SigningKeyHolder.CopyTo method")
	}

	mmCopyTo.mock.funcCopyTo = f
	return mmCopyTo.mock
}

// When sets expectation for the SigningKeyHolder.CopyTo which will trigger the result defined by the following
// Then helper
func (mmCopyTo *mSigningKeyHolderMockCopyTo) When(p []byte) *SigningKeyHolderMockCopyToExpectation {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("SigningKeyHolderMock.CopyTo mock is already set by Set")
	}

	expectation := &SigningKeyHolderMockCopyToExpectation{
		mock:   mmCopyTo.mock,
		params: &SigningKeyHolderMockCopyToParams{p},
	}
	mmCopyTo.expectations = append(mmCopyTo.expectations, expectation)
	return expectation
}

// Then sets up SigningKeyHolder.CopyTo return parameters for the expectation previously defined by the When method
func (e *SigningKeyHolderMockCopyToExpectation) Then(i1 int) *SigningKeyHolderMock {
	e.results = &SigningKeyHolderMockCopyToResults{i1}
	return e.mock
}

// CopyTo implements SigningKeyHolder
func (mmCopyTo *SigningKeyHolderMock) CopyTo(p []byte) (i1 int) {
	mm_atomic.AddUint64(&mmCopyTo.beforeCopyToCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyTo.afterCopyToCounter, 1)

	if mmCopyTo.inspectFuncCopyTo != nil {
		mmCopyTo.inspectFuncCopyTo(p)
	}

	mm_params := &SigningKeyHolderMockCopyToParams{p}

	// Record call args
	mmCopyTo.CopyToMock.mutex.Lock()
	mmCopyTo.CopyToMock.callArgs = append(mmCopyTo.CopyToMock.callArgs, mm_params)
	mmCopyTo.CopyToMock.mutex.Unlock()

	for _, e := range mmCopyTo.CopyToMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1
		}
	}

	if mmCopyTo.CopyToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyTo.CopyToMock.defaultExpectation.Counter, 1)
		mm_want := mmCopyTo.CopyToMock.defaultExpectation.params
		mm_got := SigningKeyHolderMockCopyToParams{p}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCopyTo.t.Errorf("SigningKeyHolderMock.CopyTo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCopyTo.CopyToMock.defaultExpectation.results
		if mm_results == nil {
			mmCopyTo.t.Fatal("No results are set for the SigningKeyHolderMock.CopyTo")
		}
		return (*mm_results).i1
	}
	if mmCopyTo.funcCopyTo != nil {
		return mmCopyTo.funcCopyTo(p)
	}
	mmCopyTo.t.Fatalf("Unexpected call to SigningKeyHolderMock.CopyTo. %v", p)
	return
}

// CopyToAfterCounter returns a count of finished SigningKeyHolderMock.CopyTo invocations
func (mmCopyTo *SigningKeyHolderMock) CopyToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyTo.afterCopyToCounter)
}

// CopyToBeforeCounter returns a count of SigningKeyHolderMock.CopyTo invocations
func (mmCopyTo *SigningKeyHolderMock) CopyToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyTo.beforeCopyToCounter)
}

// Calls returns a list of arguments used in each call to SigningKeyHolderMock.CopyTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCopyTo *mSigningKeyHolderMockCopyTo) Calls() []*SigningKeyHolderMockCopyToParams {
	mmCopyTo.mutex.RLock()

	argCopy := make([]*SigningKeyHolderMockCopyToParams, len(mmCopyTo.callArgs))
	copy(argCopy, mmCopyTo.callArgs)

	mmCopyTo.mutex.RUnlock()

	return argCopy
}

// MinimockCopyToDone returns true if the count of the CopyTo invocations corresponds
// the number of defined expectations
func (m *SigningKeyHolderMock) MinimockCopyToDone() bool {
	for _, e := range m.CopyToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyTo != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyToInspect logs each unmet expectation
func (m *SigningKeyHolderMock) MinimockCopyToInspect() {
	for _, e := range m.CopyToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SigningKeyHolderMock.CopyTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		if m.CopyToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SigningKeyHolderMock.CopyTo")
		} else {
			m.t.Errorf("Expected call to SigningKeyHolderMock.CopyTo with params: %#v", *m.CopyToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyTo != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		m.t.Error("Expected call to SigningKeyHolderMock.CopyTo")
	}
}

type mSigningKeyHolderMockEquals struct {
	mock               *SigningKeyHolderMock
	defaultExpectation *SigningKeyHolderMockEqualsExpectation
	expectations       []*SigningKeyHolderMockEqualsExpectation

	callArgs []*SigningKeyHolderMockEqualsParams
	mutex    sync.RWMutex
}

// SigningKeyHolderMockEqualsExpectation specifies expectation struct of the SigningKeyHolder.Equals
type SigningKeyHolderMockEqualsExpectation struct {
	mock    *SigningKeyHolderMock
	params  *SigningKeyHolderMockEqualsParams
	results *SigningKeyHolderMockEqualsResults
	Counter uint64
}

// SigningKeyHolderMockEqualsParams contains parameters of the SigningKeyHolder.Equals
type SigningKeyHolderMockEqualsParams struct {
	other SigningKeyHolder
}

// SigningKeyHolderMockEqualsResults contains results of the SigningKeyHolder.Equals
type SigningKeyHolderMockEqualsResults struct {
	b1 bool
}

// Expect sets up expected params for SigningKeyHolder.Equals
func (mmEquals *mSigningKeyHolderMockEquals) Expect(other SigningKeyHolder) *mSigningKeyHolderMockEquals {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("SigningKeyHolderMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &SigningKeyHolderMockEqualsExpectation{}
	}

	mmEquals.defaultExpectation.params = &SigningKeyHolderMockEqualsParams{other}
	for _, e := range mmEquals.expectations {
		if minimock.Equal(e.params, mmEquals.defaultExpectation.params) {
			mmEquals.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEquals.defaultExpectation.params)
		}
	}

	return mmEquals
}

// Inspect accepts an inspector function that has same arguments as the SigningKeyHolder.Equals
func (mmEquals *mSigningKeyHolderMockEquals) Inspect(f func(other SigningKeyHolder)) *mSigningKeyHolderMockEquals {
	if mmEquals.mock.inspectFuncEquals != nil {
		mmEquals.mock.t.Fatalf("Inspect function is already set for SigningKeyHolderMock.Equals")
	}

	mmEquals.mock.inspectFuncEquals = f

	return mmEquals
}

// Return sets up results that will be returned by SigningKeyHolder.Equals
func (mmEquals *mSigningKeyHolderMockEquals) Return(b1 bool) *SigningKeyHolderMock {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("SigningKeyHolderMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &SigningKeyHolderMockEqualsExpectation{mock: mmEquals.mock}
	}
	mmEquals.defaultExpectation.results = &SigningKeyHolderMockEqualsResults{b1}
	return mmEquals.mock
}

//Set uses given function f to mock the SigningKeyHolder.Equals method
func (mmEquals *mSigningKeyHolderMockEquals) Set(f func(other SigningKeyHolder) (b1 bool)) *SigningKeyHolderMock {
	if mmEquals.defaultExpectation != nil {
		mmEquals.mock.t.Fatalf("Default expectation is already set for the SigningKeyHolder.Equals method")
	}

	if len(mmEquals.expectations) > 0 {
		mmEquals.mock.t.Fatalf("Some expectations are already set for the SigningKeyHolder.Equals method")
	}

	mmEquals.mock.funcEquals = f
	return mmEquals.mock
}

// When sets expectation for the SigningKeyHolder.Equals which will trigger the result defined by the following
// Then helper
func (mmEquals *mSigningKeyHolderMockEquals) When(other SigningKeyHolder) *SigningKeyHolderMockEqualsExpectation {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("SigningKeyHolderMock.Equals mock is already set by Set")
	}

	expectation := &SigningKeyHolderMockEqualsExpectation{
		mock:   mmEquals.mock,
		params: &SigningKeyHolderMockEqualsParams{other},
	}
	mmEquals.expectations = append(mmEquals.expectations, expectation)
	return expectation
}

// Then sets up SigningKeyHolder.Equals return parameters for the expectation previously defined by the When method
func (e *SigningKeyHolderMockEqualsExpectation) Then(b1 bool) *SigningKeyHolderMock {
	e.results = &SigningKeyHolderMockEqualsResults{b1}
	return e.mock
}

// Equals implements SigningKeyHolder
func (mmEquals *SigningKeyHolderMock) Equals(other SigningKeyHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmEquals.beforeEqualsCounter, 1)
	defer mm_atomic.AddUint64(&mmEquals.afterEqualsCounter, 1)

	if mmEquals.inspectFuncEquals != nil {
		mmEquals.inspectFuncEquals(other)
	}

	mm_params := &SigningKeyHolderMockEqualsParams{other}

	// Record call args
	mmEquals.EqualsMock.mutex.Lock()
	mmEquals.EqualsMock.callArgs = append(mmEquals.EqualsMock.callArgs, mm_params)
	mmEquals.EqualsMock.mutex.Unlock()

	for _, e := range mmEquals.EqualsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmEquals.EqualsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEquals.EqualsMock.defaultExpectation.Counter, 1)
		mm_want := mmEquals.EqualsMock.defaultExpectation.params
		mm_got := SigningKeyHolderMockEqualsParams{other}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEquals.t.Errorf("SigningKeyHolderMock.Equals got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEquals.EqualsMock.defaultExpectation.results
		if mm_results == nil {
			mmEquals.t.Fatal("No results are set for the SigningKeyHolderMock.Equals")
		}
		return (*mm_results).b1
	}
	if mmEquals.funcEquals != nil {
		return mmEquals.funcEquals(other)
	}
	mmEquals.t.Fatalf("Unexpected call to SigningKeyHolderMock.Equals. %v", other)
	return
}

// EqualsAfterCounter returns a count of finished SigningKeyHolderMock.Equals invocations
func (mmEquals *SigningKeyHolderMock) EqualsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.afterEqualsCounter)
}

// EqualsBeforeCounter returns a count of SigningKeyHolderMock.Equals invocations
func (mmEquals *SigningKeyHolderMock) EqualsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.beforeEqualsCounter)
}

// Calls returns a list of arguments used in each call to SigningKeyHolderMock.Equals.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEquals *mSigningKeyHolderMockEquals) Calls() []*SigningKeyHolderMockEqualsParams {
	mmEquals.mutex.RLock()

	argCopy := make([]*SigningKeyHolderMockEqualsParams, len(mmEquals.callArgs))
	copy(argCopy, mmEquals.callArgs)

	mmEquals.mutex.RUnlock()

	return argCopy
}

// MinimockEqualsDone returns true if the count of the Equals invocations corresponds
// the number of defined expectations
func (m *SigningKeyHolderMock) MinimockEqualsDone() bool {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	return true
}

// MinimockEqualsInspect logs each unmet expectation
func (m *SigningKeyHolderMock) MinimockEqualsInspect() {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SigningKeyHolderMock.Equals with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		if m.EqualsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SigningKeyHolderMock.Equals")
		} else {
			m.t.Errorf("Expected call to SigningKeyHolderMock.Equals with params: %#v", *m.EqualsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		m.t.Error("Expected call to SigningKeyHolderMock.Equals")
	}
}

type mSigningKeyHolderMockFixedByteSize struct {
	mock               *SigningKeyHolderMock
	defaultExpectation *SigningKeyHolderMockFixedByteSizeExpectation
	expectations       []*SigningKeyHolderMockFixedByteSizeExpectation
}

// SigningKeyHolderMockFixedByteSizeExpectation specifies expectation struct of the SigningKeyHolder.FixedByteSize
type SigningKeyHolderMockFixedByteSizeExpectation struct {
	mock *SigningKeyHolderMock

	results *SigningKeyHolderMockFixedByteSizeResults
	Counter uint64
}

// SigningKeyHolderMockFixedByteSizeResults contains results of the SigningKeyHolder.FixedByteSize
type SigningKeyHolderMockFixedByteSizeResults struct {
	i1 int
}

// Expect sets up expected params for SigningKeyHolder.FixedByteSize
func (mmFixedByteSize *mSigningKeyHolderMockFixedByteSize) Expect() *mSigningKeyHolderMockFixedByteSize {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("SigningKeyHolderMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &SigningKeyHolderMockFixedByteSizeExpectation{}
	}

	return mmFixedByteSize
}

// Inspect accepts an inspector function that has same arguments as the SigningKeyHolder.FixedByteSize
func (mmFixedByteSize *mSigningKeyHolderMockFixedByteSize) Inspect(f func()) *mSigningKeyHolderMockFixedByteSize {
	if mmFixedByteSize.mock.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("Inspect function is already set for SigningKeyHolderMock.FixedByteSize")
	}

	mmFixedByteSize.mock.inspectFuncFixedByteSize = f

	return mmFixedByteSize
}

// Return sets up results that will be returned by SigningKeyHolder.FixedByteSize
func (mmFixedByteSize *mSigningKeyHolderMockFixedByteSize) Return(i1 int) *SigningKeyHolderMock {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("SigningKeyHolderMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &SigningKeyHolderMockFixedByteSizeExpectation{mock: mmFixedByteSize.mock}
	}
	mmFixedByteSize.defaultExpectation.results = &SigningKeyHolderMockFixedByteSizeResults{i1}
	return mmFixedByteSize.mock
}

//Set uses given function f to mock the SigningKeyHolder.FixedByteSize method
func (mmFixedByteSize *mSigningKeyHolderMockFixedByteSize) Set(f func() (i1 int)) *SigningKeyHolderMock {
	if mmFixedByteSize.defaultExpectation != nil {
		mmFixedByteSize.mock.t.Fatalf("Default expectation is already set for the SigningKeyHolder.FixedByteSize method")
	}

	if len(mmFixedByteSize.expectations) > 0 {
		mmFixedByteSize.mock.t.Fatalf("Some expectations are already set for the SigningKeyHolder.FixedByteSize method")
	}

	mmFixedByteSize.mock.funcFixedByteSize = f
	return mmFixedByteSize.mock
}

// FixedByteSize implements SigningKeyHolder
func (mmFixedByteSize *SigningKeyHolderMock) FixedByteSize() (i1 int) {
	mm_atomic.AddUint64(&mmFixedByteSize.beforeFixedByteSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmFixedByteSize.afterFixedByteSizeCounter, 1)

	if mmFixedByteSize.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.inspectFuncFixedByteSize()
	}

	if mmFixedByteSize.FixedByteSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFixedByteSize.FixedByteSizeMock.defaultExpectation.Counter, 1)

		mm_results := mmFixedByteSize.FixedByteSizeMock.defaultExpectation.results
		if mm_results == nil {
			mmFixedByteSize.t.Fatal("No results are set for the SigningKeyHolderMock.FixedByteSize")
		}
		return (*mm_results).i1
	}
	if mmFixedByteSize.funcFixedByteSize != nil {
		return mmFixedByteSize.funcFixedByteSize()
	}
	mmFixedByteSize.t.Fatalf("Unexpected call to SigningKeyHolderMock.FixedByteSize.")
	return
}

// FixedByteSizeAfterCounter returns a count of finished SigningKeyHolderMock.FixedByteSize invocations
func (mmFixedByteSize *SigningKeyHolderMock) FixedByteSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.afterFixedByteSizeCounter)
}

// FixedByteSizeBeforeCounter returns a count of SigningKeyHolderMock.FixedByteSize invocations
func (mmFixedByteSize *SigningKeyHolderMock) FixedByteSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.beforeFixedByteSizeCounter)
}

// MinimockFixedByteSizeDone returns true if the count of the FixedByteSize invocations corresponds
// the number of defined expectations
func (m *SigningKeyHolderMock) MinimockFixedByteSizeDone() bool {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockFixedByteSizeInspect logs each unmet expectation
func (m *SigningKeyHolderMock) MinimockFixedByteSizeInspect() {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SigningKeyHolderMock.FixedByteSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to SigningKeyHolderMock.FixedByteSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to SigningKeyHolderMock.FixedByteSize")
	}
}

type mSigningKeyHolderMockFoldToUint64 struct {
	mock               *SigningKeyHolderMock
	defaultExpectation *SigningKeyHolderMockFoldToUint64Expectation
	expectations       []*SigningKeyHolderMockFoldToUint64Expectation
}

// SigningKeyHolderMockFoldToUint64Expectation specifies expectation struct of the SigningKeyHolder.FoldToUint64
type SigningKeyHolderMockFoldToUint64Expectation struct {
	mock *SigningKeyHolderMock

	results *SigningKeyHolderMockFoldToUint64Results
	Counter uint64
}

// SigningKeyHolderMockFoldToUint64Results contains results of the SigningKeyHolder.FoldToUint64
type SigningKeyHolderMockFoldToUint64Results struct {
	u1 uint64
}

// Expect sets up expected params for SigningKeyHolder.FoldToUint64
func (mmFoldToUint64 *mSigningKeyHolderMockFoldToUint64) Expect() *mSigningKeyHolderMockFoldToUint64 {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("SigningKeyHolderMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &SigningKeyHolderMockFoldToUint64Expectation{}
	}

	return mmFoldToUint64
}

// Inspect accepts an inspector function that has same arguments as the SigningKeyHolder.FoldToUint64
func (mmFoldToUint64 *mSigningKeyHolderMockFoldToUint64) Inspect(f func()) *mSigningKeyHolderMockFoldToUint64 {
	if mmFoldToUint64.mock.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("Inspect function is already set for SigningKeyHolderMock.FoldToUint64")
	}

	mmFoldToUint64.mock.inspectFuncFoldToUint64 = f

	return mmFoldToUint64
}

// Return sets up results that will be returned by SigningKeyHolder.FoldToUint64
func (mmFoldToUint64 *mSigningKeyHolderMockFoldToUint64) Return(u1 uint64) *SigningKeyHolderMock {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("SigningKeyHolderMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &SigningKeyHolderMockFoldToUint64Expectation{mock: mmFoldToUint64.mock}
	}
	mmFoldToUint64.defaultExpectation.results = &SigningKeyHolderMockFoldToUint64Results{u1}
	return mmFoldToUint64.mock
}

//Set uses given function f to mock the SigningKeyHolder.FoldToUint64 method
func (mmFoldToUint64 *mSigningKeyHolderMockFoldToUint64) Set(f func() (u1 uint64)) *SigningKeyHolderMock {
	if mmFoldToUint64.defaultExpectation != nil {
		mmFoldToUint64.mock.t.Fatalf("Default expectation is already set for the SigningKeyHolder.FoldToUint64 method")
	}

	if len(mmFoldToUint64.expectations) > 0 {
		mmFoldToUint64.mock.t.Fatalf("Some expectations are already set for the SigningKeyHolder.FoldToUint64 method")
	}

	mmFoldToUint64.mock.funcFoldToUint64 = f
	return mmFoldToUint64.mock
}

// FoldToUint64 implements SigningKeyHolder
func (mmFoldToUint64 *SigningKeyHolderMock) FoldToUint64() (u1 uint64) {
	mm_atomic.AddUint64(&mmFoldToUint64.beforeFoldToUint64Counter, 1)
	defer mm_atomic.AddUint64(&mmFoldToUint64.afterFoldToUint64Counter, 1)

	if mmFoldToUint64.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.inspectFuncFoldToUint64()
	}

	if mmFoldToUint64.FoldToUint64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFoldToUint64.FoldToUint64Mock.defaultExpectation.Counter, 1)

		mm_results := mmFoldToUint64.FoldToUint64Mock.defaultExpectation.results
		if mm_results == nil {
			mmFoldToUint64.t.Fatal("No results are set for the SigningKeyHolderMock.FoldToUint64")
		}
		return (*mm_results).u1
	}
	if mmFoldToUint64.funcFoldToUint64 != nil {
		return mmFoldToUint64.funcFoldToUint64()
	}
	mmFoldToUint64.t.Fatalf("Unexpected call to SigningKeyHolderMock.FoldToUint64.")
	return
}

// FoldToUint64AfterCounter returns a count of finished SigningKeyHolderMock.FoldToUint64 invocations
func (mmFoldToUint64 *SigningKeyHolderMock) FoldToUint64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.afterFoldToUint64Counter)
}

// FoldToUint64BeforeCounter returns a count of SigningKeyHolderMock.FoldToUint64 invocations
func (mmFoldToUint64 *SigningKeyHolderMock) FoldToUint64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.beforeFoldToUint64Counter)
}

// MinimockFoldToUint64Done returns true if the count of the FoldToUint64 invocations corresponds
// the number of defined expectations
func (m *SigningKeyHolderMock) MinimockFoldToUint64Done() bool {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	return true
}

// MinimockFoldToUint64Inspect logs each unmet expectation
func (m *SigningKeyHolderMock) MinimockFoldToUint64Inspect() {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SigningKeyHolderMock.FoldToUint64")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to SigningKeyHolderMock.FoldToUint64")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to SigningKeyHolderMock.FoldToUint64")
	}
}

type mSigningKeyHolderMockGetSigningKeyType struct {
	mock               *SigningKeyHolderMock
	defaultExpectation *SigningKeyHolderMockGetSigningKeyTypeExpectation
	expectations       []*SigningKeyHolderMockGetSigningKeyTypeExpectation
}

// SigningKeyHolderMockGetSigningKeyTypeExpectation specifies expectation struct of the SigningKeyHolder.GetSigningKeyType
type SigningKeyHolderMockGetSigningKeyTypeExpectation struct {
	mock *SigningKeyHolderMock

	results *SigningKeyHolderMockGetSigningKeyTypeResults
	Counter uint64
}

// SigningKeyHolderMockGetSigningKeyTypeResults contains results of the SigningKeyHolder.GetSigningKeyType
type SigningKeyHolderMockGetSigningKeyTypeResults struct {
	s1 SigningKeyType
}

// Expect sets up expected params for SigningKeyHolder.GetSigningKeyType
func (mmGetSigningKeyType *mSigningKeyHolderMockGetSigningKeyType) Expect() *mSigningKeyHolderMockGetSigningKeyType {
	if mmGetSigningKeyType.mock.funcGetSigningKeyType != nil {
		mmGetSigningKeyType.mock.t.Fatalf("SigningKeyHolderMock.GetSigningKeyType mock is already set by Set")
	}

	if mmGetSigningKeyType.defaultExpectation == nil {
		mmGetSigningKeyType.defaultExpectation = &SigningKeyHolderMockGetSigningKeyTypeExpectation{}
	}

	return mmGetSigningKeyType
}

// Inspect accepts an inspector function that has same arguments as the SigningKeyHolder.GetSigningKeyType
func (mmGetSigningKeyType *mSigningKeyHolderMockGetSigningKeyType) Inspect(f func()) *mSigningKeyHolderMockGetSigningKeyType {
	if mmGetSigningKeyType.mock.inspectFuncGetSigningKeyType != nil {
		mmGetSigningKeyType.mock.t.Fatalf("Inspect function is already set for SigningKeyHolderMock.GetSigningKeyType")
	}

	mmGetSigningKeyType.mock.inspectFuncGetSigningKeyType = f

	return mmGetSigningKeyType
}

// Return sets up results that will be returned by SigningKeyHolder.GetSigningKeyType
func (mmGetSigningKeyType *mSigningKeyHolderMockGetSigningKeyType) Return(s1 SigningKeyType) *SigningKeyHolderMock {
	if mmGetSigningKeyType.mock.funcGetSigningKeyType != nil {
		mmGetSigningKeyType.mock.t.Fatalf("SigningKeyHolderMock.GetSigningKeyType mock is already set by Set")
	}

	if mmGetSigningKeyType.defaultExpectation == nil {
		mmGetSigningKeyType.defaultExpectation = &SigningKeyHolderMockGetSigningKeyTypeExpectation{mock: mmGetSigningKeyType.mock}
	}
	mmGetSigningKeyType.defaultExpectation.results = &SigningKeyHolderMockGetSigningKeyTypeResults{s1}
	return mmGetSigningKeyType.mock
}

//Set uses given function f to mock the SigningKeyHolder.GetSigningKeyType method
func (mmGetSigningKeyType *mSigningKeyHolderMockGetSigningKeyType) Set(f func() (s1 SigningKeyType)) *SigningKeyHolderMock {
	if mmGetSigningKeyType.defaultExpectation != nil {
		mmGetSigningKeyType.mock.t.Fatalf("Default expectation is already set for the SigningKeyHolder.GetSigningKeyType method")
	}

	if len(mmGetSigningKeyType.expectations) > 0 {
		mmGetSigningKeyType.mock.t.Fatalf("Some expectations are already set for the SigningKeyHolder.GetSigningKeyType method")
	}

	mmGetSigningKeyType.mock.funcGetSigningKeyType = f
	return mmGetSigningKeyType.mock
}

// GetSigningKeyType implements SigningKeyHolder
func (mmGetSigningKeyType *SigningKeyHolderMock) GetSigningKeyType() (s1 SigningKeyType) {
	mm_atomic.AddUint64(&mmGetSigningKeyType.beforeGetSigningKeyTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSigningKeyType.afterGetSigningKeyTypeCounter, 1)

	if mmGetSigningKeyType.inspectFuncGetSigningKeyType != nil {
		mmGetSigningKeyType.inspectFuncGetSigningKeyType()
	}

	if mmGetSigningKeyType.GetSigningKeyTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSigningKeyType.GetSigningKeyTypeMock.defaultExpectation.Counter, 1)

		mm_results := mmGetSigningKeyType.GetSigningKeyTypeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSigningKeyType.t.Fatal("No results are set for the SigningKeyHolderMock.GetSigningKeyType")
		}
		return (*mm_results).s1
	}
	if mmGetSigningKeyType.funcGetSigningKeyType != nil {
		return mmGetSigningKeyType.funcGetSigningKeyType()
	}
	mmGetSigningKeyType.t.Fatalf("Unexpected call to SigningKeyHolderMock.GetSigningKeyType.")
	return
}

// GetSigningKeyTypeAfterCounter returns a count of finished SigningKeyHolderMock.GetSigningKeyType invocations
func (mmGetSigningKeyType *SigningKeyHolderMock) GetSigningKeyTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSigningKeyType.afterGetSigningKeyTypeCounter)
}

// GetSigningKeyTypeBeforeCounter returns a count of SigningKeyHolderMock.GetSigningKeyType invocations
func (mmGetSigningKeyType *SigningKeyHolderMock) GetSigningKeyTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSigningKeyType.beforeGetSigningKeyTypeCounter)
}

// MinimockGetSigningKeyTypeDone returns true if the count of the GetSigningKeyType invocations corresponds
// the number of defined expectations
func (m *SigningKeyHolderMock) MinimockGetSigningKeyTypeDone() bool {
	for _, e := range m.GetSigningKeyTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSigningKeyTypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSigningKeyTypeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSigningKeyType != nil && mm_atomic.LoadUint64(&m.afterGetSigningKeyTypeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSigningKeyTypeInspect logs each unmet expectation
func (m *SigningKeyHolderMock) MinimockGetSigningKeyTypeInspect() {
	for _, e := range m.GetSigningKeyTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SigningKeyHolderMock.GetSigningKeyType")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSigningKeyTypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSigningKeyTypeCounter) < 1 {
		m.t.Error("Expected call to SigningKeyHolderMock.GetSigningKeyType")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSigningKeyType != nil && mm_atomic.LoadUint64(&m.afterGetSigningKeyTypeCounter) < 1 {
		m.t.Error("Expected call to SigningKeyHolderMock.GetSigningKeyType")
	}
}

type mSigningKeyHolderMockGetSigningMethod struct {
	mock               *SigningKeyHolderMock
	defaultExpectation *SigningKeyHolderMockGetSigningMethodExpectation
	expectations       []*SigningKeyHolderMockGetSigningMethodExpectation
}

// SigningKeyHolderMockGetSigningMethodExpectation specifies expectation struct of the SigningKeyHolder.GetSigningMethod
type SigningKeyHolderMockGetSigningMethodExpectation struct {
	mock *SigningKeyHolderMock

	results *SigningKeyHolderMockGetSigningMethodResults
	Counter uint64
}

// SigningKeyHolderMockGetSigningMethodResults contains results of the SigningKeyHolder.GetSigningMethod
type SigningKeyHolderMockGetSigningMethodResults struct {
	s1 SigningMethod
}

// Expect sets up expected params for SigningKeyHolder.GetSigningMethod
func (mmGetSigningMethod *mSigningKeyHolderMockGetSigningMethod) Expect() *mSigningKeyHolderMockGetSigningMethod {
	if mmGetSigningMethod.mock.funcGetSigningMethod != nil {
		mmGetSigningMethod.mock.t.Fatalf("SigningKeyHolderMock.GetSigningMethod mock is already set by Set")
	}

	if mmGetSigningMethod.defaultExpectation == nil {
		mmGetSigningMethod.defaultExpectation = &SigningKeyHolderMockGetSigningMethodExpectation{}
	}

	return mmGetSigningMethod
}

// Inspect accepts an inspector function that has same arguments as the SigningKeyHolder.GetSigningMethod
func (mmGetSigningMethod *mSigningKeyHolderMockGetSigningMethod) Inspect(f func()) *mSigningKeyHolderMockGetSigningMethod {
	if mmGetSigningMethod.mock.inspectFuncGetSigningMethod != nil {
		mmGetSigningMethod.mock.t.Fatalf("Inspect function is already set for SigningKeyHolderMock.GetSigningMethod")
	}

	mmGetSigningMethod.mock.inspectFuncGetSigningMethod = f

	return mmGetSigningMethod
}

// Return sets up results that will be returned by SigningKeyHolder.GetSigningMethod
func (mmGetSigningMethod *mSigningKeyHolderMockGetSigningMethod) Return(s1 SigningMethod) *SigningKeyHolderMock {
	if mmGetSigningMethod.mock.funcGetSigningMethod != nil {
		mmGetSigningMethod.mock.t.Fatalf("SigningKeyHolderMock.GetSigningMethod mock is already set by Set")
	}

	if mmGetSigningMethod.defaultExpectation == nil {
		mmGetSigningMethod.defaultExpectation = &SigningKeyHolderMockGetSigningMethodExpectation{mock: mmGetSigningMethod.mock}
	}
	mmGetSigningMethod.defaultExpectation.results = &SigningKeyHolderMockGetSigningMethodResults{s1}
	return mmGetSigningMethod.mock
}

//Set uses given function f to mock the SigningKeyHolder.GetSigningMethod method
func (mmGetSigningMethod *mSigningKeyHolderMockGetSigningMethod) Set(f func() (s1 SigningMethod)) *SigningKeyHolderMock {
	if mmGetSigningMethod.defaultExpectation != nil {
		mmGetSigningMethod.mock.t.Fatalf("Default expectation is already set for the SigningKeyHolder.GetSigningMethod method")
	}

	if len(mmGetSigningMethod.expectations) > 0 {
		mmGetSigningMethod.mock.t.Fatalf("Some expectations are already set for the SigningKeyHolder.GetSigningMethod method")
	}

	mmGetSigningMethod.mock.funcGetSigningMethod = f
	return mmGetSigningMethod.mock
}

// GetSigningMethod implements SigningKeyHolder
func (mmGetSigningMethod *SigningKeyHolderMock) GetSigningMethod() (s1 SigningMethod) {
	mm_atomic.AddUint64(&mmGetSigningMethod.beforeGetSigningMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSigningMethod.afterGetSigningMethodCounter, 1)

	if mmGetSigningMethod.inspectFuncGetSigningMethod != nil {
		mmGetSigningMethod.inspectFuncGetSigningMethod()
	}

	if mmGetSigningMethod.GetSigningMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSigningMethod.GetSigningMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetSigningMethod.GetSigningMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSigningMethod.t.Fatal("No results are set for the SigningKeyHolderMock.GetSigningMethod")
		}
		return (*mm_results).s1
	}
	if mmGetSigningMethod.funcGetSigningMethod != nil {
		return mmGetSigningMethod.funcGetSigningMethod()
	}
	mmGetSigningMethod.t.Fatalf("Unexpected call to SigningKeyHolderMock.GetSigningMethod.")
	return
}

// GetSigningMethodAfterCounter returns a count of finished SigningKeyHolderMock.GetSigningMethod invocations
func (mmGetSigningMethod *SigningKeyHolderMock) GetSigningMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSigningMethod.afterGetSigningMethodCounter)
}

// GetSigningMethodBeforeCounter returns a count of SigningKeyHolderMock.GetSigningMethod invocations
func (mmGetSigningMethod *SigningKeyHolderMock) GetSigningMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSigningMethod.beforeGetSigningMethodCounter)
}

// MinimockGetSigningMethodDone returns true if the count of the GetSigningMethod invocations corresponds
// the number of defined expectations
func (m *SigningKeyHolderMock) MinimockGetSigningMethodDone() bool {
	for _, e := range m.GetSigningMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSigningMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSigningMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSigningMethod != nil && mm_atomic.LoadUint64(&m.afterGetSigningMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSigningMethodInspect logs each unmet expectation
func (m *SigningKeyHolderMock) MinimockGetSigningMethodInspect() {
	for _, e := range m.GetSigningMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SigningKeyHolderMock.GetSigningMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSigningMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSigningMethodCounter) < 1 {
		m.t.Error("Expected call to SigningKeyHolderMock.GetSigningMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSigningMethod != nil && mm_atomic.LoadUint64(&m.afterGetSigningMethodCounter) < 1 {
		m.t.Error("Expected call to SigningKeyHolderMock.GetSigningMethod")
	}
}

type mSigningKeyHolderMockWriteTo struct {
	mock               *SigningKeyHolderMock
	defaultExpectation *SigningKeyHolderMockWriteToExpectation
	expectations       []*SigningKeyHolderMockWriteToExpectation

	callArgs []*SigningKeyHolderMockWriteToParams
	mutex    sync.RWMutex
}

// SigningKeyHolderMockWriteToExpectation specifies expectation struct of the SigningKeyHolder.WriteTo
type SigningKeyHolderMockWriteToExpectation struct {
	mock    *SigningKeyHolderMock
	params  *SigningKeyHolderMockWriteToParams
	results *SigningKeyHolderMockWriteToResults
	Counter uint64
}

// SigningKeyHolderMockWriteToParams contains parameters of the SigningKeyHolder.WriteTo
type SigningKeyHolderMockWriteToParams struct {
	w io.Writer
}

// SigningKeyHolderMockWriteToResults contains results of the SigningKeyHolder.WriteTo
type SigningKeyHolderMockWriteToResults struct {
	n   int64
	err error
}

// Expect sets up expected params for SigningKeyHolder.WriteTo
func (mmWriteTo *mSigningKeyHolderMockWriteTo) Expect(w io.Writer) *mSigningKeyHolderMockWriteTo {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("SigningKeyHolderMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &SigningKeyHolderMockWriteToExpectation{}
	}

	mmWriteTo.defaultExpectation.params = &SigningKeyHolderMockWriteToParams{w}
	for _, e := range mmWriteTo.expectations {
		if minimock.Equal(e.params, mmWriteTo.defaultExpectation.params) {
			mmWriteTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteTo.defaultExpectation.params)
		}
	}

	return mmWriteTo
}

// Inspect accepts an inspector function that has same arguments as the SigningKeyHolder.WriteTo
func (mmWriteTo *mSigningKeyHolderMockWriteTo) Inspect(f func(w io.Writer)) *mSigningKeyHolderMockWriteTo {
	if mmWriteTo.mock.inspectFuncWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("Inspect function is already set for SigningKeyHolderMock.WriteTo")
	}

	mmWriteTo.mock.inspectFuncWriteTo = f

	return mmWriteTo
}

// Return sets up results that will be returned by SigningKeyHolder.WriteTo
func (mmWriteTo *mSigningKeyHolderMockWriteTo) Return(n int64, err error) *SigningKeyHolderMock {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("SigningKeyHolderMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &SigningKeyHolderMockWriteToExpectation{mock: mmWriteTo.mock}
	}
	mmWriteTo.defaultExpectation.results = &SigningKeyHolderMockWriteToResults{n, err}
	return mmWriteTo.mock
}

//Set uses given function f to mock the SigningKeyHolder.WriteTo method
func (mmWriteTo *mSigningKeyHolderMockWriteTo) Set(f func(w io.Writer) (n int64, err error)) *SigningKeyHolderMock {
	if mmWriteTo.defaultExpectation != nil {
		mmWriteTo.mock.t.Fatalf("Default expectation is already set for the SigningKeyHolder.WriteTo method")
	}

	if len(mmWriteTo.expectations) > 0 {
		mmWriteTo.mock.t.Fatalf("Some expectations are already set for the SigningKeyHolder.WriteTo method")
	}

	mmWriteTo.mock.funcWriteTo = f
	return mmWriteTo.mock
}

// When sets expectation for the SigningKeyHolder.WriteTo which will trigger the result defined by the following
// Then helper
func (mmWriteTo *mSigningKeyHolderMockWriteTo) When(w io.Writer) *SigningKeyHolderMockWriteToExpectation {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("SigningKeyHolderMock.WriteTo mock is already set by Set")
	}

	expectation := &SigningKeyHolderMockWriteToExpectation{
		mock:   mmWriteTo.mock,
		params: &SigningKeyHolderMockWriteToParams{w},
	}
	mmWriteTo.expectations = append(mmWriteTo.expectations, expectation)
	return expectation
}

// Then sets up SigningKeyHolder.WriteTo return parameters for the expectation previously defined by the When method
func (e *SigningKeyHolderMockWriteToExpectation) Then(n int64, err error) *SigningKeyHolderMock {
	e.results = &SigningKeyHolderMockWriteToResults{n, err}
	return e.mock
}

// WriteTo implements SigningKeyHolder
func (mmWriteTo *SigningKeyHolderMock) WriteTo(w io.Writer) (n int64, err error) {
	mm_atomic.AddUint64(&mmWriteTo.beforeWriteToCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteTo.afterWriteToCounter, 1)

	if mmWriteTo.inspectFuncWriteTo != nil {
		mmWriteTo.inspectFuncWriteTo(w)
	}

	mm_params := &SigningKeyHolderMockWriteToParams{w}

	// Record call args
	mmWriteTo.WriteToMock.mutex.Lock()
	mmWriteTo.WriteToMock.callArgs = append(mmWriteTo.WriteToMock.callArgs, mm_params)
	mmWriteTo.WriteToMock.mutex.Unlock()

	for _, e := range mmWriteTo.WriteToMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWriteTo.WriteToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteTo.WriteToMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteTo.WriteToMock.defaultExpectation.params
		mm_got := SigningKeyHolderMockWriteToParams{w}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteTo.t.Errorf("SigningKeyHolderMock.WriteTo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWriteTo.WriteToMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteTo.t.Fatal("No results are set for the SigningKeyHolderMock.WriteTo")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmWriteTo.funcWriteTo != nil {
		return mmWriteTo.funcWriteTo(w)
	}
	mmWriteTo.t.Fatalf("Unexpected call to SigningKeyHolderMock.WriteTo. %v", w)
	return
}

// WriteToAfterCounter returns a count of finished SigningKeyHolderMock.WriteTo invocations
func (mmWriteTo *SigningKeyHolderMock) WriteToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.afterWriteToCounter)
}

// WriteToBeforeCounter returns a count of SigningKeyHolderMock.WriteTo invocations
func (mmWriteTo *SigningKeyHolderMock) WriteToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.beforeWriteToCounter)
}

// Calls returns a list of arguments used in each call to SigningKeyHolderMock.WriteTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteTo *mSigningKeyHolderMockWriteTo) Calls() []*SigningKeyHolderMockWriteToParams {
	mmWriteTo.mutex.RLock()

	argCopy := make([]*SigningKeyHolderMockWriteToParams, len(mmWriteTo.callArgs))
	copy(argCopy, mmWriteTo.callArgs)

	mmWriteTo.mutex.RUnlock()

	return argCopy
}

// MinimockWriteToDone returns true if the count of the WriteTo invocations corresponds
// the number of defined expectations
func (m *SigningKeyHolderMock) MinimockWriteToDone() bool {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteToInspect logs each unmet expectation
func (m *SigningKeyHolderMock) MinimockWriteToInspect() {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SigningKeyHolderMock.WriteTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		if m.WriteToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SigningKeyHolderMock.WriteTo")
		} else {
			m.t.Errorf("Expected call to SigningKeyHolderMock.WriteTo with params: %#v", *m.WriteToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		m.t.Error("Expected call to SigningKeyHolderMock.WriteTo")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SigningKeyHolderMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAsByteStringInspect()

		m.MinimockCopyToInspect()

		m.MinimockEqualsInspect()

		m.MinimockFixedByteSizeInspect()

		m.MinimockFoldToUint64Inspect()

		m.MinimockGetSigningKeyTypeInspect()

		m.MinimockGetSigningMethodInspect()

		m.MinimockWriteToInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SigningKeyHolderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SigningKeyHolderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAsByteStringDone() &&
		m.MinimockCopyToDone() &&
		m.MinimockEqualsDone() &&
		m.MinimockFixedByteSizeDone() &&
		m.MinimockFoldToUint64Done() &&
		m.MinimockGetSigningKeyTypeDone() &&
		m.MinimockGetSigningMethodDone() &&
		m.MinimockWriteToDone()
}
