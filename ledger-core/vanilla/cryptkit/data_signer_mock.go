package cryptkit

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// DataSignerMock implements DataSigner
type DataSignerMock struct {
	t minimock.Tester

	funcDigestBytes          func(ba1 []byte) (d1 Digest)
	inspectFuncDigestBytes   func(ba1 []byte)
	afterDigestBytesCounter  uint64
	beforeDigestBytesCounter uint64
	DigestBytesMock          mDataSignerMockDigestBytes

	funcDigestData          func(r1 io.Reader) (d1 Digest)
	inspectFuncDigestData   func(r1 io.Reader)
	afterDigestDataCounter  uint64
	beforeDigestDataCounter uint64
	DigestDataMock          mDataSignerMockDigestData

	funcGetDigestMethod          func() (d1 DigestMethod)
	inspectFuncGetDigestMethod   func()
	afterGetDigestMethodCounter  uint64
	beforeGetDigestMethodCounter uint64
	GetDigestMethodMock          mDataSignerMockGetDigestMethod

	funcGetDigestSize          func() (i1 int)
	inspectFuncGetDigestSize   func()
	afterGetDigestSizeCounter  uint64
	beforeGetDigestSizeCounter uint64
	GetDigestSizeMock          mDataSignerMockGetDigestSize

	funcGetSignatureMethod          func() (s1 SignatureMethod)
	inspectFuncGetSignatureMethod   func()
	afterGetSignatureMethodCounter  uint64
	beforeGetSignatureMethodCounter uint64
	GetSignatureMethodMock          mDataSignerMockGetSignatureMethod

	funcGetSigningMethod          func() (s1 SigningMethod)
	inspectFuncGetSigningMethod   func()
	afterGetSigningMethodCounter  uint64
	beforeGetSigningMethodCounter uint64
	GetSigningMethodMock          mDataSignerMockGetSigningMethod

	funcNewHasher          func() (d1 DigestHasher)
	inspectFuncNewHasher   func()
	afterNewHasherCounter  uint64
	beforeNewHasherCounter uint64
	NewHasherMock          mDataSignerMockNewHasher

	funcSignDigest          func(digest Digest) (s1 Signature)
	inspectFuncSignDigest   func(digest Digest)
	afterSignDigestCounter  uint64
	beforeSignDigestCounter uint64
	SignDigestMock          mDataSignerMockSignDigest
}

// NewDataSignerMock returns a mock for DataSigner
func NewDataSignerMock(t minimock.Tester) *DataSignerMock {
	m := &DataSignerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DigestBytesMock = mDataSignerMockDigestBytes{mock: m}
	m.DigestBytesMock.callArgs = []*DataSignerMockDigestBytesParams{}

	m.DigestDataMock = mDataSignerMockDigestData{mock: m}
	m.DigestDataMock.callArgs = []*DataSignerMockDigestDataParams{}

	m.GetDigestMethodMock = mDataSignerMockGetDigestMethod{mock: m}

	m.GetDigestSizeMock = mDataSignerMockGetDigestSize{mock: m}

	m.GetSignatureMethodMock = mDataSignerMockGetSignatureMethod{mock: m}

	m.GetSigningMethodMock = mDataSignerMockGetSigningMethod{mock: m}

	m.NewHasherMock = mDataSignerMockNewHasher{mock: m}

	m.SignDigestMock = mDataSignerMockSignDigest{mock: m}
	m.SignDigestMock.callArgs = []*DataSignerMockSignDigestParams{}

	return m
}

type mDataSignerMockDigestBytes struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockDigestBytesExpectation
	expectations       []*DataSignerMockDigestBytesExpectation

	callArgs []*DataSignerMockDigestBytesParams
	mutex    sync.RWMutex
}

// DataSignerMockDigestBytesExpectation specifies expectation struct of the DataSigner.DigestBytes
type DataSignerMockDigestBytesExpectation struct {
	mock    *DataSignerMock
	params  *DataSignerMockDigestBytesParams
	results *DataSignerMockDigestBytesResults
	Counter uint64
}

// DataSignerMockDigestBytesParams contains parameters of the DataSigner.DigestBytes
type DataSignerMockDigestBytesParams struct {
	ba1 []byte
}

// DataSignerMockDigestBytesResults contains results of the DataSigner.DigestBytes
type DataSignerMockDigestBytesResults struct {
	d1 Digest
}

// Expect sets up expected params for DataSigner.DigestBytes
func (mmDigestBytes *mDataSignerMockDigestBytes) Expect(ba1 []byte) *mDataSignerMockDigestBytes {
	if mmDigestBytes.mock.funcDigestBytes != nil {
		mmDigestBytes.mock.t.Fatalf("DataSignerMock.DigestBytes mock is already set by Set")
	}

	if mmDigestBytes.defaultExpectation == nil {
		mmDigestBytes.defaultExpectation = &DataSignerMockDigestBytesExpectation{}
	}

	mmDigestBytes.defaultExpectation.params = &DataSignerMockDigestBytesParams{ba1}
	for _, e := range mmDigestBytes.expectations {
		if minimock.Equal(e.params, mmDigestBytes.defaultExpectation.params) {
			mmDigestBytes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDigestBytes.defaultExpectation.params)
		}
	}

	return mmDigestBytes
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.DigestBytes
func (mmDigestBytes *mDataSignerMockDigestBytes) Inspect(f func(ba1 []byte)) *mDataSignerMockDigestBytes {
	if mmDigestBytes.mock.inspectFuncDigestBytes != nil {
		mmDigestBytes.mock.t.Fatalf("Inspect function is already set for DataSignerMock.DigestBytes")
	}

	mmDigestBytes.mock.inspectFuncDigestBytes = f

	return mmDigestBytes
}

// Return sets up results that will be returned by DataSigner.DigestBytes
func (mmDigestBytes *mDataSignerMockDigestBytes) Return(d1 Digest) *DataSignerMock {
	if mmDigestBytes.mock.funcDigestBytes != nil {
		mmDigestBytes.mock.t.Fatalf("DataSignerMock.DigestBytes mock is already set by Set")
	}

	if mmDigestBytes.defaultExpectation == nil {
		mmDigestBytes.defaultExpectation = &DataSignerMockDigestBytesExpectation{mock: mmDigestBytes.mock}
	}
	mmDigestBytes.defaultExpectation.results = &DataSignerMockDigestBytesResults{d1}
	return mmDigestBytes.mock
}

//Set uses given function f to mock the DataSigner.DigestBytes method
func (mmDigestBytes *mDataSignerMockDigestBytes) Set(f func(ba1 []byte) (d1 Digest)) *DataSignerMock {
	if mmDigestBytes.defaultExpectation != nil {
		mmDigestBytes.mock.t.Fatalf("Default expectation is already set for the DataSigner.DigestBytes method")
	}

	if len(mmDigestBytes.expectations) > 0 {
		mmDigestBytes.mock.t.Fatalf("Some expectations are already set for the DataSigner.DigestBytes method")
	}

	mmDigestBytes.mock.funcDigestBytes = f
	return mmDigestBytes.mock
}

// When sets expectation for the DataSigner.DigestBytes which will trigger the result defined by the following
// Then helper
func (mmDigestBytes *mDataSignerMockDigestBytes) When(ba1 []byte) *DataSignerMockDigestBytesExpectation {
	if mmDigestBytes.mock.funcDigestBytes != nil {
		mmDigestBytes.mock.t.Fatalf("DataSignerMock.DigestBytes mock is already set by Set")
	}

	expectation := &DataSignerMockDigestBytesExpectation{
		mock:   mmDigestBytes.mock,
		params: &DataSignerMockDigestBytesParams{ba1},
	}
	mmDigestBytes.expectations = append(mmDigestBytes.expectations, expectation)
	return expectation
}

// Then sets up DataSigner.DigestBytes return parameters for the expectation previously defined by the When method
func (e *DataSignerMockDigestBytesExpectation) Then(d1 Digest) *DataSignerMock {
	e.results = &DataSignerMockDigestBytesResults{d1}
	return e.mock
}

// DigestBytes implements DataSigner
func (mmDigestBytes *DataSignerMock) DigestBytes(ba1 []byte) (d1 Digest) {
	mm_atomic.AddUint64(&mmDigestBytes.beforeDigestBytesCounter, 1)
	defer mm_atomic.AddUint64(&mmDigestBytes.afterDigestBytesCounter, 1)

	if mmDigestBytes.inspectFuncDigestBytes != nil {
		mmDigestBytes.inspectFuncDigestBytes(ba1)
	}

	mm_params := &DataSignerMockDigestBytesParams{ba1}

	// Record call args
	mmDigestBytes.DigestBytesMock.mutex.Lock()
	mmDigestBytes.DigestBytesMock.callArgs = append(mmDigestBytes.DigestBytesMock.callArgs, mm_params)
	mmDigestBytes.DigestBytesMock.mutex.Unlock()

	for _, e := range mmDigestBytes.DigestBytesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.d1
		}
	}

	if mmDigestBytes.DigestBytesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDigestBytes.DigestBytesMock.defaultExpectation.Counter, 1)
		mm_want := mmDigestBytes.DigestBytesMock.defaultExpectation.params
		mm_got := DataSignerMockDigestBytesParams{ba1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDigestBytes.t.Errorf("DataSignerMock.DigestBytes got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDigestBytes.DigestBytesMock.defaultExpectation.results
		if mm_results == nil {
			mmDigestBytes.t.Fatal("No results are set for the DataSignerMock.DigestBytes")
		}
		return (*mm_results).d1
	}
	if mmDigestBytes.funcDigestBytes != nil {
		return mmDigestBytes.funcDigestBytes(ba1)
	}
	mmDigestBytes.t.Fatalf("Unexpected call to DataSignerMock.DigestBytes. %v", ba1)
	return
}

// DigestBytesAfterCounter returns a count of finished DataSignerMock.DigestBytes invocations
func (mmDigestBytes *DataSignerMock) DigestBytesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDigestBytes.afterDigestBytesCounter)
}

// DigestBytesBeforeCounter returns a count of DataSignerMock.DigestBytes invocations
func (mmDigestBytes *DataSignerMock) DigestBytesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDigestBytes.beforeDigestBytesCounter)
}

// Calls returns a list of arguments used in each call to DataSignerMock.DigestBytes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDigestBytes *mDataSignerMockDigestBytes) Calls() []*DataSignerMockDigestBytesParams {
	mmDigestBytes.mutex.RLock()

	argCopy := make([]*DataSignerMockDigestBytesParams, len(mmDigestBytes.callArgs))
	copy(argCopy, mmDigestBytes.callArgs)

	mmDigestBytes.mutex.RUnlock()

	return argCopy
}

// MinimockDigestBytesDone returns true if the count of the DigestBytes invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockDigestBytesDone() bool {
	for _, e := range m.DigestBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DigestBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDigestBytesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDigestBytes != nil && mm_atomic.LoadUint64(&m.afterDigestBytesCounter) < 1 {
		return false
	}
	return true
}

// MinimockDigestBytesInspect logs each unmet expectation
func (m *DataSignerMock) MinimockDigestBytesInspect() {
	for _, e := range m.DigestBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DataSignerMock.DigestBytes with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DigestBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDigestBytesCounter) < 1 {
		if m.DigestBytesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DataSignerMock.DigestBytes")
		} else {
			m.t.Errorf("Expected call to DataSignerMock.DigestBytes with params: %#v", *m.DigestBytesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDigestBytes != nil && mm_atomic.LoadUint64(&m.afterDigestBytesCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.DigestBytes")
	}
}

type mDataSignerMockDigestData struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockDigestDataExpectation
	expectations       []*DataSignerMockDigestDataExpectation

	callArgs []*DataSignerMockDigestDataParams
	mutex    sync.RWMutex
}

// DataSignerMockDigestDataExpectation specifies expectation struct of the DataSigner.DigestData
type DataSignerMockDigestDataExpectation struct {
	mock    *DataSignerMock
	params  *DataSignerMockDigestDataParams
	results *DataSignerMockDigestDataResults
	Counter uint64
}

// DataSignerMockDigestDataParams contains parameters of the DataSigner.DigestData
type DataSignerMockDigestDataParams struct {
	r1 io.Reader
}

// DataSignerMockDigestDataResults contains results of the DataSigner.DigestData
type DataSignerMockDigestDataResults struct {
	d1 Digest
}

// Expect sets up expected params for DataSigner.DigestData
func (mmDigestData *mDataSignerMockDigestData) Expect(r1 io.Reader) *mDataSignerMockDigestData {
	if mmDigestData.mock.funcDigestData != nil {
		mmDigestData.mock.t.Fatalf("DataSignerMock.DigestData mock is already set by Set")
	}

	if mmDigestData.defaultExpectation == nil {
		mmDigestData.defaultExpectation = &DataSignerMockDigestDataExpectation{}
	}

	mmDigestData.defaultExpectation.params = &DataSignerMockDigestDataParams{r1}
	for _, e := range mmDigestData.expectations {
		if minimock.Equal(e.params, mmDigestData.defaultExpectation.params) {
			mmDigestData.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDigestData.defaultExpectation.params)
		}
	}

	return mmDigestData
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.DigestData
func (mmDigestData *mDataSignerMockDigestData) Inspect(f func(r1 io.Reader)) *mDataSignerMockDigestData {
	if mmDigestData.mock.inspectFuncDigestData != nil {
		mmDigestData.mock.t.Fatalf("Inspect function is already set for DataSignerMock.DigestData")
	}

	mmDigestData.mock.inspectFuncDigestData = f

	return mmDigestData
}

// Return sets up results that will be returned by DataSigner.DigestData
func (mmDigestData *mDataSignerMockDigestData) Return(d1 Digest) *DataSignerMock {
	if mmDigestData.mock.funcDigestData != nil {
		mmDigestData.mock.t.Fatalf("DataSignerMock.DigestData mock is already set by Set")
	}

	if mmDigestData.defaultExpectation == nil {
		mmDigestData.defaultExpectation = &DataSignerMockDigestDataExpectation{mock: mmDigestData.mock}
	}
	mmDigestData.defaultExpectation.results = &DataSignerMockDigestDataResults{d1}
	return mmDigestData.mock
}

//Set uses given function f to mock the DataSigner.DigestData method
func (mmDigestData *mDataSignerMockDigestData) Set(f func(r1 io.Reader) (d1 Digest)) *DataSignerMock {
	if mmDigestData.defaultExpectation != nil {
		mmDigestData.mock.t.Fatalf("Default expectation is already set for the DataSigner.DigestData method")
	}

	if len(mmDigestData.expectations) > 0 {
		mmDigestData.mock.t.Fatalf("Some expectations are already set for the DataSigner.DigestData method")
	}

	mmDigestData.mock.funcDigestData = f
	return mmDigestData.mock
}

// When sets expectation for the DataSigner.DigestData which will trigger the result defined by the following
// Then helper
func (mmDigestData *mDataSignerMockDigestData) When(r1 io.Reader) *DataSignerMockDigestDataExpectation {
	if mmDigestData.mock.funcDigestData != nil {
		mmDigestData.mock.t.Fatalf("DataSignerMock.DigestData mock is already set by Set")
	}

	expectation := &DataSignerMockDigestDataExpectation{
		mock:   mmDigestData.mock,
		params: &DataSignerMockDigestDataParams{r1},
	}
	mmDigestData.expectations = append(mmDigestData.expectations, expectation)
	return expectation
}

// Then sets up DataSigner.DigestData return parameters for the expectation previously defined by the When method
func (e *DataSignerMockDigestDataExpectation) Then(d1 Digest) *DataSignerMock {
	e.results = &DataSignerMockDigestDataResults{d1}
	return e.mock
}

// DigestData implements DataSigner
func (mmDigestData *DataSignerMock) DigestData(r1 io.Reader) (d1 Digest) {
	mm_atomic.AddUint64(&mmDigestData.beforeDigestDataCounter, 1)
	defer mm_atomic.AddUint64(&mmDigestData.afterDigestDataCounter, 1)

	if mmDigestData.inspectFuncDigestData != nil {
		mmDigestData.inspectFuncDigestData(r1)
	}

	mm_params := &DataSignerMockDigestDataParams{r1}

	// Record call args
	mmDigestData.DigestDataMock.mutex.Lock()
	mmDigestData.DigestDataMock.callArgs = append(mmDigestData.DigestDataMock.callArgs, mm_params)
	mmDigestData.DigestDataMock.mutex.Unlock()

	for _, e := range mmDigestData.DigestDataMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.d1
		}
	}

	if mmDigestData.DigestDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDigestData.DigestDataMock.defaultExpectation.Counter, 1)
		mm_want := mmDigestData.DigestDataMock.defaultExpectation.params
		mm_got := DataSignerMockDigestDataParams{r1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDigestData.t.Errorf("DataSignerMock.DigestData got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDigestData.DigestDataMock.defaultExpectation.results
		if mm_results == nil {
			mmDigestData.t.Fatal("No results are set for the DataSignerMock.DigestData")
		}
		return (*mm_results).d1
	}
	if mmDigestData.funcDigestData != nil {
		return mmDigestData.funcDigestData(r1)
	}
	mmDigestData.t.Fatalf("Unexpected call to DataSignerMock.DigestData. %v", r1)
	return
}

// DigestDataAfterCounter returns a count of finished DataSignerMock.DigestData invocations
func (mmDigestData *DataSignerMock) DigestDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDigestData.afterDigestDataCounter)
}

// DigestDataBeforeCounter returns a count of DataSignerMock.DigestData invocations
func (mmDigestData *DataSignerMock) DigestDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDigestData.beforeDigestDataCounter)
}

// Calls returns a list of arguments used in each call to DataSignerMock.DigestData.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDigestData *mDataSignerMockDigestData) Calls() []*DataSignerMockDigestDataParams {
	mmDigestData.mutex.RLock()

	argCopy := make([]*DataSignerMockDigestDataParams, len(mmDigestData.callArgs))
	copy(argCopy, mmDigestData.callArgs)

	mmDigestData.mutex.RUnlock()

	return argCopy
}

// MinimockDigestDataDone returns true if the count of the DigestData invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockDigestDataDone() bool {
	for _, e := range m.DigestDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DigestDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDigestDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDigestData != nil && mm_atomic.LoadUint64(&m.afterDigestDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockDigestDataInspect logs each unmet expectation
func (m *DataSignerMock) MinimockDigestDataInspect() {
	for _, e := range m.DigestDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DataSignerMock.DigestData with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DigestDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDigestDataCounter) < 1 {
		if m.DigestDataMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DataSignerMock.DigestData")
		} else {
			m.t.Errorf("Expected call to DataSignerMock.DigestData with params: %#v", *m.DigestDataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDigestData != nil && mm_atomic.LoadUint64(&m.afterDigestDataCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.DigestData")
	}
}

type mDataSignerMockGetDigestMethod struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockGetDigestMethodExpectation
	expectations       []*DataSignerMockGetDigestMethodExpectation
}

// DataSignerMockGetDigestMethodExpectation specifies expectation struct of the DataSigner.GetDigestMethod
type DataSignerMockGetDigestMethodExpectation struct {
	mock *DataSignerMock

	results *DataSignerMockGetDigestMethodResults
	Counter uint64
}

// DataSignerMockGetDigestMethodResults contains results of the DataSigner.GetDigestMethod
type DataSignerMockGetDigestMethodResults struct {
	d1 DigestMethod
}

// Expect sets up expected params for DataSigner.GetDigestMethod
func (mmGetDigestMethod *mDataSignerMockGetDigestMethod) Expect() *mDataSignerMockGetDigestMethod {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("DataSignerMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &DataSignerMockGetDigestMethodExpectation{}
	}

	return mmGetDigestMethod
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.GetDigestMethod
func (mmGetDigestMethod *mDataSignerMockGetDigestMethod) Inspect(f func()) *mDataSignerMockGetDigestMethod {
	if mmGetDigestMethod.mock.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("Inspect function is already set for DataSignerMock.GetDigestMethod")
	}

	mmGetDigestMethod.mock.inspectFuncGetDigestMethod = f

	return mmGetDigestMethod
}

// Return sets up results that will be returned by DataSigner.GetDigestMethod
func (mmGetDigestMethod *mDataSignerMockGetDigestMethod) Return(d1 DigestMethod) *DataSignerMock {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("DataSignerMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &DataSignerMockGetDigestMethodExpectation{mock: mmGetDigestMethod.mock}
	}
	mmGetDigestMethod.defaultExpectation.results = &DataSignerMockGetDigestMethodResults{d1}
	return mmGetDigestMethod.mock
}

//Set uses given function f to mock the DataSigner.GetDigestMethod method
func (mmGetDigestMethod *mDataSignerMockGetDigestMethod) Set(f func() (d1 DigestMethod)) *DataSignerMock {
	if mmGetDigestMethod.defaultExpectation != nil {
		mmGetDigestMethod.mock.t.Fatalf("Default expectation is already set for the DataSigner.GetDigestMethod method")
	}

	if len(mmGetDigestMethod.expectations) > 0 {
		mmGetDigestMethod.mock.t.Fatalf("Some expectations are already set for the DataSigner.GetDigestMethod method")
	}

	mmGetDigestMethod.mock.funcGetDigestMethod = f
	return mmGetDigestMethod.mock
}

// GetDigestMethod implements DataSigner
func (mmGetDigestMethod *DataSignerMock) GetDigestMethod() (d1 DigestMethod) {
	mm_atomic.AddUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestMethod.afterGetDigestMethodCounter, 1)

	if mmGetDigestMethod.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.inspectFuncGetDigestMethod()
	}

	if mmGetDigestMethod.GetDigestMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDigestMethod.t.Fatal("No results are set for the DataSignerMock.GetDigestMethod")
		}
		return (*mm_results).d1
	}
	if mmGetDigestMethod.funcGetDigestMethod != nil {
		return mmGetDigestMethod.funcGetDigestMethod()
	}
	mmGetDigestMethod.t.Fatalf("Unexpected call to DataSignerMock.GetDigestMethod.")
	return
}

// GetDigestMethodAfterCounter returns a count of finished DataSignerMock.GetDigestMethod invocations
func (mmGetDigestMethod *DataSignerMock) GetDigestMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.afterGetDigestMethodCounter)
}

// GetDigestMethodBeforeCounter returns a count of DataSignerMock.GetDigestMethod invocations
func (mmGetDigestMethod *DataSignerMock) GetDigestMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter)
}

// MinimockGetDigestMethodDone returns true if the count of the GetDigestMethod invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockGetDigestMethodDone() bool {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestMethodInspect logs each unmet expectation
func (m *DataSignerMock) MinimockGetDigestMethodInspect() {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DataSignerMock.GetDigestMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetDigestMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetDigestMethod")
	}
}

type mDataSignerMockGetDigestSize struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockGetDigestSizeExpectation
	expectations       []*DataSignerMockGetDigestSizeExpectation
}

// DataSignerMockGetDigestSizeExpectation specifies expectation struct of the DataSigner.GetDigestSize
type DataSignerMockGetDigestSizeExpectation struct {
	mock *DataSignerMock

	results *DataSignerMockGetDigestSizeResults
	Counter uint64
}

// DataSignerMockGetDigestSizeResults contains results of the DataSigner.GetDigestSize
type DataSignerMockGetDigestSizeResults struct {
	i1 int
}

// Expect sets up expected params for DataSigner.GetDigestSize
func (mmGetDigestSize *mDataSignerMockGetDigestSize) Expect() *mDataSignerMockGetDigestSize {
	if mmGetDigestSize.mock.funcGetDigestSize != nil {
		mmGetDigestSize.mock.t.Fatalf("DataSignerMock.GetDigestSize mock is already set by Set")
	}

	if mmGetDigestSize.defaultExpectation == nil {
		mmGetDigestSize.defaultExpectation = &DataSignerMockGetDigestSizeExpectation{}
	}

	return mmGetDigestSize
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.GetDigestSize
func (mmGetDigestSize *mDataSignerMockGetDigestSize) Inspect(f func()) *mDataSignerMockGetDigestSize {
	if mmGetDigestSize.mock.inspectFuncGetDigestSize != nil {
		mmGetDigestSize.mock.t.Fatalf("Inspect function is already set for DataSignerMock.GetDigestSize")
	}

	mmGetDigestSize.mock.inspectFuncGetDigestSize = f

	return mmGetDigestSize
}

// Return sets up results that will be returned by DataSigner.GetDigestSize
func (mmGetDigestSize *mDataSignerMockGetDigestSize) Return(i1 int) *DataSignerMock {
	if mmGetDigestSize.mock.funcGetDigestSize != nil {
		mmGetDigestSize.mock.t.Fatalf("DataSignerMock.GetDigestSize mock is already set by Set")
	}

	if mmGetDigestSize.defaultExpectation == nil {
		mmGetDigestSize.defaultExpectation = &DataSignerMockGetDigestSizeExpectation{mock: mmGetDigestSize.mock}
	}
	mmGetDigestSize.defaultExpectation.results = &DataSignerMockGetDigestSizeResults{i1}
	return mmGetDigestSize.mock
}

//Set uses given function f to mock the DataSigner.GetDigestSize method
func (mmGetDigestSize *mDataSignerMockGetDigestSize) Set(f func() (i1 int)) *DataSignerMock {
	if mmGetDigestSize.defaultExpectation != nil {
		mmGetDigestSize.mock.t.Fatalf("Default expectation is already set for the DataSigner.GetDigestSize method")
	}

	if len(mmGetDigestSize.expectations) > 0 {
		mmGetDigestSize.mock.t.Fatalf("Some expectations are already set for the DataSigner.GetDigestSize method")
	}

	mmGetDigestSize.mock.funcGetDigestSize = f
	return mmGetDigestSize.mock
}

// GetDigestSize implements DataSigner
func (mmGetDigestSize *DataSignerMock) GetDigestSize() (i1 int) {
	mm_atomic.AddUint64(&mmGetDigestSize.beforeGetDigestSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestSize.afterGetDigestSizeCounter, 1)

	if mmGetDigestSize.inspectFuncGetDigestSize != nil {
		mmGetDigestSize.inspectFuncGetDigestSize()
	}

	if mmGetDigestSize.GetDigestSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestSize.GetDigestSizeMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDigestSize.GetDigestSizeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDigestSize.t.Fatal("No results are set for the DataSignerMock.GetDigestSize")
		}
		return (*mm_results).i1
	}
	if mmGetDigestSize.funcGetDigestSize != nil {
		return mmGetDigestSize.funcGetDigestSize()
	}
	mmGetDigestSize.t.Fatalf("Unexpected call to DataSignerMock.GetDigestSize.")
	return
}

// GetDigestSizeAfterCounter returns a count of finished DataSignerMock.GetDigestSize invocations
func (mmGetDigestSize *DataSignerMock) GetDigestSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestSize.afterGetDigestSizeCounter)
}

// GetDigestSizeBeforeCounter returns a count of DataSignerMock.GetDigestSize invocations
func (mmGetDigestSize *DataSignerMock) GetDigestSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestSize.beforeGetDigestSizeCounter)
}

// MinimockGetDigestSizeDone returns true if the count of the GetDigestSize invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockGetDigestSizeDone() bool {
	for _, e := range m.GetDigestSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestSize != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestSizeInspect logs each unmet expectation
func (m *DataSignerMock) MinimockGetDigestSizeInspect() {
	for _, e := range m.GetDigestSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DataSignerMock.GetDigestSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetDigestSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestSize != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetDigestSize")
	}
}

type mDataSignerMockGetSignatureMethod struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockGetSignatureMethodExpectation
	expectations       []*DataSignerMockGetSignatureMethodExpectation
}

// DataSignerMockGetSignatureMethodExpectation specifies expectation struct of the DataSigner.GetSignatureMethod
type DataSignerMockGetSignatureMethodExpectation struct {
	mock *DataSignerMock

	results *DataSignerMockGetSignatureMethodResults
	Counter uint64
}

// DataSignerMockGetSignatureMethodResults contains results of the DataSigner.GetSignatureMethod
type DataSignerMockGetSignatureMethodResults struct {
	s1 SignatureMethod
}

// Expect sets up expected params for DataSigner.GetSignatureMethod
func (mmGetSignatureMethod *mDataSignerMockGetSignatureMethod) Expect() *mDataSignerMockGetSignatureMethod {
	if mmGetSignatureMethod.mock.funcGetSignatureMethod != nil {
		mmGetSignatureMethod.mock.t.Fatalf("DataSignerMock.GetSignatureMethod mock is already set by Set")
	}

	if mmGetSignatureMethod.defaultExpectation == nil {
		mmGetSignatureMethod.defaultExpectation = &DataSignerMockGetSignatureMethodExpectation{}
	}

	return mmGetSignatureMethod
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.GetSignatureMethod
func (mmGetSignatureMethod *mDataSignerMockGetSignatureMethod) Inspect(f func()) *mDataSignerMockGetSignatureMethod {
	if mmGetSignatureMethod.mock.inspectFuncGetSignatureMethod != nil {
		mmGetSignatureMethod.mock.t.Fatalf("Inspect function is already set for DataSignerMock.GetSignatureMethod")
	}

	mmGetSignatureMethod.mock.inspectFuncGetSignatureMethod = f

	return mmGetSignatureMethod
}

// Return sets up results that will be returned by DataSigner.GetSignatureMethod
func (mmGetSignatureMethod *mDataSignerMockGetSignatureMethod) Return(s1 SignatureMethod) *DataSignerMock {
	if mmGetSignatureMethod.mock.funcGetSignatureMethod != nil {
		mmGetSignatureMethod.mock.t.Fatalf("DataSignerMock.GetSignatureMethod mock is already set by Set")
	}

	if mmGetSignatureMethod.defaultExpectation == nil {
		mmGetSignatureMethod.defaultExpectation = &DataSignerMockGetSignatureMethodExpectation{mock: mmGetSignatureMethod.mock}
	}
	mmGetSignatureMethod.defaultExpectation.results = &DataSignerMockGetSignatureMethodResults{s1}
	return mmGetSignatureMethod.mock
}

//Set uses given function f to mock the DataSigner.GetSignatureMethod method
func (mmGetSignatureMethod *mDataSignerMockGetSignatureMethod) Set(f func() (s1 SignatureMethod)) *DataSignerMock {
	if mmGetSignatureMethod.defaultExpectation != nil {
		mmGetSignatureMethod.mock.t.Fatalf("Default expectation is already set for the DataSigner.GetSignatureMethod method")
	}

	if len(mmGetSignatureMethod.expectations) > 0 {
		mmGetSignatureMethod.mock.t.Fatalf("Some expectations are already set for the DataSigner.GetSignatureMethod method")
	}

	mmGetSignatureMethod.mock.funcGetSignatureMethod = f
	return mmGetSignatureMethod.mock
}

// GetSignatureMethod implements DataSigner
func (mmGetSignatureMethod *DataSignerMock) GetSignatureMethod() (s1 SignatureMethod) {
	mm_atomic.AddUint64(&mmGetSignatureMethod.beforeGetSignatureMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSignatureMethod.afterGetSignatureMethodCounter, 1)

	if mmGetSignatureMethod.inspectFuncGetSignatureMethod != nil {
		mmGetSignatureMethod.inspectFuncGetSignatureMethod()
	}

	if mmGetSignatureMethod.GetSignatureMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSignatureMethod.GetSignatureMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetSignatureMethod.GetSignatureMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSignatureMethod.t.Fatal("No results are set for the DataSignerMock.GetSignatureMethod")
		}
		return (*mm_results).s1
	}
	if mmGetSignatureMethod.funcGetSignatureMethod != nil {
		return mmGetSignatureMethod.funcGetSignatureMethod()
	}
	mmGetSignatureMethod.t.Fatalf("Unexpected call to DataSignerMock.GetSignatureMethod.")
	return
}

// GetSignatureMethodAfterCounter returns a count of finished DataSignerMock.GetSignatureMethod invocations
func (mmGetSignatureMethod *DataSignerMock) GetSignatureMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureMethod.afterGetSignatureMethodCounter)
}

// GetSignatureMethodBeforeCounter returns a count of DataSignerMock.GetSignatureMethod invocations
func (mmGetSignatureMethod *DataSignerMock) GetSignatureMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureMethod.beforeGetSignatureMethodCounter)
}

// MinimockGetSignatureMethodDone returns true if the count of the GetSignatureMethod invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockGetSignatureMethodDone() bool {
	for _, e := range m.GetSignatureMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSignatureMethodInspect logs each unmet expectation
func (m *DataSignerMock) MinimockGetSignatureMethodInspect() {
	for _, e := range m.GetSignatureMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DataSignerMock.GetSignatureMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetSignatureMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetSignatureMethod")
	}
}

type mDataSignerMockGetSigningMethod struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockGetSigningMethodExpectation
	expectations       []*DataSignerMockGetSigningMethodExpectation
}

// DataSignerMockGetSigningMethodExpectation specifies expectation struct of the DataSigner.GetSigningMethod
type DataSignerMockGetSigningMethodExpectation struct {
	mock *DataSignerMock

	results *DataSignerMockGetSigningMethodResults
	Counter uint64
}

// DataSignerMockGetSigningMethodResults contains results of the DataSigner.GetSigningMethod
type DataSignerMockGetSigningMethodResults struct {
	s1 SigningMethod
}

// Expect sets up expected params for DataSigner.GetSigningMethod
func (mmGetSigningMethod *mDataSignerMockGetSigningMethod) Expect() *mDataSignerMockGetSigningMethod {
	if mmGetSigningMethod.mock.funcGetSigningMethod != nil {
		mmGetSigningMethod.mock.t.Fatalf("DataSignerMock.GetSigningMethod mock is already set by Set")
	}

	if mmGetSigningMethod.defaultExpectation == nil {
		mmGetSigningMethod.defaultExpectation = &DataSignerMockGetSigningMethodExpectation{}
	}

	return mmGetSigningMethod
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.GetSigningMethod
func (mmGetSigningMethod *mDataSignerMockGetSigningMethod) Inspect(f func()) *mDataSignerMockGetSigningMethod {
	if mmGetSigningMethod.mock.inspectFuncGetSigningMethod != nil {
		mmGetSigningMethod.mock.t.Fatalf("Inspect function is already set for DataSignerMock.GetSigningMethod")
	}

	mmGetSigningMethod.mock.inspectFuncGetSigningMethod = f

	return mmGetSigningMethod
}

// Return sets up results that will be returned by DataSigner.GetSigningMethod
func (mmGetSigningMethod *mDataSignerMockGetSigningMethod) Return(s1 SigningMethod) *DataSignerMock {
	if mmGetSigningMethod.mock.funcGetSigningMethod != nil {
		mmGetSigningMethod.mock.t.Fatalf("DataSignerMock.GetSigningMethod mock is already set by Set")
	}

	if mmGetSigningMethod.defaultExpectation == nil {
		mmGetSigningMethod.defaultExpectation = &DataSignerMockGetSigningMethodExpectation{mock: mmGetSigningMethod.mock}
	}
	mmGetSigningMethod.defaultExpectation.results = &DataSignerMockGetSigningMethodResults{s1}
	return mmGetSigningMethod.mock
}

//Set uses given function f to mock the DataSigner.GetSigningMethod method
func (mmGetSigningMethod *mDataSignerMockGetSigningMethod) Set(f func() (s1 SigningMethod)) *DataSignerMock {
	if mmGetSigningMethod.defaultExpectation != nil {
		mmGetSigningMethod.mock.t.Fatalf("Default expectation is already set for the DataSigner.GetSigningMethod method")
	}

	if len(mmGetSigningMethod.expectations) > 0 {
		mmGetSigningMethod.mock.t.Fatalf("Some expectations are already set for the DataSigner.GetSigningMethod method")
	}

	mmGetSigningMethod.mock.funcGetSigningMethod = f
	return mmGetSigningMethod.mock
}

// GetSigningMethod implements DataSigner
func (mmGetSigningMethod *DataSignerMock) GetSigningMethod() (s1 SigningMethod) {
	mm_atomic.AddUint64(&mmGetSigningMethod.beforeGetSigningMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSigningMethod.afterGetSigningMethodCounter, 1)

	if mmGetSigningMethod.inspectFuncGetSigningMethod != nil {
		mmGetSigningMethod.inspectFuncGetSigningMethod()
	}

	if mmGetSigningMethod.GetSigningMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSigningMethod.GetSigningMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetSigningMethod.GetSigningMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSigningMethod.t.Fatal("No results are set for the DataSignerMock.GetSigningMethod")
		}
		return (*mm_results).s1
	}
	if mmGetSigningMethod.funcGetSigningMethod != nil {
		return mmGetSigningMethod.funcGetSigningMethod()
	}
	mmGetSigningMethod.t.Fatalf("Unexpected call to DataSignerMock.GetSigningMethod.")
	return
}

// GetSigningMethodAfterCounter returns a count of finished DataSignerMock.GetSigningMethod invocations
func (mmGetSigningMethod *DataSignerMock) GetSigningMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSigningMethod.afterGetSigningMethodCounter)
}

// GetSigningMethodBeforeCounter returns a count of DataSignerMock.GetSigningMethod invocations
func (mmGetSigningMethod *DataSignerMock) GetSigningMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSigningMethod.beforeGetSigningMethodCounter)
}

// MinimockGetSigningMethodDone returns true if the count of the GetSigningMethod invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockGetSigningMethodDone() bool {
	for _, e := range m.GetSigningMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSigningMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSigningMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSigningMethod != nil && mm_atomic.LoadUint64(&m.afterGetSigningMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSigningMethodInspect logs each unmet expectation
func (m *DataSignerMock) MinimockGetSigningMethodInspect() {
	for _, e := range m.GetSigningMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DataSignerMock.GetSigningMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSigningMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSigningMethodCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetSigningMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSigningMethod != nil && mm_atomic.LoadUint64(&m.afterGetSigningMethodCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetSigningMethod")
	}
}

type mDataSignerMockNewHasher struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockNewHasherExpectation
	expectations       []*DataSignerMockNewHasherExpectation
}

// DataSignerMockNewHasherExpectation specifies expectation struct of the DataSigner.NewHasher
type DataSignerMockNewHasherExpectation struct {
	mock *DataSignerMock

	results *DataSignerMockNewHasherResults
	Counter uint64
}

// DataSignerMockNewHasherResults contains results of the DataSigner.NewHasher
type DataSignerMockNewHasherResults struct {
	d1 DigestHasher
}

// Expect sets up expected params for DataSigner.NewHasher
func (mmNewHasher *mDataSignerMockNewHasher) Expect() *mDataSignerMockNewHasher {
	if mmNewHasher.mock.funcNewHasher != nil {
		mmNewHasher.mock.t.Fatalf("DataSignerMock.NewHasher mock is already set by Set")
	}

	if mmNewHasher.defaultExpectation == nil {
		mmNewHasher.defaultExpectation = &DataSignerMockNewHasherExpectation{}
	}

	return mmNewHasher
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.NewHasher
func (mmNewHasher *mDataSignerMockNewHasher) Inspect(f func()) *mDataSignerMockNewHasher {
	if mmNewHasher.mock.inspectFuncNewHasher != nil {
		mmNewHasher.mock.t.Fatalf("Inspect function is already set for DataSignerMock.NewHasher")
	}

	mmNewHasher.mock.inspectFuncNewHasher = f

	return mmNewHasher
}

// Return sets up results that will be returned by DataSigner.NewHasher
func (mmNewHasher *mDataSignerMockNewHasher) Return(d1 DigestHasher) *DataSignerMock {
	if mmNewHasher.mock.funcNewHasher != nil {
		mmNewHasher.mock.t.Fatalf("DataSignerMock.NewHasher mock is already set by Set")
	}

	if mmNewHasher.defaultExpectation == nil {
		mmNewHasher.defaultExpectation = &DataSignerMockNewHasherExpectation{mock: mmNewHasher.mock}
	}
	mmNewHasher.defaultExpectation.results = &DataSignerMockNewHasherResults{d1}
	return mmNewHasher.mock
}

//Set uses given function f to mock the DataSigner.NewHasher method
func (mmNewHasher *mDataSignerMockNewHasher) Set(f func() (d1 DigestHasher)) *DataSignerMock {
	if mmNewHasher.defaultExpectation != nil {
		mmNewHasher.mock.t.Fatalf("Default expectation is already set for the DataSigner.NewHasher method")
	}

	if len(mmNewHasher.expectations) > 0 {
		mmNewHasher.mock.t.Fatalf("Some expectations are already set for the DataSigner.NewHasher method")
	}

	mmNewHasher.mock.funcNewHasher = f
	return mmNewHasher.mock
}

// NewHasher implements DataSigner
func (mmNewHasher *DataSignerMock) NewHasher() (d1 DigestHasher) {
	mm_atomic.AddUint64(&mmNewHasher.beforeNewHasherCounter, 1)
	defer mm_atomic.AddUint64(&mmNewHasher.afterNewHasherCounter, 1)

	if mmNewHasher.inspectFuncNewHasher != nil {
		mmNewHasher.inspectFuncNewHasher()
	}

	if mmNewHasher.NewHasherMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewHasher.NewHasherMock.defaultExpectation.Counter, 1)

		mm_results := mmNewHasher.NewHasherMock.defaultExpectation.results
		if mm_results == nil {
			mmNewHasher.t.Fatal("No results are set for the DataSignerMock.NewHasher")
		}
		return (*mm_results).d1
	}
	if mmNewHasher.funcNewHasher != nil {
		return mmNewHasher.funcNewHasher()
	}
	mmNewHasher.t.Fatalf("Unexpected call to DataSignerMock.NewHasher.")
	return
}

// NewHasherAfterCounter returns a count of finished DataSignerMock.NewHasher invocations
func (mmNewHasher *DataSignerMock) NewHasherAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewHasher.afterNewHasherCounter)
}

// NewHasherBeforeCounter returns a count of DataSignerMock.NewHasher invocations
func (mmNewHasher *DataSignerMock) NewHasherBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewHasher.beforeNewHasherCounter)
}

// MinimockNewHasherDone returns true if the count of the NewHasher invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockNewHasherDone() bool {
	for _, e := range m.NewHasherMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewHasherMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewHasherCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewHasher != nil && mm_atomic.LoadUint64(&m.afterNewHasherCounter) < 1 {
		return false
	}
	return true
}

// MinimockNewHasherInspect logs each unmet expectation
func (m *DataSignerMock) MinimockNewHasherInspect() {
	for _, e := range m.NewHasherMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DataSignerMock.NewHasher")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewHasherMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewHasherCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.NewHasher")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewHasher != nil && mm_atomic.LoadUint64(&m.afterNewHasherCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.NewHasher")
	}
}

type mDataSignerMockSignDigest struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockSignDigestExpectation
	expectations       []*DataSignerMockSignDigestExpectation

	callArgs []*DataSignerMockSignDigestParams
	mutex    sync.RWMutex
}

// DataSignerMockSignDigestExpectation specifies expectation struct of the DataSigner.SignDigest
type DataSignerMockSignDigestExpectation struct {
	mock    *DataSignerMock
	params  *DataSignerMockSignDigestParams
	results *DataSignerMockSignDigestResults
	Counter uint64
}

// DataSignerMockSignDigestParams contains parameters of the DataSigner.SignDigest
type DataSignerMockSignDigestParams struct {
	digest Digest
}

// DataSignerMockSignDigestResults contains results of the DataSigner.SignDigest
type DataSignerMockSignDigestResults struct {
	s1 Signature
}

// Expect sets up expected params for DataSigner.SignDigest
func (mmSignDigest *mDataSignerMockSignDigest) Expect(digest Digest) *mDataSignerMockSignDigest {
	if mmSignDigest.mock.funcSignDigest != nil {
		mmSignDigest.mock.t.Fatalf("DataSignerMock.SignDigest mock is already set by Set")
	}

	if mmSignDigest.defaultExpectation == nil {
		mmSignDigest.defaultExpectation = &DataSignerMockSignDigestExpectation{}
	}

	mmSignDigest.defaultExpectation.params = &DataSignerMockSignDigestParams{digest}
	for _, e := range mmSignDigest.expectations {
		if minimock.Equal(e.params, mmSignDigest.defaultExpectation.params) {
			mmSignDigest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSignDigest.defaultExpectation.params)
		}
	}

	return mmSignDigest
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.SignDigest
func (mmSignDigest *mDataSignerMockSignDigest) Inspect(f func(digest Digest)) *mDataSignerMockSignDigest {
	if mmSignDigest.mock.inspectFuncSignDigest != nil {
		mmSignDigest.mock.t.Fatalf("Inspect function is already set for DataSignerMock.SignDigest")
	}

	mmSignDigest.mock.inspectFuncSignDigest = f

	return mmSignDigest
}

// Return sets up results that will be returned by DataSigner.SignDigest
func (mmSignDigest *mDataSignerMockSignDigest) Return(s1 Signature) *DataSignerMock {
	if mmSignDigest.mock.funcSignDigest != nil {
		mmSignDigest.mock.t.Fatalf("DataSignerMock.SignDigest mock is already set by Set")
	}

	if mmSignDigest.defaultExpectation == nil {
		mmSignDigest.defaultExpectation = &DataSignerMockSignDigestExpectation{mock: mmSignDigest.mock}
	}
	mmSignDigest.defaultExpectation.results = &DataSignerMockSignDigestResults{s1}
	return mmSignDigest.mock
}

//Set uses given function f to mock the DataSigner.SignDigest method
func (mmSignDigest *mDataSignerMockSignDigest) Set(f func(digest Digest) (s1 Signature)) *DataSignerMock {
	if mmSignDigest.defaultExpectation != nil {
		mmSignDigest.mock.t.Fatalf("Default expectation is already set for the DataSigner.SignDigest method")
	}

	if len(mmSignDigest.expectations) > 0 {
		mmSignDigest.mock.t.Fatalf("Some expectations are already set for the DataSigner.SignDigest method")
	}

	mmSignDigest.mock.funcSignDigest = f
	return mmSignDigest.mock
}

// When sets expectation for the DataSigner.SignDigest which will trigger the result defined by the following
// Then helper
func (mmSignDigest *mDataSignerMockSignDigest) When(digest Digest) *DataSignerMockSignDigestExpectation {
	if mmSignDigest.mock.funcSignDigest != nil {
		mmSignDigest.mock.t.Fatalf("DataSignerMock.SignDigest mock is already set by Set")
	}

	expectation := &DataSignerMockSignDigestExpectation{
		mock:   mmSignDigest.mock,
		params: &DataSignerMockSignDigestParams{digest},
	}
	mmSignDigest.expectations = append(mmSignDigest.expectations, expectation)
	return expectation
}

// Then sets up DataSigner.SignDigest return parameters for the expectation previously defined by the When method
func (e *DataSignerMockSignDigestExpectation) Then(s1 Signature) *DataSignerMock {
	e.results = &DataSignerMockSignDigestResults{s1}
	return e.mock
}

// SignDigest implements DataSigner
func (mmSignDigest *DataSignerMock) SignDigest(digest Digest) (s1 Signature) {
	mm_atomic.AddUint64(&mmSignDigest.beforeSignDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmSignDigest.afterSignDigestCounter, 1)

	if mmSignDigest.inspectFuncSignDigest != nil {
		mmSignDigest.inspectFuncSignDigest(digest)
	}

	mm_params := &DataSignerMockSignDigestParams{digest}

	// Record call args
	mmSignDigest.SignDigestMock.mutex.Lock()
	mmSignDigest.SignDigestMock.callArgs = append(mmSignDigest.SignDigestMock.callArgs, mm_params)
	mmSignDigest.SignDigestMock.mutex.Unlock()

	for _, e := range mmSignDigest.SignDigestMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSignDigest.SignDigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSignDigest.SignDigestMock.defaultExpectation.Counter, 1)
		mm_want := mmSignDigest.SignDigestMock.defaultExpectation.params
		mm_got := DataSignerMockSignDigestParams{digest}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSignDigest.t.Errorf("DataSignerMock.SignDigest got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSignDigest.SignDigestMock.defaultExpectation.results
		if mm_results == nil {
			mmSignDigest.t.Fatal("No results are set for the DataSignerMock.SignDigest")
		}
		return (*mm_results).s1
	}
	if mmSignDigest.funcSignDigest != nil {
		return mmSignDigest.funcSignDigest(digest)
	}
	mmSignDigest.t.Fatalf("Unexpected call to DataSignerMock.SignDigest. %v", digest)
	return
}

// SignDigestAfterCounter returns a count of finished DataSignerMock.SignDigest invocations
func (mmSignDigest *DataSignerMock) SignDigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignDigest.afterSignDigestCounter)
}

// SignDigestBeforeCounter returns a count of DataSignerMock.SignDigest invocations
func (mmSignDigest *DataSignerMock) SignDigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignDigest.beforeSignDigestCounter)
}

// Calls returns a list of arguments used in each call to DataSignerMock.SignDigest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSignDigest *mDataSignerMockSignDigest) Calls() []*DataSignerMockSignDigestParams {
	mmSignDigest.mutex.RLock()

	argCopy := make([]*DataSignerMockSignDigestParams, len(mmSignDigest.callArgs))
	copy(argCopy, mmSignDigest.callArgs)

	mmSignDigest.mutex.RUnlock()

	return argCopy
}

// MinimockSignDigestDone returns true if the count of the SignDigest invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockSignDigestDone() bool {
	for _, e := range m.SignDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignDigestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignDigestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignDigest != nil && mm_atomic.LoadUint64(&m.afterSignDigestCounter) < 1 {
		return false
	}
	return true
}

// MinimockSignDigestInspect logs each unmet expectation
func (m *DataSignerMock) MinimockSignDigestInspect() {
	for _, e := range m.SignDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DataSignerMock.SignDigest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignDigestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignDigestCounter) < 1 {
		if m.SignDigestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DataSignerMock.SignDigest")
		} else {
			m.t.Errorf("Expected call to DataSignerMock.SignDigest with params: %#v", *m.SignDigestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignDigest != nil && mm_atomic.LoadUint64(&m.afterSignDigestCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.SignDigest")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DataSignerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDigestBytesInspect()

		m.MinimockDigestDataInspect()

		m.MinimockGetDigestMethodInspect()

		m.MinimockGetDigestSizeInspect()

		m.MinimockGetSignatureMethodInspect()

		m.MinimockGetSigningMethodInspect()

		m.MinimockNewHasherInspect()

		m.MinimockSignDigestInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DataSignerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DataSignerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDigestBytesDone() &&
		m.MinimockDigestDataDone() &&
		m.MinimockGetDigestMethodDone() &&
		m.MinimockGetDigestSizeDone() &&
		m.MinimockGetSignatureMethodDone() &&
		m.MinimockGetSigningMethodDone() &&
		m.MinimockNewHasherDone() &&
		m.MinimockSignDigestDone()
}
