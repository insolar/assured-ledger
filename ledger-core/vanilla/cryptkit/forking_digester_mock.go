package cryptkit

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/vanilla/longbits"
)

// ForkingDigesterMock implements ForkingDigester
type ForkingDigesterMock struct {
	t minimock.Tester

	funcAddNext          func(digest longbits.FoldableReader)
	inspectFuncAddNext   func(digest longbits.FoldableReader)
	afterAddNextCounter  uint64
	beforeAddNextCounter uint64
	AddNextMock          mForkingDigesterMockAddNext

	funcFinishSequence          func() (d1 Digest)
	inspectFuncFinishSequence   func()
	afterFinishSequenceCounter  uint64
	beforeFinishSequenceCounter uint64
	FinishSequenceMock          mForkingDigesterMockFinishSequence

	funcForkSequence          func() (f1 ForkingDigester)
	inspectFuncForkSequence   func()
	afterForkSequenceCounter  uint64
	beforeForkSequenceCounter uint64
	ForkSequenceMock          mForkingDigesterMockForkSequence

	funcGetDigestMethod          func() (d1 DigestMethod)
	inspectFuncGetDigestMethod   func()
	afterGetDigestMethodCounter  uint64
	beforeGetDigestMethodCounter uint64
	GetDigestMethodMock          mForkingDigesterMockGetDigestMethod

	funcGetDigestSize          func() (i1 int)
	inspectFuncGetDigestSize   func()
	afterGetDigestSizeCounter  uint64
	beforeGetDigestSizeCounter uint64
	GetDigestSizeMock          mForkingDigesterMockGetDigestSize
}

// NewForkingDigesterMock returns a mock for ForkingDigester
func NewForkingDigesterMock(t minimock.Tester) *ForkingDigesterMock {
	m := &ForkingDigesterMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddNextMock = mForkingDigesterMockAddNext{mock: m}
	m.AddNextMock.callArgs = []*ForkingDigesterMockAddNextParams{}

	m.FinishSequenceMock = mForkingDigesterMockFinishSequence{mock: m}

	m.ForkSequenceMock = mForkingDigesterMockForkSequence{mock: m}

	m.GetDigestMethodMock = mForkingDigesterMockGetDigestMethod{mock: m}

	m.GetDigestSizeMock = mForkingDigesterMockGetDigestSize{mock: m}

	return m
}

type mForkingDigesterMockAddNext struct {
	mock               *ForkingDigesterMock
	defaultExpectation *ForkingDigesterMockAddNextExpectation
	expectations       []*ForkingDigesterMockAddNextExpectation

	callArgs []*ForkingDigesterMockAddNextParams
	mutex    sync.RWMutex
}

// ForkingDigesterMockAddNextExpectation specifies expectation struct of the ForkingDigester.AddNext
type ForkingDigesterMockAddNextExpectation struct {
	mock   *ForkingDigesterMock
	params *ForkingDigesterMockAddNextParams

	Counter uint64
}

// ForkingDigesterMockAddNextParams contains parameters of the ForkingDigester.AddNext
type ForkingDigesterMockAddNextParams struct {
	digest longbits.FoldableReader
}

// Expect sets up expected params for ForkingDigester.AddNext
func (mmAddNext *mForkingDigesterMockAddNext) Expect(digest longbits.FoldableReader) *mForkingDigesterMockAddNext {
	if mmAddNext.mock.funcAddNext != nil {
		mmAddNext.mock.t.Fatalf("ForkingDigesterMock.AddNext mock is already set by Set")
	}

	if mmAddNext.defaultExpectation == nil {
		mmAddNext.defaultExpectation = &ForkingDigesterMockAddNextExpectation{}
	}

	mmAddNext.defaultExpectation.params = &ForkingDigesterMockAddNextParams{digest}
	for _, e := range mmAddNext.expectations {
		if minimock.Equal(e.params, mmAddNext.defaultExpectation.params) {
			mmAddNext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddNext.defaultExpectation.params)
		}
	}

	return mmAddNext
}

// Inspect accepts an inspector function that has same arguments as the ForkingDigester.AddNext
func (mmAddNext *mForkingDigesterMockAddNext) Inspect(f func(digest longbits.FoldableReader)) *mForkingDigesterMockAddNext {
	if mmAddNext.mock.inspectFuncAddNext != nil {
		mmAddNext.mock.t.Fatalf("Inspect function is already set for ForkingDigesterMock.AddNext")
	}

	mmAddNext.mock.inspectFuncAddNext = f

	return mmAddNext
}

// Return sets up results that will be returned by ForkingDigester.AddNext
func (mmAddNext *mForkingDigesterMockAddNext) Return() *ForkingDigesterMock {
	if mmAddNext.mock.funcAddNext != nil {
		mmAddNext.mock.t.Fatalf("ForkingDigesterMock.AddNext mock is already set by Set")
	}

	if mmAddNext.defaultExpectation == nil {
		mmAddNext.defaultExpectation = &ForkingDigesterMockAddNextExpectation{mock: mmAddNext.mock}
	}

	return mmAddNext.mock
}

//Set uses given function f to mock the ForkingDigester.AddNext method
func (mmAddNext *mForkingDigesterMockAddNext) Set(f func(digest longbits.FoldableReader)) *ForkingDigesterMock {
	if mmAddNext.defaultExpectation != nil {
		mmAddNext.mock.t.Fatalf("Default expectation is already set for the ForkingDigester.AddNext method")
	}

	if len(mmAddNext.expectations) > 0 {
		mmAddNext.mock.t.Fatalf("Some expectations are already set for the ForkingDigester.AddNext method")
	}

	mmAddNext.mock.funcAddNext = f
	return mmAddNext.mock
}

// AddNext implements ForkingDigester
func (mmAddNext *ForkingDigesterMock) AddNext(digest longbits.FoldableReader) {
	mm_atomic.AddUint64(&mmAddNext.beforeAddNextCounter, 1)
	defer mm_atomic.AddUint64(&mmAddNext.afterAddNextCounter, 1)

	if mmAddNext.inspectFuncAddNext != nil {
		mmAddNext.inspectFuncAddNext(digest)
	}

	mm_params := &ForkingDigesterMockAddNextParams{digest}

	// Record call args
	mmAddNext.AddNextMock.mutex.Lock()
	mmAddNext.AddNextMock.callArgs = append(mmAddNext.AddNextMock.callArgs, mm_params)
	mmAddNext.AddNextMock.mutex.Unlock()

	for _, e := range mmAddNext.AddNextMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddNext.AddNextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddNext.AddNextMock.defaultExpectation.Counter, 1)
		mm_want := mmAddNext.AddNextMock.defaultExpectation.params
		mm_got := ForkingDigesterMockAddNextParams{digest}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddNext.t.Errorf("ForkingDigesterMock.AddNext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddNext.funcAddNext != nil {
		mmAddNext.funcAddNext(digest)
		return
	}
	mmAddNext.t.Fatalf("Unexpected call to ForkingDigesterMock.AddNext. %v", digest)

}

// AddNextAfterCounter returns a count of finished ForkingDigesterMock.AddNext invocations
func (mmAddNext *ForkingDigesterMock) AddNextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddNext.afterAddNextCounter)
}

// AddNextBeforeCounter returns a count of ForkingDigesterMock.AddNext invocations
func (mmAddNext *ForkingDigesterMock) AddNextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddNext.beforeAddNextCounter)
}

// Calls returns a list of arguments used in each call to ForkingDigesterMock.AddNext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddNext *mForkingDigesterMockAddNext) Calls() []*ForkingDigesterMockAddNextParams {
	mmAddNext.mutex.RLock()

	argCopy := make([]*ForkingDigesterMockAddNextParams, len(mmAddNext.callArgs))
	copy(argCopy, mmAddNext.callArgs)

	mmAddNext.mutex.RUnlock()

	return argCopy
}

// MinimockAddNextDone returns true if the count of the AddNext invocations corresponds
// the number of defined expectations
func (m *ForkingDigesterMock) MinimockAddNextDone() bool {
	for _, e := range m.AddNextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddNextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddNextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddNext != nil && mm_atomic.LoadUint64(&m.afterAddNextCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddNextInspect logs each unmet expectation
func (m *ForkingDigesterMock) MinimockAddNextInspect() {
	for _, e := range m.AddNextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ForkingDigesterMock.AddNext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddNextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddNextCounter) < 1 {
		if m.AddNextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ForkingDigesterMock.AddNext")
		} else {
			m.t.Errorf("Expected call to ForkingDigesterMock.AddNext with params: %#v", *m.AddNextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddNext != nil && mm_atomic.LoadUint64(&m.afterAddNextCounter) < 1 {
		m.t.Error("Expected call to ForkingDigesterMock.AddNext")
	}
}

type mForkingDigesterMockFinishSequence struct {
	mock               *ForkingDigesterMock
	defaultExpectation *ForkingDigesterMockFinishSequenceExpectation
	expectations       []*ForkingDigesterMockFinishSequenceExpectation
}

// ForkingDigesterMockFinishSequenceExpectation specifies expectation struct of the ForkingDigester.FinishSequence
type ForkingDigesterMockFinishSequenceExpectation struct {
	mock *ForkingDigesterMock

	results *ForkingDigesterMockFinishSequenceResults
	Counter uint64
}

// ForkingDigesterMockFinishSequenceResults contains results of the ForkingDigester.FinishSequence
type ForkingDigesterMockFinishSequenceResults struct {
	d1 Digest
}

// Expect sets up expected params for ForkingDigester.FinishSequence
func (mmFinishSequence *mForkingDigesterMockFinishSequence) Expect() *mForkingDigesterMockFinishSequence {
	if mmFinishSequence.mock.funcFinishSequence != nil {
		mmFinishSequence.mock.t.Fatalf("ForkingDigesterMock.FinishSequence mock is already set by Set")
	}

	if mmFinishSequence.defaultExpectation == nil {
		mmFinishSequence.defaultExpectation = &ForkingDigesterMockFinishSequenceExpectation{}
	}

	return mmFinishSequence
}

// Inspect accepts an inspector function that has same arguments as the ForkingDigester.FinishSequence
func (mmFinishSequence *mForkingDigesterMockFinishSequence) Inspect(f func()) *mForkingDigesterMockFinishSequence {
	if mmFinishSequence.mock.inspectFuncFinishSequence != nil {
		mmFinishSequence.mock.t.Fatalf("Inspect function is already set for ForkingDigesterMock.FinishSequence")
	}

	mmFinishSequence.mock.inspectFuncFinishSequence = f

	return mmFinishSequence
}

// Return sets up results that will be returned by ForkingDigester.FinishSequence
func (mmFinishSequence *mForkingDigesterMockFinishSequence) Return(d1 Digest) *ForkingDigesterMock {
	if mmFinishSequence.mock.funcFinishSequence != nil {
		mmFinishSequence.mock.t.Fatalf("ForkingDigesterMock.FinishSequence mock is already set by Set")
	}

	if mmFinishSequence.defaultExpectation == nil {
		mmFinishSequence.defaultExpectation = &ForkingDigesterMockFinishSequenceExpectation{mock: mmFinishSequence.mock}
	}
	mmFinishSequence.defaultExpectation.results = &ForkingDigesterMockFinishSequenceResults{d1}
	return mmFinishSequence.mock
}

//Set uses given function f to mock the ForkingDigester.FinishSequence method
func (mmFinishSequence *mForkingDigesterMockFinishSequence) Set(f func() (d1 Digest)) *ForkingDigesterMock {
	if mmFinishSequence.defaultExpectation != nil {
		mmFinishSequence.mock.t.Fatalf("Default expectation is already set for the ForkingDigester.FinishSequence method")
	}

	if len(mmFinishSequence.expectations) > 0 {
		mmFinishSequence.mock.t.Fatalf("Some expectations are already set for the ForkingDigester.FinishSequence method")
	}

	mmFinishSequence.mock.funcFinishSequence = f
	return mmFinishSequence.mock
}

// FinishSequence implements ForkingDigester
func (mmFinishSequence *ForkingDigesterMock) FinishSequence() (d1 Digest) {
	mm_atomic.AddUint64(&mmFinishSequence.beforeFinishSequenceCounter, 1)
	defer mm_atomic.AddUint64(&mmFinishSequence.afterFinishSequenceCounter, 1)

	if mmFinishSequence.inspectFuncFinishSequence != nil {
		mmFinishSequence.inspectFuncFinishSequence()
	}

	if mmFinishSequence.FinishSequenceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFinishSequence.FinishSequenceMock.defaultExpectation.Counter, 1)

		mm_results := mmFinishSequence.FinishSequenceMock.defaultExpectation.results
		if mm_results == nil {
			mmFinishSequence.t.Fatal("No results are set for the ForkingDigesterMock.FinishSequence")
		}
		return (*mm_results).d1
	}
	if mmFinishSequence.funcFinishSequence != nil {
		return mmFinishSequence.funcFinishSequence()
	}
	mmFinishSequence.t.Fatalf("Unexpected call to ForkingDigesterMock.FinishSequence.")
	return
}

// FinishSequenceAfterCounter returns a count of finished ForkingDigesterMock.FinishSequence invocations
func (mmFinishSequence *ForkingDigesterMock) FinishSequenceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFinishSequence.afterFinishSequenceCounter)
}

// FinishSequenceBeforeCounter returns a count of ForkingDigesterMock.FinishSequence invocations
func (mmFinishSequence *ForkingDigesterMock) FinishSequenceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFinishSequence.beforeFinishSequenceCounter)
}

// MinimockFinishSequenceDone returns true if the count of the FinishSequence invocations corresponds
// the number of defined expectations
func (m *ForkingDigesterMock) MinimockFinishSequenceDone() bool {
	for _, e := range m.FinishSequenceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FinishSequenceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFinishSequenceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFinishSequence != nil && mm_atomic.LoadUint64(&m.afterFinishSequenceCounter) < 1 {
		return false
	}
	return true
}

// MinimockFinishSequenceInspect logs each unmet expectation
func (m *ForkingDigesterMock) MinimockFinishSequenceInspect() {
	for _, e := range m.FinishSequenceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ForkingDigesterMock.FinishSequence")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FinishSequenceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFinishSequenceCounter) < 1 {
		m.t.Error("Expected call to ForkingDigesterMock.FinishSequence")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFinishSequence != nil && mm_atomic.LoadUint64(&m.afterFinishSequenceCounter) < 1 {
		m.t.Error("Expected call to ForkingDigesterMock.FinishSequence")
	}
}

type mForkingDigesterMockForkSequence struct {
	mock               *ForkingDigesterMock
	defaultExpectation *ForkingDigesterMockForkSequenceExpectation
	expectations       []*ForkingDigesterMockForkSequenceExpectation
}

// ForkingDigesterMockForkSequenceExpectation specifies expectation struct of the ForkingDigester.ForkSequence
type ForkingDigesterMockForkSequenceExpectation struct {
	mock *ForkingDigesterMock

	results *ForkingDigesterMockForkSequenceResults
	Counter uint64
}

// ForkingDigesterMockForkSequenceResults contains results of the ForkingDigester.ForkSequence
type ForkingDigesterMockForkSequenceResults struct {
	f1 ForkingDigester
}

// Expect sets up expected params for ForkingDigester.ForkSequence
func (mmForkSequence *mForkingDigesterMockForkSequence) Expect() *mForkingDigesterMockForkSequence {
	if mmForkSequence.mock.funcForkSequence != nil {
		mmForkSequence.mock.t.Fatalf("ForkingDigesterMock.ForkSequence mock is already set by Set")
	}

	if mmForkSequence.defaultExpectation == nil {
		mmForkSequence.defaultExpectation = &ForkingDigesterMockForkSequenceExpectation{}
	}

	return mmForkSequence
}

// Inspect accepts an inspector function that has same arguments as the ForkingDigester.ForkSequence
func (mmForkSequence *mForkingDigesterMockForkSequence) Inspect(f func()) *mForkingDigesterMockForkSequence {
	if mmForkSequence.mock.inspectFuncForkSequence != nil {
		mmForkSequence.mock.t.Fatalf("Inspect function is already set for ForkingDigesterMock.ForkSequence")
	}

	mmForkSequence.mock.inspectFuncForkSequence = f

	return mmForkSequence
}

// Return sets up results that will be returned by ForkingDigester.ForkSequence
func (mmForkSequence *mForkingDigesterMockForkSequence) Return(f1 ForkingDigester) *ForkingDigesterMock {
	if mmForkSequence.mock.funcForkSequence != nil {
		mmForkSequence.mock.t.Fatalf("ForkingDigesterMock.ForkSequence mock is already set by Set")
	}

	if mmForkSequence.defaultExpectation == nil {
		mmForkSequence.defaultExpectation = &ForkingDigesterMockForkSequenceExpectation{mock: mmForkSequence.mock}
	}
	mmForkSequence.defaultExpectation.results = &ForkingDigesterMockForkSequenceResults{f1}
	return mmForkSequence.mock
}

//Set uses given function f to mock the ForkingDigester.ForkSequence method
func (mmForkSequence *mForkingDigesterMockForkSequence) Set(f func() (f1 ForkingDigester)) *ForkingDigesterMock {
	if mmForkSequence.defaultExpectation != nil {
		mmForkSequence.mock.t.Fatalf("Default expectation is already set for the ForkingDigester.ForkSequence method")
	}

	if len(mmForkSequence.expectations) > 0 {
		mmForkSequence.mock.t.Fatalf("Some expectations are already set for the ForkingDigester.ForkSequence method")
	}

	mmForkSequence.mock.funcForkSequence = f
	return mmForkSequence.mock
}

// ForkSequence implements ForkingDigester
func (mmForkSequence *ForkingDigesterMock) ForkSequence() (f1 ForkingDigester) {
	mm_atomic.AddUint64(&mmForkSequence.beforeForkSequenceCounter, 1)
	defer mm_atomic.AddUint64(&mmForkSequence.afterForkSequenceCounter, 1)

	if mmForkSequence.inspectFuncForkSequence != nil {
		mmForkSequence.inspectFuncForkSequence()
	}

	if mmForkSequence.ForkSequenceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmForkSequence.ForkSequenceMock.defaultExpectation.Counter, 1)

		mm_results := mmForkSequence.ForkSequenceMock.defaultExpectation.results
		if mm_results == nil {
			mmForkSequence.t.Fatal("No results are set for the ForkingDigesterMock.ForkSequence")
		}
		return (*mm_results).f1
	}
	if mmForkSequence.funcForkSequence != nil {
		return mmForkSequence.funcForkSequence()
	}
	mmForkSequence.t.Fatalf("Unexpected call to ForkingDigesterMock.ForkSequence.")
	return
}

// ForkSequenceAfterCounter returns a count of finished ForkingDigesterMock.ForkSequence invocations
func (mmForkSequence *ForkingDigesterMock) ForkSequenceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmForkSequence.afterForkSequenceCounter)
}

// ForkSequenceBeforeCounter returns a count of ForkingDigesterMock.ForkSequence invocations
func (mmForkSequence *ForkingDigesterMock) ForkSequenceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmForkSequence.beforeForkSequenceCounter)
}

// MinimockForkSequenceDone returns true if the count of the ForkSequence invocations corresponds
// the number of defined expectations
func (m *ForkingDigesterMock) MinimockForkSequenceDone() bool {
	for _, e := range m.ForkSequenceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ForkSequenceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterForkSequenceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcForkSequence != nil && mm_atomic.LoadUint64(&m.afterForkSequenceCounter) < 1 {
		return false
	}
	return true
}

// MinimockForkSequenceInspect logs each unmet expectation
func (m *ForkingDigesterMock) MinimockForkSequenceInspect() {
	for _, e := range m.ForkSequenceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ForkingDigesterMock.ForkSequence")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ForkSequenceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterForkSequenceCounter) < 1 {
		m.t.Error("Expected call to ForkingDigesterMock.ForkSequence")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcForkSequence != nil && mm_atomic.LoadUint64(&m.afterForkSequenceCounter) < 1 {
		m.t.Error("Expected call to ForkingDigesterMock.ForkSequence")
	}
}

type mForkingDigesterMockGetDigestMethod struct {
	mock               *ForkingDigesterMock
	defaultExpectation *ForkingDigesterMockGetDigestMethodExpectation
	expectations       []*ForkingDigesterMockGetDigestMethodExpectation
}

// ForkingDigesterMockGetDigestMethodExpectation specifies expectation struct of the ForkingDigester.GetDigestMethod
type ForkingDigesterMockGetDigestMethodExpectation struct {
	mock *ForkingDigesterMock

	results *ForkingDigesterMockGetDigestMethodResults
	Counter uint64
}

// ForkingDigesterMockGetDigestMethodResults contains results of the ForkingDigester.GetDigestMethod
type ForkingDigesterMockGetDigestMethodResults struct {
	d1 DigestMethod
}

// Expect sets up expected params for ForkingDigester.GetDigestMethod
func (mmGetDigestMethod *mForkingDigesterMockGetDigestMethod) Expect() *mForkingDigesterMockGetDigestMethod {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("ForkingDigesterMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &ForkingDigesterMockGetDigestMethodExpectation{}
	}

	return mmGetDigestMethod
}

// Inspect accepts an inspector function that has same arguments as the ForkingDigester.GetDigestMethod
func (mmGetDigestMethod *mForkingDigesterMockGetDigestMethod) Inspect(f func()) *mForkingDigesterMockGetDigestMethod {
	if mmGetDigestMethod.mock.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("Inspect function is already set for ForkingDigesterMock.GetDigestMethod")
	}

	mmGetDigestMethod.mock.inspectFuncGetDigestMethod = f

	return mmGetDigestMethod
}

// Return sets up results that will be returned by ForkingDigester.GetDigestMethod
func (mmGetDigestMethod *mForkingDigesterMockGetDigestMethod) Return(d1 DigestMethod) *ForkingDigesterMock {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("ForkingDigesterMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &ForkingDigesterMockGetDigestMethodExpectation{mock: mmGetDigestMethod.mock}
	}
	mmGetDigestMethod.defaultExpectation.results = &ForkingDigesterMockGetDigestMethodResults{d1}
	return mmGetDigestMethod.mock
}

//Set uses given function f to mock the ForkingDigester.GetDigestMethod method
func (mmGetDigestMethod *mForkingDigesterMockGetDigestMethod) Set(f func() (d1 DigestMethod)) *ForkingDigesterMock {
	if mmGetDigestMethod.defaultExpectation != nil {
		mmGetDigestMethod.mock.t.Fatalf("Default expectation is already set for the ForkingDigester.GetDigestMethod method")
	}

	if len(mmGetDigestMethod.expectations) > 0 {
		mmGetDigestMethod.mock.t.Fatalf("Some expectations are already set for the ForkingDigester.GetDigestMethod method")
	}

	mmGetDigestMethod.mock.funcGetDigestMethod = f
	return mmGetDigestMethod.mock
}

// GetDigestMethod implements ForkingDigester
func (mmGetDigestMethod *ForkingDigesterMock) GetDigestMethod() (d1 DigestMethod) {
	mm_atomic.AddUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestMethod.afterGetDigestMethodCounter, 1)

	if mmGetDigestMethod.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.inspectFuncGetDigestMethod()
	}

	if mmGetDigestMethod.GetDigestMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDigestMethod.t.Fatal("No results are set for the ForkingDigesterMock.GetDigestMethod")
		}
		return (*mm_results).d1
	}
	if mmGetDigestMethod.funcGetDigestMethod != nil {
		return mmGetDigestMethod.funcGetDigestMethod()
	}
	mmGetDigestMethod.t.Fatalf("Unexpected call to ForkingDigesterMock.GetDigestMethod.")
	return
}

// GetDigestMethodAfterCounter returns a count of finished ForkingDigesterMock.GetDigestMethod invocations
func (mmGetDigestMethod *ForkingDigesterMock) GetDigestMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.afterGetDigestMethodCounter)
}

// GetDigestMethodBeforeCounter returns a count of ForkingDigesterMock.GetDigestMethod invocations
func (mmGetDigestMethod *ForkingDigesterMock) GetDigestMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter)
}

// MinimockGetDigestMethodDone returns true if the count of the GetDigestMethod invocations corresponds
// the number of defined expectations
func (m *ForkingDigesterMock) MinimockGetDigestMethodDone() bool {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestMethodInspect logs each unmet expectation
func (m *ForkingDigesterMock) MinimockGetDigestMethodInspect() {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ForkingDigesterMock.GetDigestMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to ForkingDigesterMock.GetDigestMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to ForkingDigesterMock.GetDigestMethod")
	}
}

type mForkingDigesterMockGetDigestSize struct {
	mock               *ForkingDigesterMock
	defaultExpectation *ForkingDigesterMockGetDigestSizeExpectation
	expectations       []*ForkingDigesterMockGetDigestSizeExpectation
}

// ForkingDigesterMockGetDigestSizeExpectation specifies expectation struct of the ForkingDigester.GetDigestSize
type ForkingDigesterMockGetDigestSizeExpectation struct {
	mock *ForkingDigesterMock

	results *ForkingDigesterMockGetDigestSizeResults
	Counter uint64
}

// ForkingDigesterMockGetDigestSizeResults contains results of the ForkingDigester.GetDigestSize
type ForkingDigesterMockGetDigestSizeResults struct {
	i1 int
}

// Expect sets up expected params for ForkingDigester.GetDigestSize
func (mmGetDigestSize *mForkingDigesterMockGetDigestSize) Expect() *mForkingDigesterMockGetDigestSize {
	if mmGetDigestSize.mock.funcGetDigestSize != nil {
		mmGetDigestSize.mock.t.Fatalf("ForkingDigesterMock.GetDigestSize mock is already set by Set")
	}

	if mmGetDigestSize.defaultExpectation == nil {
		mmGetDigestSize.defaultExpectation = &ForkingDigesterMockGetDigestSizeExpectation{}
	}

	return mmGetDigestSize
}

// Inspect accepts an inspector function that has same arguments as the ForkingDigester.GetDigestSize
func (mmGetDigestSize *mForkingDigesterMockGetDigestSize) Inspect(f func()) *mForkingDigesterMockGetDigestSize {
	if mmGetDigestSize.mock.inspectFuncGetDigestSize != nil {
		mmGetDigestSize.mock.t.Fatalf("Inspect function is already set for ForkingDigesterMock.GetDigestSize")
	}

	mmGetDigestSize.mock.inspectFuncGetDigestSize = f

	return mmGetDigestSize
}

// Return sets up results that will be returned by ForkingDigester.GetDigestSize
func (mmGetDigestSize *mForkingDigesterMockGetDigestSize) Return(i1 int) *ForkingDigesterMock {
	if mmGetDigestSize.mock.funcGetDigestSize != nil {
		mmGetDigestSize.mock.t.Fatalf("ForkingDigesterMock.GetDigestSize mock is already set by Set")
	}

	if mmGetDigestSize.defaultExpectation == nil {
		mmGetDigestSize.defaultExpectation = &ForkingDigesterMockGetDigestSizeExpectation{mock: mmGetDigestSize.mock}
	}
	mmGetDigestSize.defaultExpectation.results = &ForkingDigesterMockGetDigestSizeResults{i1}
	return mmGetDigestSize.mock
}

//Set uses given function f to mock the ForkingDigester.GetDigestSize method
func (mmGetDigestSize *mForkingDigesterMockGetDigestSize) Set(f func() (i1 int)) *ForkingDigesterMock {
	if mmGetDigestSize.defaultExpectation != nil {
		mmGetDigestSize.mock.t.Fatalf("Default expectation is already set for the ForkingDigester.GetDigestSize method")
	}

	if len(mmGetDigestSize.expectations) > 0 {
		mmGetDigestSize.mock.t.Fatalf("Some expectations are already set for the ForkingDigester.GetDigestSize method")
	}

	mmGetDigestSize.mock.funcGetDigestSize = f
	return mmGetDigestSize.mock
}

// GetDigestSize implements ForkingDigester
func (mmGetDigestSize *ForkingDigesterMock) GetDigestSize() (i1 int) {
	mm_atomic.AddUint64(&mmGetDigestSize.beforeGetDigestSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestSize.afterGetDigestSizeCounter, 1)

	if mmGetDigestSize.inspectFuncGetDigestSize != nil {
		mmGetDigestSize.inspectFuncGetDigestSize()
	}

	if mmGetDigestSize.GetDigestSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestSize.GetDigestSizeMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDigestSize.GetDigestSizeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDigestSize.t.Fatal("No results are set for the ForkingDigesterMock.GetDigestSize")
		}
		return (*mm_results).i1
	}
	if mmGetDigestSize.funcGetDigestSize != nil {
		return mmGetDigestSize.funcGetDigestSize()
	}
	mmGetDigestSize.t.Fatalf("Unexpected call to ForkingDigesterMock.GetDigestSize.")
	return
}

// GetDigestSizeAfterCounter returns a count of finished ForkingDigesterMock.GetDigestSize invocations
func (mmGetDigestSize *ForkingDigesterMock) GetDigestSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestSize.afterGetDigestSizeCounter)
}

// GetDigestSizeBeforeCounter returns a count of ForkingDigesterMock.GetDigestSize invocations
func (mmGetDigestSize *ForkingDigesterMock) GetDigestSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestSize.beforeGetDigestSizeCounter)
}

// MinimockGetDigestSizeDone returns true if the count of the GetDigestSize invocations corresponds
// the number of defined expectations
func (m *ForkingDigesterMock) MinimockGetDigestSizeDone() bool {
	for _, e := range m.GetDigestSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestSize != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestSizeInspect logs each unmet expectation
func (m *ForkingDigesterMock) MinimockGetDigestSizeInspect() {
	for _, e := range m.GetDigestSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ForkingDigesterMock.GetDigestSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		m.t.Error("Expected call to ForkingDigesterMock.GetDigestSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestSize != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		m.t.Error("Expected call to ForkingDigesterMock.GetDigestSize")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ForkingDigesterMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddNextInspect()

		m.MinimockFinishSequenceInspect()

		m.MinimockForkSequenceInspect()

		m.MinimockGetDigestMethodInspect()

		m.MinimockGetDigestSizeInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ForkingDigesterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ForkingDigesterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddNextDone() &&
		m.MinimockFinishSequenceDone() &&
		m.MinimockForkSequenceDone() &&
		m.MinimockGetDigestMethodDone() &&
		m.MinimockGetDigestSizeDone()
}
