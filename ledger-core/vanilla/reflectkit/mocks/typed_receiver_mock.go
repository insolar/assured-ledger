package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"reflect"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// TypedReceiverMock implements reflectkit.TypedReceiver
type TypedReceiverMock struct {
	t minimock.Tester

	funcReceiveBool          func(k1 reflect.Kind, b1 bool)
	inspectFuncReceiveBool   func(k1 reflect.Kind, b1 bool)
	afterReceiveBoolCounter  uint64
	beforeReceiveBoolCounter uint64
	ReceiveBoolMock          mTypedReceiverMockReceiveBool

	funcReceiveComplex          func(k1 reflect.Kind, c1 complex128)
	inspectFuncReceiveComplex   func(k1 reflect.Kind, c1 complex128)
	afterReceiveComplexCounter  uint64
	beforeReceiveComplexCounter uint64
	ReceiveComplexMock          mTypedReceiverMockReceiveComplex

	funcReceiveElse          func(t reflect.Kind, v interface{}, isZero bool)
	inspectFuncReceiveElse   func(t reflect.Kind, v interface{}, isZero bool)
	afterReceiveElseCounter  uint64
	beforeReceiveElseCounter uint64
	ReceiveElseMock          mTypedReceiverMockReceiveElse

	funcReceiveFloat          func(k1 reflect.Kind, f1 float64)
	inspectFuncReceiveFloat   func(k1 reflect.Kind, f1 float64)
	afterReceiveFloatCounter  uint64
	beforeReceiveFloatCounter uint64
	ReceiveFloatMock          mTypedReceiverMockReceiveFloat

	funcReceiveIface          func(k1 reflect.Kind, p1 interface{})
	inspectFuncReceiveIface   func(k1 reflect.Kind, p1 interface{})
	afterReceiveIfaceCounter  uint64
	beforeReceiveIfaceCounter uint64
	ReceiveIfaceMock          mTypedReceiverMockReceiveIface

	funcReceiveInt          func(k1 reflect.Kind, i1 int64)
	inspectFuncReceiveInt   func(k1 reflect.Kind, i1 int64)
	afterReceiveIntCounter  uint64
	beforeReceiveIntCounter uint64
	ReceiveIntMock          mTypedReceiverMockReceiveInt

	funcReceiveNil          func(k1 reflect.Kind)
	inspectFuncReceiveNil   func(k1 reflect.Kind)
	afterReceiveNilCounter  uint64
	beforeReceiveNilCounter uint64
	ReceiveNilMock          mTypedReceiverMockReceiveNil

	funcReceiveString          func(k1 reflect.Kind, s1 string)
	inspectFuncReceiveString   func(k1 reflect.Kind, s1 string)
	afterReceiveStringCounter  uint64
	beforeReceiveStringCounter uint64
	ReceiveStringMock          mTypedReceiverMockReceiveString

	funcReceiveUint          func(k1 reflect.Kind, u1 uint64)
	inspectFuncReceiveUint   func(k1 reflect.Kind, u1 uint64)
	afterReceiveUintCounter  uint64
	beforeReceiveUintCounter uint64
	ReceiveUintMock          mTypedReceiverMockReceiveUint

	funcReceiveZero          func(k1 reflect.Kind)
	inspectFuncReceiveZero   func(k1 reflect.Kind)
	afterReceiveZeroCounter  uint64
	beforeReceiveZeroCounter uint64
	ReceiveZeroMock          mTypedReceiverMockReceiveZero
}

// NewTypedReceiverMock returns a mock for reflectkit.TypedReceiver
func NewTypedReceiverMock(t minimock.Tester) *TypedReceiverMock {
	m := &TypedReceiverMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ReceiveBoolMock = mTypedReceiverMockReceiveBool{mock: m}
	m.ReceiveBoolMock.callArgs = []*TypedReceiverMockReceiveBoolParams{}

	m.ReceiveComplexMock = mTypedReceiverMockReceiveComplex{mock: m}
	m.ReceiveComplexMock.callArgs = []*TypedReceiverMockReceiveComplexParams{}

	m.ReceiveElseMock = mTypedReceiverMockReceiveElse{mock: m}
	m.ReceiveElseMock.callArgs = []*TypedReceiverMockReceiveElseParams{}

	m.ReceiveFloatMock = mTypedReceiverMockReceiveFloat{mock: m}
	m.ReceiveFloatMock.callArgs = []*TypedReceiverMockReceiveFloatParams{}

	m.ReceiveIfaceMock = mTypedReceiverMockReceiveIface{mock: m}
	m.ReceiveIfaceMock.callArgs = []*TypedReceiverMockReceiveIfaceParams{}

	m.ReceiveIntMock = mTypedReceiverMockReceiveInt{mock: m}
	m.ReceiveIntMock.callArgs = []*TypedReceiverMockReceiveIntParams{}

	m.ReceiveNilMock = mTypedReceiverMockReceiveNil{mock: m}
	m.ReceiveNilMock.callArgs = []*TypedReceiverMockReceiveNilParams{}

	m.ReceiveStringMock = mTypedReceiverMockReceiveString{mock: m}
	m.ReceiveStringMock.callArgs = []*TypedReceiverMockReceiveStringParams{}

	m.ReceiveUintMock = mTypedReceiverMockReceiveUint{mock: m}
	m.ReceiveUintMock.callArgs = []*TypedReceiverMockReceiveUintParams{}

	m.ReceiveZeroMock = mTypedReceiverMockReceiveZero{mock: m}
	m.ReceiveZeroMock.callArgs = []*TypedReceiverMockReceiveZeroParams{}

	return m
}

type mTypedReceiverMockReceiveBool struct {
	mock               *TypedReceiverMock
	defaultExpectation *TypedReceiverMockReceiveBoolExpectation
	expectations       []*TypedReceiverMockReceiveBoolExpectation

	callArgs []*TypedReceiverMockReceiveBoolParams
	mutex    sync.RWMutex
}

// TypedReceiverMockReceiveBoolExpectation specifies expectation struct of the TypedReceiver.ReceiveBool
type TypedReceiverMockReceiveBoolExpectation struct {
	mock   *TypedReceiverMock
	params *TypedReceiverMockReceiveBoolParams

	Counter uint64
}

// TypedReceiverMockReceiveBoolParams contains parameters of the TypedReceiver.ReceiveBool
type TypedReceiverMockReceiveBoolParams struct {
	k1 reflect.Kind
	b1 bool
}

// Expect sets up expected params for TypedReceiver.ReceiveBool
func (mmReceiveBool *mTypedReceiverMockReceiveBool) Expect(k1 reflect.Kind, b1 bool) *mTypedReceiverMockReceiveBool {
	if mmReceiveBool.mock.funcReceiveBool != nil {
		mmReceiveBool.mock.t.Fatalf("TypedReceiverMock.ReceiveBool mock is already set by Set")
	}

	if mmReceiveBool.defaultExpectation == nil {
		mmReceiveBool.defaultExpectation = &TypedReceiverMockReceiveBoolExpectation{}
	}

	mmReceiveBool.defaultExpectation.params = &TypedReceiverMockReceiveBoolParams{k1, b1}
	for _, e := range mmReceiveBool.expectations {
		if minimock.Equal(e.params, mmReceiveBool.defaultExpectation.params) {
			mmReceiveBool.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReceiveBool.defaultExpectation.params)
		}
	}

	return mmReceiveBool
}

// Inspect accepts an inspector function that has same arguments as the TypedReceiver.ReceiveBool
func (mmReceiveBool *mTypedReceiverMockReceiveBool) Inspect(f func(k1 reflect.Kind, b1 bool)) *mTypedReceiverMockReceiveBool {
	if mmReceiveBool.mock.inspectFuncReceiveBool != nil {
		mmReceiveBool.mock.t.Fatalf("Inspect function is already set for TypedReceiverMock.ReceiveBool")
	}

	mmReceiveBool.mock.inspectFuncReceiveBool = f

	return mmReceiveBool
}

// Return sets up results that will be returned by TypedReceiver.ReceiveBool
func (mmReceiveBool *mTypedReceiverMockReceiveBool) Return() *TypedReceiverMock {
	if mmReceiveBool.mock.funcReceiveBool != nil {
		mmReceiveBool.mock.t.Fatalf("TypedReceiverMock.ReceiveBool mock is already set by Set")
	}

	if mmReceiveBool.defaultExpectation == nil {
		mmReceiveBool.defaultExpectation = &TypedReceiverMockReceiveBoolExpectation{mock: mmReceiveBool.mock}
	}

	return mmReceiveBool.mock
}

//Set uses given function f to mock the TypedReceiver.ReceiveBool method
func (mmReceiveBool *mTypedReceiverMockReceiveBool) Set(f func(k1 reflect.Kind, b1 bool)) *TypedReceiverMock {
	if mmReceiveBool.defaultExpectation != nil {
		mmReceiveBool.mock.t.Fatalf("Default expectation is already set for the TypedReceiver.ReceiveBool method")
	}

	if len(mmReceiveBool.expectations) > 0 {
		mmReceiveBool.mock.t.Fatalf("Some expectations are already set for the TypedReceiver.ReceiveBool method")
	}

	mmReceiveBool.mock.funcReceiveBool = f
	return mmReceiveBool.mock
}

// ReceiveBool implements reflectkit.TypedReceiver
func (mmReceiveBool *TypedReceiverMock) ReceiveBool(k1 reflect.Kind, b1 bool) {
	mm_atomic.AddUint64(&mmReceiveBool.beforeReceiveBoolCounter, 1)
	defer mm_atomic.AddUint64(&mmReceiveBool.afterReceiveBoolCounter, 1)

	if mmReceiveBool.inspectFuncReceiveBool != nil {
		mmReceiveBool.inspectFuncReceiveBool(k1, b1)
	}

	mm_params := &TypedReceiverMockReceiveBoolParams{k1, b1}

	// Record call args
	mmReceiveBool.ReceiveBoolMock.mutex.Lock()
	mmReceiveBool.ReceiveBoolMock.callArgs = append(mmReceiveBool.ReceiveBoolMock.callArgs, mm_params)
	mmReceiveBool.ReceiveBoolMock.mutex.Unlock()

	for _, e := range mmReceiveBool.ReceiveBoolMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmReceiveBool.ReceiveBoolMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReceiveBool.ReceiveBoolMock.defaultExpectation.Counter, 1)
		mm_want := mmReceiveBool.ReceiveBoolMock.defaultExpectation.params
		mm_got := TypedReceiverMockReceiveBoolParams{k1, b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReceiveBool.t.Errorf("TypedReceiverMock.ReceiveBool got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmReceiveBool.funcReceiveBool != nil {
		mmReceiveBool.funcReceiveBool(k1, b1)
		return
	}
	mmReceiveBool.t.Fatalf("Unexpected call to TypedReceiverMock.ReceiveBool. %v %v", k1, b1)

}

// ReceiveBoolAfterCounter returns a count of finished TypedReceiverMock.ReceiveBool invocations
func (mmReceiveBool *TypedReceiverMock) ReceiveBoolAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveBool.afterReceiveBoolCounter)
}

// ReceiveBoolBeforeCounter returns a count of TypedReceiverMock.ReceiveBool invocations
func (mmReceiveBool *TypedReceiverMock) ReceiveBoolBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveBool.beforeReceiveBoolCounter)
}

// Calls returns a list of arguments used in each call to TypedReceiverMock.ReceiveBool.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReceiveBool *mTypedReceiverMockReceiveBool) Calls() []*TypedReceiverMockReceiveBoolParams {
	mmReceiveBool.mutex.RLock()

	argCopy := make([]*TypedReceiverMockReceiveBoolParams, len(mmReceiveBool.callArgs))
	copy(argCopy, mmReceiveBool.callArgs)

	mmReceiveBool.mutex.RUnlock()

	return argCopy
}

// MinimockReceiveBoolDone returns true if the count of the ReceiveBool invocations corresponds
// the number of defined expectations
func (m *TypedReceiverMock) MinimockReceiveBoolDone() bool {
	for _, e := range m.ReceiveBoolMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveBoolMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveBoolCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveBool != nil && mm_atomic.LoadUint64(&m.afterReceiveBoolCounter) < 1 {
		return false
	}
	return true
}

// MinimockReceiveBoolInspect logs each unmet expectation
func (m *TypedReceiverMock) MinimockReceiveBoolInspect() {
	for _, e := range m.ReceiveBoolMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveBool with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveBoolMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveBoolCounter) < 1 {
		if m.ReceiveBoolMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TypedReceiverMock.ReceiveBool")
		} else {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveBool with params: %#v", *m.ReceiveBoolMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveBool != nil && mm_atomic.LoadUint64(&m.afterReceiveBoolCounter) < 1 {
		m.t.Error("Expected call to TypedReceiverMock.ReceiveBool")
	}
}

type mTypedReceiverMockReceiveComplex struct {
	mock               *TypedReceiverMock
	defaultExpectation *TypedReceiverMockReceiveComplexExpectation
	expectations       []*TypedReceiverMockReceiveComplexExpectation

	callArgs []*TypedReceiverMockReceiveComplexParams
	mutex    sync.RWMutex
}

// TypedReceiverMockReceiveComplexExpectation specifies expectation struct of the TypedReceiver.ReceiveComplex
type TypedReceiverMockReceiveComplexExpectation struct {
	mock   *TypedReceiverMock
	params *TypedReceiverMockReceiveComplexParams

	Counter uint64
}

// TypedReceiverMockReceiveComplexParams contains parameters of the TypedReceiver.ReceiveComplex
type TypedReceiverMockReceiveComplexParams struct {
	k1 reflect.Kind
	c1 complex128
}

// Expect sets up expected params for TypedReceiver.ReceiveComplex
func (mmReceiveComplex *mTypedReceiverMockReceiveComplex) Expect(k1 reflect.Kind, c1 complex128) *mTypedReceiverMockReceiveComplex {
	if mmReceiveComplex.mock.funcReceiveComplex != nil {
		mmReceiveComplex.mock.t.Fatalf("TypedReceiverMock.ReceiveComplex mock is already set by Set")
	}

	if mmReceiveComplex.defaultExpectation == nil {
		mmReceiveComplex.defaultExpectation = &TypedReceiverMockReceiveComplexExpectation{}
	}

	mmReceiveComplex.defaultExpectation.params = &TypedReceiverMockReceiveComplexParams{k1, c1}
	for _, e := range mmReceiveComplex.expectations {
		if minimock.Equal(e.params, mmReceiveComplex.defaultExpectation.params) {
			mmReceiveComplex.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReceiveComplex.defaultExpectation.params)
		}
	}

	return mmReceiveComplex
}

// Inspect accepts an inspector function that has same arguments as the TypedReceiver.ReceiveComplex
func (mmReceiveComplex *mTypedReceiverMockReceiveComplex) Inspect(f func(k1 reflect.Kind, c1 complex128)) *mTypedReceiverMockReceiveComplex {
	if mmReceiveComplex.mock.inspectFuncReceiveComplex != nil {
		mmReceiveComplex.mock.t.Fatalf("Inspect function is already set for TypedReceiverMock.ReceiveComplex")
	}

	mmReceiveComplex.mock.inspectFuncReceiveComplex = f

	return mmReceiveComplex
}

// Return sets up results that will be returned by TypedReceiver.ReceiveComplex
func (mmReceiveComplex *mTypedReceiverMockReceiveComplex) Return() *TypedReceiverMock {
	if mmReceiveComplex.mock.funcReceiveComplex != nil {
		mmReceiveComplex.mock.t.Fatalf("TypedReceiverMock.ReceiveComplex mock is already set by Set")
	}

	if mmReceiveComplex.defaultExpectation == nil {
		mmReceiveComplex.defaultExpectation = &TypedReceiverMockReceiveComplexExpectation{mock: mmReceiveComplex.mock}
	}

	return mmReceiveComplex.mock
}

//Set uses given function f to mock the TypedReceiver.ReceiveComplex method
func (mmReceiveComplex *mTypedReceiverMockReceiveComplex) Set(f func(k1 reflect.Kind, c1 complex128)) *TypedReceiverMock {
	if mmReceiveComplex.defaultExpectation != nil {
		mmReceiveComplex.mock.t.Fatalf("Default expectation is already set for the TypedReceiver.ReceiveComplex method")
	}

	if len(mmReceiveComplex.expectations) > 0 {
		mmReceiveComplex.mock.t.Fatalf("Some expectations are already set for the TypedReceiver.ReceiveComplex method")
	}

	mmReceiveComplex.mock.funcReceiveComplex = f
	return mmReceiveComplex.mock
}

// ReceiveComplex implements reflectkit.TypedReceiver
func (mmReceiveComplex *TypedReceiverMock) ReceiveComplex(k1 reflect.Kind, c1 complex128) {
	mm_atomic.AddUint64(&mmReceiveComplex.beforeReceiveComplexCounter, 1)
	defer mm_atomic.AddUint64(&mmReceiveComplex.afterReceiveComplexCounter, 1)

	if mmReceiveComplex.inspectFuncReceiveComplex != nil {
		mmReceiveComplex.inspectFuncReceiveComplex(k1, c1)
	}

	mm_params := &TypedReceiverMockReceiveComplexParams{k1, c1}

	// Record call args
	mmReceiveComplex.ReceiveComplexMock.mutex.Lock()
	mmReceiveComplex.ReceiveComplexMock.callArgs = append(mmReceiveComplex.ReceiveComplexMock.callArgs, mm_params)
	mmReceiveComplex.ReceiveComplexMock.mutex.Unlock()

	for _, e := range mmReceiveComplex.ReceiveComplexMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmReceiveComplex.ReceiveComplexMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReceiveComplex.ReceiveComplexMock.defaultExpectation.Counter, 1)
		mm_want := mmReceiveComplex.ReceiveComplexMock.defaultExpectation.params
		mm_got := TypedReceiverMockReceiveComplexParams{k1, c1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReceiveComplex.t.Errorf("TypedReceiverMock.ReceiveComplex got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmReceiveComplex.funcReceiveComplex != nil {
		mmReceiveComplex.funcReceiveComplex(k1, c1)
		return
	}
	mmReceiveComplex.t.Fatalf("Unexpected call to TypedReceiverMock.ReceiveComplex. %v %v", k1, c1)

}

// ReceiveComplexAfterCounter returns a count of finished TypedReceiverMock.ReceiveComplex invocations
func (mmReceiveComplex *TypedReceiverMock) ReceiveComplexAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveComplex.afterReceiveComplexCounter)
}

// ReceiveComplexBeforeCounter returns a count of TypedReceiverMock.ReceiveComplex invocations
func (mmReceiveComplex *TypedReceiverMock) ReceiveComplexBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveComplex.beforeReceiveComplexCounter)
}

// Calls returns a list of arguments used in each call to TypedReceiverMock.ReceiveComplex.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReceiveComplex *mTypedReceiverMockReceiveComplex) Calls() []*TypedReceiverMockReceiveComplexParams {
	mmReceiveComplex.mutex.RLock()

	argCopy := make([]*TypedReceiverMockReceiveComplexParams, len(mmReceiveComplex.callArgs))
	copy(argCopy, mmReceiveComplex.callArgs)

	mmReceiveComplex.mutex.RUnlock()

	return argCopy
}

// MinimockReceiveComplexDone returns true if the count of the ReceiveComplex invocations corresponds
// the number of defined expectations
func (m *TypedReceiverMock) MinimockReceiveComplexDone() bool {
	for _, e := range m.ReceiveComplexMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveComplexMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveComplexCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveComplex != nil && mm_atomic.LoadUint64(&m.afterReceiveComplexCounter) < 1 {
		return false
	}
	return true
}

// MinimockReceiveComplexInspect logs each unmet expectation
func (m *TypedReceiverMock) MinimockReceiveComplexInspect() {
	for _, e := range m.ReceiveComplexMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveComplex with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveComplexMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveComplexCounter) < 1 {
		if m.ReceiveComplexMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TypedReceiverMock.ReceiveComplex")
		} else {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveComplex with params: %#v", *m.ReceiveComplexMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveComplex != nil && mm_atomic.LoadUint64(&m.afterReceiveComplexCounter) < 1 {
		m.t.Error("Expected call to TypedReceiverMock.ReceiveComplex")
	}
}

type mTypedReceiverMockReceiveElse struct {
	mock               *TypedReceiverMock
	defaultExpectation *TypedReceiverMockReceiveElseExpectation
	expectations       []*TypedReceiverMockReceiveElseExpectation

	callArgs []*TypedReceiverMockReceiveElseParams
	mutex    sync.RWMutex
}

// TypedReceiverMockReceiveElseExpectation specifies expectation struct of the TypedReceiver.ReceiveElse
type TypedReceiverMockReceiveElseExpectation struct {
	mock   *TypedReceiverMock
	params *TypedReceiverMockReceiveElseParams

	Counter uint64
}

// TypedReceiverMockReceiveElseParams contains parameters of the TypedReceiver.ReceiveElse
type TypedReceiverMockReceiveElseParams struct {
	t      reflect.Kind
	v      interface{}
	isZero bool
}

// Expect sets up expected params for TypedReceiver.ReceiveElse
func (mmReceiveElse *mTypedReceiverMockReceiveElse) Expect(t reflect.Kind, v interface{}, isZero bool) *mTypedReceiverMockReceiveElse {
	if mmReceiveElse.mock.funcReceiveElse != nil {
		mmReceiveElse.mock.t.Fatalf("TypedReceiverMock.ReceiveElse mock is already set by Set")
	}

	if mmReceiveElse.defaultExpectation == nil {
		mmReceiveElse.defaultExpectation = &TypedReceiverMockReceiveElseExpectation{}
	}

	mmReceiveElse.defaultExpectation.params = &TypedReceiverMockReceiveElseParams{t, v, isZero}
	for _, e := range mmReceiveElse.expectations {
		if minimock.Equal(e.params, mmReceiveElse.defaultExpectation.params) {
			mmReceiveElse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReceiveElse.defaultExpectation.params)
		}
	}

	return mmReceiveElse
}

// Inspect accepts an inspector function that has same arguments as the TypedReceiver.ReceiveElse
func (mmReceiveElse *mTypedReceiverMockReceiveElse) Inspect(f func(t reflect.Kind, v interface{}, isZero bool)) *mTypedReceiverMockReceiveElse {
	if mmReceiveElse.mock.inspectFuncReceiveElse != nil {
		mmReceiveElse.mock.t.Fatalf("Inspect function is already set for TypedReceiverMock.ReceiveElse")
	}

	mmReceiveElse.mock.inspectFuncReceiveElse = f

	return mmReceiveElse
}

// Return sets up results that will be returned by TypedReceiver.ReceiveElse
func (mmReceiveElse *mTypedReceiverMockReceiveElse) Return() *TypedReceiverMock {
	if mmReceiveElse.mock.funcReceiveElse != nil {
		mmReceiveElse.mock.t.Fatalf("TypedReceiverMock.ReceiveElse mock is already set by Set")
	}

	if mmReceiveElse.defaultExpectation == nil {
		mmReceiveElse.defaultExpectation = &TypedReceiverMockReceiveElseExpectation{mock: mmReceiveElse.mock}
	}

	return mmReceiveElse.mock
}

//Set uses given function f to mock the TypedReceiver.ReceiveElse method
func (mmReceiveElse *mTypedReceiverMockReceiveElse) Set(f func(t reflect.Kind, v interface{}, isZero bool)) *TypedReceiverMock {
	if mmReceiveElse.defaultExpectation != nil {
		mmReceiveElse.mock.t.Fatalf("Default expectation is already set for the TypedReceiver.ReceiveElse method")
	}

	if len(mmReceiveElse.expectations) > 0 {
		mmReceiveElse.mock.t.Fatalf("Some expectations are already set for the TypedReceiver.ReceiveElse method")
	}

	mmReceiveElse.mock.funcReceiveElse = f
	return mmReceiveElse.mock
}

// ReceiveElse implements reflectkit.TypedReceiver
func (mmReceiveElse *TypedReceiverMock) ReceiveElse(t reflect.Kind, v interface{}, isZero bool) {
	mm_atomic.AddUint64(&mmReceiveElse.beforeReceiveElseCounter, 1)
	defer mm_atomic.AddUint64(&mmReceiveElse.afterReceiveElseCounter, 1)

	if mmReceiveElse.inspectFuncReceiveElse != nil {
		mmReceiveElse.inspectFuncReceiveElse(t, v, isZero)
	}

	mm_params := &TypedReceiverMockReceiveElseParams{t, v, isZero}

	// Record call args
	mmReceiveElse.ReceiveElseMock.mutex.Lock()
	mmReceiveElse.ReceiveElseMock.callArgs = append(mmReceiveElse.ReceiveElseMock.callArgs, mm_params)
	mmReceiveElse.ReceiveElseMock.mutex.Unlock()

	for _, e := range mmReceiveElse.ReceiveElseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmReceiveElse.ReceiveElseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReceiveElse.ReceiveElseMock.defaultExpectation.Counter, 1)
		mm_want := mmReceiveElse.ReceiveElseMock.defaultExpectation.params
		mm_got := TypedReceiverMockReceiveElseParams{t, v, isZero}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReceiveElse.t.Errorf("TypedReceiverMock.ReceiveElse got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmReceiveElse.funcReceiveElse != nil {
		mmReceiveElse.funcReceiveElse(t, v, isZero)
		return
	}
	mmReceiveElse.t.Fatalf("Unexpected call to TypedReceiverMock.ReceiveElse. %v %v %v", t, v, isZero)

}

// ReceiveElseAfterCounter returns a count of finished TypedReceiverMock.ReceiveElse invocations
func (mmReceiveElse *TypedReceiverMock) ReceiveElseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveElse.afterReceiveElseCounter)
}

// ReceiveElseBeforeCounter returns a count of TypedReceiverMock.ReceiveElse invocations
func (mmReceiveElse *TypedReceiverMock) ReceiveElseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveElse.beforeReceiveElseCounter)
}

// Calls returns a list of arguments used in each call to TypedReceiverMock.ReceiveElse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReceiveElse *mTypedReceiverMockReceiveElse) Calls() []*TypedReceiverMockReceiveElseParams {
	mmReceiveElse.mutex.RLock()

	argCopy := make([]*TypedReceiverMockReceiveElseParams, len(mmReceiveElse.callArgs))
	copy(argCopy, mmReceiveElse.callArgs)

	mmReceiveElse.mutex.RUnlock()

	return argCopy
}

// MinimockReceiveElseDone returns true if the count of the ReceiveElse invocations corresponds
// the number of defined expectations
func (m *TypedReceiverMock) MinimockReceiveElseDone() bool {
	for _, e := range m.ReceiveElseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveElseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveElseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveElse != nil && mm_atomic.LoadUint64(&m.afterReceiveElseCounter) < 1 {
		return false
	}
	return true
}

// MinimockReceiveElseInspect logs each unmet expectation
func (m *TypedReceiverMock) MinimockReceiveElseInspect() {
	for _, e := range m.ReceiveElseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveElse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveElseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveElseCounter) < 1 {
		if m.ReceiveElseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TypedReceiverMock.ReceiveElse")
		} else {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveElse with params: %#v", *m.ReceiveElseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveElse != nil && mm_atomic.LoadUint64(&m.afterReceiveElseCounter) < 1 {
		m.t.Error("Expected call to TypedReceiverMock.ReceiveElse")
	}
}

type mTypedReceiverMockReceiveFloat struct {
	mock               *TypedReceiverMock
	defaultExpectation *TypedReceiverMockReceiveFloatExpectation
	expectations       []*TypedReceiverMockReceiveFloatExpectation

	callArgs []*TypedReceiverMockReceiveFloatParams
	mutex    sync.RWMutex
}

// TypedReceiverMockReceiveFloatExpectation specifies expectation struct of the TypedReceiver.ReceiveFloat
type TypedReceiverMockReceiveFloatExpectation struct {
	mock   *TypedReceiverMock
	params *TypedReceiverMockReceiveFloatParams

	Counter uint64
}

// TypedReceiverMockReceiveFloatParams contains parameters of the TypedReceiver.ReceiveFloat
type TypedReceiverMockReceiveFloatParams struct {
	k1 reflect.Kind
	f1 float64
}

// Expect sets up expected params for TypedReceiver.ReceiveFloat
func (mmReceiveFloat *mTypedReceiverMockReceiveFloat) Expect(k1 reflect.Kind, f1 float64) *mTypedReceiverMockReceiveFloat {
	if mmReceiveFloat.mock.funcReceiveFloat != nil {
		mmReceiveFloat.mock.t.Fatalf("TypedReceiverMock.ReceiveFloat mock is already set by Set")
	}

	if mmReceiveFloat.defaultExpectation == nil {
		mmReceiveFloat.defaultExpectation = &TypedReceiverMockReceiveFloatExpectation{}
	}

	mmReceiveFloat.defaultExpectation.params = &TypedReceiverMockReceiveFloatParams{k1, f1}
	for _, e := range mmReceiveFloat.expectations {
		if minimock.Equal(e.params, mmReceiveFloat.defaultExpectation.params) {
			mmReceiveFloat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReceiveFloat.defaultExpectation.params)
		}
	}

	return mmReceiveFloat
}

// Inspect accepts an inspector function that has same arguments as the TypedReceiver.ReceiveFloat
func (mmReceiveFloat *mTypedReceiverMockReceiveFloat) Inspect(f func(k1 reflect.Kind, f1 float64)) *mTypedReceiverMockReceiveFloat {
	if mmReceiveFloat.mock.inspectFuncReceiveFloat != nil {
		mmReceiveFloat.mock.t.Fatalf("Inspect function is already set for TypedReceiverMock.ReceiveFloat")
	}

	mmReceiveFloat.mock.inspectFuncReceiveFloat = f

	return mmReceiveFloat
}

// Return sets up results that will be returned by TypedReceiver.ReceiveFloat
func (mmReceiveFloat *mTypedReceiverMockReceiveFloat) Return() *TypedReceiverMock {
	if mmReceiveFloat.mock.funcReceiveFloat != nil {
		mmReceiveFloat.mock.t.Fatalf("TypedReceiverMock.ReceiveFloat mock is already set by Set")
	}

	if mmReceiveFloat.defaultExpectation == nil {
		mmReceiveFloat.defaultExpectation = &TypedReceiverMockReceiveFloatExpectation{mock: mmReceiveFloat.mock}
	}

	return mmReceiveFloat.mock
}

//Set uses given function f to mock the TypedReceiver.ReceiveFloat method
func (mmReceiveFloat *mTypedReceiverMockReceiveFloat) Set(f func(k1 reflect.Kind, f1 float64)) *TypedReceiverMock {
	if mmReceiveFloat.defaultExpectation != nil {
		mmReceiveFloat.mock.t.Fatalf("Default expectation is already set for the TypedReceiver.ReceiveFloat method")
	}

	if len(mmReceiveFloat.expectations) > 0 {
		mmReceiveFloat.mock.t.Fatalf("Some expectations are already set for the TypedReceiver.ReceiveFloat method")
	}

	mmReceiveFloat.mock.funcReceiveFloat = f
	return mmReceiveFloat.mock
}

// ReceiveFloat implements reflectkit.TypedReceiver
func (mmReceiveFloat *TypedReceiverMock) ReceiveFloat(k1 reflect.Kind, f1 float64) {
	mm_atomic.AddUint64(&mmReceiveFloat.beforeReceiveFloatCounter, 1)
	defer mm_atomic.AddUint64(&mmReceiveFloat.afterReceiveFloatCounter, 1)

	if mmReceiveFloat.inspectFuncReceiveFloat != nil {
		mmReceiveFloat.inspectFuncReceiveFloat(k1, f1)
	}

	mm_params := &TypedReceiverMockReceiveFloatParams{k1, f1}

	// Record call args
	mmReceiveFloat.ReceiveFloatMock.mutex.Lock()
	mmReceiveFloat.ReceiveFloatMock.callArgs = append(mmReceiveFloat.ReceiveFloatMock.callArgs, mm_params)
	mmReceiveFloat.ReceiveFloatMock.mutex.Unlock()

	for _, e := range mmReceiveFloat.ReceiveFloatMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmReceiveFloat.ReceiveFloatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReceiveFloat.ReceiveFloatMock.defaultExpectation.Counter, 1)
		mm_want := mmReceiveFloat.ReceiveFloatMock.defaultExpectation.params
		mm_got := TypedReceiverMockReceiveFloatParams{k1, f1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReceiveFloat.t.Errorf("TypedReceiverMock.ReceiveFloat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmReceiveFloat.funcReceiveFloat != nil {
		mmReceiveFloat.funcReceiveFloat(k1, f1)
		return
	}
	mmReceiveFloat.t.Fatalf("Unexpected call to TypedReceiverMock.ReceiveFloat. %v %v", k1, f1)

}

// ReceiveFloatAfterCounter returns a count of finished TypedReceiverMock.ReceiveFloat invocations
func (mmReceiveFloat *TypedReceiverMock) ReceiveFloatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveFloat.afterReceiveFloatCounter)
}

// ReceiveFloatBeforeCounter returns a count of TypedReceiverMock.ReceiveFloat invocations
func (mmReceiveFloat *TypedReceiverMock) ReceiveFloatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveFloat.beforeReceiveFloatCounter)
}

// Calls returns a list of arguments used in each call to TypedReceiverMock.ReceiveFloat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReceiveFloat *mTypedReceiverMockReceiveFloat) Calls() []*TypedReceiverMockReceiveFloatParams {
	mmReceiveFloat.mutex.RLock()

	argCopy := make([]*TypedReceiverMockReceiveFloatParams, len(mmReceiveFloat.callArgs))
	copy(argCopy, mmReceiveFloat.callArgs)

	mmReceiveFloat.mutex.RUnlock()

	return argCopy
}

// MinimockReceiveFloatDone returns true if the count of the ReceiveFloat invocations corresponds
// the number of defined expectations
func (m *TypedReceiverMock) MinimockReceiveFloatDone() bool {
	for _, e := range m.ReceiveFloatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveFloatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveFloatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveFloat != nil && mm_atomic.LoadUint64(&m.afterReceiveFloatCounter) < 1 {
		return false
	}
	return true
}

// MinimockReceiveFloatInspect logs each unmet expectation
func (m *TypedReceiverMock) MinimockReceiveFloatInspect() {
	for _, e := range m.ReceiveFloatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveFloat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveFloatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveFloatCounter) < 1 {
		if m.ReceiveFloatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TypedReceiverMock.ReceiveFloat")
		} else {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveFloat with params: %#v", *m.ReceiveFloatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveFloat != nil && mm_atomic.LoadUint64(&m.afterReceiveFloatCounter) < 1 {
		m.t.Error("Expected call to TypedReceiverMock.ReceiveFloat")
	}
}

type mTypedReceiverMockReceiveIface struct {
	mock               *TypedReceiverMock
	defaultExpectation *TypedReceiverMockReceiveIfaceExpectation
	expectations       []*TypedReceiverMockReceiveIfaceExpectation

	callArgs []*TypedReceiverMockReceiveIfaceParams
	mutex    sync.RWMutex
}

// TypedReceiverMockReceiveIfaceExpectation specifies expectation struct of the TypedReceiver.ReceiveIface
type TypedReceiverMockReceiveIfaceExpectation struct {
	mock   *TypedReceiverMock
	params *TypedReceiverMockReceiveIfaceParams

	Counter uint64
}

// TypedReceiverMockReceiveIfaceParams contains parameters of the TypedReceiver.ReceiveIface
type TypedReceiverMockReceiveIfaceParams struct {
	k1 reflect.Kind
	p1 interface{}
}

// Expect sets up expected params for TypedReceiver.ReceiveIface
func (mmReceiveIface *mTypedReceiverMockReceiveIface) Expect(k1 reflect.Kind, p1 interface{}) *mTypedReceiverMockReceiveIface {
	if mmReceiveIface.mock.funcReceiveIface != nil {
		mmReceiveIface.mock.t.Fatalf("TypedReceiverMock.ReceiveIface mock is already set by Set")
	}

	if mmReceiveIface.defaultExpectation == nil {
		mmReceiveIface.defaultExpectation = &TypedReceiverMockReceiveIfaceExpectation{}
	}

	mmReceiveIface.defaultExpectation.params = &TypedReceiverMockReceiveIfaceParams{k1, p1}
	for _, e := range mmReceiveIface.expectations {
		if minimock.Equal(e.params, mmReceiveIface.defaultExpectation.params) {
			mmReceiveIface.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReceiveIface.defaultExpectation.params)
		}
	}

	return mmReceiveIface
}

// Inspect accepts an inspector function that has same arguments as the TypedReceiver.ReceiveIface
func (mmReceiveIface *mTypedReceiverMockReceiveIface) Inspect(f func(k1 reflect.Kind, p1 interface{})) *mTypedReceiverMockReceiveIface {
	if mmReceiveIface.mock.inspectFuncReceiveIface != nil {
		mmReceiveIface.mock.t.Fatalf("Inspect function is already set for TypedReceiverMock.ReceiveIface")
	}

	mmReceiveIface.mock.inspectFuncReceiveIface = f

	return mmReceiveIface
}

// Return sets up results that will be returned by TypedReceiver.ReceiveIface
func (mmReceiveIface *mTypedReceiverMockReceiveIface) Return() *TypedReceiverMock {
	if mmReceiveIface.mock.funcReceiveIface != nil {
		mmReceiveIface.mock.t.Fatalf("TypedReceiverMock.ReceiveIface mock is already set by Set")
	}

	if mmReceiveIface.defaultExpectation == nil {
		mmReceiveIface.defaultExpectation = &TypedReceiverMockReceiveIfaceExpectation{mock: mmReceiveIface.mock}
	}

	return mmReceiveIface.mock
}

//Set uses given function f to mock the TypedReceiver.ReceiveIface method
func (mmReceiveIface *mTypedReceiverMockReceiveIface) Set(f func(k1 reflect.Kind, p1 interface{})) *TypedReceiverMock {
	if mmReceiveIface.defaultExpectation != nil {
		mmReceiveIface.mock.t.Fatalf("Default expectation is already set for the TypedReceiver.ReceiveIface method")
	}

	if len(mmReceiveIface.expectations) > 0 {
		mmReceiveIface.mock.t.Fatalf("Some expectations are already set for the TypedReceiver.ReceiveIface method")
	}

	mmReceiveIface.mock.funcReceiveIface = f
	return mmReceiveIface.mock
}

// ReceiveIface implements reflectkit.TypedReceiver
func (mmReceiveIface *TypedReceiverMock) ReceiveIface(k1 reflect.Kind, p1 interface{}) {
	mm_atomic.AddUint64(&mmReceiveIface.beforeReceiveIfaceCounter, 1)
	defer mm_atomic.AddUint64(&mmReceiveIface.afterReceiveIfaceCounter, 1)

	if mmReceiveIface.inspectFuncReceiveIface != nil {
		mmReceiveIface.inspectFuncReceiveIface(k1, p1)
	}

	mm_params := &TypedReceiverMockReceiveIfaceParams{k1, p1}

	// Record call args
	mmReceiveIface.ReceiveIfaceMock.mutex.Lock()
	mmReceiveIface.ReceiveIfaceMock.callArgs = append(mmReceiveIface.ReceiveIfaceMock.callArgs, mm_params)
	mmReceiveIface.ReceiveIfaceMock.mutex.Unlock()

	for _, e := range mmReceiveIface.ReceiveIfaceMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmReceiveIface.ReceiveIfaceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReceiveIface.ReceiveIfaceMock.defaultExpectation.Counter, 1)
		mm_want := mmReceiveIface.ReceiveIfaceMock.defaultExpectation.params
		mm_got := TypedReceiverMockReceiveIfaceParams{k1, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReceiveIface.t.Errorf("TypedReceiverMock.ReceiveIface got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmReceiveIface.funcReceiveIface != nil {
		mmReceiveIface.funcReceiveIface(k1, p1)
		return
	}
	mmReceiveIface.t.Fatalf("Unexpected call to TypedReceiverMock.ReceiveIface. %v %v", k1, p1)

}

// ReceiveIfaceAfterCounter returns a count of finished TypedReceiverMock.ReceiveIface invocations
func (mmReceiveIface *TypedReceiverMock) ReceiveIfaceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveIface.afterReceiveIfaceCounter)
}

// ReceiveIfaceBeforeCounter returns a count of TypedReceiverMock.ReceiveIface invocations
func (mmReceiveIface *TypedReceiverMock) ReceiveIfaceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveIface.beforeReceiveIfaceCounter)
}

// Calls returns a list of arguments used in each call to TypedReceiverMock.ReceiveIface.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReceiveIface *mTypedReceiverMockReceiveIface) Calls() []*TypedReceiverMockReceiveIfaceParams {
	mmReceiveIface.mutex.RLock()

	argCopy := make([]*TypedReceiverMockReceiveIfaceParams, len(mmReceiveIface.callArgs))
	copy(argCopy, mmReceiveIface.callArgs)

	mmReceiveIface.mutex.RUnlock()

	return argCopy
}

// MinimockReceiveIfaceDone returns true if the count of the ReceiveIface invocations corresponds
// the number of defined expectations
func (m *TypedReceiverMock) MinimockReceiveIfaceDone() bool {
	for _, e := range m.ReceiveIfaceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveIfaceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveIfaceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveIface != nil && mm_atomic.LoadUint64(&m.afterReceiveIfaceCounter) < 1 {
		return false
	}
	return true
}

// MinimockReceiveIfaceInspect logs each unmet expectation
func (m *TypedReceiverMock) MinimockReceiveIfaceInspect() {
	for _, e := range m.ReceiveIfaceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveIface with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveIfaceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveIfaceCounter) < 1 {
		if m.ReceiveIfaceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TypedReceiverMock.ReceiveIface")
		} else {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveIface with params: %#v", *m.ReceiveIfaceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveIface != nil && mm_atomic.LoadUint64(&m.afterReceiveIfaceCounter) < 1 {
		m.t.Error("Expected call to TypedReceiverMock.ReceiveIface")
	}
}

type mTypedReceiverMockReceiveInt struct {
	mock               *TypedReceiverMock
	defaultExpectation *TypedReceiverMockReceiveIntExpectation
	expectations       []*TypedReceiverMockReceiveIntExpectation

	callArgs []*TypedReceiverMockReceiveIntParams
	mutex    sync.RWMutex
}

// TypedReceiverMockReceiveIntExpectation specifies expectation struct of the TypedReceiver.ReceiveInt
type TypedReceiverMockReceiveIntExpectation struct {
	mock   *TypedReceiverMock
	params *TypedReceiverMockReceiveIntParams

	Counter uint64
}

// TypedReceiverMockReceiveIntParams contains parameters of the TypedReceiver.ReceiveInt
type TypedReceiverMockReceiveIntParams struct {
	k1 reflect.Kind
	i1 int64
}

// Expect sets up expected params for TypedReceiver.ReceiveInt
func (mmReceiveInt *mTypedReceiverMockReceiveInt) Expect(k1 reflect.Kind, i1 int64) *mTypedReceiverMockReceiveInt {
	if mmReceiveInt.mock.funcReceiveInt != nil {
		mmReceiveInt.mock.t.Fatalf("TypedReceiverMock.ReceiveInt mock is already set by Set")
	}

	if mmReceiveInt.defaultExpectation == nil {
		mmReceiveInt.defaultExpectation = &TypedReceiverMockReceiveIntExpectation{}
	}

	mmReceiveInt.defaultExpectation.params = &TypedReceiverMockReceiveIntParams{k1, i1}
	for _, e := range mmReceiveInt.expectations {
		if minimock.Equal(e.params, mmReceiveInt.defaultExpectation.params) {
			mmReceiveInt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReceiveInt.defaultExpectation.params)
		}
	}

	return mmReceiveInt
}

// Inspect accepts an inspector function that has same arguments as the TypedReceiver.ReceiveInt
func (mmReceiveInt *mTypedReceiverMockReceiveInt) Inspect(f func(k1 reflect.Kind, i1 int64)) *mTypedReceiverMockReceiveInt {
	if mmReceiveInt.mock.inspectFuncReceiveInt != nil {
		mmReceiveInt.mock.t.Fatalf("Inspect function is already set for TypedReceiverMock.ReceiveInt")
	}

	mmReceiveInt.mock.inspectFuncReceiveInt = f

	return mmReceiveInt
}

// Return sets up results that will be returned by TypedReceiver.ReceiveInt
func (mmReceiveInt *mTypedReceiverMockReceiveInt) Return() *TypedReceiverMock {
	if mmReceiveInt.mock.funcReceiveInt != nil {
		mmReceiveInt.mock.t.Fatalf("TypedReceiverMock.ReceiveInt mock is already set by Set")
	}

	if mmReceiveInt.defaultExpectation == nil {
		mmReceiveInt.defaultExpectation = &TypedReceiverMockReceiveIntExpectation{mock: mmReceiveInt.mock}
	}

	return mmReceiveInt.mock
}

//Set uses given function f to mock the TypedReceiver.ReceiveInt method
func (mmReceiveInt *mTypedReceiverMockReceiveInt) Set(f func(k1 reflect.Kind, i1 int64)) *TypedReceiverMock {
	if mmReceiveInt.defaultExpectation != nil {
		mmReceiveInt.mock.t.Fatalf("Default expectation is already set for the TypedReceiver.ReceiveInt method")
	}

	if len(mmReceiveInt.expectations) > 0 {
		mmReceiveInt.mock.t.Fatalf("Some expectations are already set for the TypedReceiver.ReceiveInt method")
	}

	mmReceiveInt.mock.funcReceiveInt = f
	return mmReceiveInt.mock
}

// ReceiveInt implements reflectkit.TypedReceiver
func (mmReceiveInt *TypedReceiverMock) ReceiveInt(k1 reflect.Kind, i1 int64) {
	mm_atomic.AddUint64(&mmReceiveInt.beforeReceiveIntCounter, 1)
	defer mm_atomic.AddUint64(&mmReceiveInt.afterReceiveIntCounter, 1)

	if mmReceiveInt.inspectFuncReceiveInt != nil {
		mmReceiveInt.inspectFuncReceiveInt(k1, i1)
	}

	mm_params := &TypedReceiverMockReceiveIntParams{k1, i1}

	// Record call args
	mmReceiveInt.ReceiveIntMock.mutex.Lock()
	mmReceiveInt.ReceiveIntMock.callArgs = append(mmReceiveInt.ReceiveIntMock.callArgs, mm_params)
	mmReceiveInt.ReceiveIntMock.mutex.Unlock()

	for _, e := range mmReceiveInt.ReceiveIntMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmReceiveInt.ReceiveIntMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReceiveInt.ReceiveIntMock.defaultExpectation.Counter, 1)
		mm_want := mmReceiveInt.ReceiveIntMock.defaultExpectation.params
		mm_got := TypedReceiverMockReceiveIntParams{k1, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReceiveInt.t.Errorf("TypedReceiverMock.ReceiveInt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmReceiveInt.funcReceiveInt != nil {
		mmReceiveInt.funcReceiveInt(k1, i1)
		return
	}
	mmReceiveInt.t.Fatalf("Unexpected call to TypedReceiverMock.ReceiveInt. %v %v", k1, i1)

}

// ReceiveIntAfterCounter returns a count of finished TypedReceiverMock.ReceiveInt invocations
func (mmReceiveInt *TypedReceiverMock) ReceiveIntAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveInt.afterReceiveIntCounter)
}

// ReceiveIntBeforeCounter returns a count of TypedReceiverMock.ReceiveInt invocations
func (mmReceiveInt *TypedReceiverMock) ReceiveIntBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveInt.beforeReceiveIntCounter)
}

// Calls returns a list of arguments used in each call to TypedReceiverMock.ReceiveInt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReceiveInt *mTypedReceiverMockReceiveInt) Calls() []*TypedReceiverMockReceiveIntParams {
	mmReceiveInt.mutex.RLock()

	argCopy := make([]*TypedReceiverMockReceiveIntParams, len(mmReceiveInt.callArgs))
	copy(argCopy, mmReceiveInt.callArgs)

	mmReceiveInt.mutex.RUnlock()

	return argCopy
}

// MinimockReceiveIntDone returns true if the count of the ReceiveInt invocations corresponds
// the number of defined expectations
func (m *TypedReceiverMock) MinimockReceiveIntDone() bool {
	for _, e := range m.ReceiveIntMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveIntMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveIntCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveInt != nil && mm_atomic.LoadUint64(&m.afterReceiveIntCounter) < 1 {
		return false
	}
	return true
}

// MinimockReceiveIntInspect logs each unmet expectation
func (m *TypedReceiverMock) MinimockReceiveIntInspect() {
	for _, e := range m.ReceiveIntMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveInt with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveIntMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveIntCounter) < 1 {
		if m.ReceiveIntMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TypedReceiverMock.ReceiveInt")
		} else {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveInt with params: %#v", *m.ReceiveIntMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveInt != nil && mm_atomic.LoadUint64(&m.afterReceiveIntCounter) < 1 {
		m.t.Error("Expected call to TypedReceiverMock.ReceiveInt")
	}
}

type mTypedReceiverMockReceiveNil struct {
	mock               *TypedReceiverMock
	defaultExpectation *TypedReceiverMockReceiveNilExpectation
	expectations       []*TypedReceiverMockReceiveNilExpectation

	callArgs []*TypedReceiverMockReceiveNilParams
	mutex    sync.RWMutex
}

// TypedReceiverMockReceiveNilExpectation specifies expectation struct of the TypedReceiver.ReceiveNil
type TypedReceiverMockReceiveNilExpectation struct {
	mock   *TypedReceiverMock
	params *TypedReceiverMockReceiveNilParams

	Counter uint64
}

// TypedReceiverMockReceiveNilParams contains parameters of the TypedReceiver.ReceiveNil
type TypedReceiverMockReceiveNilParams struct {
	k1 reflect.Kind
}

// Expect sets up expected params for TypedReceiver.ReceiveNil
func (mmReceiveNil *mTypedReceiverMockReceiveNil) Expect(k1 reflect.Kind) *mTypedReceiverMockReceiveNil {
	if mmReceiveNil.mock.funcReceiveNil != nil {
		mmReceiveNil.mock.t.Fatalf("TypedReceiverMock.ReceiveNil mock is already set by Set")
	}

	if mmReceiveNil.defaultExpectation == nil {
		mmReceiveNil.defaultExpectation = &TypedReceiverMockReceiveNilExpectation{}
	}

	mmReceiveNil.defaultExpectation.params = &TypedReceiverMockReceiveNilParams{k1}
	for _, e := range mmReceiveNil.expectations {
		if minimock.Equal(e.params, mmReceiveNil.defaultExpectation.params) {
			mmReceiveNil.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReceiveNil.defaultExpectation.params)
		}
	}

	return mmReceiveNil
}

// Inspect accepts an inspector function that has same arguments as the TypedReceiver.ReceiveNil
func (mmReceiveNil *mTypedReceiverMockReceiveNil) Inspect(f func(k1 reflect.Kind)) *mTypedReceiverMockReceiveNil {
	if mmReceiveNil.mock.inspectFuncReceiveNil != nil {
		mmReceiveNil.mock.t.Fatalf("Inspect function is already set for TypedReceiverMock.ReceiveNil")
	}

	mmReceiveNil.mock.inspectFuncReceiveNil = f

	return mmReceiveNil
}

// Return sets up results that will be returned by TypedReceiver.ReceiveNil
func (mmReceiveNil *mTypedReceiverMockReceiveNil) Return() *TypedReceiverMock {
	if mmReceiveNil.mock.funcReceiveNil != nil {
		mmReceiveNil.mock.t.Fatalf("TypedReceiverMock.ReceiveNil mock is already set by Set")
	}

	if mmReceiveNil.defaultExpectation == nil {
		mmReceiveNil.defaultExpectation = &TypedReceiverMockReceiveNilExpectation{mock: mmReceiveNil.mock}
	}

	return mmReceiveNil.mock
}

//Set uses given function f to mock the TypedReceiver.ReceiveNil method
func (mmReceiveNil *mTypedReceiverMockReceiveNil) Set(f func(k1 reflect.Kind)) *TypedReceiverMock {
	if mmReceiveNil.defaultExpectation != nil {
		mmReceiveNil.mock.t.Fatalf("Default expectation is already set for the TypedReceiver.ReceiveNil method")
	}

	if len(mmReceiveNil.expectations) > 0 {
		mmReceiveNil.mock.t.Fatalf("Some expectations are already set for the TypedReceiver.ReceiveNil method")
	}

	mmReceiveNil.mock.funcReceiveNil = f
	return mmReceiveNil.mock
}

// ReceiveNil implements reflectkit.TypedReceiver
func (mmReceiveNil *TypedReceiverMock) ReceiveNil(k1 reflect.Kind) {
	mm_atomic.AddUint64(&mmReceiveNil.beforeReceiveNilCounter, 1)
	defer mm_atomic.AddUint64(&mmReceiveNil.afterReceiveNilCounter, 1)

	if mmReceiveNil.inspectFuncReceiveNil != nil {
		mmReceiveNil.inspectFuncReceiveNil(k1)
	}

	mm_params := &TypedReceiverMockReceiveNilParams{k1}

	// Record call args
	mmReceiveNil.ReceiveNilMock.mutex.Lock()
	mmReceiveNil.ReceiveNilMock.callArgs = append(mmReceiveNil.ReceiveNilMock.callArgs, mm_params)
	mmReceiveNil.ReceiveNilMock.mutex.Unlock()

	for _, e := range mmReceiveNil.ReceiveNilMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmReceiveNil.ReceiveNilMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReceiveNil.ReceiveNilMock.defaultExpectation.Counter, 1)
		mm_want := mmReceiveNil.ReceiveNilMock.defaultExpectation.params
		mm_got := TypedReceiverMockReceiveNilParams{k1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReceiveNil.t.Errorf("TypedReceiverMock.ReceiveNil got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmReceiveNil.funcReceiveNil != nil {
		mmReceiveNil.funcReceiveNil(k1)
		return
	}
	mmReceiveNil.t.Fatalf("Unexpected call to TypedReceiverMock.ReceiveNil. %v", k1)

}

// ReceiveNilAfterCounter returns a count of finished TypedReceiverMock.ReceiveNil invocations
func (mmReceiveNil *TypedReceiverMock) ReceiveNilAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveNil.afterReceiveNilCounter)
}

// ReceiveNilBeforeCounter returns a count of TypedReceiverMock.ReceiveNil invocations
func (mmReceiveNil *TypedReceiverMock) ReceiveNilBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveNil.beforeReceiveNilCounter)
}

// Calls returns a list of arguments used in each call to TypedReceiverMock.ReceiveNil.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReceiveNil *mTypedReceiverMockReceiveNil) Calls() []*TypedReceiverMockReceiveNilParams {
	mmReceiveNil.mutex.RLock()

	argCopy := make([]*TypedReceiverMockReceiveNilParams, len(mmReceiveNil.callArgs))
	copy(argCopy, mmReceiveNil.callArgs)

	mmReceiveNil.mutex.RUnlock()

	return argCopy
}

// MinimockReceiveNilDone returns true if the count of the ReceiveNil invocations corresponds
// the number of defined expectations
func (m *TypedReceiverMock) MinimockReceiveNilDone() bool {
	for _, e := range m.ReceiveNilMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveNilMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveNilCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveNil != nil && mm_atomic.LoadUint64(&m.afterReceiveNilCounter) < 1 {
		return false
	}
	return true
}

// MinimockReceiveNilInspect logs each unmet expectation
func (m *TypedReceiverMock) MinimockReceiveNilInspect() {
	for _, e := range m.ReceiveNilMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveNil with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveNilMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveNilCounter) < 1 {
		if m.ReceiveNilMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TypedReceiverMock.ReceiveNil")
		} else {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveNil with params: %#v", *m.ReceiveNilMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveNil != nil && mm_atomic.LoadUint64(&m.afterReceiveNilCounter) < 1 {
		m.t.Error("Expected call to TypedReceiverMock.ReceiveNil")
	}
}

type mTypedReceiverMockReceiveString struct {
	mock               *TypedReceiverMock
	defaultExpectation *TypedReceiverMockReceiveStringExpectation
	expectations       []*TypedReceiverMockReceiveStringExpectation

	callArgs []*TypedReceiverMockReceiveStringParams
	mutex    sync.RWMutex
}

// TypedReceiverMockReceiveStringExpectation specifies expectation struct of the TypedReceiver.ReceiveString
type TypedReceiverMockReceiveStringExpectation struct {
	mock   *TypedReceiverMock
	params *TypedReceiverMockReceiveStringParams

	Counter uint64
}

// TypedReceiverMockReceiveStringParams contains parameters of the TypedReceiver.ReceiveString
type TypedReceiverMockReceiveStringParams struct {
	k1 reflect.Kind
	s1 string
}

// Expect sets up expected params for TypedReceiver.ReceiveString
func (mmReceiveString *mTypedReceiverMockReceiveString) Expect(k1 reflect.Kind, s1 string) *mTypedReceiverMockReceiveString {
	if mmReceiveString.mock.funcReceiveString != nil {
		mmReceiveString.mock.t.Fatalf("TypedReceiverMock.ReceiveString mock is already set by Set")
	}

	if mmReceiveString.defaultExpectation == nil {
		mmReceiveString.defaultExpectation = &TypedReceiverMockReceiveStringExpectation{}
	}

	mmReceiveString.defaultExpectation.params = &TypedReceiverMockReceiveStringParams{k1, s1}
	for _, e := range mmReceiveString.expectations {
		if minimock.Equal(e.params, mmReceiveString.defaultExpectation.params) {
			mmReceiveString.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReceiveString.defaultExpectation.params)
		}
	}

	return mmReceiveString
}

// Inspect accepts an inspector function that has same arguments as the TypedReceiver.ReceiveString
func (mmReceiveString *mTypedReceiverMockReceiveString) Inspect(f func(k1 reflect.Kind, s1 string)) *mTypedReceiverMockReceiveString {
	if mmReceiveString.mock.inspectFuncReceiveString != nil {
		mmReceiveString.mock.t.Fatalf("Inspect function is already set for TypedReceiverMock.ReceiveString")
	}

	mmReceiveString.mock.inspectFuncReceiveString = f

	return mmReceiveString
}

// Return sets up results that will be returned by TypedReceiver.ReceiveString
func (mmReceiveString *mTypedReceiverMockReceiveString) Return() *TypedReceiverMock {
	if mmReceiveString.mock.funcReceiveString != nil {
		mmReceiveString.mock.t.Fatalf("TypedReceiverMock.ReceiveString mock is already set by Set")
	}

	if mmReceiveString.defaultExpectation == nil {
		mmReceiveString.defaultExpectation = &TypedReceiverMockReceiveStringExpectation{mock: mmReceiveString.mock}
	}

	return mmReceiveString.mock
}

//Set uses given function f to mock the TypedReceiver.ReceiveString method
func (mmReceiveString *mTypedReceiverMockReceiveString) Set(f func(k1 reflect.Kind, s1 string)) *TypedReceiverMock {
	if mmReceiveString.defaultExpectation != nil {
		mmReceiveString.mock.t.Fatalf("Default expectation is already set for the TypedReceiver.ReceiveString method")
	}

	if len(mmReceiveString.expectations) > 0 {
		mmReceiveString.mock.t.Fatalf("Some expectations are already set for the TypedReceiver.ReceiveString method")
	}

	mmReceiveString.mock.funcReceiveString = f
	return mmReceiveString.mock
}

// ReceiveString implements reflectkit.TypedReceiver
func (mmReceiveString *TypedReceiverMock) ReceiveString(k1 reflect.Kind, s1 string) {
	mm_atomic.AddUint64(&mmReceiveString.beforeReceiveStringCounter, 1)
	defer mm_atomic.AddUint64(&mmReceiveString.afterReceiveStringCounter, 1)

	if mmReceiveString.inspectFuncReceiveString != nil {
		mmReceiveString.inspectFuncReceiveString(k1, s1)
	}

	mm_params := &TypedReceiverMockReceiveStringParams{k1, s1}

	// Record call args
	mmReceiveString.ReceiveStringMock.mutex.Lock()
	mmReceiveString.ReceiveStringMock.callArgs = append(mmReceiveString.ReceiveStringMock.callArgs, mm_params)
	mmReceiveString.ReceiveStringMock.mutex.Unlock()

	for _, e := range mmReceiveString.ReceiveStringMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmReceiveString.ReceiveStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReceiveString.ReceiveStringMock.defaultExpectation.Counter, 1)
		mm_want := mmReceiveString.ReceiveStringMock.defaultExpectation.params
		mm_got := TypedReceiverMockReceiveStringParams{k1, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReceiveString.t.Errorf("TypedReceiverMock.ReceiveString got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmReceiveString.funcReceiveString != nil {
		mmReceiveString.funcReceiveString(k1, s1)
		return
	}
	mmReceiveString.t.Fatalf("Unexpected call to TypedReceiverMock.ReceiveString. %v %v", k1, s1)

}

// ReceiveStringAfterCounter returns a count of finished TypedReceiverMock.ReceiveString invocations
func (mmReceiveString *TypedReceiverMock) ReceiveStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveString.afterReceiveStringCounter)
}

// ReceiveStringBeforeCounter returns a count of TypedReceiverMock.ReceiveString invocations
func (mmReceiveString *TypedReceiverMock) ReceiveStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveString.beforeReceiveStringCounter)
}

// Calls returns a list of arguments used in each call to TypedReceiverMock.ReceiveString.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReceiveString *mTypedReceiverMockReceiveString) Calls() []*TypedReceiverMockReceiveStringParams {
	mmReceiveString.mutex.RLock()

	argCopy := make([]*TypedReceiverMockReceiveStringParams, len(mmReceiveString.callArgs))
	copy(argCopy, mmReceiveString.callArgs)

	mmReceiveString.mutex.RUnlock()

	return argCopy
}

// MinimockReceiveStringDone returns true if the count of the ReceiveString invocations corresponds
// the number of defined expectations
func (m *TypedReceiverMock) MinimockReceiveStringDone() bool {
	for _, e := range m.ReceiveStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveString != nil && mm_atomic.LoadUint64(&m.afterReceiveStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockReceiveStringInspect logs each unmet expectation
func (m *TypedReceiverMock) MinimockReceiveStringInspect() {
	for _, e := range m.ReceiveStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveString with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveStringCounter) < 1 {
		if m.ReceiveStringMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TypedReceiverMock.ReceiveString")
		} else {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveString with params: %#v", *m.ReceiveStringMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveString != nil && mm_atomic.LoadUint64(&m.afterReceiveStringCounter) < 1 {
		m.t.Error("Expected call to TypedReceiverMock.ReceiveString")
	}
}

type mTypedReceiverMockReceiveUint struct {
	mock               *TypedReceiverMock
	defaultExpectation *TypedReceiverMockReceiveUintExpectation
	expectations       []*TypedReceiverMockReceiveUintExpectation

	callArgs []*TypedReceiverMockReceiveUintParams
	mutex    sync.RWMutex
}

// TypedReceiverMockReceiveUintExpectation specifies expectation struct of the TypedReceiver.ReceiveUint
type TypedReceiverMockReceiveUintExpectation struct {
	mock   *TypedReceiverMock
	params *TypedReceiverMockReceiveUintParams

	Counter uint64
}

// TypedReceiverMockReceiveUintParams contains parameters of the TypedReceiver.ReceiveUint
type TypedReceiverMockReceiveUintParams struct {
	k1 reflect.Kind
	u1 uint64
}

// Expect sets up expected params for TypedReceiver.ReceiveUint
func (mmReceiveUint *mTypedReceiverMockReceiveUint) Expect(k1 reflect.Kind, u1 uint64) *mTypedReceiverMockReceiveUint {
	if mmReceiveUint.mock.funcReceiveUint != nil {
		mmReceiveUint.mock.t.Fatalf("TypedReceiverMock.ReceiveUint mock is already set by Set")
	}

	if mmReceiveUint.defaultExpectation == nil {
		mmReceiveUint.defaultExpectation = &TypedReceiverMockReceiveUintExpectation{}
	}

	mmReceiveUint.defaultExpectation.params = &TypedReceiverMockReceiveUintParams{k1, u1}
	for _, e := range mmReceiveUint.expectations {
		if minimock.Equal(e.params, mmReceiveUint.defaultExpectation.params) {
			mmReceiveUint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReceiveUint.defaultExpectation.params)
		}
	}

	return mmReceiveUint
}

// Inspect accepts an inspector function that has same arguments as the TypedReceiver.ReceiveUint
func (mmReceiveUint *mTypedReceiverMockReceiveUint) Inspect(f func(k1 reflect.Kind, u1 uint64)) *mTypedReceiverMockReceiveUint {
	if mmReceiveUint.mock.inspectFuncReceiveUint != nil {
		mmReceiveUint.mock.t.Fatalf("Inspect function is already set for TypedReceiverMock.ReceiveUint")
	}

	mmReceiveUint.mock.inspectFuncReceiveUint = f

	return mmReceiveUint
}

// Return sets up results that will be returned by TypedReceiver.ReceiveUint
func (mmReceiveUint *mTypedReceiverMockReceiveUint) Return() *TypedReceiverMock {
	if mmReceiveUint.mock.funcReceiveUint != nil {
		mmReceiveUint.mock.t.Fatalf("TypedReceiverMock.ReceiveUint mock is already set by Set")
	}

	if mmReceiveUint.defaultExpectation == nil {
		mmReceiveUint.defaultExpectation = &TypedReceiverMockReceiveUintExpectation{mock: mmReceiveUint.mock}
	}

	return mmReceiveUint.mock
}

//Set uses given function f to mock the TypedReceiver.ReceiveUint method
func (mmReceiveUint *mTypedReceiverMockReceiveUint) Set(f func(k1 reflect.Kind, u1 uint64)) *TypedReceiverMock {
	if mmReceiveUint.defaultExpectation != nil {
		mmReceiveUint.mock.t.Fatalf("Default expectation is already set for the TypedReceiver.ReceiveUint method")
	}

	if len(mmReceiveUint.expectations) > 0 {
		mmReceiveUint.mock.t.Fatalf("Some expectations are already set for the TypedReceiver.ReceiveUint method")
	}

	mmReceiveUint.mock.funcReceiveUint = f
	return mmReceiveUint.mock
}

// ReceiveUint implements reflectkit.TypedReceiver
func (mmReceiveUint *TypedReceiverMock) ReceiveUint(k1 reflect.Kind, u1 uint64) {
	mm_atomic.AddUint64(&mmReceiveUint.beforeReceiveUintCounter, 1)
	defer mm_atomic.AddUint64(&mmReceiveUint.afterReceiveUintCounter, 1)

	if mmReceiveUint.inspectFuncReceiveUint != nil {
		mmReceiveUint.inspectFuncReceiveUint(k1, u1)
	}

	mm_params := &TypedReceiverMockReceiveUintParams{k1, u1}

	// Record call args
	mmReceiveUint.ReceiveUintMock.mutex.Lock()
	mmReceiveUint.ReceiveUintMock.callArgs = append(mmReceiveUint.ReceiveUintMock.callArgs, mm_params)
	mmReceiveUint.ReceiveUintMock.mutex.Unlock()

	for _, e := range mmReceiveUint.ReceiveUintMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmReceiveUint.ReceiveUintMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReceiveUint.ReceiveUintMock.defaultExpectation.Counter, 1)
		mm_want := mmReceiveUint.ReceiveUintMock.defaultExpectation.params
		mm_got := TypedReceiverMockReceiveUintParams{k1, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReceiveUint.t.Errorf("TypedReceiverMock.ReceiveUint got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmReceiveUint.funcReceiveUint != nil {
		mmReceiveUint.funcReceiveUint(k1, u1)
		return
	}
	mmReceiveUint.t.Fatalf("Unexpected call to TypedReceiverMock.ReceiveUint. %v %v", k1, u1)

}

// ReceiveUintAfterCounter returns a count of finished TypedReceiverMock.ReceiveUint invocations
func (mmReceiveUint *TypedReceiverMock) ReceiveUintAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveUint.afterReceiveUintCounter)
}

// ReceiveUintBeforeCounter returns a count of TypedReceiverMock.ReceiveUint invocations
func (mmReceiveUint *TypedReceiverMock) ReceiveUintBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveUint.beforeReceiveUintCounter)
}

// Calls returns a list of arguments used in each call to TypedReceiverMock.ReceiveUint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReceiveUint *mTypedReceiverMockReceiveUint) Calls() []*TypedReceiverMockReceiveUintParams {
	mmReceiveUint.mutex.RLock()

	argCopy := make([]*TypedReceiverMockReceiveUintParams, len(mmReceiveUint.callArgs))
	copy(argCopy, mmReceiveUint.callArgs)

	mmReceiveUint.mutex.RUnlock()

	return argCopy
}

// MinimockReceiveUintDone returns true if the count of the ReceiveUint invocations corresponds
// the number of defined expectations
func (m *TypedReceiverMock) MinimockReceiveUintDone() bool {
	for _, e := range m.ReceiveUintMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveUintMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveUintCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveUint != nil && mm_atomic.LoadUint64(&m.afterReceiveUintCounter) < 1 {
		return false
	}
	return true
}

// MinimockReceiveUintInspect logs each unmet expectation
func (m *TypedReceiverMock) MinimockReceiveUintInspect() {
	for _, e := range m.ReceiveUintMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveUint with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveUintMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveUintCounter) < 1 {
		if m.ReceiveUintMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TypedReceiverMock.ReceiveUint")
		} else {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveUint with params: %#v", *m.ReceiveUintMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveUint != nil && mm_atomic.LoadUint64(&m.afterReceiveUintCounter) < 1 {
		m.t.Error("Expected call to TypedReceiverMock.ReceiveUint")
	}
}

type mTypedReceiverMockReceiveZero struct {
	mock               *TypedReceiverMock
	defaultExpectation *TypedReceiverMockReceiveZeroExpectation
	expectations       []*TypedReceiverMockReceiveZeroExpectation

	callArgs []*TypedReceiverMockReceiveZeroParams
	mutex    sync.RWMutex
}

// TypedReceiverMockReceiveZeroExpectation specifies expectation struct of the TypedReceiver.ReceiveZero
type TypedReceiverMockReceiveZeroExpectation struct {
	mock   *TypedReceiverMock
	params *TypedReceiverMockReceiveZeroParams

	Counter uint64
}

// TypedReceiverMockReceiveZeroParams contains parameters of the TypedReceiver.ReceiveZero
type TypedReceiverMockReceiveZeroParams struct {
	k1 reflect.Kind
}

// Expect sets up expected params for TypedReceiver.ReceiveZero
func (mmReceiveZero *mTypedReceiverMockReceiveZero) Expect(k1 reflect.Kind) *mTypedReceiverMockReceiveZero {
	if mmReceiveZero.mock.funcReceiveZero != nil {
		mmReceiveZero.mock.t.Fatalf("TypedReceiverMock.ReceiveZero mock is already set by Set")
	}

	if mmReceiveZero.defaultExpectation == nil {
		mmReceiveZero.defaultExpectation = &TypedReceiverMockReceiveZeroExpectation{}
	}

	mmReceiveZero.defaultExpectation.params = &TypedReceiverMockReceiveZeroParams{k1}
	for _, e := range mmReceiveZero.expectations {
		if minimock.Equal(e.params, mmReceiveZero.defaultExpectation.params) {
			mmReceiveZero.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReceiveZero.defaultExpectation.params)
		}
	}

	return mmReceiveZero
}

// Inspect accepts an inspector function that has same arguments as the TypedReceiver.ReceiveZero
func (mmReceiveZero *mTypedReceiverMockReceiveZero) Inspect(f func(k1 reflect.Kind)) *mTypedReceiverMockReceiveZero {
	if mmReceiveZero.mock.inspectFuncReceiveZero != nil {
		mmReceiveZero.mock.t.Fatalf("Inspect function is already set for TypedReceiverMock.ReceiveZero")
	}

	mmReceiveZero.mock.inspectFuncReceiveZero = f

	return mmReceiveZero
}

// Return sets up results that will be returned by TypedReceiver.ReceiveZero
func (mmReceiveZero *mTypedReceiverMockReceiveZero) Return() *TypedReceiverMock {
	if mmReceiveZero.mock.funcReceiveZero != nil {
		mmReceiveZero.mock.t.Fatalf("TypedReceiverMock.ReceiveZero mock is already set by Set")
	}

	if mmReceiveZero.defaultExpectation == nil {
		mmReceiveZero.defaultExpectation = &TypedReceiverMockReceiveZeroExpectation{mock: mmReceiveZero.mock}
	}

	return mmReceiveZero.mock
}

//Set uses given function f to mock the TypedReceiver.ReceiveZero method
func (mmReceiveZero *mTypedReceiverMockReceiveZero) Set(f func(k1 reflect.Kind)) *TypedReceiverMock {
	if mmReceiveZero.defaultExpectation != nil {
		mmReceiveZero.mock.t.Fatalf("Default expectation is already set for the TypedReceiver.ReceiveZero method")
	}

	if len(mmReceiveZero.expectations) > 0 {
		mmReceiveZero.mock.t.Fatalf("Some expectations are already set for the TypedReceiver.ReceiveZero method")
	}

	mmReceiveZero.mock.funcReceiveZero = f
	return mmReceiveZero.mock
}

// ReceiveZero implements reflectkit.TypedReceiver
func (mmReceiveZero *TypedReceiverMock) ReceiveZero(k1 reflect.Kind) {
	mm_atomic.AddUint64(&mmReceiveZero.beforeReceiveZeroCounter, 1)
	defer mm_atomic.AddUint64(&mmReceiveZero.afterReceiveZeroCounter, 1)

	if mmReceiveZero.inspectFuncReceiveZero != nil {
		mmReceiveZero.inspectFuncReceiveZero(k1)
	}

	mm_params := &TypedReceiverMockReceiveZeroParams{k1}

	// Record call args
	mmReceiveZero.ReceiveZeroMock.mutex.Lock()
	mmReceiveZero.ReceiveZeroMock.callArgs = append(mmReceiveZero.ReceiveZeroMock.callArgs, mm_params)
	mmReceiveZero.ReceiveZeroMock.mutex.Unlock()

	for _, e := range mmReceiveZero.ReceiveZeroMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmReceiveZero.ReceiveZeroMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReceiveZero.ReceiveZeroMock.defaultExpectation.Counter, 1)
		mm_want := mmReceiveZero.ReceiveZeroMock.defaultExpectation.params
		mm_got := TypedReceiverMockReceiveZeroParams{k1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReceiveZero.t.Errorf("TypedReceiverMock.ReceiveZero got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmReceiveZero.funcReceiveZero != nil {
		mmReceiveZero.funcReceiveZero(k1)
		return
	}
	mmReceiveZero.t.Fatalf("Unexpected call to TypedReceiverMock.ReceiveZero. %v", k1)

}

// ReceiveZeroAfterCounter returns a count of finished TypedReceiverMock.ReceiveZero invocations
func (mmReceiveZero *TypedReceiverMock) ReceiveZeroAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveZero.afterReceiveZeroCounter)
}

// ReceiveZeroBeforeCounter returns a count of TypedReceiverMock.ReceiveZero invocations
func (mmReceiveZero *TypedReceiverMock) ReceiveZeroBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveZero.beforeReceiveZeroCounter)
}

// Calls returns a list of arguments used in each call to TypedReceiverMock.ReceiveZero.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReceiveZero *mTypedReceiverMockReceiveZero) Calls() []*TypedReceiverMockReceiveZeroParams {
	mmReceiveZero.mutex.RLock()

	argCopy := make([]*TypedReceiverMockReceiveZeroParams, len(mmReceiveZero.callArgs))
	copy(argCopy, mmReceiveZero.callArgs)

	mmReceiveZero.mutex.RUnlock()

	return argCopy
}

// MinimockReceiveZeroDone returns true if the count of the ReceiveZero invocations corresponds
// the number of defined expectations
func (m *TypedReceiverMock) MinimockReceiveZeroDone() bool {
	for _, e := range m.ReceiveZeroMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveZeroMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveZeroCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveZero != nil && mm_atomic.LoadUint64(&m.afterReceiveZeroCounter) < 1 {
		return false
	}
	return true
}

// MinimockReceiveZeroInspect logs each unmet expectation
func (m *TypedReceiverMock) MinimockReceiveZeroInspect() {
	for _, e := range m.ReceiveZeroMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveZero with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveZeroMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveZeroCounter) < 1 {
		if m.ReceiveZeroMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TypedReceiverMock.ReceiveZero")
		} else {
			m.t.Errorf("Expected call to TypedReceiverMock.ReceiveZero with params: %#v", *m.ReceiveZeroMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveZero != nil && mm_atomic.LoadUint64(&m.afterReceiveZeroCounter) < 1 {
		m.t.Error("Expected call to TypedReceiverMock.ReceiveZero")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TypedReceiverMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockReceiveBoolInspect()

		m.MinimockReceiveComplexInspect()

		m.MinimockReceiveElseInspect()

		m.MinimockReceiveFloatInspect()

		m.MinimockReceiveIfaceInspect()

		m.MinimockReceiveIntInspect()

		m.MinimockReceiveNilInspect()

		m.MinimockReceiveStringInspect()

		m.MinimockReceiveUintInspect()

		m.MinimockReceiveZeroInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TypedReceiverMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TypedReceiverMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockReceiveBoolDone() &&
		m.MinimockReceiveComplexDone() &&
		m.MinimockReceiveElseDone() &&
		m.MinimockReceiveFloatDone() &&
		m.MinimockReceiveIfaceDone() &&
		m.MinimockReceiveIntDone() &&
		m.MinimockReceiveNilDone() &&
		m.MinimockReceiveStringDone() &&
		m.MinimockReceiveUintDone() &&
		m.MinimockReceiveZeroDone()
}
