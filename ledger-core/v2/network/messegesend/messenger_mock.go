package messegesend

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/v2/insolar"
	"github.com/insolar/assured-ledger/ledger-core/v2/insolar/payload"
	"github.com/insolar/assured-ledger/ledger-core/v2/pulse"
)

// MessengerMock implements Messenger
type MessengerMock struct {
	t minimock.Tester

	funcSendRole          func(ctx context.Context, msg payload.Marshaler, role insolar.DynamicRole, object insolar.Reference, pn pulse.Number, opts ...SendOption) (err error)
	inspectFuncSendRole   func(ctx context.Context, msg payload.Marshaler, role insolar.DynamicRole, object insolar.Reference, pn pulse.Number, opts ...SendOption)
	afterSendRoleCounter  uint64
	beforeSendRoleCounter uint64
	SendRoleMock          mMessengerMockSendRole

	funcSendTarget          func(ctx context.Context, msg payload.Marshaler, target insolar.Reference, opts ...SendOption) (err error)
	inspectFuncSendTarget   func(ctx context.Context, msg payload.Marshaler, target insolar.Reference, opts ...SendOption)
	afterSendTargetCounter  uint64
	beforeSendTargetCounter uint64
	SendTargetMock          mMessengerMockSendTarget
}

// NewMessengerMock returns a mock for Messenger
func NewMessengerMock(t minimock.Tester) *MessengerMock {
	m := &MessengerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.SendRoleMock = mMessengerMockSendRole{mock: m}
	m.SendRoleMock.callArgs = []*MessengerMockSendRoleParams{}

	m.SendTargetMock = mMessengerMockSendTarget{mock: m}
	m.SendTargetMock.callArgs = []*MessengerMockSendTargetParams{}

	return m
}

type mMessengerMockSendRole struct {
	mock               *MessengerMock
	defaultExpectation *MessengerMockSendRoleExpectation
	expectations       []*MessengerMockSendRoleExpectation

	callArgs []*MessengerMockSendRoleParams
	mutex    sync.RWMutex
}

// MessengerMockSendRoleExpectation specifies expectation struct of the Messenger.SendRole
type MessengerMockSendRoleExpectation struct {
	mock    *MessengerMock
	params  *MessengerMockSendRoleParams
	results *MessengerMockSendRoleResults
	Counter uint64
}

// MessengerMockSendRoleParams contains parameters of the Messenger.SendRole
type MessengerMockSendRoleParams struct {
	ctx    context.Context
	msg    payload.Marshaler
	role   insolar.DynamicRole
	object insolar.Reference
	pn     pulse.Number
	opts   []SendOption
}

// MessengerMockSendRoleResults contains results of the Messenger.SendRole
type MessengerMockSendRoleResults struct {
	err error
}

// Expect sets up expected params for Messenger.SendRole
func (mmSendRole *mMessengerMockSendRole) Expect(ctx context.Context, msg payload.Marshaler, role insolar.DynamicRole, object insolar.Reference, pn pulse.Number, opts ...SendOption) *mMessengerMockSendRole {
	if mmSendRole.mock.funcSendRole != nil {
		mmSendRole.mock.t.Fatalf("MessengerMock.SendRole mock is already set by Set")
	}

	if mmSendRole.defaultExpectation == nil {
		mmSendRole.defaultExpectation = &MessengerMockSendRoleExpectation{}
	}

	mmSendRole.defaultExpectation.params = &MessengerMockSendRoleParams{ctx, msg, role, object, pn, opts}
	for _, e := range mmSendRole.expectations {
		if minimock.Equal(e.params, mmSendRole.defaultExpectation.params) {
			mmSendRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendRole.defaultExpectation.params)
		}
	}

	return mmSendRole
}

// Inspect accepts an inspector function that has same arguments as the Messenger.SendRole
func (mmSendRole *mMessengerMockSendRole) Inspect(f func(ctx context.Context, msg payload.Marshaler, role insolar.DynamicRole, object insolar.Reference, pn pulse.Number, opts ...SendOption)) *mMessengerMockSendRole {
	if mmSendRole.mock.inspectFuncSendRole != nil {
		mmSendRole.mock.t.Fatalf("Inspect function is already set for MessengerMock.SendRole")
	}

	mmSendRole.mock.inspectFuncSendRole = f

	return mmSendRole
}

// Return sets up results that will be returned by Messenger.SendRole
func (mmSendRole *mMessengerMockSendRole) Return(err error) *MessengerMock {
	if mmSendRole.mock.funcSendRole != nil {
		mmSendRole.mock.t.Fatalf("MessengerMock.SendRole mock is already set by Set")
	}

	if mmSendRole.defaultExpectation == nil {
		mmSendRole.defaultExpectation = &MessengerMockSendRoleExpectation{mock: mmSendRole.mock}
	}
	mmSendRole.defaultExpectation.results = &MessengerMockSendRoleResults{err}
	return mmSendRole.mock
}

//Set uses given function f to mock the Messenger.SendRole method
func (mmSendRole *mMessengerMockSendRole) Set(f func(ctx context.Context, msg payload.Marshaler, role insolar.DynamicRole, object insolar.Reference, pn pulse.Number, opts ...SendOption) (err error)) *MessengerMock {
	if mmSendRole.defaultExpectation != nil {
		mmSendRole.mock.t.Fatalf("Default expectation is already set for the Messenger.SendRole method")
	}

	if len(mmSendRole.expectations) > 0 {
		mmSendRole.mock.t.Fatalf("Some expectations are already set for the Messenger.SendRole method")
	}

	mmSendRole.mock.funcSendRole = f
	return mmSendRole.mock
}

// When sets expectation for the Messenger.SendRole which will trigger the result defined by the following
// Then helper
func (mmSendRole *mMessengerMockSendRole) When(ctx context.Context, msg payload.Marshaler, role insolar.DynamicRole, object insolar.Reference, pn pulse.Number, opts ...SendOption) *MessengerMockSendRoleExpectation {
	if mmSendRole.mock.funcSendRole != nil {
		mmSendRole.mock.t.Fatalf("MessengerMock.SendRole mock is already set by Set")
	}

	expectation := &MessengerMockSendRoleExpectation{
		mock:   mmSendRole.mock,
		params: &MessengerMockSendRoleParams{ctx, msg, role, object, pn, opts},
	}
	mmSendRole.expectations = append(mmSendRole.expectations, expectation)
	return expectation
}

// Then sets up Messenger.SendRole return parameters for the expectation previously defined by the When method
func (e *MessengerMockSendRoleExpectation) Then(err error) *MessengerMock {
	e.results = &MessengerMockSendRoleResults{err}
	return e.mock
}

// SendRole implements Messenger
func (mmSendRole *MessengerMock) SendRole(ctx context.Context, msg payload.Marshaler, role insolar.DynamicRole, object insolar.Reference, pn pulse.Number, opts ...SendOption) (err error) {
	mm_atomic.AddUint64(&mmSendRole.beforeSendRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmSendRole.afterSendRoleCounter, 1)

	if mmSendRole.inspectFuncSendRole != nil {
		mmSendRole.inspectFuncSendRole(ctx, msg, role, object, pn, opts...)
	}

	mm_params := &MessengerMockSendRoleParams{ctx, msg, role, object, pn, opts}

	// Record call args
	mmSendRole.SendRoleMock.mutex.Lock()
	mmSendRole.SendRoleMock.callArgs = append(mmSendRole.SendRoleMock.callArgs, mm_params)
	mmSendRole.SendRoleMock.mutex.Unlock()

	for _, e := range mmSendRole.SendRoleMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendRole.SendRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendRole.SendRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmSendRole.SendRoleMock.defaultExpectation.params
		mm_got := MessengerMockSendRoleParams{ctx, msg, role, object, pn, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendRole.t.Errorf("MessengerMock.SendRole got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendRole.SendRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmSendRole.t.Fatal("No results are set for the MessengerMock.SendRole")
		}
		return (*mm_results).err
	}
	if mmSendRole.funcSendRole != nil {
		return mmSendRole.funcSendRole(ctx, msg, role, object, pn, opts...)
	}
	mmSendRole.t.Fatalf("Unexpected call to MessengerMock.SendRole. %v %v %v %v %v %v", ctx, msg, role, object, pn, opts)
	return
}

// SendRoleAfterCounter returns a count of finished MessengerMock.SendRole invocations
func (mmSendRole *MessengerMock) SendRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendRole.afterSendRoleCounter)
}

// SendRoleBeforeCounter returns a count of MessengerMock.SendRole invocations
func (mmSendRole *MessengerMock) SendRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendRole.beforeSendRoleCounter)
}

// Calls returns a list of arguments used in each call to MessengerMock.SendRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendRole *mMessengerMockSendRole) Calls() []*MessengerMockSendRoleParams {
	mmSendRole.mutex.RLock()

	argCopy := make([]*MessengerMockSendRoleParams, len(mmSendRole.callArgs))
	copy(argCopy, mmSendRole.callArgs)

	mmSendRole.mutex.RUnlock()

	return argCopy
}

// MinimockSendRoleDone returns true if the count of the SendRole invocations corresponds
// the number of defined expectations
func (m *MessengerMock) MinimockSendRoleDone() bool {
	for _, e := range m.SendRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendRoleCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendRole != nil && mm_atomic.LoadUint64(&m.afterSendRoleCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendRoleInspect logs each unmet expectation
func (m *MessengerMock) MinimockSendRoleInspect() {
	for _, e := range m.SendRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessengerMock.SendRole with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendRoleCounter) < 1 {
		if m.SendRoleMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessengerMock.SendRole")
		} else {
			m.t.Errorf("Expected call to MessengerMock.SendRole with params: %#v", *m.SendRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendRole != nil && mm_atomic.LoadUint64(&m.afterSendRoleCounter) < 1 {
		m.t.Error("Expected call to MessengerMock.SendRole")
	}
}

type mMessengerMockSendTarget struct {
	mock               *MessengerMock
	defaultExpectation *MessengerMockSendTargetExpectation
	expectations       []*MessengerMockSendTargetExpectation

	callArgs []*MessengerMockSendTargetParams
	mutex    sync.RWMutex
}

// MessengerMockSendTargetExpectation specifies expectation struct of the Messenger.SendTarget
type MessengerMockSendTargetExpectation struct {
	mock    *MessengerMock
	params  *MessengerMockSendTargetParams
	results *MessengerMockSendTargetResults
	Counter uint64
}

// MessengerMockSendTargetParams contains parameters of the Messenger.SendTarget
type MessengerMockSendTargetParams struct {
	ctx    context.Context
	msg    payload.Marshaler
	target insolar.Reference
	opts   []SendOption
}

// MessengerMockSendTargetResults contains results of the Messenger.SendTarget
type MessengerMockSendTargetResults struct {
	err error
}

// Expect sets up expected params for Messenger.SendTarget
func (mmSendTarget *mMessengerMockSendTarget) Expect(ctx context.Context, msg payload.Marshaler, target insolar.Reference, opts ...SendOption) *mMessengerMockSendTarget {
	if mmSendTarget.mock.funcSendTarget != nil {
		mmSendTarget.mock.t.Fatalf("MessengerMock.SendTarget mock is already set by Set")
	}

	if mmSendTarget.defaultExpectation == nil {
		mmSendTarget.defaultExpectation = &MessengerMockSendTargetExpectation{}
	}

	mmSendTarget.defaultExpectation.params = &MessengerMockSendTargetParams{ctx, msg, target, opts}
	for _, e := range mmSendTarget.expectations {
		if minimock.Equal(e.params, mmSendTarget.defaultExpectation.params) {
			mmSendTarget.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendTarget.defaultExpectation.params)
		}
	}

	return mmSendTarget
}

// Inspect accepts an inspector function that has same arguments as the Messenger.SendTarget
func (mmSendTarget *mMessengerMockSendTarget) Inspect(f func(ctx context.Context, msg payload.Marshaler, target insolar.Reference, opts ...SendOption)) *mMessengerMockSendTarget {
	if mmSendTarget.mock.inspectFuncSendTarget != nil {
		mmSendTarget.mock.t.Fatalf("Inspect function is already set for MessengerMock.SendTarget")
	}

	mmSendTarget.mock.inspectFuncSendTarget = f

	return mmSendTarget
}

// Return sets up results that will be returned by Messenger.SendTarget
func (mmSendTarget *mMessengerMockSendTarget) Return(err error) *MessengerMock {
	if mmSendTarget.mock.funcSendTarget != nil {
		mmSendTarget.mock.t.Fatalf("MessengerMock.SendTarget mock is already set by Set")
	}

	if mmSendTarget.defaultExpectation == nil {
		mmSendTarget.defaultExpectation = &MessengerMockSendTargetExpectation{mock: mmSendTarget.mock}
	}
	mmSendTarget.defaultExpectation.results = &MessengerMockSendTargetResults{err}
	return mmSendTarget.mock
}

//Set uses given function f to mock the Messenger.SendTarget method
func (mmSendTarget *mMessengerMockSendTarget) Set(f func(ctx context.Context, msg payload.Marshaler, target insolar.Reference, opts ...SendOption) (err error)) *MessengerMock {
	if mmSendTarget.defaultExpectation != nil {
		mmSendTarget.mock.t.Fatalf("Default expectation is already set for the Messenger.SendTarget method")
	}

	if len(mmSendTarget.expectations) > 0 {
		mmSendTarget.mock.t.Fatalf("Some expectations are already set for the Messenger.SendTarget method")
	}

	mmSendTarget.mock.funcSendTarget = f
	return mmSendTarget.mock
}

// When sets expectation for the Messenger.SendTarget which will trigger the result defined by the following
// Then helper
func (mmSendTarget *mMessengerMockSendTarget) When(ctx context.Context, msg payload.Marshaler, target insolar.Reference, opts ...SendOption) *MessengerMockSendTargetExpectation {
	if mmSendTarget.mock.funcSendTarget != nil {
		mmSendTarget.mock.t.Fatalf("MessengerMock.SendTarget mock is already set by Set")
	}

	expectation := &MessengerMockSendTargetExpectation{
		mock:   mmSendTarget.mock,
		params: &MessengerMockSendTargetParams{ctx, msg, target, opts},
	}
	mmSendTarget.expectations = append(mmSendTarget.expectations, expectation)
	return expectation
}

// Then sets up Messenger.SendTarget return parameters for the expectation previously defined by the When method
func (e *MessengerMockSendTargetExpectation) Then(err error) *MessengerMock {
	e.results = &MessengerMockSendTargetResults{err}
	return e.mock
}

// SendTarget implements Messenger
func (mmSendTarget *MessengerMock) SendTarget(ctx context.Context, msg payload.Marshaler, target insolar.Reference, opts ...SendOption) (err error) {
	mm_atomic.AddUint64(&mmSendTarget.beforeSendTargetCounter, 1)
	defer mm_atomic.AddUint64(&mmSendTarget.afterSendTargetCounter, 1)

	if mmSendTarget.inspectFuncSendTarget != nil {
		mmSendTarget.inspectFuncSendTarget(ctx, msg, target, opts...)
	}

	mm_params := &MessengerMockSendTargetParams{ctx, msg, target, opts}

	// Record call args
	mmSendTarget.SendTargetMock.mutex.Lock()
	mmSendTarget.SendTargetMock.callArgs = append(mmSendTarget.SendTargetMock.callArgs, mm_params)
	mmSendTarget.SendTargetMock.mutex.Unlock()

	for _, e := range mmSendTarget.SendTargetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendTarget.SendTargetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendTarget.SendTargetMock.defaultExpectation.Counter, 1)
		mm_want := mmSendTarget.SendTargetMock.defaultExpectation.params
		mm_got := MessengerMockSendTargetParams{ctx, msg, target, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendTarget.t.Errorf("MessengerMock.SendTarget got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendTarget.SendTargetMock.defaultExpectation.results
		if mm_results == nil {
			mmSendTarget.t.Fatal("No results are set for the MessengerMock.SendTarget")
		}
		return (*mm_results).err
	}
	if mmSendTarget.funcSendTarget != nil {
		return mmSendTarget.funcSendTarget(ctx, msg, target, opts...)
	}
	mmSendTarget.t.Fatalf("Unexpected call to MessengerMock.SendTarget. %v %v %v %v", ctx, msg, target, opts)
	return
}

// SendTargetAfterCounter returns a count of finished MessengerMock.SendTarget invocations
func (mmSendTarget *MessengerMock) SendTargetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendTarget.afterSendTargetCounter)
}

// SendTargetBeforeCounter returns a count of MessengerMock.SendTarget invocations
func (mmSendTarget *MessengerMock) SendTargetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendTarget.beforeSendTargetCounter)
}

// Calls returns a list of arguments used in each call to MessengerMock.SendTarget.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendTarget *mMessengerMockSendTarget) Calls() []*MessengerMockSendTargetParams {
	mmSendTarget.mutex.RLock()

	argCopy := make([]*MessengerMockSendTargetParams, len(mmSendTarget.callArgs))
	copy(argCopy, mmSendTarget.callArgs)

	mmSendTarget.mutex.RUnlock()

	return argCopy
}

// MinimockSendTargetDone returns true if the count of the SendTarget invocations corresponds
// the number of defined expectations
func (m *MessengerMock) MinimockSendTargetDone() bool {
	for _, e := range m.SendTargetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendTargetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendTargetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendTarget != nil && mm_atomic.LoadUint64(&m.afterSendTargetCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendTargetInspect logs each unmet expectation
func (m *MessengerMock) MinimockSendTargetInspect() {
	for _, e := range m.SendTargetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessengerMock.SendTarget with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendTargetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendTargetCounter) < 1 {
		if m.SendTargetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessengerMock.SendTarget")
		} else {
			m.t.Errorf("Expected call to MessengerMock.SendTarget with params: %#v", *m.SendTargetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendTarget != nil && mm_atomic.LoadUint64(&m.afterSendTargetCounter) < 1 {
		m.t.Error("Expected call to MessengerMock.SendTarget")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MessengerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockSendRoleInspect()

		m.MinimockSendTargetInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MessengerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MessengerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockSendRoleDone() &&
		m.MinimockSendTargetDone()
}
