package smachine

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// InitializationContextMock implements InitializationContext
type InitializationContextMock struct {
	t minimock.Tester

	funcAcquire          func(s1 SyncLink) (b1 BoolDecision)
	inspectFuncAcquire   func(s1 SyncLink)
	afterAcquireCounter  uint64
	beforeAcquireCounter uint64
	AcquireMock          mInitializationContextMockAcquire

	funcAcquireAndRelease          func(s1 SyncLink) (b1 BoolDecision)
	inspectFuncAcquireAndRelease   func(s1 SyncLink)
	afterAcquireAndReleaseCounter  uint64
	beforeAcquireAndReleaseCounter uint64
	AcquireAndReleaseMock          mInitializationContextMockAcquireAndRelease

	funcAcquireForThisStep          func(s1 SyncLink) (b1 BoolDecision)
	inspectFuncAcquireForThisStep   func(s1 SyncLink)
	afterAcquireForThisStepCounter  uint64
	beforeAcquireForThisStepCounter uint64
	AcquireForThisStepMock          mInitializationContextMockAcquireForThisStep

	funcAcquireForThisStepAndRelease          func(s1 SyncLink) (b1 BoolDecision)
	inspectFuncAcquireForThisStepAndRelease   func(s1 SyncLink)
	afterAcquireForThisStepAndReleaseCounter  uint64
	beforeAcquireForThisStepAndReleaseCounter uint64
	AcquireForThisStepAndReleaseMock          mInitializationContextMockAcquireForThisStepAndRelease

	funcApplyAdjustment          func(s1 SyncAdjustment) (b1 bool)
	inspectFuncApplyAdjustment   func(s1 SyncAdjustment)
	afterApplyAdjustmentCounter  uint64
	beforeApplyAdjustmentCounter uint64
	ApplyAdjustmentMock          mInitializationContextMockApplyAdjustment

	funcCallBargeIn          func(b BargeIn) (b1 bool)
	inspectFuncCallBargeIn   func(b BargeIn)
	afterCallBargeInCounter  uint64
	beforeCallBargeInCounter uint64
	CallBargeInMock          mInitializationContextMockCallBargeIn

	funcCallBargeInWithParam          func(b BargeInWithParam, param interface{}) (b1 bool)
	inspectFuncCallBargeInWithParam   func(b BargeInWithParam, param interface{})
	afterCallBargeInWithParamCounter  uint64
	beforeCallBargeInWithParamCounter uint64
	CallBargeInWithParamMock          mInitializationContextMockCallBargeInWithParam

	funcCheck          func(s1 SyncLink) (b1 BoolDecision)
	inspectFuncCheck   func(s1 SyncLink)
	afterCheckCounter  uint64
	beforeCheckCounter uint64
	CheckMock          mInitializationContextMockCheck

	funcError          func(e1 error) (s1 StateUpdate)
	inspectFuncError   func(e1 error)
	afterErrorCounter  uint64
	beforeErrorCounter uint64
	ErrorMock          mInitializationContextMockError

	funcErrorf          func(msg string, a ...interface{}) (s1 StateUpdate)
	inspectFuncErrorf   func(msg string, a ...interface{})
	afterErrorfCounter  uint64
	beforeErrorfCounter uint64
	ErrorfMock          mInitializationContextMockErrorf

	funcGetContext          func() (c1 context.Context)
	inspectFuncGetContext   func()
	afterGetContextCounter  uint64
	beforeGetContextCounter uint64
	GetContextMock          mInitializationContextMockGetContext

	funcGetDefaultTerminationResult          func() (p1 interface{})
	inspectFuncGetDefaultTerminationResult   func()
	afterGetDefaultTerminationResultCounter  uint64
	beforeGetDefaultTerminationResultCounter uint64
	GetDefaultTerminationResultMock          mInitializationContextMockGetDefaultTerminationResult

	funcGetPublished          func(key interface{}) (p1 interface{})
	inspectFuncGetPublished   func(key interface{})
	afterGetPublishedCounter  uint64
	beforeGetPublishedCounter uint64
	GetPublishedMock          mInitializationContextMockGetPublished

	funcGetPublishedGlobalAlias          func(key interface{}) (s1 SlotLink)
	inspectFuncGetPublishedGlobalAlias   func(key interface{})
	afterGetPublishedGlobalAliasCounter  uint64
	beforeGetPublishedGlobalAliasCounter uint64
	GetPublishedGlobalAliasMock          mInitializationContextMockGetPublishedGlobalAlias

	funcGetPublishedGlobalAliasAndBargeIn          func(key interface{}) (s1 SlotLink, b1 BargeInHolder)
	inspectFuncGetPublishedGlobalAliasAndBargeIn   func(key interface{})
	afterGetPublishedGlobalAliasAndBargeInCounter  uint64
	beforeGetPublishedGlobalAliasAndBargeInCounter uint64
	GetPublishedGlobalAliasAndBargeInMock          mInitializationContextMockGetPublishedGlobalAliasAndBargeIn

	funcGetPublishedLink          func(key interface{}) (s1 SharedDataLink)
	inspectFuncGetPublishedLink   func(key interface{})
	afterGetPublishedLinkCounter  uint64
	beforeGetPublishedLinkCounter uint64
	GetPublishedLinkMock          mInitializationContextMockGetPublishedLink

	funcJump          func(s1 StateFunc) (s2 StateUpdate)
	inspectFuncJump   func(s1 StateFunc)
	afterJumpCounter  uint64
	beforeJumpCounter uint64
	JumpMock          mInitializationContextMockJump

	funcJumpExt          func(s1 SlotStep) (s2 StateUpdate)
	inspectFuncJumpExt   func(s1 SlotStep)
	afterJumpExtCounter  uint64
	beforeJumpExtCounter uint64
	JumpExtMock          mInitializationContextMockJumpExt

	funcLog          func() (l1 Logger)
	inspectFuncLog   func()
	afterLogCounter  uint64
	beforeLogCounter uint64
	LogMock          mInitializationContextMockLog

	funcNewBargeIn          func() (b1 BargeInBuilder)
	inspectFuncNewBargeIn   func()
	afterNewBargeInCounter  uint64
	beforeNewBargeInCounter uint64
	NewBargeInMock          mInitializationContextMockNewBargeIn

	funcNewBargeInWithParam          func(b1 BargeInApplyFunc) (b2 BargeInWithParam)
	inspectFuncNewBargeInWithParam   func(b1 BargeInApplyFunc)
	afterNewBargeInWithParamCounter  uint64
	beforeNewBargeInWithParamCounter uint64
	NewBargeInWithParamMock          mInitializationContextMockNewBargeInWithParam

	funcParentLink          func() (s1 SlotLink)
	inspectFuncParentLink   func()
	afterParentLinkCounter  uint64
	beforeParentLinkCounter uint64
	ParentLinkMock          mInitializationContextMockParentLink

	funcPublish          func(key interface{}, data interface{}) (b1 bool)
	inspectFuncPublish   func(key interface{}, data interface{})
	afterPublishCounter  uint64
	beforePublishCounter uint64
	PublishMock          mInitializationContextMockPublish

	funcPublishGlobalAlias          func(key interface{}) (b1 bool)
	inspectFuncPublishGlobalAlias   func(key interface{})
	afterPublishGlobalAliasCounter  uint64
	beforePublishGlobalAliasCounter uint64
	PublishGlobalAliasMock          mInitializationContextMockPublishGlobalAlias

	funcPublishGlobalAliasAndBargeIn          func(key interface{}, handler BargeInHolder) (b1 bool)
	inspectFuncPublishGlobalAliasAndBargeIn   func(key interface{}, handler BargeInHolder)
	afterPublishGlobalAliasAndBargeInCounter  uint64
	beforePublishGlobalAliasAndBargeInCounter uint64
	PublishGlobalAliasAndBargeInMock          mInitializationContextMockPublishGlobalAliasAndBargeIn

	funcRelease          func(s1 SyncLink) (b1 bool)
	inspectFuncRelease   func(s1 SyncLink)
	afterReleaseCounter  uint64
	beforeReleaseCounter uint64
	ReleaseMock          mInitializationContextMockRelease

	funcReleaseAll          func() (b1 bool)
	inspectFuncReleaseAll   func()
	afterReleaseAllCounter  uint64
	beforeReleaseAllCounter uint64
	ReleaseAllMock          mInitializationContextMockReleaseAll

	funcSetDefaultErrorHandler          func(fn ErrorHandlerFunc)
	inspectFuncSetDefaultErrorHandler   func(fn ErrorHandlerFunc)
	afterSetDefaultErrorHandlerCounter  uint64
	beforeSetDefaultErrorHandlerCounter uint64
	SetDefaultErrorHandlerMock          mInitializationContextMockSetDefaultErrorHandler

	funcSetDefaultFlags          func(s1 StepFlags)
	inspectFuncSetDefaultFlags   func(s1 StepFlags)
	afterSetDefaultFlagsCounter  uint64
	beforeSetDefaultFlagsCounter uint64
	SetDefaultFlagsMock          mInitializationContextMockSetDefaultFlags

	funcSetDefaultMigration          func(fn MigrateFunc)
	inspectFuncSetDefaultMigration   func(fn MigrateFunc)
	afterSetDefaultMigrationCounter  uint64
	beforeSetDefaultMigrationCounter uint64
	SetDefaultMigrationMock          mInitializationContextMockSetDefaultMigration

	funcSetDefaultTerminationResult          func(p1 interface{})
	inspectFuncSetDefaultTerminationResult   func(p1 interface{})
	afterSetDefaultTerminationResultCounter  uint64
	beforeSetDefaultTerminationResultCounter uint64
	SetDefaultTerminationResultMock          mInitializationContextMockSetDefaultTerminationResult

	funcSetDynamicBoost          func(b1 bool)
	inspectFuncSetDynamicBoost   func(b1 bool)
	afterSetDynamicBoostCounter  uint64
	beforeSetDynamicBoostCounter uint64
	SetDynamicBoostMock          mInitializationContextMockSetDynamicBoost

	funcSetLogTracing          func(b1 bool)
	inspectFuncSetLogTracing   func(b1 bool)
	afterSetLogTracingCounter  uint64
	beforeSetLogTracingCounter uint64
	SetLogTracingMock          mInitializationContextMockSetLogTracing

	funcShare          func(data interface{}, flags ShareDataFlags) (s1 SharedDataLink)
	inspectFuncShare   func(data interface{}, flags ShareDataFlags)
	afterShareCounter  uint64
	beforeShareCounter uint64
	ShareMock          mInitializationContextMockShare

	funcSlotLink          func() (s1 SlotLink)
	inspectFuncSlotLink   func()
	afterSlotLinkCounter  uint64
	beforeSlotLinkCounter uint64
	SlotLinkMock          mInitializationContextMockSlotLink

	funcStop          func() (s1 StateUpdate)
	inspectFuncStop   func()
	afterStopCounter  uint64
	beforeStopCounter uint64
	StopMock          mInitializationContextMockStop

	funcUnpublish          func(key interface{}) (b1 bool)
	inspectFuncUnpublish   func(key interface{})
	afterUnpublishCounter  uint64
	beforeUnpublishCounter uint64
	UnpublishMock          mInitializationContextMockUnpublish

	funcUnpublishAll          func()
	inspectFuncUnpublishAll   func()
	afterUnpublishAllCounter  uint64
	beforeUnpublishAllCounter uint64
	UnpublishAllMock          mInitializationContextMockUnpublishAll

	funcUnpublishGlobalAlias          func(key interface{}) (b1 bool)
	inspectFuncUnpublishGlobalAlias   func(key interface{})
	afterUnpublishGlobalAliasCounter  uint64
	beforeUnpublishGlobalAliasCounter uint64
	UnpublishGlobalAliasMock          mInitializationContextMockUnpublishGlobalAlias

	funcUnshare          func(s1 SharedDataLink) (b1 bool)
	inspectFuncUnshare   func(s1 SharedDataLink)
	afterUnshareCounter  uint64
	beforeUnshareCounter uint64
	UnshareMock          mInitializationContextMockUnshare

	funcUpdateDefaultStepLogger          func(updateFn StepLoggerUpdateFunc)
	inspectFuncUpdateDefaultStepLogger   func(updateFn StepLoggerUpdateFunc)
	afterUpdateDefaultStepLoggerCounter  uint64
	beforeUpdateDefaultStepLoggerCounter uint64
	UpdateDefaultStepLoggerMock          mInitializationContextMockUpdateDefaultStepLogger
}

// NewInitializationContextMock returns a mock for InitializationContext
func NewInitializationContextMock(t minimock.Tester) *InitializationContextMock {
	m := &InitializationContextMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AcquireMock = mInitializationContextMockAcquire{mock: m}
	m.AcquireMock.callArgs = []*InitializationContextMockAcquireParams{}

	m.AcquireAndReleaseMock = mInitializationContextMockAcquireAndRelease{mock: m}
	m.AcquireAndReleaseMock.callArgs = []*InitializationContextMockAcquireAndReleaseParams{}

	m.AcquireForThisStepMock = mInitializationContextMockAcquireForThisStep{mock: m}
	m.AcquireForThisStepMock.callArgs = []*InitializationContextMockAcquireForThisStepParams{}

	m.AcquireForThisStepAndReleaseMock = mInitializationContextMockAcquireForThisStepAndRelease{mock: m}
	m.AcquireForThisStepAndReleaseMock.callArgs = []*InitializationContextMockAcquireForThisStepAndReleaseParams{}

	m.ApplyAdjustmentMock = mInitializationContextMockApplyAdjustment{mock: m}
	m.ApplyAdjustmentMock.callArgs = []*InitializationContextMockApplyAdjustmentParams{}

	m.CallBargeInMock = mInitializationContextMockCallBargeIn{mock: m}
	m.CallBargeInMock.callArgs = []*InitializationContextMockCallBargeInParams{}

	m.CallBargeInWithParamMock = mInitializationContextMockCallBargeInWithParam{mock: m}
	m.CallBargeInWithParamMock.callArgs = []*InitializationContextMockCallBargeInWithParamParams{}

	m.CheckMock = mInitializationContextMockCheck{mock: m}
	m.CheckMock.callArgs = []*InitializationContextMockCheckParams{}

	m.ErrorMock = mInitializationContextMockError{mock: m}
	m.ErrorMock.callArgs = []*InitializationContextMockErrorParams{}

	m.ErrorfMock = mInitializationContextMockErrorf{mock: m}
	m.ErrorfMock.callArgs = []*InitializationContextMockErrorfParams{}

	m.GetContextMock = mInitializationContextMockGetContext{mock: m}

	m.GetDefaultTerminationResultMock = mInitializationContextMockGetDefaultTerminationResult{mock: m}

	m.GetPublishedMock = mInitializationContextMockGetPublished{mock: m}
	m.GetPublishedMock.callArgs = []*InitializationContextMockGetPublishedParams{}

	m.GetPublishedGlobalAliasMock = mInitializationContextMockGetPublishedGlobalAlias{mock: m}
	m.GetPublishedGlobalAliasMock.callArgs = []*InitializationContextMockGetPublishedGlobalAliasParams{}

	m.GetPublishedGlobalAliasAndBargeInMock = mInitializationContextMockGetPublishedGlobalAliasAndBargeIn{mock: m}
	m.GetPublishedGlobalAliasAndBargeInMock.callArgs = []*InitializationContextMockGetPublishedGlobalAliasAndBargeInParams{}

	m.GetPublishedLinkMock = mInitializationContextMockGetPublishedLink{mock: m}
	m.GetPublishedLinkMock.callArgs = []*InitializationContextMockGetPublishedLinkParams{}

	m.JumpMock = mInitializationContextMockJump{mock: m}
	m.JumpMock.callArgs = []*InitializationContextMockJumpParams{}

	m.JumpExtMock = mInitializationContextMockJumpExt{mock: m}
	m.JumpExtMock.callArgs = []*InitializationContextMockJumpExtParams{}

	m.LogMock = mInitializationContextMockLog{mock: m}

	m.NewBargeInMock = mInitializationContextMockNewBargeIn{mock: m}

	m.NewBargeInWithParamMock = mInitializationContextMockNewBargeInWithParam{mock: m}
	m.NewBargeInWithParamMock.callArgs = []*InitializationContextMockNewBargeInWithParamParams{}

	m.ParentLinkMock = mInitializationContextMockParentLink{mock: m}

	m.PublishMock = mInitializationContextMockPublish{mock: m}
	m.PublishMock.callArgs = []*InitializationContextMockPublishParams{}

	m.PublishGlobalAliasMock = mInitializationContextMockPublishGlobalAlias{mock: m}
	m.PublishGlobalAliasMock.callArgs = []*InitializationContextMockPublishGlobalAliasParams{}

	m.PublishGlobalAliasAndBargeInMock = mInitializationContextMockPublishGlobalAliasAndBargeIn{mock: m}
	m.PublishGlobalAliasAndBargeInMock.callArgs = []*InitializationContextMockPublishGlobalAliasAndBargeInParams{}

	m.ReleaseMock = mInitializationContextMockRelease{mock: m}
	m.ReleaseMock.callArgs = []*InitializationContextMockReleaseParams{}

	m.ReleaseAllMock = mInitializationContextMockReleaseAll{mock: m}

	m.SetDefaultErrorHandlerMock = mInitializationContextMockSetDefaultErrorHandler{mock: m}
	m.SetDefaultErrorHandlerMock.callArgs = []*InitializationContextMockSetDefaultErrorHandlerParams{}

	m.SetDefaultFlagsMock = mInitializationContextMockSetDefaultFlags{mock: m}
	m.SetDefaultFlagsMock.callArgs = []*InitializationContextMockSetDefaultFlagsParams{}

	m.SetDefaultMigrationMock = mInitializationContextMockSetDefaultMigration{mock: m}
	m.SetDefaultMigrationMock.callArgs = []*InitializationContextMockSetDefaultMigrationParams{}

	m.SetDefaultTerminationResultMock = mInitializationContextMockSetDefaultTerminationResult{mock: m}
	m.SetDefaultTerminationResultMock.callArgs = []*InitializationContextMockSetDefaultTerminationResultParams{}

	m.SetDynamicBoostMock = mInitializationContextMockSetDynamicBoost{mock: m}
	m.SetDynamicBoostMock.callArgs = []*InitializationContextMockSetDynamicBoostParams{}

	m.SetLogTracingMock = mInitializationContextMockSetLogTracing{mock: m}
	m.SetLogTracingMock.callArgs = []*InitializationContextMockSetLogTracingParams{}

	m.ShareMock = mInitializationContextMockShare{mock: m}
	m.ShareMock.callArgs = []*InitializationContextMockShareParams{}

	m.SlotLinkMock = mInitializationContextMockSlotLink{mock: m}

	m.StopMock = mInitializationContextMockStop{mock: m}

	m.UnpublishMock = mInitializationContextMockUnpublish{mock: m}
	m.UnpublishMock.callArgs = []*InitializationContextMockUnpublishParams{}

	m.UnpublishAllMock = mInitializationContextMockUnpublishAll{mock: m}

	m.UnpublishGlobalAliasMock = mInitializationContextMockUnpublishGlobalAlias{mock: m}
	m.UnpublishGlobalAliasMock.callArgs = []*InitializationContextMockUnpublishGlobalAliasParams{}

	m.UnshareMock = mInitializationContextMockUnshare{mock: m}
	m.UnshareMock.callArgs = []*InitializationContextMockUnshareParams{}

	m.UpdateDefaultStepLoggerMock = mInitializationContextMockUpdateDefaultStepLogger{mock: m}
	m.UpdateDefaultStepLoggerMock.callArgs = []*InitializationContextMockUpdateDefaultStepLoggerParams{}

	return m
}

type mInitializationContextMockAcquire struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockAcquireExpectation
	expectations       []*InitializationContextMockAcquireExpectation

	callArgs []*InitializationContextMockAcquireParams
	mutex    sync.RWMutex
}

// InitializationContextMockAcquireExpectation specifies expectation struct of the InitializationContext.Acquire
type InitializationContextMockAcquireExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockAcquireParams
	results *InitializationContextMockAcquireResults
	Counter uint64
}

// InitializationContextMockAcquireParams contains parameters of the InitializationContext.Acquire
type InitializationContextMockAcquireParams struct {
	s1 SyncLink
}

// InitializationContextMockAcquireResults contains results of the InitializationContext.Acquire
type InitializationContextMockAcquireResults struct {
	b1 BoolDecision
}

// Expect sets up expected params for InitializationContext.Acquire
func (mmAcquire *mInitializationContextMockAcquire) Expect(s1 SyncLink) *mInitializationContextMockAcquire {
	if mmAcquire.mock.funcAcquire != nil {
		mmAcquire.mock.t.Fatalf("InitializationContextMock.Acquire mock is already set by Set")
	}

	if mmAcquire.defaultExpectation == nil {
		mmAcquire.defaultExpectation = &InitializationContextMockAcquireExpectation{}
	}

	mmAcquire.defaultExpectation.params = &InitializationContextMockAcquireParams{s1}
	for _, e := range mmAcquire.expectations {
		if minimock.Equal(e.params, mmAcquire.defaultExpectation.params) {
			mmAcquire.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcquire.defaultExpectation.params)
		}
	}

	return mmAcquire
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.Acquire
func (mmAcquire *mInitializationContextMockAcquire) Inspect(f func(s1 SyncLink)) *mInitializationContextMockAcquire {
	if mmAcquire.mock.inspectFuncAcquire != nil {
		mmAcquire.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.Acquire")
	}

	mmAcquire.mock.inspectFuncAcquire = f

	return mmAcquire
}

// Return sets up results that will be returned by InitializationContext.Acquire
func (mmAcquire *mInitializationContextMockAcquire) Return(b1 BoolDecision) *InitializationContextMock {
	if mmAcquire.mock.funcAcquire != nil {
		mmAcquire.mock.t.Fatalf("InitializationContextMock.Acquire mock is already set by Set")
	}

	if mmAcquire.defaultExpectation == nil {
		mmAcquire.defaultExpectation = &InitializationContextMockAcquireExpectation{mock: mmAcquire.mock}
	}
	mmAcquire.defaultExpectation.results = &InitializationContextMockAcquireResults{b1}
	return mmAcquire.mock
}

//Set uses given function f to mock the InitializationContext.Acquire method
func (mmAcquire *mInitializationContextMockAcquire) Set(f func(s1 SyncLink) (b1 BoolDecision)) *InitializationContextMock {
	if mmAcquire.defaultExpectation != nil {
		mmAcquire.mock.t.Fatalf("Default expectation is already set for the InitializationContext.Acquire method")
	}

	if len(mmAcquire.expectations) > 0 {
		mmAcquire.mock.t.Fatalf("Some expectations are already set for the InitializationContext.Acquire method")
	}

	mmAcquire.mock.funcAcquire = f
	return mmAcquire.mock
}

// When sets expectation for the InitializationContext.Acquire which will trigger the result defined by the following
// Then helper
func (mmAcquire *mInitializationContextMockAcquire) When(s1 SyncLink) *InitializationContextMockAcquireExpectation {
	if mmAcquire.mock.funcAcquire != nil {
		mmAcquire.mock.t.Fatalf("InitializationContextMock.Acquire mock is already set by Set")
	}

	expectation := &InitializationContextMockAcquireExpectation{
		mock:   mmAcquire.mock,
		params: &InitializationContextMockAcquireParams{s1},
	}
	mmAcquire.expectations = append(mmAcquire.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.Acquire return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockAcquireExpectation) Then(b1 BoolDecision) *InitializationContextMock {
	e.results = &InitializationContextMockAcquireResults{b1}
	return e.mock
}

// Acquire implements InitializationContext
func (mmAcquire *InitializationContextMock) Acquire(s1 SyncLink) (b1 BoolDecision) {
	mm_atomic.AddUint64(&mmAcquire.beforeAcquireCounter, 1)
	defer mm_atomic.AddUint64(&mmAcquire.afterAcquireCounter, 1)

	if mmAcquire.inspectFuncAcquire != nil {
		mmAcquire.inspectFuncAcquire(s1)
	}

	mm_params := &InitializationContextMockAcquireParams{s1}

	// Record call args
	mmAcquire.AcquireMock.mutex.Lock()
	mmAcquire.AcquireMock.callArgs = append(mmAcquire.AcquireMock.callArgs, mm_params)
	mmAcquire.AcquireMock.mutex.Unlock()

	for _, e := range mmAcquire.AcquireMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmAcquire.AcquireMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcquire.AcquireMock.defaultExpectation.Counter, 1)
		mm_want := mmAcquire.AcquireMock.defaultExpectation.params
		mm_got := InitializationContextMockAcquireParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcquire.t.Errorf("InitializationContextMock.Acquire got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcquire.AcquireMock.defaultExpectation.results
		if mm_results == nil {
			mmAcquire.t.Fatal("No results are set for the InitializationContextMock.Acquire")
		}
		return (*mm_results).b1
	}
	if mmAcquire.funcAcquire != nil {
		return mmAcquire.funcAcquire(s1)
	}
	mmAcquire.t.Fatalf("Unexpected call to InitializationContextMock.Acquire. %v", s1)
	return
}

// AcquireAfterCounter returns a count of finished InitializationContextMock.Acquire invocations
func (mmAcquire *InitializationContextMock) AcquireAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquire.afterAcquireCounter)
}

// AcquireBeforeCounter returns a count of InitializationContextMock.Acquire invocations
func (mmAcquire *InitializationContextMock) AcquireBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquire.beforeAcquireCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.Acquire.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcquire *mInitializationContextMockAcquire) Calls() []*InitializationContextMockAcquireParams {
	mmAcquire.mutex.RLock()

	argCopy := make([]*InitializationContextMockAcquireParams, len(mmAcquire.callArgs))
	copy(argCopy, mmAcquire.callArgs)

	mmAcquire.mutex.RUnlock()

	return argCopy
}

// MinimockAcquireDone returns true if the count of the Acquire invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockAcquireDone() bool {
	for _, e := range m.AcquireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquire != nil && mm_atomic.LoadUint64(&m.afterAcquireCounter) < 1 {
		return false
	}
	return true
}

// MinimockAcquireInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockAcquireInspect() {
	for _, e := range m.AcquireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.Acquire with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireCounter) < 1 {
		if m.AcquireMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.Acquire")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.Acquire with params: %#v", *m.AcquireMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquire != nil && mm_atomic.LoadUint64(&m.afterAcquireCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.Acquire")
	}
}

type mInitializationContextMockAcquireAndRelease struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockAcquireAndReleaseExpectation
	expectations       []*InitializationContextMockAcquireAndReleaseExpectation

	callArgs []*InitializationContextMockAcquireAndReleaseParams
	mutex    sync.RWMutex
}

// InitializationContextMockAcquireAndReleaseExpectation specifies expectation struct of the InitializationContext.AcquireAndRelease
type InitializationContextMockAcquireAndReleaseExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockAcquireAndReleaseParams
	results *InitializationContextMockAcquireAndReleaseResults
	Counter uint64
}

// InitializationContextMockAcquireAndReleaseParams contains parameters of the InitializationContext.AcquireAndRelease
type InitializationContextMockAcquireAndReleaseParams struct {
	s1 SyncLink
}

// InitializationContextMockAcquireAndReleaseResults contains results of the InitializationContext.AcquireAndRelease
type InitializationContextMockAcquireAndReleaseResults struct {
	b1 BoolDecision
}

// Expect sets up expected params for InitializationContext.AcquireAndRelease
func (mmAcquireAndRelease *mInitializationContextMockAcquireAndRelease) Expect(s1 SyncLink) *mInitializationContextMockAcquireAndRelease {
	if mmAcquireAndRelease.mock.funcAcquireAndRelease != nil {
		mmAcquireAndRelease.mock.t.Fatalf("InitializationContextMock.AcquireAndRelease mock is already set by Set")
	}

	if mmAcquireAndRelease.defaultExpectation == nil {
		mmAcquireAndRelease.defaultExpectation = &InitializationContextMockAcquireAndReleaseExpectation{}
	}

	mmAcquireAndRelease.defaultExpectation.params = &InitializationContextMockAcquireAndReleaseParams{s1}
	for _, e := range mmAcquireAndRelease.expectations {
		if minimock.Equal(e.params, mmAcquireAndRelease.defaultExpectation.params) {
			mmAcquireAndRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcquireAndRelease.defaultExpectation.params)
		}
	}

	return mmAcquireAndRelease
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.AcquireAndRelease
func (mmAcquireAndRelease *mInitializationContextMockAcquireAndRelease) Inspect(f func(s1 SyncLink)) *mInitializationContextMockAcquireAndRelease {
	if mmAcquireAndRelease.mock.inspectFuncAcquireAndRelease != nil {
		mmAcquireAndRelease.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.AcquireAndRelease")
	}

	mmAcquireAndRelease.mock.inspectFuncAcquireAndRelease = f

	return mmAcquireAndRelease
}

// Return sets up results that will be returned by InitializationContext.AcquireAndRelease
func (mmAcquireAndRelease *mInitializationContextMockAcquireAndRelease) Return(b1 BoolDecision) *InitializationContextMock {
	if mmAcquireAndRelease.mock.funcAcquireAndRelease != nil {
		mmAcquireAndRelease.mock.t.Fatalf("InitializationContextMock.AcquireAndRelease mock is already set by Set")
	}

	if mmAcquireAndRelease.defaultExpectation == nil {
		mmAcquireAndRelease.defaultExpectation = &InitializationContextMockAcquireAndReleaseExpectation{mock: mmAcquireAndRelease.mock}
	}
	mmAcquireAndRelease.defaultExpectation.results = &InitializationContextMockAcquireAndReleaseResults{b1}
	return mmAcquireAndRelease.mock
}

//Set uses given function f to mock the InitializationContext.AcquireAndRelease method
func (mmAcquireAndRelease *mInitializationContextMockAcquireAndRelease) Set(f func(s1 SyncLink) (b1 BoolDecision)) *InitializationContextMock {
	if mmAcquireAndRelease.defaultExpectation != nil {
		mmAcquireAndRelease.mock.t.Fatalf("Default expectation is already set for the InitializationContext.AcquireAndRelease method")
	}

	if len(mmAcquireAndRelease.expectations) > 0 {
		mmAcquireAndRelease.mock.t.Fatalf("Some expectations are already set for the InitializationContext.AcquireAndRelease method")
	}

	mmAcquireAndRelease.mock.funcAcquireAndRelease = f
	return mmAcquireAndRelease.mock
}

// When sets expectation for the InitializationContext.AcquireAndRelease which will trigger the result defined by the following
// Then helper
func (mmAcquireAndRelease *mInitializationContextMockAcquireAndRelease) When(s1 SyncLink) *InitializationContextMockAcquireAndReleaseExpectation {
	if mmAcquireAndRelease.mock.funcAcquireAndRelease != nil {
		mmAcquireAndRelease.mock.t.Fatalf("InitializationContextMock.AcquireAndRelease mock is already set by Set")
	}

	expectation := &InitializationContextMockAcquireAndReleaseExpectation{
		mock:   mmAcquireAndRelease.mock,
		params: &InitializationContextMockAcquireAndReleaseParams{s1},
	}
	mmAcquireAndRelease.expectations = append(mmAcquireAndRelease.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.AcquireAndRelease return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockAcquireAndReleaseExpectation) Then(b1 BoolDecision) *InitializationContextMock {
	e.results = &InitializationContextMockAcquireAndReleaseResults{b1}
	return e.mock
}

// AcquireAndRelease implements InitializationContext
func (mmAcquireAndRelease *InitializationContextMock) AcquireAndRelease(s1 SyncLink) (b1 BoolDecision) {
	mm_atomic.AddUint64(&mmAcquireAndRelease.beforeAcquireAndReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmAcquireAndRelease.afterAcquireAndReleaseCounter, 1)

	if mmAcquireAndRelease.inspectFuncAcquireAndRelease != nil {
		mmAcquireAndRelease.inspectFuncAcquireAndRelease(s1)
	}

	mm_params := &InitializationContextMockAcquireAndReleaseParams{s1}

	// Record call args
	mmAcquireAndRelease.AcquireAndReleaseMock.mutex.Lock()
	mmAcquireAndRelease.AcquireAndReleaseMock.callArgs = append(mmAcquireAndRelease.AcquireAndReleaseMock.callArgs, mm_params)
	mmAcquireAndRelease.AcquireAndReleaseMock.mutex.Unlock()

	for _, e := range mmAcquireAndRelease.AcquireAndReleaseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmAcquireAndRelease.AcquireAndReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcquireAndRelease.AcquireAndReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmAcquireAndRelease.AcquireAndReleaseMock.defaultExpectation.params
		mm_got := InitializationContextMockAcquireAndReleaseParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcquireAndRelease.t.Errorf("InitializationContextMock.AcquireAndRelease got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcquireAndRelease.AcquireAndReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmAcquireAndRelease.t.Fatal("No results are set for the InitializationContextMock.AcquireAndRelease")
		}
		return (*mm_results).b1
	}
	if mmAcquireAndRelease.funcAcquireAndRelease != nil {
		return mmAcquireAndRelease.funcAcquireAndRelease(s1)
	}
	mmAcquireAndRelease.t.Fatalf("Unexpected call to InitializationContextMock.AcquireAndRelease. %v", s1)
	return
}

// AcquireAndReleaseAfterCounter returns a count of finished InitializationContextMock.AcquireAndRelease invocations
func (mmAcquireAndRelease *InitializationContextMock) AcquireAndReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireAndRelease.afterAcquireAndReleaseCounter)
}

// AcquireAndReleaseBeforeCounter returns a count of InitializationContextMock.AcquireAndRelease invocations
func (mmAcquireAndRelease *InitializationContextMock) AcquireAndReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireAndRelease.beforeAcquireAndReleaseCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.AcquireAndRelease.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcquireAndRelease *mInitializationContextMockAcquireAndRelease) Calls() []*InitializationContextMockAcquireAndReleaseParams {
	mmAcquireAndRelease.mutex.RLock()

	argCopy := make([]*InitializationContextMockAcquireAndReleaseParams, len(mmAcquireAndRelease.callArgs))
	copy(argCopy, mmAcquireAndRelease.callArgs)

	mmAcquireAndRelease.mutex.RUnlock()

	return argCopy
}

// MinimockAcquireAndReleaseDone returns true if the count of the AcquireAndRelease invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockAcquireAndReleaseDone() bool {
	for _, e := range m.AcquireAndReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireAndReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireAndReleaseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireAndRelease != nil && mm_atomic.LoadUint64(&m.afterAcquireAndReleaseCounter) < 1 {
		return false
	}
	return true
}

// MinimockAcquireAndReleaseInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockAcquireAndReleaseInspect() {
	for _, e := range m.AcquireAndReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.AcquireAndRelease with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireAndReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireAndReleaseCounter) < 1 {
		if m.AcquireAndReleaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.AcquireAndRelease")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.AcquireAndRelease with params: %#v", *m.AcquireAndReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireAndRelease != nil && mm_atomic.LoadUint64(&m.afterAcquireAndReleaseCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.AcquireAndRelease")
	}
}

type mInitializationContextMockAcquireForThisStep struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockAcquireForThisStepExpectation
	expectations       []*InitializationContextMockAcquireForThisStepExpectation

	callArgs []*InitializationContextMockAcquireForThisStepParams
	mutex    sync.RWMutex
}

// InitializationContextMockAcquireForThisStepExpectation specifies expectation struct of the InitializationContext.AcquireForThisStep
type InitializationContextMockAcquireForThisStepExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockAcquireForThisStepParams
	results *InitializationContextMockAcquireForThisStepResults
	Counter uint64
}

// InitializationContextMockAcquireForThisStepParams contains parameters of the InitializationContext.AcquireForThisStep
type InitializationContextMockAcquireForThisStepParams struct {
	s1 SyncLink
}

// InitializationContextMockAcquireForThisStepResults contains results of the InitializationContext.AcquireForThisStep
type InitializationContextMockAcquireForThisStepResults struct {
	b1 BoolDecision
}

// Expect sets up expected params for InitializationContext.AcquireForThisStep
func (mmAcquireForThisStep *mInitializationContextMockAcquireForThisStep) Expect(s1 SyncLink) *mInitializationContextMockAcquireForThisStep {
	if mmAcquireForThisStep.mock.funcAcquireForThisStep != nil {
		mmAcquireForThisStep.mock.t.Fatalf("InitializationContextMock.AcquireForThisStep mock is already set by Set")
	}

	if mmAcquireForThisStep.defaultExpectation == nil {
		mmAcquireForThisStep.defaultExpectation = &InitializationContextMockAcquireForThisStepExpectation{}
	}

	mmAcquireForThisStep.defaultExpectation.params = &InitializationContextMockAcquireForThisStepParams{s1}
	for _, e := range mmAcquireForThisStep.expectations {
		if minimock.Equal(e.params, mmAcquireForThisStep.defaultExpectation.params) {
			mmAcquireForThisStep.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcquireForThisStep.defaultExpectation.params)
		}
	}

	return mmAcquireForThisStep
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.AcquireForThisStep
func (mmAcquireForThisStep *mInitializationContextMockAcquireForThisStep) Inspect(f func(s1 SyncLink)) *mInitializationContextMockAcquireForThisStep {
	if mmAcquireForThisStep.mock.inspectFuncAcquireForThisStep != nil {
		mmAcquireForThisStep.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.AcquireForThisStep")
	}

	mmAcquireForThisStep.mock.inspectFuncAcquireForThisStep = f

	return mmAcquireForThisStep
}

// Return sets up results that will be returned by InitializationContext.AcquireForThisStep
func (mmAcquireForThisStep *mInitializationContextMockAcquireForThisStep) Return(b1 BoolDecision) *InitializationContextMock {
	if mmAcquireForThisStep.mock.funcAcquireForThisStep != nil {
		mmAcquireForThisStep.mock.t.Fatalf("InitializationContextMock.AcquireForThisStep mock is already set by Set")
	}

	if mmAcquireForThisStep.defaultExpectation == nil {
		mmAcquireForThisStep.defaultExpectation = &InitializationContextMockAcquireForThisStepExpectation{mock: mmAcquireForThisStep.mock}
	}
	mmAcquireForThisStep.defaultExpectation.results = &InitializationContextMockAcquireForThisStepResults{b1}
	return mmAcquireForThisStep.mock
}

//Set uses given function f to mock the InitializationContext.AcquireForThisStep method
func (mmAcquireForThisStep *mInitializationContextMockAcquireForThisStep) Set(f func(s1 SyncLink) (b1 BoolDecision)) *InitializationContextMock {
	if mmAcquireForThisStep.defaultExpectation != nil {
		mmAcquireForThisStep.mock.t.Fatalf("Default expectation is already set for the InitializationContext.AcquireForThisStep method")
	}

	if len(mmAcquireForThisStep.expectations) > 0 {
		mmAcquireForThisStep.mock.t.Fatalf("Some expectations are already set for the InitializationContext.AcquireForThisStep method")
	}

	mmAcquireForThisStep.mock.funcAcquireForThisStep = f
	return mmAcquireForThisStep.mock
}

// When sets expectation for the InitializationContext.AcquireForThisStep which will trigger the result defined by the following
// Then helper
func (mmAcquireForThisStep *mInitializationContextMockAcquireForThisStep) When(s1 SyncLink) *InitializationContextMockAcquireForThisStepExpectation {
	if mmAcquireForThisStep.mock.funcAcquireForThisStep != nil {
		mmAcquireForThisStep.mock.t.Fatalf("InitializationContextMock.AcquireForThisStep mock is already set by Set")
	}

	expectation := &InitializationContextMockAcquireForThisStepExpectation{
		mock:   mmAcquireForThisStep.mock,
		params: &InitializationContextMockAcquireForThisStepParams{s1},
	}
	mmAcquireForThisStep.expectations = append(mmAcquireForThisStep.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.AcquireForThisStep return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockAcquireForThisStepExpectation) Then(b1 BoolDecision) *InitializationContextMock {
	e.results = &InitializationContextMockAcquireForThisStepResults{b1}
	return e.mock
}

// AcquireForThisStep implements InitializationContext
func (mmAcquireForThisStep *InitializationContextMock) AcquireForThisStep(s1 SyncLink) (b1 BoolDecision) {
	mm_atomic.AddUint64(&mmAcquireForThisStep.beforeAcquireForThisStepCounter, 1)
	defer mm_atomic.AddUint64(&mmAcquireForThisStep.afterAcquireForThisStepCounter, 1)

	if mmAcquireForThisStep.inspectFuncAcquireForThisStep != nil {
		mmAcquireForThisStep.inspectFuncAcquireForThisStep(s1)
	}

	mm_params := &InitializationContextMockAcquireForThisStepParams{s1}

	// Record call args
	mmAcquireForThisStep.AcquireForThisStepMock.mutex.Lock()
	mmAcquireForThisStep.AcquireForThisStepMock.callArgs = append(mmAcquireForThisStep.AcquireForThisStepMock.callArgs, mm_params)
	mmAcquireForThisStep.AcquireForThisStepMock.mutex.Unlock()

	for _, e := range mmAcquireForThisStep.AcquireForThisStepMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmAcquireForThisStep.AcquireForThisStepMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcquireForThisStep.AcquireForThisStepMock.defaultExpectation.Counter, 1)
		mm_want := mmAcquireForThisStep.AcquireForThisStepMock.defaultExpectation.params
		mm_got := InitializationContextMockAcquireForThisStepParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcquireForThisStep.t.Errorf("InitializationContextMock.AcquireForThisStep got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcquireForThisStep.AcquireForThisStepMock.defaultExpectation.results
		if mm_results == nil {
			mmAcquireForThisStep.t.Fatal("No results are set for the InitializationContextMock.AcquireForThisStep")
		}
		return (*mm_results).b1
	}
	if mmAcquireForThisStep.funcAcquireForThisStep != nil {
		return mmAcquireForThisStep.funcAcquireForThisStep(s1)
	}
	mmAcquireForThisStep.t.Fatalf("Unexpected call to InitializationContextMock.AcquireForThisStep. %v", s1)
	return
}

// AcquireForThisStepAfterCounter returns a count of finished InitializationContextMock.AcquireForThisStep invocations
func (mmAcquireForThisStep *InitializationContextMock) AcquireForThisStepAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireForThisStep.afterAcquireForThisStepCounter)
}

// AcquireForThisStepBeforeCounter returns a count of InitializationContextMock.AcquireForThisStep invocations
func (mmAcquireForThisStep *InitializationContextMock) AcquireForThisStepBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireForThisStep.beforeAcquireForThisStepCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.AcquireForThisStep.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcquireForThisStep *mInitializationContextMockAcquireForThisStep) Calls() []*InitializationContextMockAcquireForThisStepParams {
	mmAcquireForThisStep.mutex.RLock()

	argCopy := make([]*InitializationContextMockAcquireForThisStepParams, len(mmAcquireForThisStep.callArgs))
	copy(argCopy, mmAcquireForThisStep.callArgs)

	mmAcquireForThisStep.mutex.RUnlock()

	return argCopy
}

// MinimockAcquireForThisStepDone returns true if the count of the AcquireForThisStep invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockAcquireForThisStepDone() bool {
	for _, e := range m.AcquireForThisStepMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireForThisStepMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireForThisStep != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepCounter) < 1 {
		return false
	}
	return true
}

// MinimockAcquireForThisStepInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockAcquireForThisStepInspect() {
	for _, e := range m.AcquireForThisStepMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.AcquireForThisStep with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireForThisStepMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepCounter) < 1 {
		if m.AcquireForThisStepMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.AcquireForThisStep")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.AcquireForThisStep with params: %#v", *m.AcquireForThisStepMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireForThisStep != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.AcquireForThisStep")
	}
}

type mInitializationContextMockAcquireForThisStepAndRelease struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockAcquireForThisStepAndReleaseExpectation
	expectations       []*InitializationContextMockAcquireForThisStepAndReleaseExpectation

	callArgs []*InitializationContextMockAcquireForThisStepAndReleaseParams
	mutex    sync.RWMutex
}

// InitializationContextMockAcquireForThisStepAndReleaseExpectation specifies expectation struct of the InitializationContext.AcquireForThisStepAndRelease
type InitializationContextMockAcquireForThisStepAndReleaseExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockAcquireForThisStepAndReleaseParams
	results *InitializationContextMockAcquireForThisStepAndReleaseResults
	Counter uint64
}

// InitializationContextMockAcquireForThisStepAndReleaseParams contains parameters of the InitializationContext.AcquireForThisStepAndRelease
type InitializationContextMockAcquireForThisStepAndReleaseParams struct {
	s1 SyncLink
}

// InitializationContextMockAcquireForThisStepAndReleaseResults contains results of the InitializationContext.AcquireForThisStepAndRelease
type InitializationContextMockAcquireForThisStepAndReleaseResults struct {
	b1 BoolDecision
}

// Expect sets up expected params for InitializationContext.AcquireForThisStepAndRelease
func (mmAcquireForThisStepAndRelease *mInitializationContextMockAcquireForThisStepAndRelease) Expect(s1 SyncLink) *mInitializationContextMockAcquireForThisStepAndRelease {
	if mmAcquireForThisStepAndRelease.mock.funcAcquireForThisStepAndRelease != nil {
		mmAcquireForThisStepAndRelease.mock.t.Fatalf("InitializationContextMock.AcquireForThisStepAndRelease mock is already set by Set")
	}

	if mmAcquireForThisStepAndRelease.defaultExpectation == nil {
		mmAcquireForThisStepAndRelease.defaultExpectation = &InitializationContextMockAcquireForThisStepAndReleaseExpectation{}
	}

	mmAcquireForThisStepAndRelease.defaultExpectation.params = &InitializationContextMockAcquireForThisStepAndReleaseParams{s1}
	for _, e := range mmAcquireForThisStepAndRelease.expectations {
		if minimock.Equal(e.params, mmAcquireForThisStepAndRelease.defaultExpectation.params) {
			mmAcquireForThisStepAndRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcquireForThisStepAndRelease.defaultExpectation.params)
		}
	}

	return mmAcquireForThisStepAndRelease
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.AcquireForThisStepAndRelease
func (mmAcquireForThisStepAndRelease *mInitializationContextMockAcquireForThisStepAndRelease) Inspect(f func(s1 SyncLink)) *mInitializationContextMockAcquireForThisStepAndRelease {
	if mmAcquireForThisStepAndRelease.mock.inspectFuncAcquireForThisStepAndRelease != nil {
		mmAcquireForThisStepAndRelease.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.AcquireForThisStepAndRelease")
	}

	mmAcquireForThisStepAndRelease.mock.inspectFuncAcquireForThisStepAndRelease = f

	return mmAcquireForThisStepAndRelease
}

// Return sets up results that will be returned by InitializationContext.AcquireForThisStepAndRelease
func (mmAcquireForThisStepAndRelease *mInitializationContextMockAcquireForThisStepAndRelease) Return(b1 BoolDecision) *InitializationContextMock {
	if mmAcquireForThisStepAndRelease.mock.funcAcquireForThisStepAndRelease != nil {
		mmAcquireForThisStepAndRelease.mock.t.Fatalf("InitializationContextMock.AcquireForThisStepAndRelease mock is already set by Set")
	}

	if mmAcquireForThisStepAndRelease.defaultExpectation == nil {
		mmAcquireForThisStepAndRelease.defaultExpectation = &InitializationContextMockAcquireForThisStepAndReleaseExpectation{mock: mmAcquireForThisStepAndRelease.mock}
	}
	mmAcquireForThisStepAndRelease.defaultExpectation.results = &InitializationContextMockAcquireForThisStepAndReleaseResults{b1}
	return mmAcquireForThisStepAndRelease.mock
}

//Set uses given function f to mock the InitializationContext.AcquireForThisStepAndRelease method
func (mmAcquireForThisStepAndRelease *mInitializationContextMockAcquireForThisStepAndRelease) Set(f func(s1 SyncLink) (b1 BoolDecision)) *InitializationContextMock {
	if mmAcquireForThisStepAndRelease.defaultExpectation != nil {
		mmAcquireForThisStepAndRelease.mock.t.Fatalf("Default expectation is already set for the InitializationContext.AcquireForThisStepAndRelease method")
	}

	if len(mmAcquireForThisStepAndRelease.expectations) > 0 {
		mmAcquireForThisStepAndRelease.mock.t.Fatalf("Some expectations are already set for the InitializationContext.AcquireForThisStepAndRelease method")
	}

	mmAcquireForThisStepAndRelease.mock.funcAcquireForThisStepAndRelease = f
	return mmAcquireForThisStepAndRelease.mock
}

// When sets expectation for the InitializationContext.AcquireForThisStepAndRelease which will trigger the result defined by the following
// Then helper
func (mmAcquireForThisStepAndRelease *mInitializationContextMockAcquireForThisStepAndRelease) When(s1 SyncLink) *InitializationContextMockAcquireForThisStepAndReleaseExpectation {
	if mmAcquireForThisStepAndRelease.mock.funcAcquireForThisStepAndRelease != nil {
		mmAcquireForThisStepAndRelease.mock.t.Fatalf("InitializationContextMock.AcquireForThisStepAndRelease mock is already set by Set")
	}

	expectation := &InitializationContextMockAcquireForThisStepAndReleaseExpectation{
		mock:   mmAcquireForThisStepAndRelease.mock,
		params: &InitializationContextMockAcquireForThisStepAndReleaseParams{s1},
	}
	mmAcquireForThisStepAndRelease.expectations = append(mmAcquireForThisStepAndRelease.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.AcquireForThisStepAndRelease return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockAcquireForThisStepAndReleaseExpectation) Then(b1 BoolDecision) *InitializationContextMock {
	e.results = &InitializationContextMockAcquireForThisStepAndReleaseResults{b1}
	return e.mock
}

// AcquireForThisStepAndRelease implements InitializationContext
func (mmAcquireForThisStepAndRelease *InitializationContextMock) AcquireForThisStepAndRelease(s1 SyncLink) (b1 BoolDecision) {
	mm_atomic.AddUint64(&mmAcquireForThisStepAndRelease.beforeAcquireForThisStepAndReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmAcquireForThisStepAndRelease.afterAcquireForThisStepAndReleaseCounter, 1)

	if mmAcquireForThisStepAndRelease.inspectFuncAcquireForThisStepAndRelease != nil {
		mmAcquireForThisStepAndRelease.inspectFuncAcquireForThisStepAndRelease(s1)
	}

	mm_params := &InitializationContextMockAcquireForThisStepAndReleaseParams{s1}

	// Record call args
	mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.mutex.Lock()
	mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.callArgs = append(mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.callArgs, mm_params)
	mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.mutex.Unlock()

	for _, e := range mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.defaultExpectation.params
		mm_got := InitializationContextMockAcquireForThisStepAndReleaseParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcquireForThisStepAndRelease.t.Errorf("InitializationContextMock.AcquireForThisStepAndRelease got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmAcquireForThisStepAndRelease.t.Fatal("No results are set for the InitializationContextMock.AcquireForThisStepAndRelease")
		}
		return (*mm_results).b1
	}
	if mmAcquireForThisStepAndRelease.funcAcquireForThisStepAndRelease != nil {
		return mmAcquireForThisStepAndRelease.funcAcquireForThisStepAndRelease(s1)
	}
	mmAcquireForThisStepAndRelease.t.Fatalf("Unexpected call to InitializationContextMock.AcquireForThisStepAndRelease. %v", s1)
	return
}

// AcquireForThisStepAndReleaseAfterCounter returns a count of finished InitializationContextMock.AcquireForThisStepAndRelease invocations
func (mmAcquireForThisStepAndRelease *InitializationContextMock) AcquireForThisStepAndReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireForThisStepAndRelease.afterAcquireForThisStepAndReleaseCounter)
}

// AcquireForThisStepAndReleaseBeforeCounter returns a count of InitializationContextMock.AcquireForThisStepAndRelease invocations
func (mmAcquireForThisStepAndRelease *InitializationContextMock) AcquireForThisStepAndReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireForThisStepAndRelease.beforeAcquireForThisStepAndReleaseCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.AcquireForThisStepAndRelease.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcquireForThisStepAndRelease *mInitializationContextMockAcquireForThisStepAndRelease) Calls() []*InitializationContextMockAcquireForThisStepAndReleaseParams {
	mmAcquireForThisStepAndRelease.mutex.RLock()

	argCopy := make([]*InitializationContextMockAcquireForThisStepAndReleaseParams, len(mmAcquireForThisStepAndRelease.callArgs))
	copy(argCopy, mmAcquireForThisStepAndRelease.callArgs)

	mmAcquireForThisStepAndRelease.mutex.RUnlock()

	return argCopy
}

// MinimockAcquireForThisStepAndReleaseDone returns true if the count of the AcquireForThisStepAndRelease invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockAcquireForThisStepAndReleaseDone() bool {
	for _, e := range m.AcquireForThisStepAndReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireForThisStepAndReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepAndReleaseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireForThisStepAndRelease != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepAndReleaseCounter) < 1 {
		return false
	}
	return true
}

// MinimockAcquireForThisStepAndReleaseInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockAcquireForThisStepAndReleaseInspect() {
	for _, e := range m.AcquireForThisStepAndReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.AcquireForThisStepAndRelease with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireForThisStepAndReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepAndReleaseCounter) < 1 {
		if m.AcquireForThisStepAndReleaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.AcquireForThisStepAndRelease")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.AcquireForThisStepAndRelease with params: %#v", *m.AcquireForThisStepAndReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireForThisStepAndRelease != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepAndReleaseCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.AcquireForThisStepAndRelease")
	}
}

type mInitializationContextMockApplyAdjustment struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockApplyAdjustmentExpectation
	expectations       []*InitializationContextMockApplyAdjustmentExpectation

	callArgs []*InitializationContextMockApplyAdjustmentParams
	mutex    sync.RWMutex
}

// InitializationContextMockApplyAdjustmentExpectation specifies expectation struct of the InitializationContext.ApplyAdjustment
type InitializationContextMockApplyAdjustmentExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockApplyAdjustmentParams
	results *InitializationContextMockApplyAdjustmentResults
	Counter uint64
}

// InitializationContextMockApplyAdjustmentParams contains parameters of the InitializationContext.ApplyAdjustment
type InitializationContextMockApplyAdjustmentParams struct {
	s1 SyncAdjustment
}

// InitializationContextMockApplyAdjustmentResults contains results of the InitializationContext.ApplyAdjustment
type InitializationContextMockApplyAdjustmentResults struct {
	b1 bool
}

// Expect sets up expected params for InitializationContext.ApplyAdjustment
func (mmApplyAdjustment *mInitializationContextMockApplyAdjustment) Expect(s1 SyncAdjustment) *mInitializationContextMockApplyAdjustment {
	if mmApplyAdjustment.mock.funcApplyAdjustment != nil {
		mmApplyAdjustment.mock.t.Fatalf("InitializationContextMock.ApplyAdjustment mock is already set by Set")
	}

	if mmApplyAdjustment.defaultExpectation == nil {
		mmApplyAdjustment.defaultExpectation = &InitializationContextMockApplyAdjustmentExpectation{}
	}

	mmApplyAdjustment.defaultExpectation.params = &InitializationContextMockApplyAdjustmentParams{s1}
	for _, e := range mmApplyAdjustment.expectations {
		if minimock.Equal(e.params, mmApplyAdjustment.defaultExpectation.params) {
			mmApplyAdjustment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmApplyAdjustment.defaultExpectation.params)
		}
	}

	return mmApplyAdjustment
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.ApplyAdjustment
func (mmApplyAdjustment *mInitializationContextMockApplyAdjustment) Inspect(f func(s1 SyncAdjustment)) *mInitializationContextMockApplyAdjustment {
	if mmApplyAdjustment.mock.inspectFuncApplyAdjustment != nil {
		mmApplyAdjustment.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.ApplyAdjustment")
	}

	mmApplyAdjustment.mock.inspectFuncApplyAdjustment = f

	return mmApplyAdjustment
}

// Return sets up results that will be returned by InitializationContext.ApplyAdjustment
func (mmApplyAdjustment *mInitializationContextMockApplyAdjustment) Return(b1 bool) *InitializationContextMock {
	if mmApplyAdjustment.mock.funcApplyAdjustment != nil {
		mmApplyAdjustment.mock.t.Fatalf("InitializationContextMock.ApplyAdjustment mock is already set by Set")
	}

	if mmApplyAdjustment.defaultExpectation == nil {
		mmApplyAdjustment.defaultExpectation = &InitializationContextMockApplyAdjustmentExpectation{mock: mmApplyAdjustment.mock}
	}
	mmApplyAdjustment.defaultExpectation.results = &InitializationContextMockApplyAdjustmentResults{b1}
	return mmApplyAdjustment.mock
}

//Set uses given function f to mock the InitializationContext.ApplyAdjustment method
func (mmApplyAdjustment *mInitializationContextMockApplyAdjustment) Set(f func(s1 SyncAdjustment) (b1 bool)) *InitializationContextMock {
	if mmApplyAdjustment.defaultExpectation != nil {
		mmApplyAdjustment.mock.t.Fatalf("Default expectation is already set for the InitializationContext.ApplyAdjustment method")
	}

	if len(mmApplyAdjustment.expectations) > 0 {
		mmApplyAdjustment.mock.t.Fatalf("Some expectations are already set for the InitializationContext.ApplyAdjustment method")
	}

	mmApplyAdjustment.mock.funcApplyAdjustment = f
	return mmApplyAdjustment.mock
}

// When sets expectation for the InitializationContext.ApplyAdjustment which will trigger the result defined by the following
// Then helper
func (mmApplyAdjustment *mInitializationContextMockApplyAdjustment) When(s1 SyncAdjustment) *InitializationContextMockApplyAdjustmentExpectation {
	if mmApplyAdjustment.mock.funcApplyAdjustment != nil {
		mmApplyAdjustment.mock.t.Fatalf("InitializationContextMock.ApplyAdjustment mock is already set by Set")
	}

	expectation := &InitializationContextMockApplyAdjustmentExpectation{
		mock:   mmApplyAdjustment.mock,
		params: &InitializationContextMockApplyAdjustmentParams{s1},
	}
	mmApplyAdjustment.expectations = append(mmApplyAdjustment.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.ApplyAdjustment return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockApplyAdjustmentExpectation) Then(b1 bool) *InitializationContextMock {
	e.results = &InitializationContextMockApplyAdjustmentResults{b1}
	return e.mock
}

// ApplyAdjustment implements InitializationContext
func (mmApplyAdjustment *InitializationContextMock) ApplyAdjustment(s1 SyncAdjustment) (b1 bool) {
	mm_atomic.AddUint64(&mmApplyAdjustment.beforeApplyAdjustmentCounter, 1)
	defer mm_atomic.AddUint64(&mmApplyAdjustment.afterApplyAdjustmentCounter, 1)

	if mmApplyAdjustment.inspectFuncApplyAdjustment != nil {
		mmApplyAdjustment.inspectFuncApplyAdjustment(s1)
	}

	mm_params := &InitializationContextMockApplyAdjustmentParams{s1}

	// Record call args
	mmApplyAdjustment.ApplyAdjustmentMock.mutex.Lock()
	mmApplyAdjustment.ApplyAdjustmentMock.callArgs = append(mmApplyAdjustment.ApplyAdjustmentMock.callArgs, mm_params)
	mmApplyAdjustment.ApplyAdjustmentMock.mutex.Unlock()

	for _, e := range mmApplyAdjustment.ApplyAdjustmentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmApplyAdjustment.ApplyAdjustmentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmApplyAdjustment.ApplyAdjustmentMock.defaultExpectation.Counter, 1)
		mm_want := mmApplyAdjustment.ApplyAdjustmentMock.defaultExpectation.params
		mm_got := InitializationContextMockApplyAdjustmentParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmApplyAdjustment.t.Errorf("InitializationContextMock.ApplyAdjustment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmApplyAdjustment.ApplyAdjustmentMock.defaultExpectation.results
		if mm_results == nil {
			mmApplyAdjustment.t.Fatal("No results are set for the InitializationContextMock.ApplyAdjustment")
		}
		return (*mm_results).b1
	}
	if mmApplyAdjustment.funcApplyAdjustment != nil {
		return mmApplyAdjustment.funcApplyAdjustment(s1)
	}
	mmApplyAdjustment.t.Fatalf("Unexpected call to InitializationContextMock.ApplyAdjustment. %v", s1)
	return
}

// ApplyAdjustmentAfterCounter returns a count of finished InitializationContextMock.ApplyAdjustment invocations
func (mmApplyAdjustment *InitializationContextMock) ApplyAdjustmentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyAdjustment.afterApplyAdjustmentCounter)
}

// ApplyAdjustmentBeforeCounter returns a count of InitializationContextMock.ApplyAdjustment invocations
func (mmApplyAdjustment *InitializationContextMock) ApplyAdjustmentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyAdjustment.beforeApplyAdjustmentCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.ApplyAdjustment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmApplyAdjustment *mInitializationContextMockApplyAdjustment) Calls() []*InitializationContextMockApplyAdjustmentParams {
	mmApplyAdjustment.mutex.RLock()

	argCopy := make([]*InitializationContextMockApplyAdjustmentParams, len(mmApplyAdjustment.callArgs))
	copy(argCopy, mmApplyAdjustment.callArgs)

	mmApplyAdjustment.mutex.RUnlock()

	return argCopy
}

// MinimockApplyAdjustmentDone returns true if the count of the ApplyAdjustment invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockApplyAdjustmentDone() bool {
	for _, e := range m.ApplyAdjustmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyAdjustmentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterApplyAdjustmentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApplyAdjustment != nil && mm_atomic.LoadUint64(&m.afterApplyAdjustmentCounter) < 1 {
		return false
	}
	return true
}

// MinimockApplyAdjustmentInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockApplyAdjustmentInspect() {
	for _, e := range m.ApplyAdjustmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.ApplyAdjustment with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyAdjustmentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterApplyAdjustmentCounter) < 1 {
		if m.ApplyAdjustmentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.ApplyAdjustment")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.ApplyAdjustment with params: %#v", *m.ApplyAdjustmentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApplyAdjustment != nil && mm_atomic.LoadUint64(&m.afterApplyAdjustmentCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.ApplyAdjustment")
	}
}

type mInitializationContextMockCallBargeIn struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockCallBargeInExpectation
	expectations       []*InitializationContextMockCallBargeInExpectation

	callArgs []*InitializationContextMockCallBargeInParams
	mutex    sync.RWMutex
}

// InitializationContextMockCallBargeInExpectation specifies expectation struct of the InitializationContext.CallBargeIn
type InitializationContextMockCallBargeInExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockCallBargeInParams
	results *InitializationContextMockCallBargeInResults
	Counter uint64
}

// InitializationContextMockCallBargeInParams contains parameters of the InitializationContext.CallBargeIn
type InitializationContextMockCallBargeInParams struct {
	b BargeIn
}

// InitializationContextMockCallBargeInResults contains results of the InitializationContext.CallBargeIn
type InitializationContextMockCallBargeInResults struct {
	b1 bool
}

// Expect sets up expected params for InitializationContext.CallBargeIn
func (mmCallBargeIn *mInitializationContextMockCallBargeIn) Expect(b BargeIn) *mInitializationContextMockCallBargeIn {
	if mmCallBargeIn.mock.funcCallBargeIn != nil {
		mmCallBargeIn.mock.t.Fatalf("InitializationContextMock.CallBargeIn mock is already set by Set")
	}

	if mmCallBargeIn.defaultExpectation == nil {
		mmCallBargeIn.defaultExpectation = &InitializationContextMockCallBargeInExpectation{}
	}

	mmCallBargeIn.defaultExpectation.params = &InitializationContextMockCallBargeInParams{b}
	for _, e := range mmCallBargeIn.expectations {
		if minimock.Equal(e.params, mmCallBargeIn.defaultExpectation.params) {
			mmCallBargeIn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCallBargeIn.defaultExpectation.params)
		}
	}

	return mmCallBargeIn
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.CallBargeIn
func (mmCallBargeIn *mInitializationContextMockCallBargeIn) Inspect(f func(b BargeIn)) *mInitializationContextMockCallBargeIn {
	if mmCallBargeIn.mock.inspectFuncCallBargeIn != nil {
		mmCallBargeIn.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.CallBargeIn")
	}

	mmCallBargeIn.mock.inspectFuncCallBargeIn = f

	return mmCallBargeIn
}

// Return sets up results that will be returned by InitializationContext.CallBargeIn
func (mmCallBargeIn *mInitializationContextMockCallBargeIn) Return(b1 bool) *InitializationContextMock {
	if mmCallBargeIn.mock.funcCallBargeIn != nil {
		mmCallBargeIn.mock.t.Fatalf("InitializationContextMock.CallBargeIn mock is already set by Set")
	}

	if mmCallBargeIn.defaultExpectation == nil {
		mmCallBargeIn.defaultExpectation = &InitializationContextMockCallBargeInExpectation{mock: mmCallBargeIn.mock}
	}
	mmCallBargeIn.defaultExpectation.results = &InitializationContextMockCallBargeInResults{b1}
	return mmCallBargeIn.mock
}

//Set uses given function f to mock the InitializationContext.CallBargeIn method
func (mmCallBargeIn *mInitializationContextMockCallBargeIn) Set(f func(b BargeIn) (b1 bool)) *InitializationContextMock {
	if mmCallBargeIn.defaultExpectation != nil {
		mmCallBargeIn.mock.t.Fatalf("Default expectation is already set for the InitializationContext.CallBargeIn method")
	}

	if len(mmCallBargeIn.expectations) > 0 {
		mmCallBargeIn.mock.t.Fatalf("Some expectations are already set for the InitializationContext.CallBargeIn method")
	}

	mmCallBargeIn.mock.funcCallBargeIn = f
	return mmCallBargeIn.mock
}

// When sets expectation for the InitializationContext.CallBargeIn which will trigger the result defined by the following
// Then helper
func (mmCallBargeIn *mInitializationContextMockCallBargeIn) When(b BargeIn) *InitializationContextMockCallBargeInExpectation {
	if mmCallBargeIn.mock.funcCallBargeIn != nil {
		mmCallBargeIn.mock.t.Fatalf("InitializationContextMock.CallBargeIn mock is already set by Set")
	}

	expectation := &InitializationContextMockCallBargeInExpectation{
		mock:   mmCallBargeIn.mock,
		params: &InitializationContextMockCallBargeInParams{b},
	}
	mmCallBargeIn.expectations = append(mmCallBargeIn.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.CallBargeIn return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockCallBargeInExpectation) Then(b1 bool) *InitializationContextMock {
	e.results = &InitializationContextMockCallBargeInResults{b1}
	return e.mock
}

// CallBargeIn implements InitializationContext
func (mmCallBargeIn *InitializationContextMock) CallBargeIn(b BargeIn) (b1 bool) {
	mm_atomic.AddUint64(&mmCallBargeIn.beforeCallBargeInCounter, 1)
	defer mm_atomic.AddUint64(&mmCallBargeIn.afterCallBargeInCounter, 1)

	if mmCallBargeIn.inspectFuncCallBargeIn != nil {
		mmCallBargeIn.inspectFuncCallBargeIn(b)
	}

	mm_params := &InitializationContextMockCallBargeInParams{b}

	// Record call args
	mmCallBargeIn.CallBargeInMock.mutex.Lock()
	mmCallBargeIn.CallBargeInMock.callArgs = append(mmCallBargeIn.CallBargeInMock.callArgs, mm_params)
	mmCallBargeIn.CallBargeInMock.mutex.Unlock()

	for _, e := range mmCallBargeIn.CallBargeInMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmCallBargeIn.CallBargeInMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCallBargeIn.CallBargeInMock.defaultExpectation.Counter, 1)
		mm_want := mmCallBargeIn.CallBargeInMock.defaultExpectation.params
		mm_got := InitializationContextMockCallBargeInParams{b}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCallBargeIn.t.Errorf("InitializationContextMock.CallBargeIn got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCallBargeIn.CallBargeInMock.defaultExpectation.results
		if mm_results == nil {
			mmCallBargeIn.t.Fatal("No results are set for the InitializationContextMock.CallBargeIn")
		}
		return (*mm_results).b1
	}
	if mmCallBargeIn.funcCallBargeIn != nil {
		return mmCallBargeIn.funcCallBargeIn(b)
	}
	mmCallBargeIn.t.Fatalf("Unexpected call to InitializationContextMock.CallBargeIn. %v", b)
	return
}

// CallBargeInAfterCounter returns a count of finished InitializationContextMock.CallBargeIn invocations
func (mmCallBargeIn *InitializationContextMock) CallBargeInAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallBargeIn.afterCallBargeInCounter)
}

// CallBargeInBeforeCounter returns a count of InitializationContextMock.CallBargeIn invocations
func (mmCallBargeIn *InitializationContextMock) CallBargeInBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallBargeIn.beforeCallBargeInCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.CallBargeIn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCallBargeIn *mInitializationContextMockCallBargeIn) Calls() []*InitializationContextMockCallBargeInParams {
	mmCallBargeIn.mutex.RLock()

	argCopy := make([]*InitializationContextMockCallBargeInParams, len(mmCallBargeIn.callArgs))
	copy(argCopy, mmCallBargeIn.callArgs)

	mmCallBargeIn.mutex.RUnlock()

	return argCopy
}

// MinimockCallBargeInDone returns true if the count of the CallBargeIn invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockCallBargeInDone() bool {
	for _, e := range m.CallBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallBargeInCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallBargeIn != nil && mm_atomic.LoadUint64(&m.afterCallBargeInCounter) < 1 {
		return false
	}
	return true
}

// MinimockCallBargeInInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockCallBargeInInspect() {
	for _, e := range m.CallBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.CallBargeIn with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallBargeInCounter) < 1 {
		if m.CallBargeInMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.CallBargeIn")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.CallBargeIn with params: %#v", *m.CallBargeInMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallBargeIn != nil && mm_atomic.LoadUint64(&m.afterCallBargeInCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.CallBargeIn")
	}
}

type mInitializationContextMockCallBargeInWithParam struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockCallBargeInWithParamExpectation
	expectations       []*InitializationContextMockCallBargeInWithParamExpectation

	callArgs []*InitializationContextMockCallBargeInWithParamParams
	mutex    sync.RWMutex
}

// InitializationContextMockCallBargeInWithParamExpectation specifies expectation struct of the InitializationContext.CallBargeInWithParam
type InitializationContextMockCallBargeInWithParamExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockCallBargeInWithParamParams
	results *InitializationContextMockCallBargeInWithParamResults
	Counter uint64
}

// InitializationContextMockCallBargeInWithParamParams contains parameters of the InitializationContext.CallBargeInWithParam
type InitializationContextMockCallBargeInWithParamParams struct {
	b     BargeInWithParam
	param interface{}
}

// InitializationContextMockCallBargeInWithParamResults contains results of the InitializationContext.CallBargeInWithParam
type InitializationContextMockCallBargeInWithParamResults struct {
	b1 bool
}

// Expect sets up expected params for InitializationContext.CallBargeInWithParam
func (mmCallBargeInWithParam *mInitializationContextMockCallBargeInWithParam) Expect(b BargeInWithParam, param interface{}) *mInitializationContextMockCallBargeInWithParam {
	if mmCallBargeInWithParam.mock.funcCallBargeInWithParam != nil {
		mmCallBargeInWithParam.mock.t.Fatalf("InitializationContextMock.CallBargeInWithParam mock is already set by Set")
	}

	if mmCallBargeInWithParam.defaultExpectation == nil {
		mmCallBargeInWithParam.defaultExpectation = &InitializationContextMockCallBargeInWithParamExpectation{}
	}

	mmCallBargeInWithParam.defaultExpectation.params = &InitializationContextMockCallBargeInWithParamParams{b, param}
	for _, e := range mmCallBargeInWithParam.expectations {
		if minimock.Equal(e.params, mmCallBargeInWithParam.defaultExpectation.params) {
			mmCallBargeInWithParam.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCallBargeInWithParam.defaultExpectation.params)
		}
	}

	return mmCallBargeInWithParam
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.CallBargeInWithParam
func (mmCallBargeInWithParam *mInitializationContextMockCallBargeInWithParam) Inspect(f func(b BargeInWithParam, param interface{})) *mInitializationContextMockCallBargeInWithParam {
	if mmCallBargeInWithParam.mock.inspectFuncCallBargeInWithParam != nil {
		mmCallBargeInWithParam.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.CallBargeInWithParam")
	}

	mmCallBargeInWithParam.mock.inspectFuncCallBargeInWithParam = f

	return mmCallBargeInWithParam
}

// Return sets up results that will be returned by InitializationContext.CallBargeInWithParam
func (mmCallBargeInWithParam *mInitializationContextMockCallBargeInWithParam) Return(b1 bool) *InitializationContextMock {
	if mmCallBargeInWithParam.mock.funcCallBargeInWithParam != nil {
		mmCallBargeInWithParam.mock.t.Fatalf("InitializationContextMock.CallBargeInWithParam mock is already set by Set")
	}

	if mmCallBargeInWithParam.defaultExpectation == nil {
		mmCallBargeInWithParam.defaultExpectation = &InitializationContextMockCallBargeInWithParamExpectation{mock: mmCallBargeInWithParam.mock}
	}
	mmCallBargeInWithParam.defaultExpectation.results = &InitializationContextMockCallBargeInWithParamResults{b1}
	return mmCallBargeInWithParam.mock
}

//Set uses given function f to mock the InitializationContext.CallBargeInWithParam method
func (mmCallBargeInWithParam *mInitializationContextMockCallBargeInWithParam) Set(f func(b BargeInWithParam, param interface{}) (b1 bool)) *InitializationContextMock {
	if mmCallBargeInWithParam.defaultExpectation != nil {
		mmCallBargeInWithParam.mock.t.Fatalf("Default expectation is already set for the InitializationContext.CallBargeInWithParam method")
	}

	if len(mmCallBargeInWithParam.expectations) > 0 {
		mmCallBargeInWithParam.mock.t.Fatalf("Some expectations are already set for the InitializationContext.CallBargeInWithParam method")
	}

	mmCallBargeInWithParam.mock.funcCallBargeInWithParam = f
	return mmCallBargeInWithParam.mock
}

// When sets expectation for the InitializationContext.CallBargeInWithParam which will trigger the result defined by the following
// Then helper
func (mmCallBargeInWithParam *mInitializationContextMockCallBargeInWithParam) When(b BargeInWithParam, param interface{}) *InitializationContextMockCallBargeInWithParamExpectation {
	if mmCallBargeInWithParam.mock.funcCallBargeInWithParam != nil {
		mmCallBargeInWithParam.mock.t.Fatalf("InitializationContextMock.CallBargeInWithParam mock is already set by Set")
	}

	expectation := &InitializationContextMockCallBargeInWithParamExpectation{
		mock:   mmCallBargeInWithParam.mock,
		params: &InitializationContextMockCallBargeInWithParamParams{b, param},
	}
	mmCallBargeInWithParam.expectations = append(mmCallBargeInWithParam.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.CallBargeInWithParam return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockCallBargeInWithParamExpectation) Then(b1 bool) *InitializationContextMock {
	e.results = &InitializationContextMockCallBargeInWithParamResults{b1}
	return e.mock
}

// CallBargeInWithParam implements InitializationContext
func (mmCallBargeInWithParam *InitializationContextMock) CallBargeInWithParam(b BargeInWithParam, param interface{}) (b1 bool) {
	mm_atomic.AddUint64(&mmCallBargeInWithParam.beforeCallBargeInWithParamCounter, 1)
	defer mm_atomic.AddUint64(&mmCallBargeInWithParam.afterCallBargeInWithParamCounter, 1)

	if mmCallBargeInWithParam.inspectFuncCallBargeInWithParam != nil {
		mmCallBargeInWithParam.inspectFuncCallBargeInWithParam(b, param)
	}

	mm_params := &InitializationContextMockCallBargeInWithParamParams{b, param}

	// Record call args
	mmCallBargeInWithParam.CallBargeInWithParamMock.mutex.Lock()
	mmCallBargeInWithParam.CallBargeInWithParamMock.callArgs = append(mmCallBargeInWithParam.CallBargeInWithParamMock.callArgs, mm_params)
	mmCallBargeInWithParam.CallBargeInWithParamMock.mutex.Unlock()

	for _, e := range mmCallBargeInWithParam.CallBargeInWithParamMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmCallBargeInWithParam.CallBargeInWithParamMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCallBargeInWithParam.CallBargeInWithParamMock.defaultExpectation.Counter, 1)
		mm_want := mmCallBargeInWithParam.CallBargeInWithParamMock.defaultExpectation.params
		mm_got := InitializationContextMockCallBargeInWithParamParams{b, param}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCallBargeInWithParam.t.Errorf("InitializationContextMock.CallBargeInWithParam got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCallBargeInWithParam.CallBargeInWithParamMock.defaultExpectation.results
		if mm_results == nil {
			mmCallBargeInWithParam.t.Fatal("No results are set for the InitializationContextMock.CallBargeInWithParam")
		}
		return (*mm_results).b1
	}
	if mmCallBargeInWithParam.funcCallBargeInWithParam != nil {
		return mmCallBargeInWithParam.funcCallBargeInWithParam(b, param)
	}
	mmCallBargeInWithParam.t.Fatalf("Unexpected call to InitializationContextMock.CallBargeInWithParam. %v %v", b, param)
	return
}

// CallBargeInWithParamAfterCounter returns a count of finished InitializationContextMock.CallBargeInWithParam invocations
func (mmCallBargeInWithParam *InitializationContextMock) CallBargeInWithParamAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallBargeInWithParam.afterCallBargeInWithParamCounter)
}

// CallBargeInWithParamBeforeCounter returns a count of InitializationContextMock.CallBargeInWithParam invocations
func (mmCallBargeInWithParam *InitializationContextMock) CallBargeInWithParamBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallBargeInWithParam.beforeCallBargeInWithParamCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.CallBargeInWithParam.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCallBargeInWithParam *mInitializationContextMockCallBargeInWithParam) Calls() []*InitializationContextMockCallBargeInWithParamParams {
	mmCallBargeInWithParam.mutex.RLock()

	argCopy := make([]*InitializationContextMockCallBargeInWithParamParams, len(mmCallBargeInWithParam.callArgs))
	copy(argCopy, mmCallBargeInWithParam.callArgs)

	mmCallBargeInWithParam.mutex.RUnlock()

	return argCopy
}

// MinimockCallBargeInWithParamDone returns true if the count of the CallBargeInWithParam invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockCallBargeInWithParamDone() bool {
	for _, e := range m.CallBargeInWithParamMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallBargeInWithParamMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallBargeInWithParamCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallBargeInWithParam != nil && mm_atomic.LoadUint64(&m.afterCallBargeInWithParamCounter) < 1 {
		return false
	}
	return true
}

// MinimockCallBargeInWithParamInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockCallBargeInWithParamInspect() {
	for _, e := range m.CallBargeInWithParamMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.CallBargeInWithParam with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallBargeInWithParamMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallBargeInWithParamCounter) < 1 {
		if m.CallBargeInWithParamMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.CallBargeInWithParam")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.CallBargeInWithParam with params: %#v", *m.CallBargeInWithParamMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallBargeInWithParam != nil && mm_atomic.LoadUint64(&m.afterCallBargeInWithParamCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.CallBargeInWithParam")
	}
}

type mInitializationContextMockCheck struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockCheckExpectation
	expectations       []*InitializationContextMockCheckExpectation

	callArgs []*InitializationContextMockCheckParams
	mutex    sync.RWMutex
}

// InitializationContextMockCheckExpectation specifies expectation struct of the InitializationContext.Check
type InitializationContextMockCheckExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockCheckParams
	results *InitializationContextMockCheckResults
	Counter uint64
}

// InitializationContextMockCheckParams contains parameters of the InitializationContext.Check
type InitializationContextMockCheckParams struct {
	s1 SyncLink
}

// InitializationContextMockCheckResults contains results of the InitializationContext.Check
type InitializationContextMockCheckResults struct {
	b1 BoolDecision
}

// Expect sets up expected params for InitializationContext.Check
func (mmCheck *mInitializationContextMockCheck) Expect(s1 SyncLink) *mInitializationContextMockCheck {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("InitializationContextMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &InitializationContextMockCheckExpectation{}
	}

	mmCheck.defaultExpectation.params = &InitializationContextMockCheckParams{s1}
	for _, e := range mmCheck.expectations {
		if minimock.Equal(e.params, mmCheck.defaultExpectation.params) {
			mmCheck.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheck.defaultExpectation.params)
		}
	}

	return mmCheck
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.Check
func (mmCheck *mInitializationContextMockCheck) Inspect(f func(s1 SyncLink)) *mInitializationContextMockCheck {
	if mmCheck.mock.inspectFuncCheck != nil {
		mmCheck.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.Check")
	}

	mmCheck.mock.inspectFuncCheck = f

	return mmCheck
}

// Return sets up results that will be returned by InitializationContext.Check
func (mmCheck *mInitializationContextMockCheck) Return(b1 BoolDecision) *InitializationContextMock {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("InitializationContextMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &InitializationContextMockCheckExpectation{mock: mmCheck.mock}
	}
	mmCheck.defaultExpectation.results = &InitializationContextMockCheckResults{b1}
	return mmCheck.mock
}

//Set uses given function f to mock the InitializationContext.Check method
func (mmCheck *mInitializationContextMockCheck) Set(f func(s1 SyncLink) (b1 BoolDecision)) *InitializationContextMock {
	if mmCheck.defaultExpectation != nil {
		mmCheck.mock.t.Fatalf("Default expectation is already set for the InitializationContext.Check method")
	}

	if len(mmCheck.expectations) > 0 {
		mmCheck.mock.t.Fatalf("Some expectations are already set for the InitializationContext.Check method")
	}

	mmCheck.mock.funcCheck = f
	return mmCheck.mock
}

// When sets expectation for the InitializationContext.Check which will trigger the result defined by the following
// Then helper
func (mmCheck *mInitializationContextMockCheck) When(s1 SyncLink) *InitializationContextMockCheckExpectation {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("InitializationContextMock.Check mock is already set by Set")
	}

	expectation := &InitializationContextMockCheckExpectation{
		mock:   mmCheck.mock,
		params: &InitializationContextMockCheckParams{s1},
	}
	mmCheck.expectations = append(mmCheck.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.Check return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockCheckExpectation) Then(b1 BoolDecision) *InitializationContextMock {
	e.results = &InitializationContextMockCheckResults{b1}
	return e.mock
}

// Check implements InitializationContext
func (mmCheck *InitializationContextMock) Check(s1 SyncLink) (b1 BoolDecision) {
	mm_atomic.AddUint64(&mmCheck.beforeCheckCounter, 1)
	defer mm_atomic.AddUint64(&mmCheck.afterCheckCounter, 1)

	if mmCheck.inspectFuncCheck != nil {
		mmCheck.inspectFuncCheck(s1)
	}

	mm_params := &InitializationContextMockCheckParams{s1}

	// Record call args
	mmCheck.CheckMock.mutex.Lock()
	mmCheck.CheckMock.callArgs = append(mmCheck.CheckMock.callArgs, mm_params)
	mmCheck.CheckMock.mutex.Unlock()

	for _, e := range mmCheck.CheckMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmCheck.CheckMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheck.CheckMock.defaultExpectation.Counter, 1)
		mm_want := mmCheck.CheckMock.defaultExpectation.params
		mm_got := InitializationContextMockCheckParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheck.t.Errorf("InitializationContextMock.Check got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheck.CheckMock.defaultExpectation.results
		if mm_results == nil {
			mmCheck.t.Fatal("No results are set for the InitializationContextMock.Check")
		}
		return (*mm_results).b1
	}
	if mmCheck.funcCheck != nil {
		return mmCheck.funcCheck(s1)
	}
	mmCheck.t.Fatalf("Unexpected call to InitializationContextMock.Check. %v", s1)
	return
}

// CheckAfterCounter returns a count of finished InitializationContextMock.Check invocations
func (mmCheck *InitializationContextMock) CheckAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheck.afterCheckCounter)
}

// CheckBeforeCounter returns a count of InitializationContextMock.Check invocations
func (mmCheck *InitializationContextMock) CheckBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheck.beforeCheckCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.Check.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheck *mInitializationContextMockCheck) Calls() []*InitializationContextMockCheckParams {
	mmCheck.mutex.RLock()

	argCopy := make([]*InitializationContextMockCheckParams, len(mmCheck.callArgs))
	copy(argCopy, mmCheck.callArgs)

	mmCheck.mutex.RUnlock()

	return argCopy
}

// MinimockCheckDone returns true if the count of the Check invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockCheckDone() bool {
	for _, e := range m.CheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheck != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		return false
	}
	return true
}

// MinimockCheckInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockCheckInspect() {
	for _, e := range m.CheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.Check with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		if m.CheckMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.Check")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.Check with params: %#v", *m.CheckMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheck != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.Check")
	}
}

type mInitializationContextMockError struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockErrorExpectation
	expectations       []*InitializationContextMockErrorExpectation

	callArgs []*InitializationContextMockErrorParams
	mutex    sync.RWMutex
}

// InitializationContextMockErrorExpectation specifies expectation struct of the InitializationContext.Error
type InitializationContextMockErrorExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockErrorParams
	results *InitializationContextMockErrorResults
	Counter uint64
}

// InitializationContextMockErrorParams contains parameters of the InitializationContext.Error
type InitializationContextMockErrorParams struct {
	e1 error
}

// InitializationContextMockErrorResults contains results of the InitializationContext.Error
type InitializationContextMockErrorResults struct {
	s1 StateUpdate
}

// Expect sets up expected params for InitializationContext.Error
func (mmError *mInitializationContextMockError) Expect(e1 error) *mInitializationContextMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("InitializationContextMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &InitializationContextMockErrorExpectation{}
	}

	mmError.defaultExpectation.params = &InitializationContextMockErrorParams{e1}
	for _, e := range mmError.expectations {
		if minimock.Equal(e.params, mmError.defaultExpectation.params) {
			mmError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmError.defaultExpectation.params)
		}
	}

	return mmError
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.Error
func (mmError *mInitializationContextMockError) Inspect(f func(e1 error)) *mInitializationContextMockError {
	if mmError.mock.inspectFuncError != nil {
		mmError.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.Error")
	}

	mmError.mock.inspectFuncError = f

	return mmError
}

// Return sets up results that will be returned by InitializationContext.Error
func (mmError *mInitializationContextMockError) Return(s1 StateUpdate) *InitializationContextMock {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("InitializationContextMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &InitializationContextMockErrorExpectation{mock: mmError.mock}
	}
	mmError.defaultExpectation.results = &InitializationContextMockErrorResults{s1}
	return mmError.mock
}

//Set uses given function f to mock the InitializationContext.Error method
func (mmError *mInitializationContextMockError) Set(f func(e1 error) (s1 StateUpdate)) *InitializationContextMock {
	if mmError.defaultExpectation != nil {
		mmError.mock.t.Fatalf("Default expectation is already set for the InitializationContext.Error method")
	}

	if len(mmError.expectations) > 0 {
		mmError.mock.t.Fatalf("Some expectations are already set for the InitializationContext.Error method")
	}

	mmError.mock.funcError = f
	return mmError.mock
}

// When sets expectation for the InitializationContext.Error which will trigger the result defined by the following
// Then helper
func (mmError *mInitializationContextMockError) When(e1 error) *InitializationContextMockErrorExpectation {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("InitializationContextMock.Error mock is already set by Set")
	}

	expectation := &InitializationContextMockErrorExpectation{
		mock:   mmError.mock,
		params: &InitializationContextMockErrorParams{e1},
	}
	mmError.expectations = append(mmError.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.Error return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockErrorExpectation) Then(s1 StateUpdate) *InitializationContextMock {
	e.results = &InitializationContextMockErrorResults{s1}
	return e.mock
}

// Error implements InitializationContext
func (mmError *InitializationContextMock) Error(e1 error) (s1 StateUpdate) {
	mm_atomic.AddUint64(&mmError.beforeErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmError.afterErrorCounter, 1)

	if mmError.inspectFuncError != nil {
		mmError.inspectFuncError(e1)
	}

	mm_params := &InitializationContextMockErrorParams{e1}

	// Record call args
	mmError.ErrorMock.mutex.Lock()
	mmError.ErrorMock.callArgs = append(mmError.ErrorMock.callArgs, mm_params)
	mmError.ErrorMock.mutex.Unlock()

	for _, e := range mmError.ErrorMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmError.ErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmError.ErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmError.ErrorMock.defaultExpectation.params
		mm_got := InitializationContextMockErrorParams{e1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmError.t.Errorf("InitializationContextMock.Error got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmError.ErrorMock.defaultExpectation.results
		if mm_results == nil {
			mmError.t.Fatal("No results are set for the InitializationContextMock.Error")
		}
		return (*mm_results).s1
	}
	if mmError.funcError != nil {
		return mmError.funcError(e1)
	}
	mmError.t.Fatalf("Unexpected call to InitializationContextMock.Error. %v", e1)
	return
}

// ErrorAfterCounter returns a count of finished InitializationContextMock.Error invocations
func (mmError *InitializationContextMock) ErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.afterErrorCounter)
}

// ErrorBeforeCounter returns a count of InitializationContextMock.Error invocations
func (mmError *InitializationContextMock) ErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.beforeErrorCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.Error.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmError *mInitializationContextMockError) Calls() []*InitializationContextMockErrorParams {
	mmError.mutex.RLock()

	argCopy := make([]*InitializationContextMockErrorParams, len(mmError.callArgs))
	copy(argCopy, mmError.callArgs)

	mmError.mutex.RUnlock()

	return argCopy
}

// MinimockErrorDone returns true if the count of the Error invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockErrorDone() bool {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	return true
}

// MinimockErrorInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockErrorInspect() {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.Error with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		if m.ErrorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.Error")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.Error with params: %#v", *m.ErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.Error")
	}
}

type mInitializationContextMockErrorf struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockErrorfExpectation
	expectations       []*InitializationContextMockErrorfExpectation

	callArgs []*InitializationContextMockErrorfParams
	mutex    sync.RWMutex
}

// InitializationContextMockErrorfExpectation specifies expectation struct of the InitializationContext.Errorf
type InitializationContextMockErrorfExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockErrorfParams
	results *InitializationContextMockErrorfResults
	Counter uint64
}

// InitializationContextMockErrorfParams contains parameters of the InitializationContext.Errorf
type InitializationContextMockErrorfParams struct {
	msg string
	a   []interface{}
}

// InitializationContextMockErrorfResults contains results of the InitializationContext.Errorf
type InitializationContextMockErrorfResults struct {
	s1 StateUpdate
}

// Expect sets up expected params for InitializationContext.Errorf
func (mmErrorf *mInitializationContextMockErrorf) Expect(msg string, a ...interface{}) *mInitializationContextMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("InitializationContextMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &InitializationContextMockErrorfExpectation{}
	}

	mmErrorf.defaultExpectation.params = &InitializationContextMockErrorfParams{msg, a}
	for _, e := range mmErrorf.expectations {
		if minimock.Equal(e.params, mmErrorf.defaultExpectation.params) {
			mmErrorf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmErrorf.defaultExpectation.params)
		}
	}

	return mmErrorf
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.Errorf
func (mmErrorf *mInitializationContextMockErrorf) Inspect(f func(msg string, a ...interface{})) *mInitializationContextMockErrorf {
	if mmErrorf.mock.inspectFuncErrorf != nil {
		mmErrorf.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.Errorf")
	}

	mmErrorf.mock.inspectFuncErrorf = f

	return mmErrorf
}

// Return sets up results that will be returned by InitializationContext.Errorf
func (mmErrorf *mInitializationContextMockErrorf) Return(s1 StateUpdate) *InitializationContextMock {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("InitializationContextMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &InitializationContextMockErrorfExpectation{mock: mmErrorf.mock}
	}
	mmErrorf.defaultExpectation.results = &InitializationContextMockErrorfResults{s1}
	return mmErrorf.mock
}

//Set uses given function f to mock the InitializationContext.Errorf method
func (mmErrorf *mInitializationContextMockErrorf) Set(f func(msg string, a ...interface{}) (s1 StateUpdate)) *InitializationContextMock {
	if mmErrorf.defaultExpectation != nil {
		mmErrorf.mock.t.Fatalf("Default expectation is already set for the InitializationContext.Errorf method")
	}

	if len(mmErrorf.expectations) > 0 {
		mmErrorf.mock.t.Fatalf("Some expectations are already set for the InitializationContext.Errorf method")
	}

	mmErrorf.mock.funcErrorf = f
	return mmErrorf.mock
}

// When sets expectation for the InitializationContext.Errorf which will trigger the result defined by the following
// Then helper
func (mmErrorf *mInitializationContextMockErrorf) When(msg string, a ...interface{}) *InitializationContextMockErrorfExpectation {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("InitializationContextMock.Errorf mock is already set by Set")
	}

	expectation := &InitializationContextMockErrorfExpectation{
		mock:   mmErrorf.mock,
		params: &InitializationContextMockErrorfParams{msg, a},
	}
	mmErrorf.expectations = append(mmErrorf.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.Errorf return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockErrorfExpectation) Then(s1 StateUpdate) *InitializationContextMock {
	e.results = &InitializationContextMockErrorfResults{s1}
	return e.mock
}

// Errorf implements InitializationContext
func (mmErrorf *InitializationContextMock) Errorf(msg string, a ...interface{}) (s1 StateUpdate) {
	mm_atomic.AddUint64(&mmErrorf.beforeErrorfCounter, 1)
	defer mm_atomic.AddUint64(&mmErrorf.afterErrorfCounter, 1)

	if mmErrorf.inspectFuncErrorf != nil {
		mmErrorf.inspectFuncErrorf(msg, a...)
	}

	mm_params := &InitializationContextMockErrorfParams{msg, a}

	// Record call args
	mmErrorf.ErrorfMock.mutex.Lock()
	mmErrorf.ErrorfMock.callArgs = append(mmErrorf.ErrorfMock.callArgs, mm_params)
	mmErrorf.ErrorfMock.mutex.Unlock()

	for _, e := range mmErrorf.ErrorfMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmErrorf.ErrorfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmErrorf.ErrorfMock.defaultExpectation.Counter, 1)
		mm_want := mmErrorf.ErrorfMock.defaultExpectation.params
		mm_got := InitializationContextMockErrorfParams{msg, a}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmErrorf.t.Errorf("InitializationContextMock.Errorf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmErrorf.ErrorfMock.defaultExpectation.results
		if mm_results == nil {
			mmErrorf.t.Fatal("No results are set for the InitializationContextMock.Errorf")
		}
		return (*mm_results).s1
	}
	if mmErrorf.funcErrorf != nil {
		return mmErrorf.funcErrorf(msg, a...)
	}
	mmErrorf.t.Fatalf("Unexpected call to InitializationContextMock.Errorf. %v %v", msg, a)
	return
}

// ErrorfAfterCounter returns a count of finished InitializationContextMock.Errorf invocations
func (mmErrorf *InitializationContextMock) ErrorfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.afterErrorfCounter)
}

// ErrorfBeforeCounter returns a count of InitializationContextMock.Errorf invocations
func (mmErrorf *InitializationContextMock) ErrorfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.beforeErrorfCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.Errorf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmErrorf *mInitializationContextMockErrorf) Calls() []*InitializationContextMockErrorfParams {
	mmErrorf.mutex.RLock()

	argCopy := make([]*InitializationContextMockErrorfParams, len(mmErrorf.callArgs))
	copy(argCopy, mmErrorf.callArgs)

	mmErrorf.mutex.RUnlock()

	return argCopy
}

// MinimockErrorfDone returns true if the count of the Errorf invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockErrorfDone() bool {
	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErrorf != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		return false
	}
	return true
}

// MinimockErrorfInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockErrorfInspect() {
	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.Errorf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		if m.ErrorfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.Errorf")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.Errorf with params: %#v", *m.ErrorfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErrorf != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.Errorf")
	}
}

type mInitializationContextMockGetContext struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockGetContextExpectation
	expectations       []*InitializationContextMockGetContextExpectation
}

// InitializationContextMockGetContextExpectation specifies expectation struct of the InitializationContext.GetContext
type InitializationContextMockGetContextExpectation struct {
	mock *InitializationContextMock

	results *InitializationContextMockGetContextResults
	Counter uint64
}

// InitializationContextMockGetContextResults contains results of the InitializationContext.GetContext
type InitializationContextMockGetContextResults struct {
	c1 context.Context
}

// Expect sets up expected params for InitializationContext.GetContext
func (mmGetContext *mInitializationContextMockGetContext) Expect() *mInitializationContextMockGetContext {
	if mmGetContext.mock.funcGetContext != nil {
		mmGetContext.mock.t.Fatalf("InitializationContextMock.GetContext mock is already set by Set")
	}

	if mmGetContext.defaultExpectation == nil {
		mmGetContext.defaultExpectation = &InitializationContextMockGetContextExpectation{}
	}

	return mmGetContext
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.GetContext
func (mmGetContext *mInitializationContextMockGetContext) Inspect(f func()) *mInitializationContextMockGetContext {
	if mmGetContext.mock.inspectFuncGetContext != nil {
		mmGetContext.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.GetContext")
	}

	mmGetContext.mock.inspectFuncGetContext = f

	return mmGetContext
}

// Return sets up results that will be returned by InitializationContext.GetContext
func (mmGetContext *mInitializationContextMockGetContext) Return(c1 context.Context) *InitializationContextMock {
	if mmGetContext.mock.funcGetContext != nil {
		mmGetContext.mock.t.Fatalf("InitializationContextMock.GetContext mock is already set by Set")
	}

	if mmGetContext.defaultExpectation == nil {
		mmGetContext.defaultExpectation = &InitializationContextMockGetContextExpectation{mock: mmGetContext.mock}
	}
	mmGetContext.defaultExpectation.results = &InitializationContextMockGetContextResults{c1}
	return mmGetContext.mock
}

//Set uses given function f to mock the InitializationContext.GetContext method
func (mmGetContext *mInitializationContextMockGetContext) Set(f func() (c1 context.Context)) *InitializationContextMock {
	if mmGetContext.defaultExpectation != nil {
		mmGetContext.mock.t.Fatalf("Default expectation is already set for the InitializationContext.GetContext method")
	}

	if len(mmGetContext.expectations) > 0 {
		mmGetContext.mock.t.Fatalf("Some expectations are already set for the InitializationContext.GetContext method")
	}

	mmGetContext.mock.funcGetContext = f
	return mmGetContext.mock
}

// GetContext implements InitializationContext
func (mmGetContext *InitializationContextMock) GetContext() (c1 context.Context) {
	mm_atomic.AddUint64(&mmGetContext.beforeGetContextCounter, 1)
	defer mm_atomic.AddUint64(&mmGetContext.afterGetContextCounter, 1)

	if mmGetContext.inspectFuncGetContext != nil {
		mmGetContext.inspectFuncGetContext()
	}

	if mmGetContext.GetContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetContext.GetContextMock.defaultExpectation.Counter, 1)

		mm_results := mmGetContext.GetContextMock.defaultExpectation.results
		if mm_results == nil {
			mmGetContext.t.Fatal("No results are set for the InitializationContextMock.GetContext")
		}
		return (*mm_results).c1
	}
	if mmGetContext.funcGetContext != nil {
		return mmGetContext.funcGetContext()
	}
	mmGetContext.t.Fatalf("Unexpected call to InitializationContextMock.GetContext.")
	return
}

// GetContextAfterCounter returns a count of finished InitializationContextMock.GetContext invocations
func (mmGetContext *InitializationContextMock) GetContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContext.afterGetContextCounter)
}

// GetContextBeforeCounter returns a count of InitializationContextMock.GetContext invocations
func (mmGetContext *InitializationContextMock) GetContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContext.beforeGetContextCounter)
}

// MinimockGetContextDone returns true if the count of the GetContext invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockGetContextDone() bool {
	for _, e := range m.GetContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetContext != nil && mm_atomic.LoadUint64(&m.afterGetContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetContextInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockGetContextInspect() {
	for _, e := range m.GetContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to InitializationContextMock.GetContext")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetContextCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.GetContext")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetContext != nil && mm_atomic.LoadUint64(&m.afterGetContextCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.GetContext")
	}
}

type mInitializationContextMockGetDefaultTerminationResult struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockGetDefaultTerminationResultExpectation
	expectations       []*InitializationContextMockGetDefaultTerminationResultExpectation
}

// InitializationContextMockGetDefaultTerminationResultExpectation specifies expectation struct of the InitializationContext.GetDefaultTerminationResult
type InitializationContextMockGetDefaultTerminationResultExpectation struct {
	mock *InitializationContextMock

	results *InitializationContextMockGetDefaultTerminationResultResults
	Counter uint64
}

// InitializationContextMockGetDefaultTerminationResultResults contains results of the InitializationContext.GetDefaultTerminationResult
type InitializationContextMockGetDefaultTerminationResultResults struct {
	p1 interface{}
}

// Expect sets up expected params for InitializationContext.GetDefaultTerminationResult
func (mmGetDefaultTerminationResult *mInitializationContextMockGetDefaultTerminationResult) Expect() *mInitializationContextMockGetDefaultTerminationResult {
	if mmGetDefaultTerminationResult.mock.funcGetDefaultTerminationResult != nil {
		mmGetDefaultTerminationResult.mock.t.Fatalf("InitializationContextMock.GetDefaultTerminationResult mock is already set by Set")
	}

	if mmGetDefaultTerminationResult.defaultExpectation == nil {
		mmGetDefaultTerminationResult.defaultExpectation = &InitializationContextMockGetDefaultTerminationResultExpectation{}
	}

	return mmGetDefaultTerminationResult
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.GetDefaultTerminationResult
func (mmGetDefaultTerminationResult *mInitializationContextMockGetDefaultTerminationResult) Inspect(f func()) *mInitializationContextMockGetDefaultTerminationResult {
	if mmGetDefaultTerminationResult.mock.inspectFuncGetDefaultTerminationResult != nil {
		mmGetDefaultTerminationResult.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.GetDefaultTerminationResult")
	}

	mmGetDefaultTerminationResult.mock.inspectFuncGetDefaultTerminationResult = f

	return mmGetDefaultTerminationResult
}

// Return sets up results that will be returned by InitializationContext.GetDefaultTerminationResult
func (mmGetDefaultTerminationResult *mInitializationContextMockGetDefaultTerminationResult) Return(p1 interface{}) *InitializationContextMock {
	if mmGetDefaultTerminationResult.mock.funcGetDefaultTerminationResult != nil {
		mmGetDefaultTerminationResult.mock.t.Fatalf("InitializationContextMock.GetDefaultTerminationResult mock is already set by Set")
	}

	if mmGetDefaultTerminationResult.defaultExpectation == nil {
		mmGetDefaultTerminationResult.defaultExpectation = &InitializationContextMockGetDefaultTerminationResultExpectation{mock: mmGetDefaultTerminationResult.mock}
	}
	mmGetDefaultTerminationResult.defaultExpectation.results = &InitializationContextMockGetDefaultTerminationResultResults{p1}
	return mmGetDefaultTerminationResult.mock
}

//Set uses given function f to mock the InitializationContext.GetDefaultTerminationResult method
func (mmGetDefaultTerminationResult *mInitializationContextMockGetDefaultTerminationResult) Set(f func() (p1 interface{})) *InitializationContextMock {
	if mmGetDefaultTerminationResult.defaultExpectation != nil {
		mmGetDefaultTerminationResult.mock.t.Fatalf("Default expectation is already set for the InitializationContext.GetDefaultTerminationResult method")
	}

	if len(mmGetDefaultTerminationResult.expectations) > 0 {
		mmGetDefaultTerminationResult.mock.t.Fatalf("Some expectations are already set for the InitializationContext.GetDefaultTerminationResult method")
	}

	mmGetDefaultTerminationResult.mock.funcGetDefaultTerminationResult = f
	return mmGetDefaultTerminationResult.mock
}

// GetDefaultTerminationResult implements InitializationContext
func (mmGetDefaultTerminationResult *InitializationContextMock) GetDefaultTerminationResult() (p1 interface{}) {
	mm_atomic.AddUint64(&mmGetDefaultTerminationResult.beforeGetDefaultTerminationResultCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDefaultTerminationResult.afterGetDefaultTerminationResultCounter, 1)

	if mmGetDefaultTerminationResult.inspectFuncGetDefaultTerminationResult != nil {
		mmGetDefaultTerminationResult.inspectFuncGetDefaultTerminationResult()
	}

	if mmGetDefaultTerminationResult.GetDefaultTerminationResultMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDefaultTerminationResult.GetDefaultTerminationResultMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDefaultTerminationResult.GetDefaultTerminationResultMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDefaultTerminationResult.t.Fatal("No results are set for the InitializationContextMock.GetDefaultTerminationResult")
		}
		return (*mm_results).p1
	}
	if mmGetDefaultTerminationResult.funcGetDefaultTerminationResult != nil {
		return mmGetDefaultTerminationResult.funcGetDefaultTerminationResult()
	}
	mmGetDefaultTerminationResult.t.Fatalf("Unexpected call to InitializationContextMock.GetDefaultTerminationResult.")
	return
}

// GetDefaultTerminationResultAfterCounter returns a count of finished InitializationContextMock.GetDefaultTerminationResult invocations
func (mmGetDefaultTerminationResult *InitializationContextMock) GetDefaultTerminationResultAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDefaultTerminationResult.afterGetDefaultTerminationResultCounter)
}

// GetDefaultTerminationResultBeforeCounter returns a count of InitializationContextMock.GetDefaultTerminationResult invocations
func (mmGetDefaultTerminationResult *InitializationContextMock) GetDefaultTerminationResultBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDefaultTerminationResult.beforeGetDefaultTerminationResultCounter)
}

// MinimockGetDefaultTerminationResultDone returns true if the count of the GetDefaultTerminationResult invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockGetDefaultTerminationResultDone() bool {
	for _, e := range m.GetDefaultTerminationResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDefaultTerminationResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDefaultTerminationResultCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDefaultTerminationResult != nil && mm_atomic.LoadUint64(&m.afterGetDefaultTerminationResultCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDefaultTerminationResultInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockGetDefaultTerminationResultInspect() {
	for _, e := range m.GetDefaultTerminationResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to InitializationContextMock.GetDefaultTerminationResult")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDefaultTerminationResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDefaultTerminationResultCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.GetDefaultTerminationResult")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDefaultTerminationResult != nil && mm_atomic.LoadUint64(&m.afterGetDefaultTerminationResultCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.GetDefaultTerminationResult")
	}
}

type mInitializationContextMockGetPublished struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockGetPublishedExpectation
	expectations       []*InitializationContextMockGetPublishedExpectation

	callArgs []*InitializationContextMockGetPublishedParams
	mutex    sync.RWMutex
}

// InitializationContextMockGetPublishedExpectation specifies expectation struct of the InitializationContext.GetPublished
type InitializationContextMockGetPublishedExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockGetPublishedParams
	results *InitializationContextMockGetPublishedResults
	Counter uint64
}

// InitializationContextMockGetPublishedParams contains parameters of the InitializationContext.GetPublished
type InitializationContextMockGetPublishedParams struct {
	key interface{}
}

// InitializationContextMockGetPublishedResults contains results of the InitializationContext.GetPublished
type InitializationContextMockGetPublishedResults struct {
	p1 interface{}
}

// Expect sets up expected params for InitializationContext.GetPublished
func (mmGetPublished *mInitializationContextMockGetPublished) Expect(key interface{}) *mInitializationContextMockGetPublished {
	if mmGetPublished.mock.funcGetPublished != nil {
		mmGetPublished.mock.t.Fatalf("InitializationContextMock.GetPublished mock is already set by Set")
	}

	if mmGetPublished.defaultExpectation == nil {
		mmGetPublished.defaultExpectation = &InitializationContextMockGetPublishedExpectation{}
	}

	mmGetPublished.defaultExpectation.params = &InitializationContextMockGetPublishedParams{key}
	for _, e := range mmGetPublished.expectations {
		if minimock.Equal(e.params, mmGetPublished.defaultExpectation.params) {
			mmGetPublished.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPublished.defaultExpectation.params)
		}
	}

	return mmGetPublished
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.GetPublished
func (mmGetPublished *mInitializationContextMockGetPublished) Inspect(f func(key interface{})) *mInitializationContextMockGetPublished {
	if mmGetPublished.mock.inspectFuncGetPublished != nil {
		mmGetPublished.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.GetPublished")
	}

	mmGetPublished.mock.inspectFuncGetPublished = f

	return mmGetPublished
}

// Return sets up results that will be returned by InitializationContext.GetPublished
func (mmGetPublished *mInitializationContextMockGetPublished) Return(p1 interface{}) *InitializationContextMock {
	if mmGetPublished.mock.funcGetPublished != nil {
		mmGetPublished.mock.t.Fatalf("InitializationContextMock.GetPublished mock is already set by Set")
	}

	if mmGetPublished.defaultExpectation == nil {
		mmGetPublished.defaultExpectation = &InitializationContextMockGetPublishedExpectation{mock: mmGetPublished.mock}
	}
	mmGetPublished.defaultExpectation.results = &InitializationContextMockGetPublishedResults{p1}
	return mmGetPublished.mock
}

//Set uses given function f to mock the InitializationContext.GetPublished method
func (mmGetPublished *mInitializationContextMockGetPublished) Set(f func(key interface{}) (p1 interface{})) *InitializationContextMock {
	if mmGetPublished.defaultExpectation != nil {
		mmGetPublished.mock.t.Fatalf("Default expectation is already set for the InitializationContext.GetPublished method")
	}

	if len(mmGetPublished.expectations) > 0 {
		mmGetPublished.mock.t.Fatalf("Some expectations are already set for the InitializationContext.GetPublished method")
	}

	mmGetPublished.mock.funcGetPublished = f
	return mmGetPublished.mock
}

// When sets expectation for the InitializationContext.GetPublished which will trigger the result defined by the following
// Then helper
func (mmGetPublished *mInitializationContextMockGetPublished) When(key interface{}) *InitializationContextMockGetPublishedExpectation {
	if mmGetPublished.mock.funcGetPublished != nil {
		mmGetPublished.mock.t.Fatalf("InitializationContextMock.GetPublished mock is already set by Set")
	}

	expectation := &InitializationContextMockGetPublishedExpectation{
		mock:   mmGetPublished.mock,
		params: &InitializationContextMockGetPublishedParams{key},
	}
	mmGetPublished.expectations = append(mmGetPublished.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.GetPublished return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockGetPublishedExpectation) Then(p1 interface{}) *InitializationContextMock {
	e.results = &InitializationContextMockGetPublishedResults{p1}
	return e.mock
}

// GetPublished implements InitializationContext
func (mmGetPublished *InitializationContextMock) GetPublished(key interface{}) (p1 interface{}) {
	mm_atomic.AddUint64(&mmGetPublished.beforeGetPublishedCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPublished.afterGetPublishedCounter, 1)

	if mmGetPublished.inspectFuncGetPublished != nil {
		mmGetPublished.inspectFuncGetPublished(key)
	}

	mm_params := &InitializationContextMockGetPublishedParams{key}

	// Record call args
	mmGetPublished.GetPublishedMock.mutex.Lock()
	mmGetPublished.GetPublishedMock.callArgs = append(mmGetPublished.GetPublishedMock.callArgs, mm_params)
	mmGetPublished.GetPublishedMock.mutex.Unlock()

	for _, e := range mmGetPublished.GetPublishedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1
		}
	}

	if mmGetPublished.GetPublishedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPublished.GetPublishedMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPublished.GetPublishedMock.defaultExpectation.params
		mm_got := InitializationContextMockGetPublishedParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPublished.t.Errorf("InitializationContextMock.GetPublished got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPublished.GetPublishedMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPublished.t.Fatal("No results are set for the InitializationContextMock.GetPublished")
		}
		return (*mm_results).p1
	}
	if mmGetPublished.funcGetPublished != nil {
		return mmGetPublished.funcGetPublished(key)
	}
	mmGetPublished.t.Fatalf("Unexpected call to InitializationContextMock.GetPublished. %v", key)
	return
}

// GetPublishedAfterCounter returns a count of finished InitializationContextMock.GetPublished invocations
func (mmGetPublished *InitializationContextMock) GetPublishedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublished.afterGetPublishedCounter)
}

// GetPublishedBeforeCounter returns a count of InitializationContextMock.GetPublished invocations
func (mmGetPublished *InitializationContextMock) GetPublishedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublished.beforeGetPublishedCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.GetPublished.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPublished *mInitializationContextMockGetPublished) Calls() []*InitializationContextMockGetPublishedParams {
	mmGetPublished.mutex.RLock()

	argCopy := make([]*InitializationContextMockGetPublishedParams, len(mmGetPublished.callArgs))
	copy(argCopy, mmGetPublished.callArgs)

	mmGetPublished.mutex.RUnlock()

	return argCopy
}

// MinimockGetPublishedDone returns true if the count of the GetPublished invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockGetPublishedDone() bool {
	for _, e := range m.GetPublishedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublished != nil && mm_atomic.LoadUint64(&m.afterGetPublishedCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPublishedInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockGetPublishedInspect() {
	for _, e := range m.GetPublishedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.GetPublished with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedCounter) < 1 {
		if m.GetPublishedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.GetPublished")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.GetPublished with params: %#v", *m.GetPublishedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublished != nil && mm_atomic.LoadUint64(&m.afterGetPublishedCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.GetPublished")
	}
}

type mInitializationContextMockGetPublishedGlobalAlias struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockGetPublishedGlobalAliasExpectation
	expectations       []*InitializationContextMockGetPublishedGlobalAliasExpectation

	callArgs []*InitializationContextMockGetPublishedGlobalAliasParams
	mutex    sync.RWMutex
}

// InitializationContextMockGetPublishedGlobalAliasExpectation specifies expectation struct of the InitializationContext.GetPublishedGlobalAlias
type InitializationContextMockGetPublishedGlobalAliasExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockGetPublishedGlobalAliasParams
	results *InitializationContextMockGetPublishedGlobalAliasResults
	Counter uint64
}

// InitializationContextMockGetPublishedGlobalAliasParams contains parameters of the InitializationContext.GetPublishedGlobalAlias
type InitializationContextMockGetPublishedGlobalAliasParams struct {
	key interface{}
}

// InitializationContextMockGetPublishedGlobalAliasResults contains results of the InitializationContext.GetPublishedGlobalAlias
type InitializationContextMockGetPublishedGlobalAliasResults struct {
	s1 SlotLink
}

// Expect sets up expected params for InitializationContext.GetPublishedGlobalAlias
func (mmGetPublishedGlobalAlias *mInitializationContextMockGetPublishedGlobalAlias) Expect(key interface{}) *mInitializationContextMockGetPublishedGlobalAlias {
	if mmGetPublishedGlobalAlias.mock.funcGetPublishedGlobalAlias != nil {
		mmGetPublishedGlobalAlias.mock.t.Fatalf("InitializationContextMock.GetPublishedGlobalAlias mock is already set by Set")
	}

	if mmGetPublishedGlobalAlias.defaultExpectation == nil {
		mmGetPublishedGlobalAlias.defaultExpectation = &InitializationContextMockGetPublishedGlobalAliasExpectation{}
	}

	mmGetPublishedGlobalAlias.defaultExpectation.params = &InitializationContextMockGetPublishedGlobalAliasParams{key}
	for _, e := range mmGetPublishedGlobalAlias.expectations {
		if minimock.Equal(e.params, mmGetPublishedGlobalAlias.defaultExpectation.params) {
			mmGetPublishedGlobalAlias.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPublishedGlobalAlias.defaultExpectation.params)
		}
	}

	return mmGetPublishedGlobalAlias
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.GetPublishedGlobalAlias
func (mmGetPublishedGlobalAlias *mInitializationContextMockGetPublishedGlobalAlias) Inspect(f func(key interface{})) *mInitializationContextMockGetPublishedGlobalAlias {
	if mmGetPublishedGlobalAlias.mock.inspectFuncGetPublishedGlobalAlias != nil {
		mmGetPublishedGlobalAlias.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.GetPublishedGlobalAlias")
	}

	mmGetPublishedGlobalAlias.mock.inspectFuncGetPublishedGlobalAlias = f

	return mmGetPublishedGlobalAlias
}

// Return sets up results that will be returned by InitializationContext.GetPublishedGlobalAlias
func (mmGetPublishedGlobalAlias *mInitializationContextMockGetPublishedGlobalAlias) Return(s1 SlotLink) *InitializationContextMock {
	if mmGetPublishedGlobalAlias.mock.funcGetPublishedGlobalAlias != nil {
		mmGetPublishedGlobalAlias.mock.t.Fatalf("InitializationContextMock.GetPublishedGlobalAlias mock is already set by Set")
	}

	if mmGetPublishedGlobalAlias.defaultExpectation == nil {
		mmGetPublishedGlobalAlias.defaultExpectation = &InitializationContextMockGetPublishedGlobalAliasExpectation{mock: mmGetPublishedGlobalAlias.mock}
	}
	mmGetPublishedGlobalAlias.defaultExpectation.results = &InitializationContextMockGetPublishedGlobalAliasResults{s1}
	return mmGetPublishedGlobalAlias.mock
}

//Set uses given function f to mock the InitializationContext.GetPublishedGlobalAlias method
func (mmGetPublishedGlobalAlias *mInitializationContextMockGetPublishedGlobalAlias) Set(f func(key interface{}) (s1 SlotLink)) *InitializationContextMock {
	if mmGetPublishedGlobalAlias.defaultExpectation != nil {
		mmGetPublishedGlobalAlias.mock.t.Fatalf("Default expectation is already set for the InitializationContext.GetPublishedGlobalAlias method")
	}

	if len(mmGetPublishedGlobalAlias.expectations) > 0 {
		mmGetPublishedGlobalAlias.mock.t.Fatalf("Some expectations are already set for the InitializationContext.GetPublishedGlobalAlias method")
	}

	mmGetPublishedGlobalAlias.mock.funcGetPublishedGlobalAlias = f
	return mmGetPublishedGlobalAlias.mock
}

// When sets expectation for the InitializationContext.GetPublishedGlobalAlias which will trigger the result defined by the following
// Then helper
func (mmGetPublishedGlobalAlias *mInitializationContextMockGetPublishedGlobalAlias) When(key interface{}) *InitializationContextMockGetPublishedGlobalAliasExpectation {
	if mmGetPublishedGlobalAlias.mock.funcGetPublishedGlobalAlias != nil {
		mmGetPublishedGlobalAlias.mock.t.Fatalf("InitializationContextMock.GetPublishedGlobalAlias mock is already set by Set")
	}

	expectation := &InitializationContextMockGetPublishedGlobalAliasExpectation{
		mock:   mmGetPublishedGlobalAlias.mock,
		params: &InitializationContextMockGetPublishedGlobalAliasParams{key},
	}
	mmGetPublishedGlobalAlias.expectations = append(mmGetPublishedGlobalAlias.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.GetPublishedGlobalAlias return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockGetPublishedGlobalAliasExpectation) Then(s1 SlotLink) *InitializationContextMock {
	e.results = &InitializationContextMockGetPublishedGlobalAliasResults{s1}
	return e.mock
}

// GetPublishedGlobalAlias implements InitializationContext
func (mmGetPublishedGlobalAlias *InitializationContextMock) GetPublishedGlobalAlias(key interface{}) (s1 SlotLink) {
	mm_atomic.AddUint64(&mmGetPublishedGlobalAlias.beforeGetPublishedGlobalAliasCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPublishedGlobalAlias.afterGetPublishedGlobalAliasCounter, 1)

	if mmGetPublishedGlobalAlias.inspectFuncGetPublishedGlobalAlias != nil {
		mmGetPublishedGlobalAlias.inspectFuncGetPublishedGlobalAlias(key)
	}

	mm_params := &InitializationContextMockGetPublishedGlobalAliasParams{key}

	// Record call args
	mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.mutex.Lock()
	mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.callArgs = append(mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.callArgs, mm_params)
	mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.mutex.Unlock()

	for _, e := range mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.defaultExpectation.params
		mm_got := InitializationContextMockGetPublishedGlobalAliasParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPublishedGlobalAlias.t.Errorf("InitializationContextMock.GetPublishedGlobalAlias got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPublishedGlobalAlias.t.Fatal("No results are set for the InitializationContextMock.GetPublishedGlobalAlias")
		}
		return (*mm_results).s1
	}
	if mmGetPublishedGlobalAlias.funcGetPublishedGlobalAlias != nil {
		return mmGetPublishedGlobalAlias.funcGetPublishedGlobalAlias(key)
	}
	mmGetPublishedGlobalAlias.t.Fatalf("Unexpected call to InitializationContextMock.GetPublishedGlobalAlias. %v", key)
	return
}

// GetPublishedGlobalAliasAfterCounter returns a count of finished InitializationContextMock.GetPublishedGlobalAlias invocations
func (mmGetPublishedGlobalAlias *InitializationContextMock) GetPublishedGlobalAliasAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublishedGlobalAlias.afterGetPublishedGlobalAliasCounter)
}

// GetPublishedGlobalAliasBeforeCounter returns a count of InitializationContextMock.GetPublishedGlobalAlias invocations
func (mmGetPublishedGlobalAlias *InitializationContextMock) GetPublishedGlobalAliasBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublishedGlobalAlias.beforeGetPublishedGlobalAliasCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.GetPublishedGlobalAlias.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPublishedGlobalAlias *mInitializationContextMockGetPublishedGlobalAlias) Calls() []*InitializationContextMockGetPublishedGlobalAliasParams {
	mmGetPublishedGlobalAlias.mutex.RLock()

	argCopy := make([]*InitializationContextMockGetPublishedGlobalAliasParams, len(mmGetPublishedGlobalAlias.callArgs))
	copy(argCopy, mmGetPublishedGlobalAlias.callArgs)

	mmGetPublishedGlobalAlias.mutex.RUnlock()

	return argCopy
}

// MinimockGetPublishedGlobalAliasDone returns true if the count of the GetPublishedGlobalAlias invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockGetPublishedGlobalAliasDone() bool {
	for _, e := range m.GetPublishedGlobalAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedGlobalAliasMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublishedGlobalAlias != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPublishedGlobalAliasInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockGetPublishedGlobalAliasInspect() {
	for _, e := range m.GetPublishedGlobalAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.GetPublishedGlobalAlias with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedGlobalAliasMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasCounter) < 1 {
		if m.GetPublishedGlobalAliasMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.GetPublishedGlobalAlias")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.GetPublishedGlobalAlias with params: %#v", *m.GetPublishedGlobalAliasMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublishedGlobalAlias != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.GetPublishedGlobalAlias")
	}
}

type mInitializationContextMockGetPublishedGlobalAliasAndBargeIn struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockGetPublishedGlobalAliasAndBargeInExpectation
	expectations       []*InitializationContextMockGetPublishedGlobalAliasAndBargeInExpectation

	callArgs []*InitializationContextMockGetPublishedGlobalAliasAndBargeInParams
	mutex    sync.RWMutex
}

// InitializationContextMockGetPublishedGlobalAliasAndBargeInExpectation specifies expectation struct of the InitializationContext.GetPublishedGlobalAliasAndBargeIn
type InitializationContextMockGetPublishedGlobalAliasAndBargeInExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockGetPublishedGlobalAliasAndBargeInParams
	results *InitializationContextMockGetPublishedGlobalAliasAndBargeInResults
	Counter uint64
}

// InitializationContextMockGetPublishedGlobalAliasAndBargeInParams contains parameters of the InitializationContext.GetPublishedGlobalAliasAndBargeIn
type InitializationContextMockGetPublishedGlobalAliasAndBargeInParams struct {
	key interface{}
}

// InitializationContextMockGetPublishedGlobalAliasAndBargeInResults contains results of the InitializationContext.GetPublishedGlobalAliasAndBargeIn
type InitializationContextMockGetPublishedGlobalAliasAndBargeInResults struct {
	s1 SlotLink
	b1 BargeInHolder
}

// Expect sets up expected params for InitializationContext.GetPublishedGlobalAliasAndBargeIn
func (mmGetPublishedGlobalAliasAndBargeIn *mInitializationContextMockGetPublishedGlobalAliasAndBargeIn) Expect(key interface{}) *mInitializationContextMockGetPublishedGlobalAliasAndBargeIn {
	if mmGetPublishedGlobalAliasAndBargeIn.mock.funcGetPublishedGlobalAliasAndBargeIn != nil {
		mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("InitializationContextMock.GetPublishedGlobalAliasAndBargeIn mock is already set by Set")
	}

	if mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation == nil {
		mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation = &InitializationContextMockGetPublishedGlobalAliasAndBargeInExpectation{}
	}

	mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation.params = &InitializationContextMockGetPublishedGlobalAliasAndBargeInParams{key}
	for _, e := range mmGetPublishedGlobalAliasAndBargeIn.expectations {
		if minimock.Equal(e.params, mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation.params) {
			mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation.params)
		}
	}

	return mmGetPublishedGlobalAliasAndBargeIn
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.GetPublishedGlobalAliasAndBargeIn
func (mmGetPublishedGlobalAliasAndBargeIn *mInitializationContextMockGetPublishedGlobalAliasAndBargeIn) Inspect(f func(key interface{})) *mInitializationContextMockGetPublishedGlobalAliasAndBargeIn {
	if mmGetPublishedGlobalAliasAndBargeIn.mock.inspectFuncGetPublishedGlobalAliasAndBargeIn != nil {
		mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.GetPublishedGlobalAliasAndBargeIn")
	}

	mmGetPublishedGlobalAliasAndBargeIn.mock.inspectFuncGetPublishedGlobalAliasAndBargeIn = f

	return mmGetPublishedGlobalAliasAndBargeIn
}

// Return sets up results that will be returned by InitializationContext.GetPublishedGlobalAliasAndBargeIn
func (mmGetPublishedGlobalAliasAndBargeIn *mInitializationContextMockGetPublishedGlobalAliasAndBargeIn) Return(s1 SlotLink, b1 BargeInHolder) *InitializationContextMock {
	if mmGetPublishedGlobalAliasAndBargeIn.mock.funcGetPublishedGlobalAliasAndBargeIn != nil {
		mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("InitializationContextMock.GetPublishedGlobalAliasAndBargeIn mock is already set by Set")
	}

	if mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation == nil {
		mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation = &InitializationContextMockGetPublishedGlobalAliasAndBargeInExpectation{mock: mmGetPublishedGlobalAliasAndBargeIn.mock}
	}
	mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation.results = &InitializationContextMockGetPublishedGlobalAliasAndBargeInResults{s1, b1}
	return mmGetPublishedGlobalAliasAndBargeIn.mock
}

//Set uses given function f to mock the InitializationContext.GetPublishedGlobalAliasAndBargeIn method
func (mmGetPublishedGlobalAliasAndBargeIn *mInitializationContextMockGetPublishedGlobalAliasAndBargeIn) Set(f func(key interface{}) (s1 SlotLink, b1 BargeInHolder)) *InitializationContextMock {
	if mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation != nil {
		mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("Default expectation is already set for the InitializationContext.GetPublishedGlobalAliasAndBargeIn method")
	}

	if len(mmGetPublishedGlobalAliasAndBargeIn.expectations) > 0 {
		mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("Some expectations are already set for the InitializationContext.GetPublishedGlobalAliasAndBargeIn method")
	}

	mmGetPublishedGlobalAliasAndBargeIn.mock.funcGetPublishedGlobalAliasAndBargeIn = f
	return mmGetPublishedGlobalAliasAndBargeIn.mock
}

// When sets expectation for the InitializationContext.GetPublishedGlobalAliasAndBargeIn which will trigger the result defined by the following
// Then helper
func (mmGetPublishedGlobalAliasAndBargeIn *mInitializationContextMockGetPublishedGlobalAliasAndBargeIn) When(key interface{}) *InitializationContextMockGetPublishedGlobalAliasAndBargeInExpectation {
	if mmGetPublishedGlobalAliasAndBargeIn.mock.funcGetPublishedGlobalAliasAndBargeIn != nil {
		mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("InitializationContextMock.GetPublishedGlobalAliasAndBargeIn mock is already set by Set")
	}

	expectation := &InitializationContextMockGetPublishedGlobalAliasAndBargeInExpectation{
		mock:   mmGetPublishedGlobalAliasAndBargeIn.mock,
		params: &InitializationContextMockGetPublishedGlobalAliasAndBargeInParams{key},
	}
	mmGetPublishedGlobalAliasAndBargeIn.expectations = append(mmGetPublishedGlobalAliasAndBargeIn.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.GetPublishedGlobalAliasAndBargeIn return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockGetPublishedGlobalAliasAndBargeInExpectation) Then(s1 SlotLink, b1 BargeInHolder) *InitializationContextMock {
	e.results = &InitializationContextMockGetPublishedGlobalAliasAndBargeInResults{s1, b1}
	return e.mock
}

// GetPublishedGlobalAliasAndBargeIn implements InitializationContext
func (mmGetPublishedGlobalAliasAndBargeIn *InitializationContextMock) GetPublishedGlobalAliasAndBargeIn(key interface{}) (s1 SlotLink, b1 BargeInHolder) {
	mm_atomic.AddUint64(&mmGetPublishedGlobalAliasAndBargeIn.beforeGetPublishedGlobalAliasAndBargeInCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPublishedGlobalAliasAndBargeIn.afterGetPublishedGlobalAliasAndBargeInCounter, 1)

	if mmGetPublishedGlobalAliasAndBargeIn.inspectFuncGetPublishedGlobalAliasAndBargeIn != nil {
		mmGetPublishedGlobalAliasAndBargeIn.inspectFuncGetPublishedGlobalAliasAndBargeIn(key)
	}

	mm_params := &InitializationContextMockGetPublishedGlobalAliasAndBargeInParams{key}

	// Record call args
	mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.mutex.Lock()
	mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.callArgs = append(mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.callArgs, mm_params)
	mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.mutex.Unlock()

	for _, e := range mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.b1
		}
	}

	if mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation.params
		mm_got := InitializationContextMockGetPublishedGlobalAliasAndBargeInParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPublishedGlobalAliasAndBargeIn.t.Errorf("InitializationContextMock.GetPublishedGlobalAliasAndBargeIn got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPublishedGlobalAliasAndBargeIn.t.Fatal("No results are set for the InitializationContextMock.GetPublishedGlobalAliasAndBargeIn")
		}
		return (*mm_results).s1, (*mm_results).b1
	}
	if mmGetPublishedGlobalAliasAndBargeIn.funcGetPublishedGlobalAliasAndBargeIn != nil {
		return mmGetPublishedGlobalAliasAndBargeIn.funcGetPublishedGlobalAliasAndBargeIn(key)
	}
	mmGetPublishedGlobalAliasAndBargeIn.t.Fatalf("Unexpected call to InitializationContextMock.GetPublishedGlobalAliasAndBargeIn. %v", key)
	return
}

// GetPublishedGlobalAliasAndBargeInAfterCounter returns a count of finished InitializationContextMock.GetPublishedGlobalAliasAndBargeIn invocations
func (mmGetPublishedGlobalAliasAndBargeIn *InitializationContextMock) GetPublishedGlobalAliasAndBargeInAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublishedGlobalAliasAndBargeIn.afterGetPublishedGlobalAliasAndBargeInCounter)
}

// GetPublishedGlobalAliasAndBargeInBeforeCounter returns a count of InitializationContextMock.GetPublishedGlobalAliasAndBargeIn invocations
func (mmGetPublishedGlobalAliasAndBargeIn *InitializationContextMock) GetPublishedGlobalAliasAndBargeInBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublishedGlobalAliasAndBargeIn.beforeGetPublishedGlobalAliasAndBargeInCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.GetPublishedGlobalAliasAndBargeIn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPublishedGlobalAliasAndBargeIn *mInitializationContextMockGetPublishedGlobalAliasAndBargeIn) Calls() []*InitializationContextMockGetPublishedGlobalAliasAndBargeInParams {
	mmGetPublishedGlobalAliasAndBargeIn.mutex.RLock()

	argCopy := make([]*InitializationContextMockGetPublishedGlobalAliasAndBargeInParams, len(mmGetPublishedGlobalAliasAndBargeIn.callArgs))
	copy(argCopy, mmGetPublishedGlobalAliasAndBargeIn.callArgs)

	mmGetPublishedGlobalAliasAndBargeIn.mutex.RUnlock()

	return argCopy
}

// MinimockGetPublishedGlobalAliasAndBargeInDone returns true if the count of the GetPublishedGlobalAliasAndBargeIn invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockGetPublishedGlobalAliasAndBargeInDone() bool {
	for _, e := range m.GetPublishedGlobalAliasAndBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasAndBargeInCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublishedGlobalAliasAndBargeIn != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasAndBargeInCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPublishedGlobalAliasAndBargeInInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockGetPublishedGlobalAliasAndBargeInInspect() {
	for _, e := range m.GetPublishedGlobalAliasAndBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.GetPublishedGlobalAliasAndBargeIn with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasAndBargeInCounter) < 1 {
		if m.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.GetPublishedGlobalAliasAndBargeIn")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.GetPublishedGlobalAliasAndBargeIn with params: %#v", *m.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublishedGlobalAliasAndBargeIn != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasAndBargeInCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.GetPublishedGlobalAliasAndBargeIn")
	}
}

type mInitializationContextMockGetPublishedLink struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockGetPublishedLinkExpectation
	expectations       []*InitializationContextMockGetPublishedLinkExpectation

	callArgs []*InitializationContextMockGetPublishedLinkParams
	mutex    sync.RWMutex
}

// InitializationContextMockGetPublishedLinkExpectation specifies expectation struct of the InitializationContext.GetPublishedLink
type InitializationContextMockGetPublishedLinkExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockGetPublishedLinkParams
	results *InitializationContextMockGetPublishedLinkResults
	Counter uint64
}

// InitializationContextMockGetPublishedLinkParams contains parameters of the InitializationContext.GetPublishedLink
type InitializationContextMockGetPublishedLinkParams struct {
	key interface{}
}

// InitializationContextMockGetPublishedLinkResults contains results of the InitializationContext.GetPublishedLink
type InitializationContextMockGetPublishedLinkResults struct {
	s1 SharedDataLink
}

// Expect sets up expected params for InitializationContext.GetPublishedLink
func (mmGetPublishedLink *mInitializationContextMockGetPublishedLink) Expect(key interface{}) *mInitializationContextMockGetPublishedLink {
	if mmGetPublishedLink.mock.funcGetPublishedLink != nil {
		mmGetPublishedLink.mock.t.Fatalf("InitializationContextMock.GetPublishedLink mock is already set by Set")
	}

	if mmGetPublishedLink.defaultExpectation == nil {
		mmGetPublishedLink.defaultExpectation = &InitializationContextMockGetPublishedLinkExpectation{}
	}

	mmGetPublishedLink.defaultExpectation.params = &InitializationContextMockGetPublishedLinkParams{key}
	for _, e := range mmGetPublishedLink.expectations {
		if minimock.Equal(e.params, mmGetPublishedLink.defaultExpectation.params) {
			mmGetPublishedLink.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPublishedLink.defaultExpectation.params)
		}
	}

	return mmGetPublishedLink
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.GetPublishedLink
func (mmGetPublishedLink *mInitializationContextMockGetPublishedLink) Inspect(f func(key interface{})) *mInitializationContextMockGetPublishedLink {
	if mmGetPublishedLink.mock.inspectFuncGetPublishedLink != nil {
		mmGetPublishedLink.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.GetPublishedLink")
	}

	mmGetPublishedLink.mock.inspectFuncGetPublishedLink = f

	return mmGetPublishedLink
}

// Return sets up results that will be returned by InitializationContext.GetPublishedLink
func (mmGetPublishedLink *mInitializationContextMockGetPublishedLink) Return(s1 SharedDataLink) *InitializationContextMock {
	if mmGetPublishedLink.mock.funcGetPublishedLink != nil {
		mmGetPublishedLink.mock.t.Fatalf("InitializationContextMock.GetPublishedLink mock is already set by Set")
	}

	if mmGetPublishedLink.defaultExpectation == nil {
		mmGetPublishedLink.defaultExpectation = &InitializationContextMockGetPublishedLinkExpectation{mock: mmGetPublishedLink.mock}
	}
	mmGetPublishedLink.defaultExpectation.results = &InitializationContextMockGetPublishedLinkResults{s1}
	return mmGetPublishedLink.mock
}

//Set uses given function f to mock the InitializationContext.GetPublishedLink method
func (mmGetPublishedLink *mInitializationContextMockGetPublishedLink) Set(f func(key interface{}) (s1 SharedDataLink)) *InitializationContextMock {
	if mmGetPublishedLink.defaultExpectation != nil {
		mmGetPublishedLink.mock.t.Fatalf("Default expectation is already set for the InitializationContext.GetPublishedLink method")
	}

	if len(mmGetPublishedLink.expectations) > 0 {
		mmGetPublishedLink.mock.t.Fatalf("Some expectations are already set for the InitializationContext.GetPublishedLink method")
	}

	mmGetPublishedLink.mock.funcGetPublishedLink = f
	return mmGetPublishedLink.mock
}

// When sets expectation for the InitializationContext.GetPublishedLink which will trigger the result defined by the following
// Then helper
func (mmGetPublishedLink *mInitializationContextMockGetPublishedLink) When(key interface{}) *InitializationContextMockGetPublishedLinkExpectation {
	if mmGetPublishedLink.mock.funcGetPublishedLink != nil {
		mmGetPublishedLink.mock.t.Fatalf("InitializationContextMock.GetPublishedLink mock is already set by Set")
	}

	expectation := &InitializationContextMockGetPublishedLinkExpectation{
		mock:   mmGetPublishedLink.mock,
		params: &InitializationContextMockGetPublishedLinkParams{key},
	}
	mmGetPublishedLink.expectations = append(mmGetPublishedLink.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.GetPublishedLink return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockGetPublishedLinkExpectation) Then(s1 SharedDataLink) *InitializationContextMock {
	e.results = &InitializationContextMockGetPublishedLinkResults{s1}
	return e.mock
}

// GetPublishedLink implements InitializationContext
func (mmGetPublishedLink *InitializationContextMock) GetPublishedLink(key interface{}) (s1 SharedDataLink) {
	mm_atomic.AddUint64(&mmGetPublishedLink.beforeGetPublishedLinkCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPublishedLink.afterGetPublishedLinkCounter, 1)

	if mmGetPublishedLink.inspectFuncGetPublishedLink != nil {
		mmGetPublishedLink.inspectFuncGetPublishedLink(key)
	}

	mm_params := &InitializationContextMockGetPublishedLinkParams{key}

	// Record call args
	mmGetPublishedLink.GetPublishedLinkMock.mutex.Lock()
	mmGetPublishedLink.GetPublishedLinkMock.callArgs = append(mmGetPublishedLink.GetPublishedLinkMock.callArgs, mm_params)
	mmGetPublishedLink.GetPublishedLinkMock.mutex.Unlock()

	for _, e := range mmGetPublishedLink.GetPublishedLinkMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmGetPublishedLink.GetPublishedLinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPublishedLink.GetPublishedLinkMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPublishedLink.GetPublishedLinkMock.defaultExpectation.params
		mm_got := InitializationContextMockGetPublishedLinkParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPublishedLink.t.Errorf("InitializationContextMock.GetPublishedLink got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPublishedLink.GetPublishedLinkMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPublishedLink.t.Fatal("No results are set for the InitializationContextMock.GetPublishedLink")
		}
		return (*mm_results).s1
	}
	if mmGetPublishedLink.funcGetPublishedLink != nil {
		return mmGetPublishedLink.funcGetPublishedLink(key)
	}
	mmGetPublishedLink.t.Fatalf("Unexpected call to InitializationContextMock.GetPublishedLink. %v", key)
	return
}

// GetPublishedLinkAfterCounter returns a count of finished InitializationContextMock.GetPublishedLink invocations
func (mmGetPublishedLink *InitializationContextMock) GetPublishedLinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublishedLink.afterGetPublishedLinkCounter)
}

// GetPublishedLinkBeforeCounter returns a count of InitializationContextMock.GetPublishedLink invocations
func (mmGetPublishedLink *InitializationContextMock) GetPublishedLinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublishedLink.beforeGetPublishedLinkCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.GetPublishedLink.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPublishedLink *mInitializationContextMockGetPublishedLink) Calls() []*InitializationContextMockGetPublishedLinkParams {
	mmGetPublishedLink.mutex.RLock()

	argCopy := make([]*InitializationContextMockGetPublishedLinkParams, len(mmGetPublishedLink.callArgs))
	copy(argCopy, mmGetPublishedLink.callArgs)

	mmGetPublishedLink.mutex.RUnlock()

	return argCopy
}

// MinimockGetPublishedLinkDone returns true if the count of the GetPublishedLink invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockGetPublishedLinkDone() bool {
	for _, e := range m.GetPublishedLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedLinkCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublishedLink != nil && mm_atomic.LoadUint64(&m.afterGetPublishedLinkCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPublishedLinkInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockGetPublishedLinkInspect() {
	for _, e := range m.GetPublishedLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.GetPublishedLink with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedLinkCounter) < 1 {
		if m.GetPublishedLinkMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.GetPublishedLink")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.GetPublishedLink with params: %#v", *m.GetPublishedLinkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublishedLink != nil && mm_atomic.LoadUint64(&m.afterGetPublishedLinkCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.GetPublishedLink")
	}
}

type mInitializationContextMockJump struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockJumpExpectation
	expectations       []*InitializationContextMockJumpExpectation

	callArgs []*InitializationContextMockJumpParams
	mutex    sync.RWMutex
}

// InitializationContextMockJumpExpectation specifies expectation struct of the InitializationContext.Jump
type InitializationContextMockJumpExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockJumpParams
	results *InitializationContextMockJumpResults
	Counter uint64
}

// InitializationContextMockJumpParams contains parameters of the InitializationContext.Jump
type InitializationContextMockJumpParams struct {
	s1 StateFunc
}

// InitializationContextMockJumpResults contains results of the InitializationContext.Jump
type InitializationContextMockJumpResults struct {
	s2 StateUpdate
}

// Expect sets up expected params for InitializationContext.Jump
func (mmJump *mInitializationContextMockJump) Expect(s1 StateFunc) *mInitializationContextMockJump {
	if mmJump.mock.funcJump != nil {
		mmJump.mock.t.Fatalf("InitializationContextMock.Jump mock is already set by Set")
	}

	if mmJump.defaultExpectation == nil {
		mmJump.defaultExpectation = &InitializationContextMockJumpExpectation{}
	}

	mmJump.defaultExpectation.params = &InitializationContextMockJumpParams{s1}
	for _, e := range mmJump.expectations {
		if minimock.Equal(e.params, mmJump.defaultExpectation.params) {
			mmJump.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmJump.defaultExpectation.params)
		}
	}

	return mmJump
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.Jump
func (mmJump *mInitializationContextMockJump) Inspect(f func(s1 StateFunc)) *mInitializationContextMockJump {
	if mmJump.mock.inspectFuncJump != nil {
		mmJump.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.Jump")
	}

	mmJump.mock.inspectFuncJump = f

	return mmJump
}

// Return sets up results that will be returned by InitializationContext.Jump
func (mmJump *mInitializationContextMockJump) Return(s2 StateUpdate) *InitializationContextMock {
	if mmJump.mock.funcJump != nil {
		mmJump.mock.t.Fatalf("InitializationContextMock.Jump mock is already set by Set")
	}

	if mmJump.defaultExpectation == nil {
		mmJump.defaultExpectation = &InitializationContextMockJumpExpectation{mock: mmJump.mock}
	}
	mmJump.defaultExpectation.results = &InitializationContextMockJumpResults{s2}
	return mmJump.mock
}

//Set uses given function f to mock the InitializationContext.Jump method
func (mmJump *mInitializationContextMockJump) Set(f func(s1 StateFunc) (s2 StateUpdate)) *InitializationContextMock {
	if mmJump.defaultExpectation != nil {
		mmJump.mock.t.Fatalf("Default expectation is already set for the InitializationContext.Jump method")
	}

	if len(mmJump.expectations) > 0 {
		mmJump.mock.t.Fatalf("Some expectations are already set for the InitializationContext.Jump method")
	}

	mmJump.mock.funcJump = f
	return mmJump.mock
}

// When sets expectation for the InitializationContext.Jump which will trigger the result defined by the following
// Then helper
func (mmJump *mInitializationContextMockJump) When(s1 StateFunc) *InitializationContextMockJumpExpectation {
	if mmJump.mock.funcJump != nil {
		mmJump.mock.t.Fatalf("InitializationContextMock.Jump mock is already set by Set")
	}

	expectation := &InitializationContextMockJumpExpectation{
		mock:   mmJump.mock,
		params: &InitializationContextMockJumpParams{s1},
	}
	mmJump.expectations = append(mmJump.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.Jump return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockJumpExpectation) Then(s2 StateUpdate) *InitializationContextMock {
	e.results = &InitializationContextMockJumpResults{s2}
	return e.mock
}

// Jump implements InitializationContext
func (mmJump *InitializationContextMock) Jump(s1 StateFunc) (s2 StateUpdate) {
	mm_atomic.AddUint64(&mmJump.beforeJumpCounter, 1)
	defer mm_atomic.AddUint64(&mmJump.afterJumpCounter, 1)

	if mmJump.inspectFuncJump != nil {
		mmJump.inspectFuncJump(s1)
	}

	mm_params := &InitializationContextMockJumpParams{s1}

	// Record call args
	mmJump.JumpMock.mutex.Lock()
	mmJump.JumpMock.callArgs = append(mmJump.JumpMock.callArgs, mm_params)
	mmJump.JumpMock.mutex.Unlock()

	for _, e := range mmJump.JumpMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2
		}
	}

	if mmJump.JumpMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmJump.JumpMock.defaultExpectation.Counter, 1)
		mm_want := mmJump.JumpMock.defaultExpectation.params
		mm_got := InitializationContextMockJumpParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmJump.t.Errorf("InitializationContextMock.Jump got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmJump.JumpMock.defaultExpectation.results
		if mm_results == nil {
			mmJump.t.Fatal("No results are set for the InitializationContextMock.Jump")
		}
		return (*mm_results).s2
	}
	if mmJump.funcJump != nil {
		return mmJump.funcJump(s1)
	}
	mmJump.t.Fatalf("Unexpected call to InitializationContextMock.Jump. %v", s1)
	return
}

// JumpAfterCounter returns a count of finished InitializationContextMock.Jump invocations
func (mmJump *InitializationContextMock) JumpAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJump.afterJumpCounter)
}

// JumpBeforeCounter returns a count of InitializationContextMock.Jump invocations
func (mmJump *InitializationContextMock) JumpBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJump.beforeJumpCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.Jump.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmJump *mInitializationContextMockJump) Calls() []*InitializationContextMockJumpParams {
	mmJump.mutex.RLock()

	argCopy := make([]*InitializationContextMockJumpParams, len(mmJump.callArgs))
	copy(argCopy, mmJump.callArgs)

	mmJump.mutex.RUnlock()

	return argCopy
}

// MinimockJumpDone returns true if the count of the Jump invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockJumpDone() bool {
	for _, e := range m.JumpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.JumpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterJumpCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJump != nil && mm_atomic.LoadUint64(&m.afterJumpCounter) < 1 {
		return false
	}
	return true
}

// MinimockJumpInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockJumpInspect() {
	for _, e := range m.JumpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.Jump with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.JumpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterJumpCounter) < 1 {
		if m.JumpMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.Jump")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.Jump with params: %#v", *m.JumpMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJump != nil && mm_atomic.LoadUint64(&m.afterJumpCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.Jump")
	}
}

type mInitializationContextMockJumpExt struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockJumpExtExpectation
	expectations       []*InitializationContextMockJumpExtExpectation

	callArgs []*InitializationContextMockJumpExtParams
	mutex    sync.RWMutex
}

// InitializationContextMockJumpExtExpectation specifies expectation struct of the InitializationContext.JumpExt
type InitializationContextMockJumpExtExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockJumpExtParams
	results *InitializationContextMockJumpExtResults
	Counter uint64
}

// InitializationContextMockJumpExtParams contains parameters of the InitializationContext.JumpExt
type InitializationContextMockJumpExtParams struct {
	s1 SlotStep
}

// InitializationContextMockJumpExtResults contains results of the InitializationContext.JumpExt
type InitializationContextMockJumpExtResults struct {
	s2 StateUpdate
}

// Expect sets up expected params for InitializationContext.JumpExt
func (mmJumpExt *mInitializationContextMockJumpExt) Expect(s1 SlotStep) *mInitializationContextMockJumpExt {
	if mmJumpExt.mock.funcJumpExt != nil {
		mmJumpExt.mock.t.Fatalf("InitializationContextMock.JumpExt mock is already set by Set")
	}

	if mmJumpExt.defaultExpectation == nil {
		mmJumpExt.defaultExpectation = &InitializationContextMockJumpExtExpectation{}
	}

	mmJumpExt.defaultExpectation.params = &InitializationContextMockJumpExtParams{s1}
	for _, e := range mmJumpExt.expectations {
		if minimock.Equal(e.params, mmJumpExt.defaultExpectation.params) {
			mmJumpExt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmJumpExt.defaultExpectation.params)
		}
	}

	return mmJumpExt
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.JumpExt
func (mmJumpExt *mInitializationContextMockJumpExt) Inspect(f func(s1 SlotStep)) *mInitializationContextMockJumpExt {
	if mmJumpExt.mock.inspectFuncJumpExt != nil {
		mmJumpExt.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.JumpExt")
	}

	mmJumpExt.mock.inspectFuncJumpExt = f

	return mmJumpExt
}

// Return sets up results that will be returned by InitializationContext.JumpExt
func (mmJumpExt *mInitializationContextMockJumpExt) Return(s2 StateUpdate) *InitializationContextMock {
	if mmJumpExt.mock.funcJumpExt != nil {
		mmJumpExt.mock.t.Fatalf("InitializationContextMock.JumpExt mock is already set by Set")
	}

	if mmJumpExt.defaultExpectation == nil {
		mmJumpExt.defaultExpectation = &InitializationContextMockJumpExtExpectation{mock: mmJumpExt.mock}
	}
	mmJumpExt.defaultExpectation.results = &InitializationContextMockJumpExtResults{s2}
	return mmJumpExt.mock
}

//Set uses given function f to mock the InitializationContext.JumpExt method
func (mmJumpExt *mInitializationContextMockJumpExt) Set(f func(s1 SlotStep) (s2 StateUpdate)) *InitializationContextMock {
	if mmJumpExt.defaultExpectation != nil {
		mmJumpExt.mock.t.Fatalf("Default expectation is already set for the InitializationContext.JumpExt method")
	}

	if len(mmJumpExt.expectations) > 0 {
		mmJumpExt.mock.t.Fatalf("Some expectations are already set for the InitializationContext.JumpExt method")
	}

	mmJumpExt.mock.funcJumpExt = f
	return mmJumpExt.mock
}

// When sets expectation for the InitializationContext.JumpExt which will trigger the result defined by the following
// Then helper
func (mmJumpExt *mInitializationContextMockJumpExt) When(s1 SlotStep) *InitializationContextMockJumpExtExpectation {
	if mmJumpExt.mock.funcJumpExt != nil {
		mmJumpExt.mock.t.Fatalf("InitializationContextMock.JumpExt mock is already set by Set")
	}

	expectation := &InitializationContextMockJumpExtExpectation{
		mock:   mmJumpExt.mock,
		params: &InitializationContextMockJumpExtParams{s1},
	}
	mmJumpExt.expectations = append(mmJumpExt.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.JumpExt return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockJumpExtExpectation) Then(s2 StateUpdate) *InitializationContextMock {
	e.results = &InitializationContextMockJumpExtResults{s2}
	return e.mock
}

// JumpExt implements InitializationContext
func (mmJumpExt *InitializationContextMock) JumpExt(s1 SlotStep) (s2 StateUpdate) {
	mm_atomic.AddUint64(&mmJumpExt.beforeJumpExtCounter, 1)
	defer mm_atomic.AddUint64(&mmJumpExt.afterJumpExtCounter, 1)

	if mmJumpExt.inspectFuncJumpExt != nil {
		mmJumpExt.inspectFuncJumpExt(s1)
	}

	mm_params := &InitializationContextMockJumpExtParams{s1}

	// Record call args
	mmJumpExt.JumpExtMock.mutex.Lock()
	mmJumpExt.JumpExtMock.callArgs = append(mmJumpExt.JumpExtMock.callArgs, mm_params)
	mmJumpExt.JumpExtMock.mutex.Unlock()

	for _, e := range mmJumpExt.JumpExtMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2
		}
	}

	if mmJumpExt.JumpExtMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmJumpExt.JumpExtMock.defaultExpectation.Counter, 1)
		mm_want := mmJumpExt.JumpExtMock.defaultExpectation.params
		mm_got := InitializationContextMockJumpExtParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmJumpExt.t.Errorf("InitializationContextMock.JumpExt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmJumpExt.JumpExtMock.defaultExpectation.results
		if mm_results == nil {
			mmJumpExt.t.Fatal("No results are set for the InitializationContextMock.JumpExt")
		}
		return (*mm_results).s2
	}
	if mmJumpExt.funcJumpExt != nil {
		return mmJumpExt.funcJumpExt(s1)
	}
	mmJumpExt.t.Fatalf("Unexpected call to InitializationContextMock.JumpExt. %v", s1)
	return
}

// JumpExtAfterCounter returns a count of finished InitializationContextMock.JumpExt invocations
func (mmJumpExt *InitializationContextMock) JumpExtAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJumpExt.afterJumpExtCounter)
}

// JumpExtBeforeCounter returns a count of InitializationContextMock.JumpExt invocations
func (mmJumpExt *InitializationContextMock) JumpExtBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJumpExt.beforeJumpExtCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.JumpExt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmJumpExt *mInitializationContextMockJumpExt) Calls() []*InitializationContextMockJumpExtParams {
	mmJumpExt.mutex.RLock()

	argCopy := make([]*InitializationContextMockJumpExtParams, len(mmJumpExt.callArgs))
	copy(argCopy, mmJumpExt.callArgs)

	mmJumpExt.mutex.RUnlock()

	return argCopy
}

// MinimockJumpExtDone returns true if the count of the JumpExt invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockJumpExtDone() bool {
	for _, e := range m.JumpExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.JumpExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterJumpExtCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJumpExt != nil && mm_atomic.LoadUint64(&m.afterJumpExtCounter) < 1 {
		return false
	}
	return true
}

// MinimockJumpExtInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockJumpExtInspect() {
	for _, e := range m.JumpExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.JumpExt with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.JumpExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterJumpExtCounter) < 1 {
		if m.JumpExtMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.JumpExt")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.JumpExt with params: %#v", *m.JumpExtMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJumpExt != nil && mm_atomic.LoadUint64(&m.afterJumpExtCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.JumpExt")
	}
}

type mInitializationContextMockLog struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockLogExpectation
	expectations       []*InitializationContextMockLogExpectation
}

// InitializationContextMockLogExpectation specifies expectation struct of the InitializationContext.Log
type InitializationContextMockLogExpectation struct {
	mock *InitializationContextMock

	results *InitializationContextMockLogResults
	Counter uint64
}

// InitializationContextMockLogResults contains results of the InitializationContext.Log
type InitializationContextMockLogResults struct {
	l1 Logger
}

// Expect sets up expected params for InitializationContext.Log
func (mmLog *mInitializationContextMockLog) Expect() *mInitializationContextMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("InitializationContextMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &InitializationContextMockLogExpectation{}
	}

	return mmLog
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.Log
func (mmLog *mInitializationContextMockLog) Inspect(f func()) *mInitializationContextMockLog {
	if mmLog.mock.inspectFuncLog != nil {
		mmLog.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.Log")
	}

	mmLog.mock.inspectFuncLog = f

	return mmLog
}

// Return sets up results that will be returned by InitializationContext.Log
func (mmLog *mInitializationContextMockLog) Return(l1 Logger) *InitializationContextMock {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("InitializationContextMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &InitializationContextMockLogExpectation{mock: mmLog.mock}
	}
	mmLog.defaultExpectation.results = &InitializationContextMockLogResults{l1}
	return mmLog.mock
}

//Set uses given function f to mock the InitializationContext.Log method
func (mmLog *mInitializationContextMockLog) Set(f func() (l1 Logger)) *InitializationContextMock {
	if mmLog.defaultExpectation != nil {
		mmLog.mock.t.Fatalf("Default expectation is already set for the InitializationContext.Log method")
	}

	if len(mmLog.expectations) > 0 {
		mmLog.mock.t.Fatalf("Some expectations are already set for the InitializationContext.Log method")
	}

	mmLog.mock.funcLog = f
	return mmLog.mock
}

// Log implements InitializationContext
func (mmLog *InitializationContextMock) Log() (l1 Logger) {
	mm_atomic.AddUint64(&mmLog.beforeLogCounter, 1)
	defer mm_atomic.AddUint64(&mmLog.afterLogCounter, 1)

	if mmLog.inspectFuncLog != nil {
		mmLog.inspectFuncLog()
	}

	if mmLog.LogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLog.LogMock.defaultExpectation.Counter, 1)

		mm_results := mmLog.LogMock.defaultExpectation.results
		if mm_results == nil {
			mmLog.t.Fatal("No results are set for the InitializationContextMock.Log")
		}
		return (*mm_results).l1
	}
	if mmLog.funcLog != nil {
		return mmLog.funcLog()
	}
	mmLog.t.Fatalf("Unexpected call to InitializationContextMock.Log.")
	return
}

// LogAfterCounter returns a count of finished InitializationContextMock.Log invocations
func (mmLog *InitializationContextMock) LogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLog.afterLogCounter)
}

// LogBeforeCounter returns a count of InitializationContextMock.Log invocations
func (mmLog *InitializationContextMock) LogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLog.beforeLogCounter)
}

// MinimockLogDone returns true if the count of the Log invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockLogDone() bool {
	for _, e := range m.LogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLogCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLog != nil && mm_atomic.LoadUint64(&m.afterLogCounter) < 1 {
		return false
	}
	return true
}

// MinimockLogInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockLogInspect() {
	for _, e := range m.LogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to InitializationContextMock.Log")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLogCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.Log")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLog != nil && mm_atomic.LoadUint64(&m.afterLogCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.Log")
	}
}

type mInitializationContextMockNewBargeIn struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockNewBargeInExpectation
	expectations       []*InitializationContextMockNewBargeInExpectation
}

// InitializationContextMockNewBargeInExpectation specifies expectation struct of the InitializationContext.NewBargeIn
type InitializationContextMockNewBargeInExpectation struct {
	mock *InitializationContextMock

	results *InitializationContextMockNewBargeInResults
	Counter uint64
}

// InitializationContextMockNewBargeInResults contains results of the InitializationContext.NewBargeIn
type InitializationContextMockNewBargeInResults struct {
	b1 BargeInBuilder
}

// Expect sets up expected params for InitializationContext.NewBargeIn
func (mmNewBargeIn *mInitializationContextMockNewBargeIn) Expect() *mInitializationContextMockNewBargeIn {
	if mmNewBargeIn.mock.funcNewBargeIn != nil {
		mmNewBargeIn.mock.t.Fatalf("InitializationContextMock.NewBargeIn mock is already set by Set")
	}

	if mmNewBargeIn.defaultExpectation == nil {
		mmNewBargeIn.defaultExpectation = &InitializationContextMockNewBargeInExpectation{}
	}

	return mmNewBargeIn
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.NewBargeIn
func (mmNewBargeIn *mInitializationContextMockNewBargeIn) Inspect(f func()) *mInitializationContextMockNewBargeIn {
	if mmNewBargeIn.mock.inspectFuncNewBargeIn != nil {
		mmNewBargeIn.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.NewBargeIn")
	}

	mmNewBargeIn.mock.inspectFuncNewBargeIn = f

	return mmNewBargeIn
}

// Return sets up results that will be returned by InitializationContext.NewBargeIn
func (mmNewBargeIn *mInitializationContextMockNewBargeIn) Return(b1 BargeInBuilder) *InitializationContextMock {
	if mmNewBargeIn.mock.funcNewBargeIn != nil {
		mmNewBargeIn.mock.t.Fatalf("InitializationContextMock.NewBargeIn mock is already set by Set")
	}

	if mmNewBargeIn.defaultExpectation == nil {
		mmNewBargeIn.defaultExpectation = &InitializationContextMockNewBargeInExpectation{mock: mmNewBargeIn.mock}
	}
	mmNewBargeIn.defaultExpectation.results = &InitializationContextMockNewBargeInResults{b1}
	return mmNewBargeIn.mock
}

//Set uses given function f to mock the InitializationContext.NewBargeIn method
func (mmNewBargeIn *mInitializationContextMockNewBargeIn) Set(f func() (b1 BargeInBuilder)) *InitializationContextMock {
	if mmNewBargeIn.defaultExpectation != nil {
		mmNewBargeIn.mock.t.Fatalf("Default expectation is already set for the InitializationContext.NewBargeIn method")
	}

	if len(mmNewBargeIn.expectations) > 0 {
		mmNewBargeIn.mock.t.Fatalf("Some expectations are already set for the InitializationContext.NewBargeIn method")
	}

	mmNewBargeIn.mock.funcNewBargeIn = f
	return mmNewBargeIn.mock
}

// NewBargeIn implements InitializationContext
func (mmNewBargeIn *InitializationContextMock) NewBargeIn() (b1 BargeInBuilder) {
	mm_atomic.AddUint64(&mmNewBargeIn.beforeNewBargeInCounter, 1)
	defer mm_atomic.AddUint64(&mmNewBargeIn.afterNewBargeInCounter, 1)

	if mmNewBargeIn.inspectFuncNewBargeIn != nil {
		mmNewBargeIn.inspectFuncNewBargeIn()
	}

	if mmNewBargeIn.NewBargeInMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewBargeIn.NewBargeInMock.defaultExpectation.Counter, 1)

		mm_results := mmNewBargeIn.NewBargeInMock.defaultExpectation.results
		if mm_results == nil {
			mmNewBargeIn.t.Fatal("No results are set for the InitializationContextMock.NewBargeIn")
		}
		return (*mm_results).b1
	}
	if mmNewBargeIn.funcNewBargeIn != nil {
		return mmNewBargeIn.funcNewBargeIn()
	}
	mmNewBargeIn.t.Fatalf("Unexpected call to InitializationContextMock.NewBargeIn.")
	return
}

// NewBargeInAfterCounter returns a count of finished InitializationContextMock.NewBargeIn invocations
func (mmNewBargeIn *InitializationContextMock) NewBargeInAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewBargeIn.afterNewBargeInCounter)
}

// NewBargeInBeforeCounter returns a count of InitializationContextMock.NewBargeIn invocations
func (mmNewBargeIn *InitializationContextMock) NewBargeInBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewBargeIn.beforeNewBargeInCounter)
}

// MinimockNewBargeInDone returns true if the count of the NewBargeIn invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockNewBargeInDone() bool {
	for _, e := range m.NewBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewBargeInCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewBargeIn != nil && mm_atomic.LoadUint64(&m.afterNewBargeInCounter) < 1 {
		return false
	}
	return true
}

// MinimockNewBargeInInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockNewBargeInInspect() {
	for _, e := range m.NewBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to InitializationContextMock.NewBargeIn")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewBargeInCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.NewBargeIn")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewBargeIn != nil && mm_atomic.LoadUint64(&m.afterNewBargeInCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.NewBargeIn")
	}
}

type mInitializationContextMockNewBargeInWithParam struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockNewBargeInWithParamExpectation
	expectations       []*InitializationContextMockNewBargeInWithParamExpectation

	callArgs []*InitializationContextMockNewBargeInWithParamParams
	mutex    sync.RWMutex
}

// InitializationContextMockNewBargeInWithParamExpectation specifies expectation struct of the InitializationContext.NewBargeInWithParam
type InitializationContextMockNewBargeInWithParamExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockNewBargeInWithParamParams
	results *InitializationContextMockNewBargeInWithParamResults
	Counter uint64
}

// InitializationContextMockNewBargeInWithParamParams contains parameters of the InitializationContext.NewBargeInWithParam
type InitializationContextMockNewBargeInWithParamParams struct {
	b1 BargeInApplyFunc
}

// InitializationContextMockNewBargeInWithParamResults contains results of the InitializationContext.NewBargeInWithParam
type InitializationContextMockNewBargeInWithParamResults struct {
	b2 BargeInWithParam
}

// Expect sets up expected params for InitializationContext.NewBargeInWithParam
func (mmNewBargeInWithParam *mInitializationContextMockNewBargeInWithParam) Expect(b1 BargeInApplyFunc) *mInitializationContextMockNewBargeInWithParam {
	if mmNewBargeInWithParam.mock.funcNewBargeInWithParam != nil {
		mmNewBargeInWithParam.mock.t.Fatalf("InitializationContextMock.NewBargeInWithParam mock is already set by Set")
	}

	if mmNewBargeInWithParam.defaultExpectation == nil {
		mmNewBargeInWithParam.defaultExpectation = &InitializationContextMockNewBargeInWithParamExpectation{}
	}

	mmNewBargeInWithParam.defaultExpectation.params = &InitializationContextMockNewBargeInWithParamParams{b1}
	for _, e := range mmNewBargeInWithParam.expectations {
		if minimock.Equal(e.params, mmNewBargeInWithParam.defaultExpectation.params) {
			mmNewBargeInWithParam.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNewBargeInWithParam.defaultExpectation.params)
		}
	}

	return mmNewBargeInWithParam
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.NewBargeInWithParam
func (mmNewBargeInWithParam *mInitializationContextMockNewBargeInWithParam) Inspect(f func(b1 BargeInApplyFunc)) *mInitializationContextMockNewBargeInWithParam {
	if mmNewBargeInWithParam.mock.inspectFuncNewBargeInWithParam != nil {
		mmNewBargeInWithParam.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.NewBargeInWithParam")
	}

	mmNewBargeInWithParam.mock.inspectFuncNewBargeInWithParam = f

	return mmNewBargeInWithParam
}

// Return sets up results that will be returned by InitializationContext.NewBargeInWithParam
func (mmNewBargeInWithParam *mInitializationContextMockNewBargeInWithParam) Return(b2 BargeInWithParam) *InitializationContextMock {
	if mmNewBargeInWithParam.mock.funcNewBargeInWithParam != nil {
		mmNewBargeInWithParam.mock.t.Fatalf("InitializationContextMock.NewBargeInWithParam mock is already set by Set")
	}

	if mmNewBargeInWithParam.defaultExpectation == nil {
		mmNewBargeInWithParam.defaultExpectation = &InitializationContextMockNewBargeInWithParamExpectation{mock: mmNewBargeInWithParam.mock}
	}
	mmNewBargeInWithParam.defaultExpectation.results = &InitializationContextMockNewBargeInWithParamResults{b2}
	return mmNewBargeInWithParam.mock
}

//Set uses given function f to mock the InitializationContext.NewBargeInWithParam method
func (mmNewBargeInWithParam *mInitializationContextMockNewBargeInWithParam) Set(f func(b1 BargeInApplyFunc) (b2 BargeInWithParam)) *InitializationContextMock {
	if mmNewBargeInWithParam.defaultExpectation != nil {
		mmNewBargeInWithParam.mock.t.Fatalf("Default expectation is already set for the InitializationContext.NewBargeInWithParam method")
	}

	if len(mmNewBargeInWithParam.expectations) > 0 {
		mmNewBargeInWithParam.mock.t.Fatalf("Some expectations are already set for the InitializationContext.NewBargeInWithParam method")
	}

	mmNewBargeInWithParam.mock.funcNewBargeInWithParam = f
	return mmNewBargeInWithParam.mock
}

// When sets expectation for the InitializationContext.NewBargeInWithParam which will trigger the result defined by the following
// Then helper
func (mmNewBargeInWithParam *mInitializationContextMockNewBargeInWithParam) When(b1 BargeInApplyFunc) *InitializationContextMockNewBargeInWithParamExpectation {
	if mmNewBargeInWithParam.mock.funcNewBargeInWithParam != nil {
		mmNewBargeInWithParam.mock.t.Fatalf("InitializationContextMock.NewBargeInWithParam mock is already set by Set")
	}

	expectation := &InitializationContextMockNewBargeInWithParamExpectation{
		mock:   mmNewBargeInWithParam.mock,
		params: &InitializationContextMockNewBargeInWithParamParams{b1},
	}
	mmNewBargeInWithParam.expectations = append(mmNewBargeInWithParam.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.NewBargeInWithParam return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockNewBargeInWithParamExpectation) Then(b2 BargeInWithParam) *InitializationContextMock {
	e.results = &InitializationContextMockNewBargeInWithParamResults{b2}
	return e.mock
}

// NewBargeInWithParam implements InitializationContext
func (mmNewBargeInWithParam *InitializationContextMock) NewBargeInWithParam(b1 BargeInApplyFunc) (b2 BargeInWithParam) {
	mm_atomic.AddUint64(&mmNewBargeInWithParam.beforeNewBargeInWithParamCounter, 1)
	defer mm_atomic.AddUint64(&mmNewBargeInWithParam.afterNewBargeInWithParamCounter, 1)

	if mmNewBargeInWithParam.inspectFuncNewBargeInWithParam != nil {
		mmNewBargeInWithParam.inspectFuncNewBargeInWithParam(b1)
	}

	mm_params := &InitializationContextMockNewBargeInWithParamParams{b1}

	// Record call args
	mmNewBargeInWithParam.NewBargeInWithParamMock.mutex.Lock()
	mmNewBargeInWithParam.NewBargeInWithParamMock.callArgs = append(mmNewBargeInWithParam.NewBargeInWithParamMock.callArgs, mm_params)
	mmNewBargeInWithParam.NewBargeInWithParamMock.mutex.Unlock()

	for _, e := range mmNewBargeInWithParam.NewBargeInWithParamMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b2
		}
	}

	if mmNewBargeInWithParam.NewBargeInWithParamMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewBargeInWithParam.NewBargeInWithParamMock.defaultExpectation.Counter, 1)
		mm_want := mmNewBargeInWithParam.NewBargeInWithParamMock.defaultExpectation.params
		mm_got := InitializationContextMockNewBargeInWithParamParams{b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNewBargeInWithParam.t.Errorf("InitializationContextMock.NewBargeInWithParam got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNewBargeInWithParam.NewBargeInWithParamMock.defaultExpectation.results
		if mm_results == nil {
			mmNewBargeInWithParam.t.Fatal("No results are set for the InitializationContextMock.NewBargeInWithParam")
		}
		return (*mm_results).b2
	}
	if mmNewBargeInWithParam.funcNewBargeInWithParam != nil {
		return mmNewBargeInWithParam.funcNewBargeInWithParam(b1)
	}
	mmNewBargeInWithParam.t.Fatalf("Unexpected call to InitializationContextMock.NewBargeInWithParam. %v", b1)
	return
}

// NewBargeInWithParamAfterCounter returns a count of finished InitializationContextMock.NewBargeInWithParam invocations
func (mmNewBargeInWithParam *InitializationContextMock) NewBargeInWithParamAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewBargeInWithParam.afterNewBargeInWithParamCounter)
}

// NewBargeInWithParamBeforeCounter returns a count of InitializationContextMock.NewBargeInWithParam invocations
func (mmNewBargeInWithParam *InitializationContextMock) NewBargeInWithParamBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewBargeInWithParam.beforeNewBargeInWithParamCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.NewBargeInWithParam.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNewBargeInWithParam *mInitializationContextMockNewBargeInWithParam) Calls() []*InitializationContextMockNewBargeInWithParamParams {
	mmNewBargeInWithParam.mutex.RLock()

	argCopy := make([]*InitializationContextMockNewBargeInWithParamParams, len(mmNewBargeInWithParam.callArgs))
	copy(argCopy, mmNewBargeInWithParam.callArgs)

	mmNewBargeInWithParam.mutex.RUnlock()

	return argCopy
}

// MinimockNewBargeInWithParamDone returns true if the count of the NewBargeInWithParam invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockNewBargeInWithParamDone() bool {
	for _, e := range m.NewBargeInWithParamMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewBargeInWithParamMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewBargeInWithParamCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewBargeInWithParam != nil && mm_atomic.LoadUint64(&m.afterNewBargeInWithParamCounter) < 1 {
		return false
	}
	return true
}

// MinimockNewBargeInWithParamInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockNewBargeInWithParamInspect() {
	for _, e := range m.NewBargeInWithParamMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.NewBargeInWithParam with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewBargeInWithParamMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewBargeInWithParamCounter) < 1 {
		if m.NewBargeInWithParamMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.NewBargeInWithParam")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.NewBargeInWithParam with params: %#v", *m.NewBargeInWithParamMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewBargeInWithParam != nil && mm_atomic.LoadUint64(&m.afterNewBargeInWithParamCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.NewBargeInWithParam")
	}
}

type mInitializationContextMockParentLink struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockParentLinkExpectation
	expectations       []*InitializationContextMockParentLinkExpectation
}

// InitializationContextMockParentLinkExpectation specifies expectation struct of the InitializationContext.ParentLink
type InitializationContextMockParentLinkExpectation struct {
	mock *InitializationContextMock

	results *InitializationContextMockParentLinkResults
	Counter uint64
}

// InitializationContextMockParentLinkResults contains results of the InitializationContext.ParentLink
type InitializationContextMockParentLinkResults struct {
	s1 SlotLink
}

// Expect sets up expected params for InitializationContext.ParentLink
func (mmParentLink *mInitializationContextMockParentLink) Expect() *mInitializationContextMockParentLink {
	if mmParentLink.mock.funcParentLink != nil {
		mmParentLink.mock.t.Fatalf("InitializationContextMock.ParentLink mock is already set by Set")
	}

	if mmParentLink.defaultExpectation == nil {
		mmParentLink.defaultExpectation = &InitializationContextMockParentLinkExpectation{}
	}

	return mmParentLink
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.ParentLink
func (mmParentLink *mInitializationContextMockParentLink) Inspect(f func()) *mInitializationContextMockParentLink {
	if mmParentLink.mock.inspectFuncParentLink != nil {
		mmParentLink.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.ParentLink")
	}

	mmParentLink.mock.inspectFuncParentLink = f

	return mmParentLink
}

// Return sets up results that will be returned by InitializationContext.ParentLink
func (mmParentLink *mInitializationContextMockParentLink) Return(s1 SlotLink) *InitializationContextMock {
	if mmParentLink.mock.funcParentLink != nil {
		mmParentLink.mock.t.Fatalf("InitializationContextMock.ParentLink mock is already set by Set")
	}

	if mmParentLink.defaultExpectation == nil {
		mmParentLink.defaultExpectation = &InitializationContextMockParentLinkExpectation{mock: mmParentLink.mock}
	}
	mmParentLink.defaultExpectation.results = &InitializationContextMockParentLinkResults{s1}
	return mmParentLink.mock
}

//Set uses given function f to mock the InitializationContext.ParentLink method
func (mmParentLink *mInitializationContextMockParentLink) Set(f func() (s1 SlotLink)) *InitializationContextMock {
	if mmParentLink.defaultExpectation != nil {
		mmParentLink.mock.t.Fatalf("Default expectation is already set for the InitializationContext.ParentLink method")
	}

	if len(mmParentLink.expectations) > 0 {
		mmParentLink.mock.t.Fatalf("Some expectations are already set for the InitializationContext.ParentLink method")
	}

	mmParentLink.mock.funcParentLink = f
	return mmParentLink.mock
}

// ParentLink implements InitializationContext
func (mmParentLink *InitializationContextMock) ParentLink() (s1 SlotLink) {
	mm_atomic.AddUint64(&mmParentLink.beforeParentLinkCounter, 1)
	defer mm_atomic.AddUint64(&mmParentLink.afterParentLinkCounter, 1)

	if mmParentLink.inspectFuncParentLink != nil {
		mmParentLink.inspectFuncParentLink()
	}

	if mmParentLink.ParentLinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmParentLink.ParentLinkMock.defaultExpectation.Counter, 1)

		mm_results := mmParentLink.ParentLinkMock.defaultExpectation.results
		if mm_results == nil {
			mmParentLink.t.Fatal("No results are set for the InitializationContextMock.ParentLink")
		}
		return (*mm_results).s1
	}
	if mmParentLink.funcParentLink != nil {
		return mmParentLink.funcParentLink()
	}
	mmParentLink.t.Fatalf("Unexpected call to InitializationContextMock.ParentLink.")
	return
}

// ParentLinkAfterCounter returns a count of finished InitializationContextMock.ParentLink invocations
func (mmParentLink *InitializationContextMock) ParentLinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParentLink.afterParentLinkCounter)
}

// ParentLinkBeforeCounter returns a count of InitializationContextMock.ParentLink invocations
func (mmParentLink *InitializationContextMock) ParentLinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParentLink.beforeParentLinkCounter)
}

// MinimockParentLinkDone returns true if the count of the ParentLink invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockParentLinkDone() bool {
	for _, e := range m.ParentLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParentLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParentLinkCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParentLink != nil && mm_atomic.LoadUint64(&m.afterParentLinkCounter) < 1 {
		return false
	}
	return true
}

// MinimockParentLinkInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockParentLinkInspect() {
	for _, e := range m.ParentLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to InitializationContextMock.ParentLink")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParentLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParentLinkCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.ParentLink")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParentLink != nil && mm_atomic.LoadUint64(&m.afterParentLinkCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.ParentLink")
	}
}

type mInitializationContextMockPublish struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockPublishExpectation
	expectations       []*InitializationContextMockPublishExpectation

	callArgs []*InitializationContextMockPublishParams
	mutex    sync.RWMutex
}

// InitializationContextMockPublishExpectation specifies expectation struct of the InitializationContext.Publish
type InitializationContextMockPublishExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockPublishParams
	results *InitializationContextMockPublishResults
	Counter uint64
}

// InitializationContextMockPublishParams contains parameters of the InitializationContext.Publish
type InitializationContextMockPublishParams struct {
	key  interface{}
	data interface{}
}

// InitializationContextMockPublishResults contains results of the InitializationContext.Publish
type InitializationContextMockPublishResults struct {
	b1 bool
}

// Expect sets up expected params for InitializationContext.Publish
func (mmPublish *mInitializationContextMockPublish) Expect(key interface{}, data interface{}) *mInitializationContextMockPublish {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("InitializationContextMock.Publish mock is already set by Set")
	}

	if mmPublish.defaultExpectation == nil {
		mmPublish.defaultExpectation = &InitializationContextMockPublishExpectation{}
	}

	mmPublish.defaultExpectation.params = &InitializationContextMockPublishParams{key, data}
	for _, e := range mmPublish.expectations {
		if minimock.Equal(e.params, mmPublish.defaultExpectation.params) {
			mmPublish.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPublish.defaultExpectation.params)
		}
	}

	return mmPublish
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.Publish
func (mmPublish *mInitializationContextMockPublish) Inspect(f func(key interface{}, data interface{})) *mInitializationContextMockPublish {
	if mmPublish.mock.inspectFuncPublish != nil {
		mmPublish.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.Publish")
	}

	mmPublish.mock.inspectFuncPublish = f

	return mmPublish
}

// Return sets up results that will be returned by InitializationContext.Publish
func (mmPublish *mInitializationContextMockPublish) Return(b1 bool) *InitializationContextMock {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("InitializationContextMock.Publish mock is already set by Set")
	}

	if mmPublish.defaultExpectation == nil {
		mmPublish.defaultExpectation = &InitializationContextMockPublishExpectation{mock: mmPublish.mock}
	}
	mmPublish.defaultExpectation.results = &InitializationContextMockPublishResults{b1}
	return mmPublish.mock
}

//Set uses given function f to mock the InitializationContext.Publish method
func (mmPublish *mInitializationContextMockPublish) Set(f func(key interface{}, data interface{}) (b1 bool)) *InitializationContextMock {
	if mmPublish.defaultExpectation != nil {
		mmPublish.mock.t.Fatalf("Default expectation is already set for the InitializationContext.Publish method")
	}

	if len(mmPublish.expectations) > 0 {
		mmPublish.mock.t.Fatalf("Some expectations are already set for the InitializationContext.Publish method")
	}

	mmPublish.mock.funcPublish = f
	return mmPublish.mock
}

// When sets expectation for the InitializationContext.Publish which will trigger the result defined by the following
// Then helper
func (mmPublish *mInitializationContextMockPublish) When(key interface{}, data interface{}) *InitializationContextMockPublishExpectation {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("InitializationContextMock.Publish mock is already set by Set")
	}

	expectation := &InitializationContextMockPublishExpectation{
		mock:   mmPublish.mock,
		params: &InitializationContextMockPublishParams{key, data},
	}
	mmPublish.expectations = append(mmPublish.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.Publish return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockPublishExpectation) Then(b1 bool) *InitializationContextMock {
	e.results = &InitializationContextMockPublishResults{b1}
	return e.mock
}

// Publish implements InitializationContext
func (mmPublish *InitializationContextMock) Publish(key interface{}, data interface{}) (b1 bool) {
	mm_atomic.AddUint64(&mmPublish.beforePublishCounter, 1)
	defer mm_atomic.AddUint64(&mmPublish.afterPublishCounter, 1)

	if mmPublish.inspectFuncPublish != nil {
		mmPublish.inspectFuncPublish(key, data)
	}

	mm_params := &InitializationContextMockPublishParams{key, data}

	// Record call args
	mmPublish.PublishMock.mutex.Lock()
	mmPublish.PublishMock.callArgs = append(mmPublish.PublishMock.callArgs, mm_params)
	mmPublish.PublishMock.mutex.Unlock()

	for _, e := range mmPublish.PublishMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmPublish.PublishMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublish.PublishMock.defaultExpectation.Counter, 1)
		mm_want := mmPublish.PublishMock.defaultExpectation.params
		mm_got := InitializationContextMockPublishParams{key, data}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPublish.t.Errorf("InitializationContextMock.Publish got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPublish.PublishMock.defaultExpectation.results
		if mm_results == nil {
			mmPublish.t.Fatal("No results are set for the InitializationContextMock.Publish")
		}
		return (*mm_results).b1
	}
	if mmPublish.funcPublish != nil {
		return mmPublish.funcPublish(key, data)
	}
	mmPublish.t.Fatalf("Unexpected call to InitializationContextMock.Publish. %v %v", key, data)
	return
}

// PublishAfterCounter returns a count of finished InitializationContextMock.Publish invocations
func (mmPublish *InitializationContextMock) PublishAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublish.afterPublishCounter)
}

// PublishBeforeCounter returns a count of InitializationContextMock.Publish invocations
func (mmPublish *InitializationContextMock) PublishBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublish.beforePublishCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.Publish.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPublish *mInitializationContextMockPublish) Calls() []*InitializationContextMockPublishParams {
	mmPublish.mutex.RLock()

	argCopy := make([]*InitializationContextMockPublishParams, len(mmPublish.callArgs))
	copy(argCopy, mmPublish.callArgs)

	mmPublish.mutex.RUnlock()

	return argCopy
}

// MinimockPublishDone returns true if the count of the Publish invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockPublishDone() bool {
	for _, e := range m.PublishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublish != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		return false
	}
	return true
}

// MinimockPublishInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockPublishInspect() {
	for _, e := range m.PublishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.Publish with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		if m.PublishMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.Publish")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.Publish with params: %#v", *m.PublishMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublish != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.Publish")
	}
}

type mInitializationContextMockPublishGlobalAlias struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockPublishGlobalAliasExpectation
	expectations       []*InitializationContextMockPublishGlobalAliasExpectation

	callArgs []*InitializationContextMockPublishGlobalAliasParams
	mutex    sync.RWMutex
}

// InitializationContextMockPublishGlobalAliasExpectation specifies expectation struct of the InitializationContext.PublishGlobalAlias
type InitializationContextMockPublishGlobalAliasExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockPublishGlobalAliasParams
	results *InitializationContextMockPublishGlobalAliasResults
	Counter uint64
}

// InitializationContextMockPublishGlobalAliasParams contains parameters of the InitializationContext.PublishGlobalAlias
type InitializationContextMockPublishGlobalAliasParams struct {
	key interface{}
}

// InitializationContextMockPublishGlobalAliasResults contains results of the InitializationContext.PublishGlobalAlias
type InitializationContextMockPublishGlobalAliasResults struct {
	b1 bool
}

// Expect sets up expected params for InitializationContext.PublishGlobalAlias
func (mmPublishGlobalAlias *mInitializationContextMockPublishGlobalAlias) Expect(key interface{}) *mInitializationContextMockPublishGlobalAlias {
	if mmPublishGlobalAlias.mock.funcPublishGlobalAlias != nil {
		mmPublishGlobalAlias.mock.t.Fatalf("InitializationContextMock.PublishGlobalAlias mock is already set by Set")
	}

	if mmPublishGlobalAlias.defaultExpectation == nil {
		mmPublishGlobalAlias.defaultExpectation = &InitializationContextMockPublishGlobalAliasExpectation{}
	}

	mmPublishGlobalAlias.defaultExpectation.params = &InitializationContextMockPublishGlobalAliasParams{key}
	for _, e := range mmPublishGlobalAlias.expectations {
		if minimock.Equal(e.params, mmPublishGlobalAlias.defaultExpectation.params) {
			mmPublishGlobalAlias.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPublishGlobalAlias.defaultExpectation.params)
		}
	}

	return mmPublishGlobalAlias
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.PublishGlobalAlias
func (mmPublishGlobalAlias *mInitializationContextMockPublishGlobalAlias) Inspect(f func(key interface{})) *mInitializationContextMockPublishGlobalAlias {
	if mmPublishGlobalAlias.mock.inspectFuncPublishGlobalAlias != nil {
		mmPublishGlobalAlias.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.PublishGlobalAlias")
	}

	mmPublishGlobalAlias.mock.inspectFuncPublishGlobalAlias = f

	return mmPublishGlobalAlias
}

// Return sets up results that will be returned by InitializationContext.PublishGlobalAlias
func (mmPublishGlobalAlias *mInitializationContextMockPublishGlobalAlias) Return(b1 bool) *InitializationContextMock {
	if mmPublishGlobalAlias.mock.funcPublishGlobalAlias != nil {
		mmPublishGlobalAlias.mock.t.Fatalf("InitializationContextMock.PublishGlobalAlias mock is already set by Set")
	}

	if mmPublishGlobalAlias.defaultExpectation == nil {
		mmPublishGlobalAlias.defaultExpectation = &InitializationContextMockPublishGlobalAliasExpectation{mock: mmPublishGlobalAlias.mock}
	}
	mmPublishGlobalAlias.defaultExpectation.results = &InitializationContextMockPublishGlobalAliasResults{b1}
	return mmPublishGlobalAlias.mock
}

//Set uses given function f to mock the InitializationContext.PublishGlobalAlias method
func (mmPublishGlobalAlias *mInitializationContextMockPublishGlobalAlias) Set(f func(key interface{}) (b1 bool)) *InitializationContextMock {
	if mmPublishGlobalAlias.defaultExpectation != nil {
		mmPublishGlobalAlias.mock.t.Fatalf("Default expectation is already set for the InitializationContext.PublishGlobalAlias method")
	}

	if len(mmPublishGlobalAlias.expectations) > 0 {
		mmPublishGlobalAlias.mock.t.Fatalf("Some expectations are already set for the InitializationContext.PublishGlobalAlias method")
	}

	mmPublishGlobalAlias.mock.funcPublishGlobalAlias = f
	return mmPublishGlobalAlias.mock
}

// When sets expectation for the InitializationContext.PublishGlobalAlias which will trigger the result defined by the following
// Then helper
func (mmPublishGlobalAlias *mInitializationContextMockPublishGlobalAlias) When(key interface{}) *InitializationContextMockPublishGlobalAliasExpectation {
	if mmPublishGlobalAlias.mock.funcPublishGlobalAlias != nil {
		mmPublishGlobalAlias.mock.t.Fatalf("InitializationContextMock.PublishGlobalAlias mock is already set by Set")
	}

	expectation := &InitializationContextMockPublishGlobalAliasExpectation{
		mock:   mmPublishGlobalAlias.mock,
		params: &InitializationContextMockPublishGlobalAliasParams{key},
	}
	mmPublishGlobalAlias.expectations = append(mmPublishGlobalAlias.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.PublishGlobalAlias return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockPublishGlobalAliasExpectation) Then(b1 bool) *InitializationContextMock {
	e.results = &InitializationContextMockPublishGlobalAliasResults{b1}
	return e.mock
}

// PublishGlobalAlias implements InitializationContext
func (mmPublishGlobalAlias *InitializationContextMock) PublishGlobalAlias(key interface{}) (b1 bool) {
	mm_atomic.AddUint64(&mmPublishGlobalAlias.beforePublishGlobalAliasCounter, 1)
	defer mm_atomic.AddUint64(&mmPublishGlobalAlias.afterPublishGlobalAliasCounter, 1)

	if mmPublishGlobalAlias.inspectFuncPublishGlobalAlias != nil {
		mmPublishGlobalAlias.inspectFuncPublishGlobalAlias(key)
	}

	mm_params := &InitializationContextMockPublishGlobalAliasParams{key}

	// Record call args
	mmPublishGlobalAlias.PublishGlobalAliasMock.mutex.Lock()
	mmPublishGlobalAlias.PublishGlobalAliasMock.callArgs = append(mmPublishGlobalAlias.PublishGlobalAliasMock.callArgs, mm_params)
	mmPublishGlobalAlias.PublishGlobalAliasMock.mutex.Unlock()

	for _, e := range mmPublishGlobalAlias.PublishGlobalAliasMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmPublishGlobalAlias.PublishGlobalAliasMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublishGlobalAlias.PublishGlobalAliasMock.defaultExpectation.Counter, 1)
		mm_want := mmPublishGlobalAlias.PublishGlobalAliasMock.defaultExpectation.params
		mm_got := InitializationContextMockPublishGlobalAliasParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPublishGlobalAlias.t.Errorf("InitializationContextMock.PublishGlobalAlias got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPublishGlobalAlias.PublishGlobalAliasMock.defaultExpectation.results
		if mm_results == nil {
			mmPublishGlobalAlias.t.Fatal("No results are set for the InitializationContextMock.PublishGlobalAlias")
		}
		return (*mm_results).b1
	}
	if mmPublishGlobalAlias.funcPublishGlobalAlias != nil {
		return mmPublishGlobalAlias.funcPublishGlobalAlias(key)
	}
	mmPublishGlobalAlias.t.Fatalf("Unexpected call to InitializationContextMock.PublishGlobalAlias. %v", key)
	return
}

// PublishGlobalAliasAfterCounter returns a count of finished InitializationContextMock.PublishGlobalAlias invocations
func (mmPublishGlobalAlias *InitializationContextMock) PublishGlobalAliasAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishGlobalAlias.afterPublishGlobalAliasCounter)
}

// PublishGlobalAliasBeforeCounter returns a count of InitializationContextMock.PublishGlobalAlias invocations
func (mmPublishGlobalAlias *InitializationContextMock) PublishGlobalAliasBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishGlobalAlias.beforePublishGlobalAliasCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.PublishGlobalAlias.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPublishGlobalAlias *mInitializationContextMockPublishGlobalAlias) Calls() []*InitializationContextMockPublishGlobalAliasParams {
	mmPublishGlobalAlias.mutex.RLock()

	argCopy := make([]*InitializationContextMockPublishGlobalAliasParams, len(mmPublishGlobalAlias.callArgs))
	copy(argCopy, mmPublishGlobalAlias.callArgs)

	mmPublishGlobalAlias.mutex.RUnlock()

	return argCopy
}

// MinimockPublishGlobalAliasDone returns true if the count of the PublishGlobalAlias invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockPublishGlobalAliasDone() bool {
	for _, e := range m.PublishGlobalAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishGlobalAliasMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublishGlobalAlias != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasCounter) < 1 {
		return false
	}
	return true
}

// MinimockPublishGlobalAliasInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockPublishGlobalAliasInspect() {
	for _, e := range m.PublishGlobalAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.PublishGlobalAlias with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishGlobalAliasMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasCounter) < 1 {
		if m.PublishGlobalAliasMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.PublishGlobalAlias")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.PublishGlobalAlias with params: %#v", *m.PublishGlobalAliasMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublishGlobalAlias != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.PublishGlobalAlias")
	}
}

type mInitializationContextMockPublishGlobalAliasAndBargeIn struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockPublishGlobalAliasAndBargeInExpectation
	expectations       []*InitializationContextMockPublishGlobalAliasAndBargeInExpectation

	callArgs []*InitializationContextMockPublishGlobalAliasAndBargeInParams
	mutex    sync.RWMutex
}

// InitializationContextMockPublishGlobalAliasAndBargeInExpectation specifies expectation struct of the InitializationContext.PublishGlobalAliasAndBargeIn
type InitializationContextMockPublishGlobalAliasAndBargeInExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockPublishGlobalAliasAndBargeInParams
	results *InitializationContextMockPublishGlobalAliasAndBargeInResults
	Counter uint64
}

// InitializationContextMockPublishGlobalAliasAndBargeInParams contains parameters of the InitializationContext.PublishGlobalAliasAndBargeIn
type InitializationContextMockPublishGlobalAliasAndBargeInParams struct {
	key     interface{}
	handler BargeInHolder
}

// InitializationContextMockPublishGlobalAliasAndBargeInResults contains results of the InitializationContext.PublishGlobalAliasAndBargeIn
type InitializationContextMockPublishGlobalAliasAndBargeInResults struct {
	b1 bool
}

// Expect sets up expected params for InitializationContext.PublishGlobalAliasAndBargeIn
func (mmPublishGlobalAliasAndBargeIn *mInitializationContextMockPublishGlobalAliasAndBargeIn) Expect(key interface{}, handler BargeInHolder) *mInitializationContextMockPublishGlobalAliasAndBargeIn {
	if mmPublishGlobalAliasAndBargeIn.mock.funcPublishGlobalAliasAndBargeIn != nil {
		mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("InitializationContextMock.PublishGlobalAliasAndBargeIn mock is already set by Set")
	}

	if mmPublishGlobalAliasAndBargeIn.defaultExpectation == nil {
		mmPublishGlobalAliasAndBargeIn.defaultExpectation = &InitializationContextMockPublishGlobalAliasAndBargeInExpectation{}
	}

	mmPublishGlobalAliasAndBargeIn.defaultExpectation.params = &InitializationContextMockPublishGlobalAliasAndBargeInParams{key, handler}
	for _, e := range mmPublishGlobalAliasAndBargeIn.expectations {
		if minimock.Equal(e.params, mmPublishGlobalAliasAndBargeIn.defaultExpectation.params) {
			mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPublishGlobalAliasAndBargeIn.defaultExpectation.params)
		}
	}

	return mmPublishGlobalAliasAndBargeIn
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.PublishGlobalAliasAndBargeIn
func (mmPublishGlobalAliasAndBargeIn *mInitializationContextMockPublishGlobalAliasAndBargeIn) Inspect(f func(key interface{}, handler BargeInHolder)) *mInitializationContextMockPublishGlobalAliasAndBargeIn {
	if mmPublishGlobalAliasAndBargeIn.mock.inspectFuncPublishGlobalAliasAndBargeIn != nil {
		mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.PublishGlobalAliasAndBargeIn")
	}

	mmPublishGlobalAliasAndBargeIn.mock.inspectFuncPublishGlobalAliasAndBargeIn = f

	return mmPublishGlobalAliasAndBargeIn
}

// Return sets up results that will be returned by InitializationContext.PublishGlobalAliasAndBargeIn
func (mmPublishGlobalAliasAndBargeIn *mInitializationContextMockPublishGlobalAliasAndBargeIn) Return(b1 bool) *InitializationContextMock {
	if mmPublishGlobalAliasAndBargeIn.mock.funcPublishGlobalAliasAndBargeIn != nil {
		mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("InitializationContextMock.PublishGlobalAliasAndBargeIn mock is already set by Set")
	}

	if mmPublishGlobalAliasAndBargeIn.defaultExpectation == nil {
		mmPublishGlobalAliasAndBargeIn.defaultExpectation = &InitializationContextMockPublishGlobalAliasAndBargeInExpectation{mock: mmPublishGlobalAliasAndBargeIn.mock}
	}
	mmPublishGlobalAliasAndBargeIn.defaultExpectation.results = &InitializationContextMockPublishGlobalAliasAndBargeInResults{b1}
	return mmPublishGlobalAliasAndBargeIn.mock
}

//Set uses given function f to mock the InitializationContext.PublishGlobalAliasAndBargeIn method
func (mmPublishGlobalAliasAndBargeIn *mInitializationContextMockPublishGlobalAliasAndBargeIn) Set(f func(key interface{}, handler BargeInHolder) (b1 bool)) *InitializationContextMock {
	if mmPublishGlobalAliasAndBargeIn.defaultExpectation != nil {
		mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("Default expectation is already set for the InitializationContext.PublishGlobalAliasAndBargeIn method")
	}

	if len(mmPublishGlobalAliasAndBargeIn.expectations) > 0 {
		mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("Some expectations are already set for the InitializationContext.PublishGlobalAliasAndBargeIn method")
	}

	mmPublishGlobalAliasAndBargeIn.mock.funcPublishGlobalAliasAndBargeIn = f
	return mmPublishGlobalAliasAndBargeIn.mock
}

// When sets expectation for the InitializationContext.PublishGlobalAliasAndBargeIn which will trigger the result defined by the following
// Then helper
func (mmPublishGlobalAliasAndBargeIn *mInitializationContextMockPublishGlobalAliasAndBargeIn) When(key interface{}, handler BargeInHolder) *InitializationContextMockPublishGlobalAliasAndBargeInExpectation {
	if mmPublishGlobalAliasAndBargeIn.mock.funcPublishGlobalAliasAndBargeIn != nil {
		mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("InitializationContextMock.PublishGlobalAliasAndBargeIn mock is already set by Set")
	}

	expectation := &InitializationContextMockPublishGlobalAliasAndBargeInExpectation{
		mock:   mmPublishGlobalAliasAndBargeIn.mock,
		params: &InitializationContextMockPublishGlobalAliasAndBargeInParams{key, handler},
	}
	mmPublishGlobalAliasAndBargeIn.expectations = append(mmPublishGlobalAliasAndBargeIn.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.PublishGlobalAliasAndBargeIn return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockPublishGlobalAliasAndBargeInExpectation) Then(b1 bool) *InitializationContextMock {
	e.results = &InitializationContextMockPublishGlobalAliasAndBargeInResults{b1}
	return e.mock
}

// PublishGlobalAliasAndBargeIn implements InitializationContext
func (mmPublishGlobalAliasAndBargeIn *InitializationContextMock) PublishGlobalAliasAndBargeIn(key interface{}, handler BargeInHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmPublishGlobalAliasAndBargeIn.beforePublishGlobalAliasAndBargeInCounter, 1)
	defer mm_atomic.AddUint64(&mmPublishGlobalAliasAndBargeIn.afterPublishGlobalAliasAndBargeInCounter, 1)

	if mmPublishGlobalAliasAndBargeIn.inspectFuncPublishGlobalAliasAndBargeIn != nil {
		mmPublishGlobalAliasAndBargeIn.inspectFuncPublishGlobalAliasAndBargeIn(key, handler)
	}

	mm_params := &InitializationContextMockPublishGlobalAliasAndBargeInParams{key, handler}

	// Record call args
	mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.mutex.Lock()
	mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.callArgs = append(mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.callArgs, mm_params)
	mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.mutex.Unlock()

	for _, e := range mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.defaultExpectation.Counter, 1)
		mm_want := mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.defaultExpectation.params
		mm_got := InitializationContextMockPublishGlobalAliasAndBargeInParams{key, handler}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPublishGlobalAliasAndBargeIn.t.Errorf("InitializationContextMock.PublishGlobalAliasAndBargeIn got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.defaultExpectation.results
		if mm_results == nil {
			mmPublishGlobalAliasAndBargeIn.t.Fatal("No results are set for the InitializationContextMock.PublishGlobalAliasAndBargeIn")
		}
		return (*mm_results).b1
	}
	if mmPublishGlobalAliasAndBargeIn.funcPublishGlobalAliasAndBargeIn != nil {
		return mmPublishGlobalAliasAndBargeIn.funcPublishGlobalAliasAndBargeIn(key, handler)
	}
	mmPublishGlobalAliasAndBargeIn.t.Fatalf("Unexpected call to InitializationContextMock.PublishGlobalAliasAndBargeIn. %v %v", key, handler)
	return
}

// PublishGlobalAliasAndBargeInAfterCounter returns a count of finished InitializationContextMock.PublishGlobalAliasAndBargeIn invocations
func (mmPublishGlobalAliasAndBargeIn *InitializationContextMock) PublishGlobalAliasAndBargeInAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishGlobalAliasAndBargeIn.afterPublishGlobalAliasAndBargeInCounter)
}

// PublishGlobalAliasAndBargeInBeforeCounter returns a count of InitializationContextMock.PublishGlobalAliasAndBargeIn invocations
func (mmPublishGlobalAliasAndBargeIn *InitializationContextMock) PublishGlobalAliasAndBargeInBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishGlobalAliasAndBargeIn.beforePublishGlobalAliasAndBargeInCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.PublishGlobalAliasAndBargeIn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPublishGlobalAliasAndBargeIn *mInitializationContextMockPublishGlobalAliasAndBargeIn) Calls() []*InitializationContextMockPublishGlobalAliasAndBargeInParams {
	mmPublishGlobalAliasAndBargeIn.mutex.RLock()

	argCopy := make([]*InitializationContextMockPublishGlobalAliasAndBargeInParams, len(mmPublishGlobalAliasAndBargeIn.callArgs))
	copy(argCopy, mmPublishGlobalAliasAndBargeIn.callArgs)

	mmPublishGlobalAliasAndBargeIn.mutex.RUnlock()

	return argCopy
}

// MinimockPublishGlobalAliasAndBargeInDone returns true if the count of the PublishGlobalAliasAndBargeIn invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockPublishGlobalAliasAndBargeInDone() bool {
	for _, e := range m.PublishGlobalAliasAndBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishGlobalAliasAndBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasAndBargeInCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublishGlobalAliasAndBargeIn != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasAndBargeInCounter) < 1 {
		return false
	}
	return true
}

// MinimockPublishGlobalAliasAndBargeInInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockPublishGlobalAliasAndBargeInInspect() {
	for _, e := range m.PublishGlobalAliasAndBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.PublishGlobalAliasAndBargeIn with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishGlobalAliasAndBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasAndBargeInCounter) < 1 {
		if m.PublishGlobalAliasAndBargeInMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.PublishGlobalAliasAndBargeIn")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.PublishGlobalAliasAndBargeIn with params: %#v", *m.PublishGlobalAliasAndBargeInMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublishGlobalAliasAndBargeIn != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasAndBargeInCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.PublishGlobalAliasAndBargeIn")
	}
}

type mInitializationContextMockRelease struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockReleaseExpectation
	expectations       []*InitializationContextMockReleaseExpectation

	callArgs []*InitializationContextMockReleaseParams
	mutex    sync.RWMutex
}

// InitializationContextMockReleaseExpectation specifies expectation struct of the InitializationContext.Release
type InitializationContextMockReleaseExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockReleaseParams
	results *InitializationContextMockReleaseResults
	Counter uint64
}

// InitializationContextMockReleaseParams contains parameters of the InitializationContext.Release
type InitializationContextMockReleaseParams struct {
	s1 SyncLink
}

// InitializationContextMockReleaseResults contains results of the InitializationContext.Release
type InitializationContextMockReleaseResults struct {
	b1 bool
}

// Expect sets up expected params for InitializationContext.Release
func (mmRelease *mInitializationContextMockRelease) Expect(s1 SyncLink) *mInitializationContextMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("InitializationContextMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &InitializationContextMockReleaseExpectation{}
	}

	mmRelease.defaultExpectation.params = &InitializationContextMockReleaseParams{s1}
	for _, e := range mmRelease.expectations {
		if minimock.Equal(e.params, mmRelease.defaultExpectation.params) {
			mmRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRelease.defaultExpectation.params)
		}
	}

	return mmRelease
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.Release
func (mmRelease *mInitializationContextMockRelease) Inspect(f func(s1 SyncLink)) *mInitializationContextMockRelease {
	if mmRelease.mock.inspectFuncRelease != nil {
		mmRelease.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.Release")
	}

	mmRelease.mock.inspectFuncRelease = f

	return mmRelease
}

// Return sets up results that will be returned by InitializationContext.Release
func (mmRelease *mInitializationContextMockRelease) Return(b1 bool) *InitializationContextMock {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("InitializationContextMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &InitializationContextMockReleaseExpectation{mock: mmRelease.mock}
	}
	mmRelease.defaultExpectation.results = &InitializationContextMockReleaseResults{b1}
	return mmRelease.mock
}

//Set uses given function f to mock the InitializationContext.Release method
func (mmRelease *mInitializationContextMockRelease) Set(f func(s1 SyncLink) (b1 bool)) *InitializationContextMock {
	if mmRelease.defaultExpectation != nil {
		mmRelease.mock.t.Fatalf("Default expectation is already set for the InitializationContext.Release method")
	}

	if len(mmRelease.expectations) > 0 {
		mmRelease.mock.t.Fatalf("Some expectations are already set for the InitializationContext.Release method")
	}

	mmRelease.mock.funcRelease = f
	return mmRelease.mock
}

// When sets expectation for the InitializationContext.Release which will trigger the result defined by the following
// Then helper
func (mmRelease *mInitializationContextMockRelease) When(s1 SyncLink) *InitializationContextMockReleaseExpectation {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("InitializationContextMock.Release mock is already set by Set")
	}

	expectation := &InitializationContextMockReleaseExpectation{
		mock:   mmRelease.mock,
		params: &InitializationContextMockReleaseParams{s1},
	}
	mmRelease.expectations = append(mmRelease.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.Release return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockReleaseExpectation) Then(b1 bool) *InitializationContextMock {
	e.results = &InitializationContextMockReleaseResults{b1}
	return e.mock
}

// Release implements InitializationContext
func (mmRelease *InitializationContextMock) Release(s1 SyncLink) (b1 bool) {
	mm_atomic.AddUint64(&mmRelease.beforeReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmRelease.afterReleaseCounter, 1)

	if mmRelease.inspectFuncRelease != nil {
		mmRelease.inspectFuncRelease(s1)
	}

	mm_params := &InitializationContextMockReleaseParams{s1}

	// Record call args
	mmRelease.ReleaseMock.mutex.Lock()
	mmRelease.ReleaseMock.callArgs = append(mmRelease.ReleaseMock.callArgs, mm_params)
	mmRelease.ReleaseMock.mutex.Unlock()

	for _, e := range mmRelease.ReleaseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmRelease.ReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRelease.ReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmRelease.ReleaseMock.defaultExpectation.params
		mm_got := InitializationContextMockReleaseParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRelease.t.Errorf("InitializationContextMock.Release got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRelease.ReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmRelease.t.Fatal("No results are set for the InitializationContextMock.Release")
		}
		return (*mm_results).b1
	}
	if mmRelease.funcRelease != nil {
		return mmRelease.funcRelease(s1)
	}
	mmRelease.t.Fatalf("Unexpected call to InitializationContextMock.Release. %v", s1)
	return
}

// ReleaseAfterCounter returns a count of finished InitializationContextMock.Release invocations
func (mmRelease *InitializationContextMock) ReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.afterReleaseCounter)
}

// ReleaseBeforeCounter returns a count of InitializationContextMock.Release invocations
func (mmRelease *InitializationContextMock) ReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.beforeReleaseCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.Release.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRelease *mInitializationContextMockRelease) Calls() []*InitializationContextMockReleaseParams {
	mmRelease.mutex.RLock()

	argCopy := make([]*InitializationContextMockReleaseParams, len(mmRelease.callArgs))
	copy(argCopy, mmRelease.callArgs)

	mmRelease.mutex.RUnlock()

	return argCopy
}

// MinimockReleaseDone returns true if the count of the Release invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockReleaseDone() bool {
	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReleaseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRelease != nil && mm_atomic.LoadUint64(&m.afterReleaseCounter) < 1 {
		return false
	}
	return true
}

// MinimockReleaseInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockReleaseInspect() {
	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.Release with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReleaseCounter) < 1 {
		if m.ReleaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.Release")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.Release with params: %#v", *m.ReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRelease != nil && mm_atomic.LoadUint64(&m.afterReleaseCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.Release")
	}
}

type mInitializationContextMockReleaseAll struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockReleaseAllExpectation
	expectations       []*InitializationContextMockReleaseAllExpectation
}

// InitializationContextMockReleaseAllExpectation specifies expectation struct of the InitializationContext.ReleaseAll
type InitializationContextMockReleaseAllExpectation struct {
	mock *InitializationContextMock

	results *InitializationContextMockReleaseAllResults
	Counter uint64
}

// InitializationContextMockReleaseAllResults contains results of the InitializationContext.ReleaseAll
type InitializationContextMockReleaseAllResults struct {
	b1 bool
}

// Expect sets up expected params for InitializationContext.ReleaseAll
func (mmReleaseAll *mInitializationContextMockReleaseAll) Expect() *mInitializationContextMockReleaseAll {
	if mmReleaseAll.mock.funcReleaseAll != nil {
		mmReleaseAll.mock.t.Fatalf("InitializationContextMock.ReleaseAll mock is already set by Set")
	}

	if mmReleaseAll.defaultExpectation == nil {
		mmReleaseAll.defaultExpectation = &InitializationContextMockReleaseAllExpectation{}
	}

	return mmReleaseAll
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.ReleaseAll
func (mmReleaseAll *mInitializationContextMockReleaseAll) Inspect(f func()) *mInitializationContextMockReleaseAll {
	if mmReleaseAll.mock.inspectFuncReleaseAll != nil {
		mmReleaseAll.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.ReleaseAll")
	}

	mmReleaseAll.mock.inspectFuncReleaseAll = f

	return mmReleaseAll
}

// Return sets up results that will be returned by InitializationContext.ReleaseAll
func (mmReleaseAll *mInitializationContextMockReleaseAll) Return(b1 bool) *InitializationContextMock {
	if mmReleaseAll.mock.funcReleaseAll != nil {
		mmReleaseAll.mock.t.Fatalf("InitializationContextMock.ReleaseAll mock is already set by Set")
	}

	if mmReleaseAll.defaultExpectation == nil {
		mmReleaseAll.defaultExpectation = &InitializationContextMockReleaseAllExpectation{mock: mmReleaseAll.mock}
	}
	mmReleaseAll.defaultExpectation.results = &InitializationContextMockReleaseAllResults{b1}
	return mmReleaseAll.mock
}

//Set uses given function f to mock the InitializationContext.ReleaseAll method
func (mmReleaseAll *mInitializationContextMockReleaseAll) Set(f func() (b1 bool)) *InitializationContextMock {
	if mmReleaseAll.defaultExpectation != nil {
		mmReleaseAll.mock.t.Fatalf("Default expectation is already set for the InitializationContext.ReleaseAll method")
	}

	if len(mmReleaseAll.expectations) > 0 {
		mmReleaseAll.mock.t.Fatalf("Some expectations are already set for the InitializationContext.ReleaseAll method")
	}

	mmReleaseAll.mock.funcReleaseAll = f
	return mmReleaseAll.mock
}

// ReleaseAll implements InitializationContext
func (mmReleaseAll *InitializationContextMock) ReleaseAll() (b1 bool) {
	mm_atomic.AddUint64(&mmReleaseAll.beforeReleaseAllCounter, 1)
	defer mm_atomic.AddUint64(&mmReleaseAll.afterReleaseAllCounter, 1)

	if mmReleaseAll.inspectFuncReleaseAll != nil {
		mmReleaseAll.inspectFuncReleaseAll()
	}

	if mmReleaseAll.ReleaseAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReleaseAll.ReleaseAllMock.defaultExpectation.Counter, 1)

		mm_results := mmReleaseAll.ReleaseAllMock.defaultExpectation.results
		if mm_results == nil {
			mmReleaseAll.t.Fatal("No results are set for the InitializationContextMock.ReleaseAll")
		}
		return (*mm_results).b1
	}
	if mmReleaseAll.funcReleaseAll != nil {
		return mmReleaseAll.funcReleaseAll()
	}
	mmReleaseAll.t.Fatalf("Unexpected call to InitializationContextMock.ReleaseAll.")
	return
}

// ReleaseAllAfterCounter returns a count of finished InitializationContextMock.ReleaseAll invocations
func (mmReleaseAll *InitializationContextMock) ReleaseAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReleaseAll.afterReleaseAllCounter)
}

// ReleaseAllBeforeCounter returns a count of InitializationContextMock.ReleaseAll invocations
func (mmReleaseAll *InitializationContextMock) ReleaseAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReleaseAll.beforeReleaseAllCounter)
}

// MinimockReleaseAllDone returns true if the count of the ReleaseAll invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockReleaseAllDone() bool {
	for _, e := range m.ReleaseAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReleaseAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReleaseAll != nil && mm_atomic.LoadUint64(&m.afterReleaseAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockReleaseAllInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockReleaseAllInspect() {
	for _, e := range m.ReleaseAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to InitializationContextMock.ReleaseAll")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReleaseAllCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.ReleaseAll")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReleaseAll != nil && mm_atomic.LoadUint64(&m.afterReleaseAllCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.ReleaseAll")
	}
}

type mInitializationContextMockSetDefaultErrorHandler struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockSetDefaultErrorHandlerExpectation
	expectations       []*InitializationContextMockSetDefaultErrorHandlerExpectation

	callArgs []*InitializationContextMockSetDefaultErrorHandlerParams
	mutex    sync.RWMutex
}

// InitializationContextMockSetDefaultErrorHandlerExpectation specifies expectation struct of the InitializationContext.SetDefaultErrorHandler
type InitializationContextMockSetDefaultErrorHandlerExpectation struct {
	mock   *InitializationContextMock
	params *InitializationContextMockSetDefaultErrorHandlerParams

	Counter uint64
}

// InitializationContextMockSetDefaultErrorHandlerParams contains parameters of the InitializationContext.SetDefaultErrorHandler
type InitializationContextMockSetDefaultErrorHandlerParams struct {
	fn ErrorHandlerFunc
}

// Expect sets up expected params for InitializationContext.SetDefaultErrorHandler
func (mmSetDefaultErrorHandler *mInitializationContextMockSetDefaultErrorHandler) Expect(fn ErrorHandlerFunc) *mInitializationContextMockSetDefaultErrorHandler {
	if mmSetDefaultErrorHandler.mock.funcSetDefaultErrorHandler != nil {
		mmSetDefaultErrorHandler.mock.t.Fatalf("InitializationContextMock.SetDefaultErrorHandler mock is already set by Set")
	}

	if mmSetDefaultErrorHandler.defaultExpectation == nil {
		mmSetDefaultErrorHandler.defaultExpectation = &InitializationContextMockSetDefaultErrorHandlerExpectation{}
	}

	mmSetDefaultErrorHandler.defaultExpectation.params = &InitializationContextMockSetDefaultErrorHandlerParams{fn}
	for _, e := range mmSetDefaultErrorHandler.expectations {
		if minimock.Equal(e.params, mmSetDefaultErrorHandler.defaultExpectation.params) {
			mmSetDefaultErrorHandler.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetDefaultErrorHandler.defaultExpectation.params)
		}
	}

	return mmSetDefaultErrorHandler
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.SetDefaultErrorHandler
func (mmSetDefaultErrorHandler *mInitializationContextMockSetDefaultErrorHandler) Inspect(f func(fn ErrorHandlerFunc)) *mInitializationContextMockSetDefaultErrorHandler {
	if mmSetDefaultErrorHandler.mock.inspectFuncSetDefaultErrorHandler != nil {
		mmSetDefaultErrorHandler.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.SetDefaultErrorHandler")
	}

	mmSetDefaultErrorHandler.mock.inspectFuncSetDefaultErrorHandler = f

	return mmSetDefaultErrorHandler
}

// Return sets up results that will be returned by InitializationContext.SetDefaultErrorHandler
func (mmSetDefaultErrorHandler *mInitializationContextMockSetDefaultErrorHandler) Return() *InitializationContextMock {
	if mmSetDefaultErrorHandler.mock.funcSetDefaultErrorHandler != nil {
		mmSetDefaultErrorHandler.mock.t.Fatalf("InitializationContextMock.SetDefaultErrorHandler mock is already set by Set")
	}

	if mmSetDefaultErrorHandler.defaultExpectation == nil {
		mmSetDefaultErrorHandler.defaultExpectation = &InitializationContextMockSetDefaultErrorHandlerExpectation{mock: mmSetDefaultErrorHandler.mock}
	}

	return mmSetDefaultErrorHandler.mock
}

//Set uses given function f to mock the InitializationContext.SetDefaultErrorHandler method
func (mmSetDefaultErrorHandler *mInitializationContextMockSetDefaultErrorHandler) Set(f func(fn ErrorHandlerFunc)) *InitializationContextMock {
	if mmSetDefaultErrorHandler.defaultExpectation != nil {
		mmSetDefaultErrorHandler.mock.t.Fatalf("Default expectation is already set for the InitializationContext.SetDefaultErrorHandler method")
	}

	if len(mmSetDefaultErrorHandler.expectations) > 0 {
		mmSetDefaultErrorHandler.mock.t.Fatalf("Some expectations are already set for the InitializationContext.SetDefaultErrorHandler method")
	}

	mmSetDefaultErrorHandler.mock.funcSetDefaultErrorHandler = f
	return mmSetDefaultErrorHandler.mock
}

// SetDefaultErrorHandler implements InitializationContext
func (mmSetDefaultErrorHandler *InitializationContextMock) SetDefaultErrorHandler(fn ErrorHandlerFunc) {
	mm_atomic.AddUint64(&mmSetDefaultErrorHandler.beforeSetDefaultErrorHandlerCounter, 1)
	defer mm_atomic.AddUint64(&mmSetDefaultErrorHandler.afterSetDefaultErrorHandlerCounter, 1)

	if mmSetDefaultErrorHandler.inspectFuncSetDefaultErrorHandler != nil {
		mmSetDefaultErrorHandler.inspectFuncSetDefaultErrorHandler(fn)
	}

	mm_params := &InitializationContextMockSetDefaultErrorHandlerParams{fn}

	// Record call args
	mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.mutex.Lock()
	mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.callArgs = append(mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.callArgs, mm_params)
	mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.mutex.Unlock()

	for _, e := range mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.defaultExpectation.Counter, 1)
		mm_want := mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.defaultExpectation.params
		mm_got := InitializationContextMockSetDefaultErrorHandlerParams{fn}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetDefaultErrorHandler.t.Errorf("InitializationContextMock.SetDefaultErrorHandler got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetDefaultErrorHandler.funcSetDefaultErrorHandler != nil {
		mmSetDefaultErrorHandler.funcSetDefaultErrorHandler(fn)
		return
	}
	mmSetDefaultErrorHandler.t.Fatalf("Unexpected call to InitializationContextMock.SetDefaultErrorHandler. %v", fn)

}

// SetDefaultErrorHandlerAfterCounter returns a count of finished InitializationContextMock.SetDefaultErrorHandler invocations
func (mmSetDefaultErrorHandler *InitializationContextMock) SetDefaultErrorHandlerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultErrorHandler.afterSetDefaultErrorHandlerCounter)
}

// SetDefaultErrorHandlerBeforeCounter returns a count of InitializationContextMock.SetDefaultErrorHandler invocations
func (mmSetDefaultErrorHandler *InitializationContextMock) SetDefaultErrorHandlerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultErrorHandler.beforeSetDefaultErrorHandlerCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.SetDefaultErrorHandler.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetDefaultErrorHandler *mInitializationContextMockSetDefaultErrorHandler) Calls() []*InitializationContextMockSetDefaultErrorHandlerParams {
	mmSetDefaultErrorHandler.mutex.RLock()

	argCopy := make([]*InitializationContextMockSetDefaultErrorHandlerParams, len(mmSetDefaultErrorHandler.callArgs))
	copy(argCopy, mmSetDefaultErrorHandler.callArgs)

	mmSetDefaultErrorHandler.mutex.RUnlock()

	return argCopy
}

// MinimockSetDefaultErrorHandlerDone returns true if the count of the SetDefaultErrorHandler invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockSetDefaultErrorHandlerDone() bool {
	for _, e := range m.SetDefaultErrorHandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultErrorHandlerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultErrorHandlerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultErrorHandler != nil && mm_atomic.LoadUint64(&m.afterSetDefaultErrorHandlerCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetDefaultErrorHandlerInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockSetDefaultErrorHandlerInspect() {
	for _, e := range m.SetDefaultErrorHandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.SetDefaultErrorHandler with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultErrorHandlerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultErrorHandlerCounter) < 1 {
		if m.SetDefaultErrorHandlerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.SetDefaultErrorHandler")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.SetDefaultErrorHandler with params: %#v", *m.SetDefaultErrorHandlerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultErrorHandler != nil && mm_atomic.LoadUint64(&m.afterSetDefaultErrorHandlerCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.SetDefaultErrorHandler")
	}
}

type mInitializationContextMockSetDefaultFlags struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockSetDefaultFlagsExpectation
	expectations       []*InitializationContextMockSetDefaultFlagsExpectation

	callArgs []*InitializationContextMockSetDefaultFlagsParams
	mutex    sync.RWMutex
}

// InitializationContextMockSetDefaultFlagsExpectation specifies expectation struct of the InitializationContext.SetDefaultFlags
type InitializationContextMockSetDefaultFlagsExpectation struct {
	mock   *InitializationContextMock
	params *InitializationContextMockSetDefaultFlagsParams

	Counter uint64
}

// InitializationContextMockSetDefaultFlagsParams contains parameters of the InitializationContext.SetDefaultFlags
type InitializationContextMockSetDefaultFlagsParams struct {
	s1 StepFlags
}

// Expect sets up expected params for InitializationContext.SetDefaultFlags
func (mmSetDefaultFlags *mInitializationContextMockSetDefaultFlags) Expect(s1 StepFlags) *mInitializationContextMockSetDefaultFlags {
	if mmSetDefaultFlags.mock.funcSetDefaultFlags != nil {
		mmSetDefaultFlags.mock.t.Fatalf("InitializationContextMock.SetDefaultFlags mock is already set by Set")
	}

	if mmSetDefaultFlags.defaultExpectation == nil {
		mmSetDefaultFlags.defaultExpectation = &InitializationContextMockSetDefaultFlagsExpectation{}
	}

	mmSetDefaultFlags.defaultExpectation.params = &InitializationContextMockSetDefaultFlagsParams{s1}
	for _, e := range mmSetDefaultFlags.expectations {
		if minimock.Equal(e.params, mmSetDefaultFlags.defaultExpectation.params) {
			mmSetDefaultFlags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetDefaultFlags.defaultExpectation.params)
		}
	}

	return mmSetDefaultFlags
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.SetDefaultFlags
func (mmSetDefaultFlags *mInitializationContextMockSetDefaultFlags) Inspect(f func(s1 StepFlags)) *mInitializationContextMockSetDefaultFlags {
	if mmSetDefaultFlags.mock.inspectFuncSetDefaultFlags != nil {
		mmSetDefaultFlags.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.SetDefaultFlags")
	}

	mmSetDefaultFlags.mock.inspectFuncSetDefaultFlags = f

	return mmSetDefaultFlags
}

// Return sets up results that will be returned by InitializationContext.SetDefaultFlags
func (mmSetDefaultFlags *mInitializationContextMockSetDefaultFlags) Return() *InitializationContextMock {
	if mmSetDefaultFlags.mock.funcSetDefaultFlags != nil {
		mmSetDefaultFlags.mock.t.Fatalf("InitializationContextMock.SetDefaultFlags mock is already set by Set")
	}

	if mmSetDefaultFlags.defaultExpectation == nil {
		mmSetDefaultFlags.defaultExpectation = &InitializationContextMockSetDefaultFlagsExpectation{mock: mmSetDefaultFlags.mock}
	}

	return mmSetDefaultFlags.mock
}

//Set uses given function f to mock the InitializationContext.SetDefaultFlags method
func (mmSetDefaultFlags *mInitializationContextMockSetDefaultFlags) Set(f func(s1 StepFlags)) *InitializationContextMock {
	if mmSetDefaultFlags.defaultExpectation != nil {
		mmSetDefaultFlags.mock.t.Fatalf("Default expectation is already set for the InitializationContext.SetDefaultFlags method")
	}

	if len(mmSetDefaultFlags.expectations) > 0 {
		mmSetDefaultFlags.mock.t.Fatalf("Some expectations are already set for the InitializationContext.SetDefaultFlags method")
	}

	mmSetDefaultFlags.mock.funcSetDefaultFlags = f
	return mmSetDefaultFlags.mock
}

// SetDefaultFlags implements InitializationContext
func (mmSetDefaultFlags *InitializationContextMock) SetDefaultFlags(s1 StepFlags) {
	mm_atomic.AddUint64(&mmSetDefaultFlags.beforeSetDefaultFlagsCounter, 1)
	defer mm_atomic.AddUint64(&mmSetDefaultFlags.afterSetDefaultFlagsCounter, 1)

	if mmSetDefaultFlags.inspectFuncSetDefaultFlags != nil {
		mmSetDefaultFlags.inspectFuncSetDefaultFlags(s1)
	}

	mm_params := &InitializationContextMockSetDefaultFlagsParams{s1}

	// Record call args
	mmSetDefaultFlags.SetDefaultFlagsMock.mutex.Lock()
	mmSetDefaultFlags.SetDefaultFlagsMock.callArgs = append(mmSetDefaultFlags.SetDefaultFlagsMock.callArgs, mm_params)
	mmSetDefaultFlags.SetDefaultFlagsMock.mutex.Unlock()

	for _, e := range mmSetDefaultFlags.SetDefaultFlagsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetDefaultFlags.SetDefaultFlagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetDefaultFlags.SetDefaultFlagsMock.defaultExpectation.Counter, 1)
		mm_want := mmSetDefaultFlags.SetDefaultFlagsMock.defaultExpectation.params
		mm_got := InitializationContextMockSetDefaultFlagsParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetDefaultFlags.t.Errorf("InitializationContextMock.SetDefaultFlags got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetDefaultFlags.funcSetDefaultFlags != nil {
		mmSetDefaultFlags.funcSetDefaultFlags(s1)
		return
	}
	mmSetDefaultFlags.t.Fatalf("Unexpected call to InitializationContextMock.SetDefaultFlags. %v", s1)

}

// SetDefaultFlagsAfterCounter returns a count of finished InitializationContextMock.SetDefaultFlags invocations
func (mmSetDefaultFlags *InitializationContextMock) SetDefaultFlagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultFlags.afterSetDefaultFlagsCounter)
}

// SetDefaultFlagsBeforeCounter returns a count of InitializationContextMock.SetDefaultFlags invocations
func (mmSetDefaultFlags *InitializationContextMock) SetDefaultFlagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultFlags.beforeSetDefaultFlagsCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.SetDefaultFlags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetDefaultFlags *mInitializationContextMockSetDefaultFlags) Calls() []*InitializationContextMockSetDefaultFlagsParams {
	mmSetDefaultFlags.mutex.RLock()

	argCopy := make([]*InitializationContextMockSetDefaultFlagsParams, len(mmSetDefaultFlags.callArgs))
	copy(argCopy, mmSetDefaultFlags.callArgs)

	mmSetDefaultFlags.mutex.RUnlock()

	return argCopy
}

// MinimockSetDefaultFlagsDone returns true if the count of the SetDefaultFlags invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockSetDefaultFlagsDone() bool {
	for _, e := range m.SetDefaultFlagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultFlagsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultFlagsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultFlags != nil && mm_atomic.LoadUint64(&m.afterSetDefaultFlagsCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetDefaultFlagsInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockSetDefaultFlagsInspect() {
	for _, e := range m.SetDefaultFlagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.SetDefaultFlags with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultFlagsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultFlagsCounter) < 1 {
		if m.SetDefaultFlagsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.SetDefaultFlags")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.SetDefaultFlags with params: %#v", *m.SetDefaultFlagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultFlags != nil && mm_atomic.LoadUint64(&m.afterSetDefaultFlagsCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.SetDefaultFlags")
	}
}

type mInitializationContextMockSetDefaultMigration struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockSetDefaultMigrationExpectation
	expectations       []*InitializationContextMockSetDefaultMigrationExpectation

	callArgs []*InitializationContextMockSetDefaultMigrationParams
	mutex    sync.RWMutex
}

// InitializationContextMockSetDefaultMigrationExpectation specifies expectation struct of the InitializationContext.SetDefaultMigration
type InitializationContextMockSetDefaultMigrationExpectation struct {
	mock   *InitializationContextMock
	params *InitializationContextMockSetDefaultMigrationParams

	Counter uint64
}

// InitializationContextMockSetDefaultMigrationParams contains parameters of the InitializationContext.SetDefaultMigration
type InitializationContextMockSetDefaultMigrationParams struct {
	fn MigrateFunc
}

// Expect sets up expected params for InitializationContext.SetDefaultMigration
func (mmSetDefaultMigration *mInitializationContextMockSetDefaultMigration) Expect(fn MigrateFunc) *mInitializationContextMockSetDefaultMigration {
	if mmSetDefaultMigration.mock.funcSetDefaultMigration != nil {
		mmSetDefaultMigration.mock.t.Fatalf("InitializationContextMock.SetDefaultMigration mock is already set by Set")
	}

	if mmSetDefaultMigration.defaultExpectation == nil {
		mmSetDefaultMigration.defaultExpectation = &InitializationContextMockSetDefaultMigrationExpectation{}
	}

	mmSetDefaultMigration.defaultExpectation.params = &InitializationContextMockSetDefaultMigrationParams{fn}
	for _, e := range mmSetDefaultMigration.expectations {
		if minimock.Equal(e.params, mmSetDefaultMigration.defaultExpectation.params) {
			mmSetDefaultMigration.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetDefaultMigration.defaultExpectation.params)
		}
	}

	return mmSetDefaultMigration
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.SetDefaultMigration
func (mmSetDefaultMigration *mInitializationContextMockSetDefaultMigration) Inspect(f func(fn MigrateFunc)) *mInitializationContextMockSetDefaultMigration {
	if mmSetDefaultMigration.mock.inspectFuncSetDefaultMigration != nil {
		mmSetDefaultMigration.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.SetDefaultMigration")
	}

	mmSetDefaultMigration.mock.inspectFuncSetDefaultMigration = f

	return mmSetDefaultMigration
}

// Return sets up results that will be returned by InitializationContext.SetDefaultMigration
func (mmSetDefaultMigration *mInitializationContextMockSetDefaultMigration) Return() *InitializationContextMock {
	if mmSetDefaultMigration.mock.funcSetDefaultMigration != nil {
		mmSetDefaultMigration.mock.t.Fatalf("InitializationContextMock.SetDefaultMigration mock is already set by Set")
	}

	if mmSetDefaultMigration.defaultExpectation == nil {
		mmSetDefaultMigration.defaultExpectation = &InitializationContextMockSetDefaultMigrationExpectation{mock: mmSetDefaultMigration.mock}
	}

	return mmSetDefaultMigration.mock
}

//Set uses given function f to mock the InitializationContext.SetDefaultMigration method
func (mmSetDefaultMigration *mInitializationContextMockSetDefaultMigration) Set(f func(fn MigrateFunc)) *InitializationContextMock {
	if mmSetDefaultMigration.defaultExpectation != nil {
		mmSetDefaultMigration.mock.t.Fatalf("Default expectation is already set for the InitializationContext.SetDefaultMigration method")
	}

	if len(mmSetDefaultMigration.expectations) > 0 {
		mmSetDefaultMigration.mock.t.Fatalf("Some expectations are already set for the InitializationContext.SetDefaultMigration method")
	}

	mmSetDefaultMigration.mock.funcSetDefaultMigration = f
	return mmSetDefaultMigration.mock
}

// SetDefaultMigration implements InitializationContext
func (mmSetDefaultMigration *InitializationContextMock) SetDefaultMigration(fn MigrateFunc) {
	mm_atomic.AddUint64(&mmSetDefaultMigration.beforeSetDefaultMigrationCounter, 1)
	defer mm_atomic.AddUint64(&mmSetDefaultMigration.afterSetDefaultMigrationCounter, 1)

	if mmSetDefaultMigration.inspectFuncSetDefaultMigration != nil {
		mmSetDefaultMigration.inspectFuncSetDefaultMigration(fn)
	}

	mm_params := &InitializationContextMockSetDefaultMigrationParams{fn}

	// Record call args
	mmSetDefaultMigration.SetDefaultMigrationMock.mutex.Lock()
	mmSetDefaultMigration.SetDefaultMigrationMock.callArgs = append(mmSetDefaultMigration.SetDefaultMigrationMock.callArgs, mm_params)
	mmSetDefaultMigration.SetDefaultMigrationMock.mutex.Unlock()

	for _, e := range mmSetDefaultMigration.SetDefaultMigrationMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetDefaultMigration.SetDefaultMigrationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetDefaultMigration.SetDefaultMigrationMock.defaultExpectation.Counter, 1)
		mm_want := mmSetDefaultMigration.SetDefaultMigrationMock.defaultExpectation.params
		mm_got := InitializationContextMockSetDefaultMigrationParams{fn}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetDefaultMigration.t.Errorf("InitializationContextMock.SetDefaultMigration got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetDefaultMigration.funcSetDefaultMigration != nil {
		mmSetDefaultMigration.funcSetDefaultMigration(fn)
		return
	}
	mmSetDefaultMigration.t.Fatalf("Unexpected call to InitializationContextMock.SetDefaultMigration. %v", fn)

}

// SetDefaultMigrationAfterCounter returns a count of finished InitializationContextMock.SetDefaultMigration invocations
func (mmSetDefaultMigration *InitializationContextMock) SetDefaultMigrationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultMigration.afterSetDefaultMigrationCounter)
}

// SetDefaultMigrationBeforeCounter returns a count of InitializationContextMock.SetDefaultMigration invocations
func (mmSetDefaultMigration *InitializationContextMock) SetDefaultMigrationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultMigration.beforeSetDefaultMigrationCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.SetDefaultMigration.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetDefaultMigration *mInitializationContextMockSetDefaultMigration) Calls() []*InitializationContextMockSetDefaultMigrationParams {
	mmSetDefaultMigration.mutex.RLock()

	argCopy := make([]*InitializationContextMockSetDefaultMigrationParams, len(mmSetDefaultMigration.callArgs))
	copy(argCopy, mmSetDefaultMigration.callArgs)

	mmSetDefaultMigration.mutex.RUnlock()

	return argCopy
}

// MinimockSetDefaultMigrationDone returns true if the count of the SetDefaultMigration invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockSetDefaultMigrationDone() bool {
	for _, e := range m.SetDefaultMigrationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultMigrationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultMigrationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultMigration != nil && mm_atomic.LoadUint64(&m.afterSetDefaultMigrationCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetDefaultMigrationInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockSetDefaultMigrationInspect() {
	for _, e := range m.SetDefaultMigrationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.SetDefaultMigration with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultMigrationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultMigrationCounter) < 1 {
		if m.SetDefaultMigrationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.SetDefaultMigration")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.SetDefaultMigration with params: %#v", *m.SetDefaultMigrationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultMigration != nil && mm_atomic.LoadUint64(&m.afterSetDefaultMigrationCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.SetDefaultMigration")
	}
}

type mInitializationContextMockSetDefaultTerminationResult struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockSetDefaultTerminationResultExpectation
	expectations       []*InitializationContextMockSetDefaultTerminationResultExpectation

	callArgs []*InitializationContextMockSetDefaultTerminationResultParams
	mutex    sync.RWMutex
}

// InitializationContextMockSetDefaultTerminationResultExpectation specifies expectation struct of the InitializationContext.SetDefaultTerminationResult
type InitializationContextMockSetDefaultTerminationResultExpectation struct {
	mock   *InitializationContextMock
	params *InitializationContextMockSetDefaultTerminationResultParams

	Counter uint64
}

// InitializationContextMockSetDefaultTerminationResultParams contains parameters of the InitializationContext.SetDefaultTerminationResult
type InitializationContextMockSetDefaultTerminationResultParams struct {
	p1 interface{}
}

// Expect sets up expected params for InitializationContext.SetDefaultTerminationResult
func (mmSetDefaultTerminationResult *mInitializationContextMockSetDefaultTerminationResult) Expect(p1 interface{}) *mInitializationContextMockSetDefaultTerminationResult {
	if mmSetDefaultTerminationResult.mock.funcSetDefaultTerminationResult != nil {
		mmSetDefaultTerminationResult.mock.t.Fatalf("InitializationContextMock.SetDefaultTerminationResult mock is already set by Set")
	}

	if mmSetDefaultTerminationResult.defaultExpectation == nil {
		mmSetDefaultTerminationResult.defaultExpectation = &InitializationContextMockSetDefaultTerminationResultExpectation{}
	}

	mmSetDefaultTerminationResult.defaultExpectation.params = &InitializationContextMockSetDefaultTerminationResultParams{p1}
	for _, e := range mmSetDefaultTerminationResult.expectations {
		if minimock.Equal(e.params, mmSetDefaultTerminationResult.defaultExpectation.params) {
			mmSetDefaultTerminationResult.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetDefaultTerminationResult.defaultExpectation.params)
		}
	}

	return mmSetDefaultTerminationResult
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.SetDefaultTerminationResult
func (mmSetDefaultTerminationResult *mInitializationContextMockSetDefaultTerminationResult) Inspect(f func(p1 interface{})) *mInitializationContextMockSetDefaultTerminationResult {
	if mmSetDefaultTerminationResult.mock.inspectFuncSetDefaultTerminationResult != nil {
		mmSetDefaultTerminationResult.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.SetDefaultTerminationResult")
	}

	mmSetDefaultTerminationResult.mock.inspectFuncSetDefaultTerminationResult = f

	return mmSetDefaultTerminationResult
}

// Return sets up results that will be returned by InitializationContext.SetDefaultTerminationResult
func (mmSetDefaultTerminationResult *mInitializationContextMockSetDefaultTerminationResult) Return() *InitializationContextMock {
	if mmSetDefaultTerminationResult.mock.funcSetDefaultTerminationResult != nil {
		mmSetDefaultTerminationResult.mock.t.Fatalf("InitializationContextMock.SetDefaultTerminationResult mock is already set by Set")
	}

	if mmSetDefaultTerminationResult.defaultExpectation == nil {
		mmSetDefaultTerminationResult.defaultExpectation = &InitializationContextMockSetDefaultTerminationResultExpectation{mock: mmSetDefaultTerminationResult.mock}
	}

	return mmSetDefaultTerminationResult.mock
}

//Set uses given function f to mock the InitializationContext.SetDefaultTerminationResult method
func (mmSetDefaultTerminationResult *mInitializationContextMockSetDefaultTerminationResult) Set(f func(p1 interface{})) *InitializationContextMock {
	if mmSetDefaultTerminationResult.defaultExpectation != nil {
		mmSetDefaultTerminationResult.mock.t.Fatalf("Default expectation is already set for the InitializationContext.SetDefaultTerminationResult method")
	}

	if len(mmSetDefaultTerminationResult.expectations) > 0 {
		mmSetDefaultTerminationResult.mock.t.Fatalf("Some expectations are already set for the InitializationContext.SetDefaultTerminationResult method")
	}

	mmSetDefaultTerminationResult.mock.funcSetDefaultTerminationResult = f
	return mmSetDefaultTerminationResult.mock
}

// SetDefaultTerminationResult implements InitializationContext
func (mmSetDefaultTerminationResult *InitializationContextMock) SetDefaultTerminationResult(p1 interface{}) {
	mm_atomic.AddUint64(&mmSetDefaultTerminationResult.beforeSetDefaultTerminationResultCounter, 1)
	defer mm_atomic.AddUint64(&mmSetDefaultTerminationResult.afterSetDefaultTerminationResultCounter, 1)

	if mmSetDefaultTerminationResult.inspectFuncSetDefaultTerminationResult != nil {
		mmSetDefaultTerminationResult.inspectFuncSetDefaultTerminationResult(p1)
	}

	mm_params := &InitializationContextMockSetDefaultTerminationResultParams{p1}

	// Record call args
	mmSetDefaultTerminationResult.SetDefaultTerminationResultMock.mutex.Lock()
	mmSetDefaultTerminationResult.SetDefaultTerminationResultMock.callArgs = append(mmSetDefaultTerminationResult.SetDefaultTerminationResultMock.callArgs, mm_params)
	mmSetDefaultTerminationResult.SetDefaultTerminationResultMock.mutex.Unlock()

	for _, e := range mmSetDefaultTerminationResult.SetDefaultTerminationResultMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetDefaultTerminationResult.SetDefaultTerminationResultMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetDefaultTerminationResult.SetDefaultTerminationResultMock.defaultExpectation.Counter, 1)
		mm_want := mmSetDefaultTerminationResult.SetDefaultTerminationResultMock.defaultExpectation.params
		mm_got := InitializationContextMockSetDefaultTerminationResultParams{p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetDefaultTerminationResult.t.Errorf("InitializationContextMock.SetDefaultTerminationResult got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetDefaultTerminationResult.funcSetDefaultTerminationResult != nil {
		mmSetDefaultTerminationResult.funcSetDefaultTerminationResult(p1)
		return
	}
	mmSetDefaultTerminationResult.t.Fatalf("Unexpected call to InitializationContextMock.SetDefaultTerminationResult. %v", p1)

}

// SetDefaultTerminationResultAfterCounter returns a count of finished InitializationContextMock.SetDefaultTerminationResult invocations
func (mmSetDefaultTerminationResult *InitializationContextMock) SetDefaultTerminationResultAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultTerminationResult.afterSetDefaultTerminationResultCounter)
}

// SetDefaultTerminationResultBeforeCounter returns a count of InitializationContextMock.SetDefaultTerminationResult invocations
func (mmSetDefaultTerminationResult *InitializationContextMock) SetDefaultTerminationResultBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultTerminationResult.beforeSetDefaultTerminationResultCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.SetDefaultTerminationResult.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetDefaultTerminationResult *mInitializationContextMockSetDefaultTerminationResult) Calls() []*InitializationContextMockSetDefaultTerminationResultParams {
	mmSetDefaultTerminationResult.mutex.RLock()

	argCopy := make([]*InitializationContextMockSetDefaultTerminationResultParams, len(mmSetDefaultTerminationResult.callArgs))
	copy(argCopy, mmSetDefaultTerminationResult.callArgs)

	mmSetDefaultTerminationResult.mutex.RUnlock()

	return argCopy
}

// MinimockSetDefaultTerminationResultDone returns true if the count of the SetDefaultTerminationResult invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockSetDefaultTerminationResultDone() bool {
	for _, e := range m.SetDefaultTerminationResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultTerminationResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultTerminationResultCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultTerminationResult != nil && mm_atomic.LoadUint64(&m.afterSetDefaultTerminationResultCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetDefaultTerminationResultInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockSetDefaultTerminationResultInspect() {
	for _, e := range m.SetDefaultTerminationResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.SetDefaultTerminationResult with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultTerminationResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultTerminationResultCounter) < 1 {
		if m.SetDefaultTerminationResultMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.SetDefaultTerminationResult")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.SetDefaultTerminationResult with params: %#v", *m.SetDefaultTerminationResultMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultTerminationResult != nil && mm_atomic.LoadUint64(&m.afterSetDefaultTerminationResultCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.SetDefaultTerminationResult")
	}
}

type mInitializationContextMockSetDynamicBoost struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockSetDynamicBoostExpectation
	expectations       []*InitializationContextMockSetDynamicBoostExpectation

	callArgs []*InitializationContextMockSetDynamicBoostParams
	mutex    sync.RWMutex
}

// InitializationContextMockSetDynamicBoostExpectation specifies expectation struct of the InitializationContext.SetDynamicBoost
type InitializationContextMockSetDynamicBoostExpectation struct {
	mock   *InitializationContextMock
	params *InitializationContextMockSetDynamicBoostParams

	Counter uint64
}

// InitializationContextMockSetDynamicBoostParams contains parameters of the InitializationContext.SetDynamicBoost
type InitializationContextMockSetDynamicBoostParams struct {
	b1 bool
}

// Expect sets up expected params for InitializationContext.SetDynamicBoost
func (mmSetDynamicBoost *mInitializationContextMockSetDynamicBoost) Expect(b1 bool) *mInitializationContextMockSetDynamicBoost {
	if mmSetDynamicBoost.mock.funcSetDynamicBoost != nil {
		mmSetDynamicBoost.mock.t.Fatalf("InitializationContextMock.SetDynamicBoost mock is already set by Set")
	}

	if mmSetDynamicBoost.defaultExpectation == nil {
		mmSetDynamicBoost.defaultExpectation = &InitializationContextMockSetDynamicBoostExpectation{}
	}

	mmSetDynamicBoost.defaultExpectation.params = &InitializationContextMockSetDynamicBoostParams{b1}
	for _, e := range mmSetDynamicBoost.expectations {
		if minimock.Equal(e.params, mmSetDynamicBoost.defaultExpectation.params) {
			mmSetDynamicBoost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetDynamicBoost.defaultExpectation.params)
		}
	}

	return mmSetDynamicBoost
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.SetDynamicBoost
func (mmSetDynamicBoost *mInitializationContextMockSetDynamicBoost) Inspect(f func(b1 bool)) *mInitializationContextMockSetDynamicBoost {
	if mmSetDynamicBoost.mock.inspectFuncSetDynamicBoost != nil {
		mmSetDynamicBoost.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.SetDynamicBoost")
	}

	mmSetDynamicBoost.mock.inspectFuncSetDynamicBoost = f

	return mmSetDynamicBoost
}

// Return sets up results that will be returned by InitializationContext.SetDynamicBoost
func (mmSetDynamicBoost *mInitializationContextMockSetDynamicBoost) Return() *InitializationContextMock {
	if mmSetDynamicBoost.mock.funcSetDynamicBoost != nil {
		mmSetDynamicBoost.mock.t.Fatalf("InitializationContextMock.SetDynamicBoost mock is already set by Set")
	}

	if mmSetDynamicBoost.defaultExpectation == nil {
		mmSetDynamicBoost.defaultExpectation = &InitializationContextMockSetDynamicBoostExpectation{mock: mmSetDynamicBoost.mock}
	}

	return mmSetDynamicBoost.mock
}

//Set uses given function f to mock the InitializationContext.SetDynamicBoost method
func (mmSetDynamicBoost *mInitializationContextMockSetDynamicBoost) Set(f func(b1 bool)) *InitializationContextMock {
	if mmSetDynamicBoost.defaultExpectation != nil {
		mmSetDynamicBoost.mock.t.Fatalf("Default expectation is already set for the InitializationContext.SetDynamicBoost method")
	}

	if len(mmSetDynamicBoost.expectations) > 0 {
		mmSetDynamicBoost.mock.t.Fatalf("Some expectations are already set for the InitializationContext.SetDynamicBoost method")
	}

	mmSetDynamicBoost.mock.funcSetDynamicBoost = f
	return mmSetDynamicBoost.mock
}

// SetDynamicBoost implements InitializationContext
func (mmSetDynamicBoost *InitializationContextMock) SetDynamicBoost(b1 bool) {
	mm_atomic.AddUint64(&mmSetDynamicBoost.beforeSetDynamicBoostCounter, 1)
	defer mm_atomic.AddUint64(&mmSetDynamicBoost.afterSetDynamicBoostCounter, 1)

	if mmSetDynamicBoost.inspectFuncSetDynamicBoost != nil {
		mmSetDynamicBoost.inspectFuncSetDynamicBoost(b1)
	}

	mm_params := &InitializationContextMockSetDynamicBoostParams{b1}

	// Record call args
	mmSetDynamicBoost.SetDynamicBoostMock.mutex.Lock()
	mmSetDynamicBoost.SetDynamicBoostMock.callArgs = append(mmSetDynamicBoost.SetDynamicBoostMock.callArgs, mm_params)
	mmSetDynamicBoost.SetDynamicBoostMock.mutex.Unlock()

	for _, e := range mmSetDynamicBoost.SetDynamicBoostMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetDynamicBoost.SetDynamicBoostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetDynamicBoost.SetDynamicBoostMock.defaultExpectation.Counter, 1)
		mm_want := mmSetDynamicBoost.SetDynamicBoostMock.defaultExpectation.params
		mm_got := InitializationContextMockSetDynamicBoostParams{b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetDynamicBoost.t.Errorf("InitializationContextMock.SetDynamicBoost got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetDynamicBoost.funcSetDynamicBoost != nil {
		mmSetDynamicBoost.funcSetDynamicBoost(b1)
		return
	}
	mmSetDynamicBoost.t.Fatalf("Unexpected call to InitializationContextMock.SetDynamicBoost. %v", b1)

}

// SetDynamicBoostAfterCounter returns a count of finished InitializationContextMock.SetDynamicBoost invocations
func (mmSetDynamicBoost *InitializationContextMock) SetDynamicBoostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDynamicBoost.afterSetDynamicBoostCounter)
}

// SetDynamicBoostBeforeCounter returns a count of InitializationContextMock.SetDynamicBoost invocations
func (mmSetDynamicBoost *InitializationContextMock) SetDynamicBoostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDynamicBoost.beforeSetDynamicBoostCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.SetDynamicBoost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetDynamicBoost *mInitializationContextMockSetDynamicBoost) Calls() []*InitializationContextMockSetDynamicBoostParams {
	mmSetDynamicBoost.mutex.RLock()

	argCopy := make([]*InitializationContextMockSetDynamicBoostParams, len(mmSetDynamicBoost.callArgs))
	copy(argCopy, mmSetDynamicBoost.callArgs)

	mmSetDynamicBoost.mutex.RUnlock()

	return argCopy
}

// MinimockSetDynamicBoostDone returns true if the count of the SetDynamicBoost invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockSetDynamicBoostDone() bool {
	for _, e := range m.SetDynamicBoostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDynamicBoostMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDynamicBoostCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDynamicBoost != nil && mm_atomic.LoadUint64(&m.afterSetDynamicBoostCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetDynamicBoostInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockSetDynamicBoostInspect() {
	for _, e := range m.SetDynamicBoostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.SetDynamicBoost with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDynamicBoostMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDynamicBoostCounter) < 1 {
		if m.SetDynamicBoostMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.SetDynamicBoost")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.SetDynamicBoost with params: %#v", *m.SetDynamicBoostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDynamicBoost != nil && mm_atomic.LoadUint64(&m.afterSetDynamicBoostCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.SetDynamicBoost")
	}
}

type mInitializationContextMockSetLogTracing struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockSetLogTracingExpectation
	expectations       []*InitializationContextMockSetLogTracingExpectation

	callArgs []*InitializationContextMockSetLogTracingParams
	mutex    sync.RWMutex
}

// InitializationContextMockSetLogTracingExpectation specifies expectation struct of the InitializationContext.SetLogTracing
type InitializationContextMockSetLogTracingExpectation struct {
	mock   *InitializationContextMock
	params *InitializationContextMockSetLogTracingParams

	Counter uint64
}

// InitializationContextMockSetLogTracingParams contains parameters of the InitializationContext.SetLogTracing
type InitializationContextMockSetLogTracingParams struct {
	b1 bool
}

// Expect sets up expected params for InitializationContext.SetLogTracing
func (mmSetLogTracing *mInitializationContextMockSetLogTracing) Expect(b1 bool) *mInitializationContextMockSetLogTracing {
	if mmSetLogTracing.mock.funcSetLogTracing != nil {
		mmSetLogTracing.mock.t.Fatalf("InitializationContextMock.SetLogTracing mock is already set by Set")
	}

	if mmSetLogTracing.defaultExpectation == nil {
		mmSetLogTracing.defaultExpectation = &InitializationContextMockSetLogTracingExpectation{}
	}

	mmSetLogTracing.defaultExpectation.params = &InitializationContextMockSetLogTracingParams{b1}
	for _, e := range mmSetLogTracing.expectations {
		if minimock.Equal(e.params, mmSetLogTracing.defaultExpectation.params) {
			mmSetLogTracing.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetLogTracing.defaultExpectation.params)
		}
	}

	return mmSetLogTracing
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.SetLogTracing
func (mmSetLogTracing *mInitializationContextMockSetLogTracing) Inspect(f func(b1 bool)) *mInitializationContextMockSetLogTracing {
	if mmSetLogTracing.mock.inspectFuncSetLogTracing != nil {
		mmSetLogTracing.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.SetLogTracing")
	}

	mmSetLogTracing.mock.inspectFuncSetLogTracing = f

	return mmSetLogTracing
}

// Return sets up results that will be returned by InitializationContext.SetLogTracing
func (mmSetLogTracing *mInitializationContextMockSetLogTracing) Return() *InitializationContextMock {
	if mmSetLogTracing.mock.funcSetLogTracing != nil {
		mmSetLogTracing.mock.t.Fatalf("InitializationContextMock.SetLogTracing mock is already set by Set")
	}

	if mmSetLogTracing.defaultExpectation == nil {
		mmSetLogTracing.defaultExpectation = &InitializationContextMockSetLogTracingExpectation{mock: mmSetLogTracing.mock}
	}

	return mmSetLogTracing.mock
}

//Set uses given function f to mock the InitializationContext.SetLogTracing method
func (mmSetLogTracing *mInitializationContextMockSetLogTracing) Set(f func(b1 bool)) *InitializationContextMock {
	if mmSetLogTracing.defaultExpectation != nil {
		mmSetLogTracing.mock.t.Fatalf("Default expectation is already set for the InitializationContext.SetLogTracing method")
	}

	if len(mmSetLogTracing.expectations) > 0 {
		mmSetLogTracing.mock.t.Fatalf("Some expectations are already set for the InitializationContext.SetLogTracing method")
	}

	mmSetLogTracing.mock.funcSetLogTracing = f
	return mmSetLogTracing.mock
}

// SetLogTracing implements InitializationContext
func (mmSetLogTracing *InitializationContextMock) SetLogTracing(b1 bool) {
	mm_atomic.AddUint64(&mmSetLogTracing.beforeSetLogTracingCounter, 1)
	defer mm_atomic.AddUint64(&mmSetLogTracing.afterSetLogTracingCounter, 1)

	if mmSetLogTracing.inspectFuncSetLogTracing != nil {
		mmSetLogTracing.inspectFuncSetLogTracing(b1)
	}

	mm_params := &InitializationContextMockSetLogTracingParams{b1}

	// Record call args
	mmSetLogTracing.SetLogTracingMock.mutex.Lock()
	mmSetLogTracing.SetLogTracingMock.callArgs = append(mmSetLogTracing.SetLogTracingMock.callArgs, mm_params)
	mmSetLogTracing.SetLogTracingMock.mutex.Unlock()

	for _, e := range mmSetLogTracing.SetLogTracingMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetLogTracing.SetLogTracingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetLogTracing.SetLogTracingMock.defaultExpectation.Counter, 1)
		mm_want := mmSetLogTracing.SetLogTracingMock.defaultExpectation.params
		mm_got := InitializationContextMockSetLogTracingParams{b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetLogTracing.t.Errorf("InitializationContextMock.SetLogTracing got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetLogTracing.funcSetLogTracing != nil {
		mmSetLogTracing.funcSetLogTracing(b1)
		return
	}
	mmSetLogTracing.t.Fatalf("Unexpected call to InitializationContextMock.SetLogTracing. %v", b1)

}

// SetLogTracingAfterCounter returns a count of finished InitializationContextMock.SetLogTracing invocations
func (mmSetLogTracing *InitializationContextMock) SetLogTracingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetLogTracing.afterSetLogTracingCounter)
}

// SetLogTracingBeforeCounter returns a count of InitializationContextMock.SetLogTracing invocations
func (mmSetLogTracing *InitializationContextMock) SetLogTracingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetLogTracing.beforeSetLogTracingCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.SetLogTracing.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetLogTracing *mInitializationContextMockSetLogTracing) Calls() []*InitializationContextMockSetLogTracingParams {
	mmSetLogTracing.mutex.RLock()

	argCopy := make([]*InitializationContextMockSetLogTracingParams, len(mmSetLogTracing.callArgs))
	copy(argCopy, mmSetLogTracing.callArgs)

	mmSetLogTracing.mutex.RUnlock()

	return argCopy
}

// MinimockSetLogTracingDone returns true if the count of the SetLogTracing invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockSetLogTracingDone() bool {
	for _, e := range m.SetLogTracingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetLogTracingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetLogTracingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetLogTracing != nil && mm_atomic.LoadUint64(&m.afterSetLogTracingCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetLogTracingInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockSetLogTracingInspect() {
	for _, e := range m.SetLogTracingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.SetLogTracing with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetLogTracingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetLogTracingCounter) < 1 {
		if m.SetLogTracingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.SetLogTracing")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.SetLogTracing with params: %#v", *m.SetLogTracingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetLogTracing != nil && mm_atomic.LoadUint64(&m.afterSetLogTracingCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.SetLogTracing")
	}
}

type mInitializationContextMockShare struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockShareExpectation
	expectations       []*InitializationContextMockShareExpectation

	callArgs []*InitializationContextMockShareParams
	mutex    sync.RWMutex
}

// InitializationContextMockShareExpectation specifies expectation struct of the InitializationContext.Share
type InitializationContextMockShareExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockShareParams
	results *InitializationContextMockShareResults
	Counter uint64
}

// InitializationContextMockShareParams contains parameters of the InitializationContext.Share
type InitializationContextMockShareParams struct {
	data  interface{}
	flags ShareDataFlags
}

// InitializationContextMockShareResults contains results of the InitializationContext.Share
type InitializationContextMockShareResults struct {
	s1 SharedDataLink
}

// Expect sets up expected params for InitializationContext.Share
func (mmShare *mInitializationContextMockShare) Expect(data interface{}, flags ShareDataFlags) *mInitializationContextMockShare {
	if mmShare.mock.funcShare != nil {
		mmShare.mock.t.Fatalf("InitializationContextMock.Share mock is already set by Set")
	}

	if mmShare.defaultExpectation == nil {
		mmShare.defaultExpectation = &InitializationContextMockShareExpectation{}
	}

	mmShare.defaultExpectation.params = &InitializationContextMockShareParams{data, flags}
	for _, e := range mmShare.expectations {
		if minimock.Equal(e.params, mmShare.defaultExpectation.params) {
			mmShare.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmShare.defaultExpectation.params)
		}
	}

	return mmShare
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.Share
func (mmShare *mInitializationContextMockShare) Inspect(f func(data interface{}, flags ShareDataFlags)) *mInitializationContextMockShare {
	if mmShare.mock.inspectFuncShare != nil {
		mmShare.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.Share")
	}

	mmShare.mock.inspectFuncShare = f

	return mmShare
}

// Return sets up results that will be returned by InitializationContext.Share
func (mmShare *mInitializationContextMockShare) Return(s1 SharedDataLink) *InitializationContextMock {
	if mmShare.mock.funcShare != nil {
		mmShare.mock.t.Fatalf("InitializationContextMock.Share mock is already set by Set")
	}

	if mmShare.defaultExpectation == nil {
		mmShare.defaultExpectation = &InitializationContextMockShareExpectation{mock: mmShare.mock}
	}
	mmShare.defaultExpectation.results = &InitializationContextMockShareResults{s1}
	return mmShare.mock
}

//Set uses given function f to mock the InitializationContext.Share method
func (mmShare *mInitializationContextMockShare) Set(f func(data interface{}, flags ShareDataFlags) (s1 SharedDataLink)) *InitializationContextMock {
	if mmShare.defaultExpectation != nil {
		mmShare.mock.t.Fatalf("Default expectation is already set for the InitializationContext.Share method")
	}

	if len(mmShare.expectations) > 0 {
		mmShare.mock.t.Fatalf("Some expectations are already set for the InitializationContext.Share method")
	}

	mmShare.mock.funcShare = f
	return mmShare.mock
}

// When sets expectation for the InitializationContext.Share which will trigger the result defined by the following
// Then helper
func (mmShare *mInitializationContextMockShare) When(data interface{}, flags ShareDataFlags) *InitializationContextMockShareExpectation {
	if mmShare.mock.funcShare != nil {
		mmShare.mock.t.Fatalf("InitializationContextMock.Share mock is already set by Set")
	}

	expectation := &InitializationContextMockShareExpectation{
		mock:   mmShare.mock,
		params: &InitializationContextMockShareParams{data, flags},
	}
	mmShare.expectations = append(mmShare.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.Share return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockShareExpectation) Then(s1 SharedDataLink) *InitializationContextMock {
	e.results = &InitializationContextMockShareResults{s1}
	return e.mock
}

// Share implements InitializationContext
func (mmShare *InitializationContextMock) Share(data interface{}, flags ShareDataFlags) (s1 SharedDataLink) {
	mm_atomic.AddUint64(&mmShare.beforeShareCounter, 1)
	defer mm_atomic.AddUint64(&mmShare.afterShareCounter, 1)

	if mmShare.inspectFuncShare != nil {
		mmShare.inspectFuncShare(data, flags)
	}

	mm_params := &InitializationContextMockShareParams{data, flags}

	// Record call args
	mmShare.ShareMock.mutex.Lock()
	mmShare.ShareMock.callArgs = append(mmShare.ShareMock.callArgs, mm_params)
	mmShare.ShareMock.mutex.Unlock()

	for _, e := range mmShare.ShareMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmShare.ShareMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShare.ShareMock.defaultExpectation.Counter, 1)
		mm_want := mmShare.ShareMock.defaultExpectation.params
		mm_got := InitializationContextMockShareParams{data, flags}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmShare.t.Errorf("InitializationContextMock.Share got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmShare.ShareMock.defaultExpectation.results
		if mm_results == nil {
			mmShare.t.Fatal("No results are set for the InitializationContextMock.Share")
		}
		return (*mm_results).s1
	}
	if mmShare.funcShare != nil {
		return mmShare.funcShare(data, flags)
	}
	mmShare.t.Fatalf("Unexpected call to InitializationContextMock.Share. %v %v", data, flags)
	return
}

// ShareAfterCounter returns a count of finished InitializationContextMock.Share invocations
func (mmShare *InitializationContextMock) ShareAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShare.afterShareCounter)
}

// ShareBeforeCounter returns a count of InitializationContextMock.Share invocations
func (mmShare *InitializationContextMock) ShareBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShare.beforeShareCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.Share.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmShare *mInitializationContextMockShare) Calls() []*InitializationContextMockShareParams {
	mmShare.mutex.RLock()

	argCopy := make([]*InitializationContextMockShareParams, len(mmShare.callArgs))
	copy(argCopy, mmShare.callArgs)

	mmShare.mutex.RUnlock()

	return argCopy
}

// MinimockShareDone returns true if the count of the Share invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockShareDone() bool {
	for _, e := range m.ShareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShareCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShare != nil && mm_atomic.LoadUint64(&m.afterShareCounter) < 1 {
		return false
	}
	return true
}

// MinimockShareInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockShareInspect() {
	for _, e := range m.ShareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.Share with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShareCounter) < 1 {
		if m.ShareMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.Share")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.Share with params: %#v", *m.ShareMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShare != nil && mm_atomic.LoadUint64(&m.afterShareCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.Share")
	}
}

type mInitializationContextMockSlotLink struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockSlotLinkExpectation
	expectations       []*InitializationContextMockSlotLinkExpectation
}

// InitializationContextMockSlotLinkExpectation specifies expectation struct of the InitializationContext.SlotLink
type InitializationContextMockSlotLinkExpectation struct {
	mock *InitializationContextMock

	results *InitializationContextMockSlotLinkResults
	Counter uint64
}

// InitializationContextMockSlotLinkResults contains results of the InitializationContext.SlotLink
type InitializationContextMockSlotLinkResults struct {
	s1 SlotLink
}

// Expect sets up expected params for InitializationContext.SlotLink
func (mmSlotLink *mInitializationContextMockSlotLink) Expect() *mInitializationContextMockSlotLink {
	if mmSlotLink.mock.funcSlotLink != nil {
		mmSlotLink.mock.t.Fatalf("InitializationContextMock.SlotLink mock is already set by Set")
	}

	if mmSlotLink.defaultExpectation == nil {
		mmSlotLink.defaultExpectation = &InitializationContextMockSlotLinkExpectation{}
	}

	return mmSlotLink
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.SlotLink
func (mmSlotLink *mInitializationContextMockSlotLink) Inspect(f func()) *mInitializationContextMockSlotLink {
	if mmSlotLink.mock.inspectFuncSlotLink != nil {
		mmSlotLink.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.SlotLink")
	}

	mmSlotLink.mock.inspectFuncSlotLink = f

	return mmSlotLink
}

// Return sets up results that will be returned by InitializationContext.SlotLink
func (mmSlotLink *mInitializationContextMockSlotLink) Return(s1 SlotLink) *InitializationContextMock {
	if mmSlotLink.mock.funcSlotLink != nil {
		mmSlotLink.mock.t.Fatalf("InitializationContextMock.SlotLink mock is already set by Set")
	}

	if mmSlotLink.defaultExpectation == nil {
		mmSlotLink.defaultExpectation = &InitializationContextMockSlotLinkExpectation{mock: mmSlotLink.mock}
	}
	mmSlotLink.defaultExpectation.results = &InitializationContextMockSlotLinkResults{s1}
	return mmSlotLink.mock
}

//Set uses given function f to mock the InitializationContext.SlotLink method
func (mmSlotLink *mInitializationContextMockSlotLink) Set(f func() (s1 SlotLink)) *InitializationContextMock {
	if mmSlotLink.defaultExpectation != nil {
		mmSlotLink.mock.t.Fatalf("Default expectation is already set for the InitializationContext.SlotLink method")
	}

	if len(mmSlotLink.expectations) > 0 {
		mmSlotLink.mock.t.Fatalf("Some expectations are already set for the InitializationContext.SlotLink method")
	}

	mmSlotLink.mock.funcSlotLink = f
	return mmSlotLink.mock
}

// SlotLink implements InitializationContext
func (mmSlotLink *InitializationContextMock) SlotLink() (s1 SlotLink) {
	mm_atomic.AddUint64(&mmSlotLink.beforeSlotLinkCounter, 1)
	defer mm_atomic.AddUint64(&mmSlotLink.afterSlotLinkCounter, 1)

	if mmSlotLink.inspectFuncSlotLink != nil {
		mmSlotLink.inspectFuncSlotLink()
	}

	if mmSlotLink.SlotLinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSlotLink.SlotLinkMock.defaultExpectation.Counter, 1)

		mm_results := mmSlotLink.SlotLinkMock.defaultExpectation.results
		if mm_results == nil {
			mmSlotLink.t.Fatal("No results are set for the InitializationContextMock.SlotLink")
		}
		return (*mm_results).s1
	}
	if mmSlotLink.funcSlotLink != nil {
		return mmSlotLink.funcSlotLink()
	}
	mmSlotLink.t.Fatalf("Unexpected call to InitializationContextMock.SlotLink.")
	return
}

// SlotLinkAfterCounter returns a count of finished InitializationContextMock.SlotLink invocations
func (mmSlotLink *InitializationContextMock) SlotLinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSlotLink.afterSlotLinkCounter)
}

// SlotLinkBeforeCounter returns a count of InitializationContextMock.SlotLink invocations
func (mmSlotLink *InitializationContextMock) SlotLinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSlotLink.beforeSlotLinkCounter)
}

// MinimockSlotLinkDone returns true if the count of the SlotLink invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockSlotLinkDone() bool {
	for _, e := range m.SlotLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SlotLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSlotLinkCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSlotLink != nil && mm_atomic.LoadUint64(&m.afterSlotLinkCounter) < 1 {
		return false
	}
	return true
}

// MinimockSlotLinkInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockSlotLinkInspect() {
	for _, e := range m.SlotLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to InitializationContextMock.SlotLink")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SlotLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSlotLinkCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.SlotLink")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSlotLink != nil && mm_atomic.LoadUint64(&m.afterSlotLinkCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.SlotLink")
	}
}

type mInitializationContextMockStop struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockStopExpectation
	expectations       []*InitializationContextMockStopExpectation
}

// InitializationContextMockStopExpectation specifies expectation struct of the InitializationContext.Stop
type InitializationContextMockStopExpectation struct {
	mock *InitializationContextMock

	results *InitializationContextMockStopResults
	Counter uint64
}

// InitializationContextMockStopResults contains results of the InitializationContext.Stop
type InitializationContextMockStopResults struct {
	s1 StateUpdate
}

// Expect sets up expected params for InitializationContext.Stop
func (mmStop *mInitializationContextMockStop) Expect() *mInitializationContextMockStop {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("InitializationContextMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &InitializationContextMockStopExpectation{}
	}

	return mmStop
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.Stop
func (mmStop *mInitializationContextMockStop) Inspect(f func()) *mInitializationContextMockStop {
	if mmStop.mock.inspectFuncStop != nil {
		mmStop.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.Stop")
	}

	mmStop.mock.inspectFuncStop = f

	return mmStop
}

// Return sets up results that will be returned by InitializationContext.Stop
func (mmStop *mInitializationContextMockStop) Return(s1 StateUpdate) *InitializationContextMock {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("InitializationContextMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &InitializationContextMockStopExpectation{mock: mmStop.mock}
	}
	mmStop.defaultExpectation.results = &InitializationContextMockStopResults{s1}
	return mmStop.mock
}

//Set uses given function f to mock the InitializationContext.Stop method
func (mmStop *mInitializationContextMockStop) Set(f func() (s1 StateUpdate)) *InitializationContextMock {
	if mmStop.defaultExpectation != nil {
		mmStop.mock.t.Fatalf("Default expectation is already set for the InitializationContext.Stop method")
	}

	if len(mmStop.expectations) > 0 {
		mmStop.mock.t.Fatalf("Some expectations are already set for the InitializationContext.Stop method")
	}

	mmStop.mock.funcStop = f
	return mmStop.mock
}

// Stop implements InitializationContext
func (mmStop *InitializationContextMock) Stop() (s1 StateUpdate) {
	mm_atomic.AddUint64(&mmStop.beforeStopCounter, 1)
	defer mm_atomic.AddUint64(&mmStop.afterStopCounter, 1)

	if mmStop.inspectFuncStop != nil {
		mmStop.inspectFuncStop()
	}

	if mmStop.StopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStop.StopMock.defaultExpectation.Counter, 1)

		mm_results := mmStop.StopMock.defaultExpectation.results
		if mm_results == nil {
			mmStop.t.Fatal("No results are set for the InitializationContextMock.Stop")
		}
		return (*mm_results).s1
	}
	if mmStop.funcStop != nil {
		return mmStop.funcStop()
	}
	mmStop.t.Fatalf("Unexpected call to InitializationContextMock.Stop.")
	return
}

// StopAfterCounter returns a count of finished InitializationContextMock.Stop invocations
func (mmStop *InitializationContextMock) StopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.afterStopCounter)
}

// StopBeforeCounter returns a count of InitializationContextMock.Stop invocations
func (mmStop *InitializationContextMock) StopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.beforeStopCounter)
}

// MinimockStopDone returns true if the count of the Stop invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockStopDone() bool {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	return true
}

// MinimockStopInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockStopInspect() {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to InitializationContextMock.Stop")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.Stop")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.Stop")
	}
}

type mInitializationContextMockUnpublish struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockUnpublishExpectation
	expectations       []*InitializationContextMockUnpublishExpectation

	callArgs []*InitializationContextMockUnpublishParams
	mutex    sync.RWMutex
}

// InitializationContextMockUnpublishExpectation specifies expectation struct of the InitializationContext.Unpublish
type InitializationContextMockUnpublishExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockUnpublishParams
	results *InitializationContextMockUnpublishResults
	Counter uint64
}

// InitializationContextMockUnpublishParams contains parameters of the InitializationContext.Unpublish
type InitializationContextMockUnpublishParams struct {
	key interface{}
}

// InitializationContextMockUnpublishResults contains results of the InitializationContext.Unpublish
type InitializationContextMockUnpublishResults struct {
	b1 bool
}

// Expect sets up expected params for InitializationContext.Unpublish
func (mmUnpublish *mInitializationContextMockUnpublish) Expect(key interface{}) *mInitializationContextMockUnpublish {
	if mmUnpublish.mock.funcUnpublish != nil {
		mmUnpublish.mock.t.Fatalf("InitializationContextMock.Unpublish mock is already set by Set")
	}

	if mmUnpublish.defaultExpectation == nil {
		mmUnpublish.defaultExpectation = &InitializationContextMockUnpublishExpectation{}
	}

	mmUnpublish.defaultExpectation.params = &InitializationContextMockUnpublishParams{key}
	for _, e := range mmUnpublish.expectations {
		if minimock.Equal(e.params, mmUnpublish.defaultExpectation.params) {
			mmUnpublish.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnpublish.defaultExpectation.params)
		}
	}

	return mmUnpublish
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.Unpublish
func (mmUnpublish *mInitializationContextMockUnpublish) Inspect(f func(key interface{})) *mInitializationContextMockUnpublish {
	if mmUnpublish.mock.inspectFuncUnpublish != nil {
		mmUnpublish.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.Unpublish")
	}

	mmUnpublish.mock.inspectFuncUnpublish = f

	return mmUnpublish
}

// Return sets up results that will be returned by InitializationContext.Unpublish
func (mmUnpublish *mInitializationContextMockUnpublish) Return(b1 bool) *InitializationContextMock {
	if mmUnpublish.mock.funcUnpublish != nil {
		mmUnpublish.mock.t.Fatalf("InitializationContextMock.Unpublish mock is already set by Set")
	}

	if mmUnpublish.defaultExpectation == nil {
		mmUnpublish.defaultExpectation = &InitializationContextMockUnpublishExpectation{mock: mmUnpublish.mock}
	}
	mmUnpublish.defaultExpectation.results = &InitializationContextMockUnpublishResults{b1}
	return mmUnpublish.mock
}

//Set uses given function f to mock the InitializationContext.Unpublish method
func (mmUnpublish *mInitializationContextMockUnpublish) Set(f func(key interface{}) (b1 bool)) *InitializationContextMock {
	if mmUnpublish.defaultExpectation != nil {
		mmUnpublish.mock.t.Fatalf("Default expectation is already set for the InitializationContext.Unpublish method")
	}

	if len(mmUnpublish.expectations) > 0 {
		mmUnpublish.mock.t.Fatalf("Some expectations are already set for the InitializationContext.Unpublish method")
	}

	mmUnpublish.mock.funcUnpublish = f
	return mmUnpublish.mock
}

// When sets expectation for the InitializationContext.Unpublish which will trigger the result defined by the following
// Then helper
func (mmUnpublish *mInitializationContextMockUnpublish) When(key interface{}) *InitializationContextMockUnpublishExpectation {
	if mmUnpublish.mock.funcUnpublish != nil {
		mmUnpublish.mock.t.Fatalf("InitializationContextMock.Unpublish mock is already set by Set")
	}

	expectation := &InitializationContextMockUnpublishExpectation{
		mock:   mmUnpublish.mock,
		params: &InitializationContextMockUnpublishParams{key},
	}
	mmUnpublish.expectations = append(mmUnpublish.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.Unpublish return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockUnpublishExpectation) Then(b1 bool) *InitializationContextMock {
	e.results = &InitializationContextMockUnpublishResults{b1}
	return e.mock
}

// Unpublish implements InitializationContext
func (mmUnpublish *InitializationContextMock) Unpublish(key interface{}) (b1 bool) {
	mm_atomic.AddUint64(&mmUnpublish.beforeUnpublishCounter, 1)
	defer mm_atomic.AddUint64(&mmUnpublish.afterUnpublishCounter, 1)

	if mmUnpublish.inspectFuncUnpublish != nil {
		mmUnpublish.inspectFuncUnpublish(key)
	}

	mm_params := &InitializationContextMockUnpublishParams{key}

	// Record call args
	mmUnpublish.UnpublishMock.mutex.Lock()
	mmUnpublish.UnpublishMock.callArgs = append(mmUnpublish.UnpublishMock.callArgs, mm_params)
	mmUnpublish.UnpublishMock.mutex.Unlock()

	for _, e := range mmUnpublish.UnpublishMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmUnpublish.UnpublishMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnpublish.UnpublishMock.defaultExpectation.Counter, 1)
		mm_want := mmUnpublish.UnpublishMock.defaultExpectation.params
		mm_got := InitializationContextMockUnpublishParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnpublish.t.Errorf("InitializationContextMock.Unpublish got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnpublish.UnpublishMock.defaultExpectation.results
		if mm_results == nil {
			mmUnpublish.t.Fatal("No results are set for the InitializationContextMock.Unpublish")
		}
		return (*mm_results).b1
	}
	if mmUnpublish.funcUnpublish != nil {
		return mmUnpublish.funcUnpublish(key)
	}
	mmUnpublish.t.Fatalf("Unexpected call to InitializationContextMock.Unpublish. %v", key)
	return
}

// UnpublishAfterCounter returns a count of finished InitializationContextMock.Unpublish invocations
func (mmUnpublish *InitializationContextMock) UnpublishAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpublish.afterUnpublishCounter)
}

// UnpublishBeforeCounter returns a count of InitializationContextMock.Unpublish invocations
func (mmUnpublish *InitializationContextMock) UnpublishBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpublish.beforeUnpublishCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.Unpublish.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnpublish *mInitializationContextMockUnpublish) Calls() []*InitializationContextMockUnpublishParams {
	mmUnpublish.mutex.RLock()

	argCopy := make([]*InitializationContextMockUnpublishParams, len(mmUnpublish.callArgs))
	copy(argCopy, mmUnpublish.callArgs)

	mmUnpublish.mutex.RUnlock()

	return argCopy
}

// MinimockUnpublishDone returns true if the count of the Unpublish invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockUnpublishDone() bool {
	for _, e := range m.UnpublishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpublishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpublishCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpublish != nil && mm_atomic.LoadUint64(&m.afterUnpublishCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnpublishInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockUnpublishInspect() {
	for _, e := range m.UnpublishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.Unpublish with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpublishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpublishCounter) < 1 {
		if m.UnpublishMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.Unpublish")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.Unpublish with params: %#v", *m.UnpublishMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpublish != nil && mm_atomic.LoadUint64(&m.afterUnpublishCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.Unpublish")
	}
}

type mInitializationContextMockUnpublishAll struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockUnpublishAllExpectation
	expectations       []*InitializationContextMockUnpublishAllExpectation
}

// InitializationContextMockUnpublishAllExpectation specifies expectation struct of the InitializationContext.UnpublishAll
type InitializationContextMockUnpublishAllExpectation struct {
	mock *InitializationContextMock

	Counter uint64
}

// Expect sets up expected params for InitializationContext.UnpublishAll
func (mmUnpublishAll *mInitializationContextMockUnpublishAll) Expect() *mInitializationContextMockUnpublishAll {
	if mmUnpublishAll.mock.funcUnpublishAll != nil {
		mmUnpublishAll.mock.t.Fatalf("InitializationContextMock.UnpublishAll mock is already set by Set")
	}

	if mmUnpublishAll.defaultExpectation == nil {
		mmUnpublishAll.defaultExpectation = &InitializationContextMockUnpublishAllExpectation{}
	}

	return mmUnpublishAll
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.UnpublishAll
func (mmUnpublishAll *mInitializationContextMockUnpublishAll) Inspect(f func()) *mInitializationContextMockUnpublishAll {
	if mmUnpublishAll.mock.inspectFuncUnpublishAll != nil {
		mmUnpublishAll.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.UnpublishAll")
	}

	mmUnpublishAll.mock.inspectFuncUnpublishAll = f

	return mmUnpublishAll
}

// Return sets up results that will be returned by InitializationContext.UnpublishAll
func (mmUnpublishAll *mInitializationContextMockUnpublishAll) Return() *InitializationContextMock {
	if mmUnpublishAll.mock.funcUnpublishAll != nil {
		mmUnpublishAll.mock.t.Fatalf("InitializationContextMock.UnpublishAll mock is already set by Set")
	}

	if mmUnpublishAll.defaultExpectation == nil {
		mmUnpublishAll.defaultExpectation = &InitializationContextMockUnpublishAllExpectation{mock: mmUnpublishAll.mock}
	}

	return mmUnpublishAll.mock
}

//Set uses given function f to mock the InitializationContext.UnpublishAll method
func (mmUnpublishAll *mInitializationContextMockUnpublishAll) Set(f func()) *InitializationContextMock {
	if mmUnpublishAll.defaultExpectation != nil {
		mmUnpublishAll.mock.t.Fatalf("Default expectation is already set for the InitializationContext.UnpublishAll method")
	}

	if len(mmUnpublishAll.expectations) > 0 {
		mmUnpublishAll.mock.t.Fatalf("Some expectations are already set for the InitializationContext.UnpublishAll method")
	}

	mmUnpublishAll.mock.funcUnpublishAll = f
	return mmUnpublishAll.mock
}

// UnpublishAll implements InitializationContext
func (mmUnpublishAll *InitializationContextMock) UnpublishAll() {
	mm_atomic.AddUint64(&mmUnpublishAll.beforeUnpublishAllCounter, 1)
	defer mm_atomic.AddUint64(&mmUnpublishAll.afterUnpublishAllCounter, 1)

	if mmUnpublishAll.inspectFuncUnpublishAll != nil {
		mmUnpublishAll.inspectFuncUnpublishAll()
	}

	if mmUnpublishAll.UnpublishAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnpublishAll.UnpublishAllMock.defaultExpectation.Counter, 1)

		return

	}
	if mmUnpublishAll.funcUnpublishAll != nil {
		mmUnpublishAll.funcUnpublishAll()
		return
	}
	mmUnpublishAll.t.Fatalf("Unexpected call to InitializationContextMock.UnpublishAll.")

}

// UnpublishAllAfterCounter returns a count of finished InitializationContextMock.UnpublishAll invocations
func (mmUnpublishAll *InitializationContextMock) UnpublishAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpublishAll.afterUnpublishAllCounter)
}

// UnpublishAllBeforeCounter returns a count of InitializationContextMock.UnpublishAll invocations
func (mmUnpublishAll *InitializationContextMock) UnpublishAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpublishAll.beforeUnpublishAllCounter)
}

// MinimockUnpublishAllDone returns true if the count of the UnpublishAll invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockUnpublishAllDone() bool {
	for _, e := range m.UnpublishAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpublishAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpublishAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpublishAll != nil && mm_atomic.LoadUint64(&m.afterUnpublishAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnpublishAllInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockUnpublishAllInspect() {
	for _, e := range m.UnpublishAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to InitializationContextMock.UnpublishAll")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpublishAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpublishAllCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.UnpublishAll")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpublishAll != nil && mm_atomic.LoadUint64(&m.afterUnpublishAllCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.UnpublishAll")
	}
}

type mInitializationContextMockUnpublishGlobalAlias struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockUnpublishGlobalAliasExpectation
	expectations       []*InitializationContextMockUnpublishGlobalAliasExpectation

	callArgs []*InitializationContextMockUnpublishGlobalAliasParams
	mutex    sync.RWMutex
}

// InitializationContextMockUnpublishGlobalAliasExpectation specifies expectation struct of the InitializationContext.UnpublishGlobalAlias
type InitializationContextMockUnpublishGlobalAliasExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockUnpublishGlobalAliasParams
	results *InitializationContextMockUnpublishGlobalAliasResults
	Counter uint64
}

// InitializationContextMockUnpublishGlobalAliasParams contains parameters of the InitializationContext.UnpublishGlobalAlias
type InitializationContextMockUnpublishGlobalAliasParams struct {
	key interface{}
}

// InitializationContextMockUnpublishGlobalAliasResults contains results of the InitializationContext.UnpublishGlobalAlias
type InitializationContextMockUnpublishGlobalAliasResults struct {
	b1 bool
}

// Expect sets up expected params for InitializationContext.UnpublishGlobalAlias
func (mmUnpublishGlobalAlias *mInitializationContextMockUnpublishGlobalAlias) Expect(key interface{}) *mInitializationContextMockUnpublishGlobalAlias {
	if mmUnpublishGlobalAlias.mock.funcUnpublishGlobalAlias != nil {
		mmUnpublishGlobalAlias.mock.t.Fatalf("InitializationContextMock.UnpublishGlobalAlias mock is already set by Set")
	}

	if mmUnpublishGlobalAlias.defaultExpectation == nil {
		mmUnpublishGlobalAlias.defaultExpectation = &InitializationContextMockUnpublishGlobalAliasExpectation{}
	}

	mmUnpublishGlobalAlias.defaultExpectation.params = &InitializationContextMockUnpublishGlobalAliasParams{key}
	for _, e := range mmUnpublishGlobalAlias.expectations {
		if minimock.Equal(e.params, mmUnpublishGlobalAlias.defaultExpectation.params) {
			mmUnpublishGlobalAlias.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnpublishGlobalAlias.defaultExpectation.params)
		}
	}

	return mmUnpublishGlobalAlias
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.UnpublishGlobalAlias
func (mmUnpublishGlobalAlias *mInitializationContextMockUnpublishGlobalAlias) Inspect(f func(key interface{})) *mInitializationContextMockUnpublishGlobalAlias {
	if mmUnpublishGlobalAlias.mock.inspectFuncUnpublishGlobalAlias != nil {
		mmUnpublishGlobalAlias.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.UnpublishGlobalAlias")
	}

	mmUnpublishGlobalAlias.mock.inspectFuncUnpublishGlobalAlias = f

	return mmUnpublishGlobalAlias
}

// Return sets up results that will be returned by InitializationContext.UnpublishGlobalAlias
func (mmUnpublishGlobalAlias *mInitializationContextMockUnpublishGlobalAlias) Return(b1 bool) *InitializationContextMock {
	if mmUnpublishGlobalAlias.mock.funcUnpublishGlobalAlias != nil {
		mmUnpublishGlobalAlias.mock.t.Fatalf("InitializationContextMock.UnpublishGlobalAlias mock is already set by Set")
	}

	if mmUnpublishGlobalAlias.defaultExpectation == nil {
		mmUnpublishGlobalAlias.defaultExpectation = &InitializationContextMockUnpublishGlobalAliasExpectation{mock: mmUnpublishGlobalAlias.mock}
	}
	mmUnpublishGlobalAlias.defaultExpectation.results = &InitializationContextMockUnpublishGlobalAliasResults{b1}
	return mmUnpublishGlobalAlias.mock
}

//Set uses given function f to mock the InitializationContext.UnpublishGlobalAlias method
func (mmUnpublishGlobalAlias *mInitializationContextMockUnpublishGlobalAlias) Set(f func(key interface{}) (b1 bool)) *InitializationContextMock {
	if mmUnpublishGlobalAlias.defaultExpectation != nil {
		mmUnpublishGlobalAlias.mock.t.Fatalf("Default expectation is already set for the InitializationContext.UnpublishGlobalAlias method")
	}

	if len(mmUnpublishGlobalAlias.expectations) > 0 {
		mmUnpublishGlobalAlias.mock.t.Fatalf("Some expectations are already set for the InitializationContext.UnpublishGlobalAlias method")
	}

	mmUnpublishGlobalAlias.mock.funcUnpublishGlobalAlias = f
	return mmUnpublishGlobalAlias.mock
}

// When sets expectation for the InitializationContext.UnpublishGlobalAlias which will trigger the result defined by the following
// Then helper
func (mmUnpublishGlobalAlias *mInitializationContextMockUnpublishGlobalAlias) When(key interface{}) *InitializationContextMockUnpublishGlobalAliasExpectation {
	if mmUnpublishGlobalAlias.mock.funcUnpublishGlobalAlias != nil {
		mmUnpublishGlobalAlias.mock.t.Fatalf("InitializationContextMock.UnpublishGlobalAlias mock is already set by Set")
	}

	expectation := &InitializationContextMockUnpublishGlobalAliasExpectation{
		mock:   mmUnpublishGlobalAlias.mock,
		params: &InitializationContextMockUnpublishGlobalAliasParams{key},
	}
	mmUnpublishGlobalAlias.expectations = append(mmUnpublishGlobalAlias.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.UnpublishGlobalAlias return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockUnpublishGlobalAliasExpectation) Then(b1 bool) *InitializationContextMock {
	e.results = &InitializationContextMockUnpublishGlobalAliasResults{b1}
	return e.mock
}

// UnpublishGlobalAlias implements InitializationContext
func (mmUnpublishGlobalAlias *InitializationContextMock) UnpublishGlobalAlias(key interface{}) (b1 bool) {
	mm_atomic.AddUint64(&mmUnpublishGlobalAlias.beforeUnpublishGlobalAliasCounter, 1)
	defer mm_atomic.AddUint64(&mmUnpublishGlobalAlias.afterUnpublishGlobalAliasCounter, 1)

	if mmUnpublishGlobalAlias.inspectFuncUnpublishGlobalAlias != nil {
		mmUnpublishGlobalAlias.inspectFuncUnpublishGlobalAlias(key)
	}

	mm_params := &InitializationContextMockUnpublishGlobalAliasParams{key}

	// Record call args
	mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.mutex.Lock()
	mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.callArgs = append(mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.callArgs, mm_params)
	mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.mutex.Unlock()

	for _, e := range mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.defaultExpectation.Counter, 1)
		mm_want := mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.defaultExpectation.params
		mm_got := InitializationContextMockUnpublishGlobalAliasParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnpublishGlobalAlias.t.Errorf("InitializationContextMock.UnpublishGlobalAlias got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.defaultExpectation.results
		if mm_results == nil {
			mmUnpublishGlobalAlias.t.Fatal("No results are set for the InitializationContextMock.UnpublishGlobalAlias")
		}
		return (*mm_results).b1
	}
	if mmUnpublishGlobalAlias.funcUnpublishGlobalAlias != nil {
		return mmUnpublishGlobalAlias.funcUnpublishGlobalAlias(key)
	}
	mmUnpublishGlobalAlias.t.Fatalf("Unexpected call to InitializationContextMock.UnpublishGlobalAlias. %v", key)
	return
}

// UnpublishGlobalAliasAfterCounter returns a count of finished InitializationContextMock.UnpublishGlobalAlias invocations
func (mmUnpublishGlobalAlias *InitializationContextMock) UnpublishGlobalAliasAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpublishGlobalAlias.afterUnpublishGlobalAliasCounter)
}

// UnpublishGlobalAliasBeforeCounter returns a count of InitializationContextMock.UnpublishGlobalAlias invocations
func (mmUnpublishGlobalAlias *InitializationContextMock) UnpublishGlobalAliasBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpublishGlobalAlias.beforeUnpublishGlobalAliasCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.UnpublishGlobalAlias.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnpublishGlobalAlias *mInitializationContextMockUnpublishGlobalAlias) Calls() []*InitializationContextMockUnpublishGlobalAliasParams {
	mmUnpublishGlobalAlias.mutex.RLock()

	argCopy := make([]*InitializationContextMockUnpublishGlobalAliasParams, len(mmUnpublishGlobalAlias.callArgs))
	copy(argCopy, mmUnpublishGlobalAlias.callArgs)

	mmUnpublishGlobalAlias.mutex.RUnlock()

	return argCopy
}

// MinimockUnpublishGlobalAliasDone returns true if the count of the UnpublishGlobalAlias invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockUnpublishGlobalAliasDone() bool {
	for _, e := range m.UnpublishGlobalAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpublishGlobalAliasMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpublishGlobalAliasCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpublishGlobalAlias != nil && mm_atomic.LoadUint64(&m.afterUnpublishGlobalAliasCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnpublishGlobalAliasInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockUnpublishGlobalAliasInspect() {
	for _, e := range m.UnpublishGlobalAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.UnpublishGlobalAlias with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpublishGlobalAliasMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpublishGlobalAliasCounter) < 1 {
		if m.UnpublishGlobalAliasMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.UnpublishGlobalAlias")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.UnpublishGlobalAlias with params: %#v", *m.UnpublishGlobalAliasMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpublishGlobalAlias != nil && mm_atomic.LoadUint64(&m.afterUnpublishGlobalAliasCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.UnpublishGlobalAlias")
	}
}

type mInitializationContextMockUnshare struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockUnshareExpectation
	expectations       []*InitializationContextMockUnshareExpectation

	callArgs []*InitializationContextMockUnshareParams
	mutex    sync.RWMutex
}

// InitializationContextMockUnshareExpectation specifies expectation struct of the InitializationContext.Unshare
type InitializationContextMockUnshareExpectation struct {
	mock    *InitializationContextMock
	params  *InitializationContextMockUnshareParams
	results *InitializationContextMockUnshareResults
	Counter uint64
}

// InitializationContextMockUnshareParams contains parameters of the InitializationContext.Unshare
type InitializationContextMockUnshareParams struct {
	s1 SharedDataLink
}

// InitializationContextMockUnshareResults contains results of the InitializationContext.Unshare
type InitializationContextMockUnshareResults struct {
	b1 bool
}

// Expect sets up expected params for InitializationContext.Unshare
func (mmUnshare *mInitializationContextMockUnshare) Expect(s1 SharedDataLink) *mInitializationContextMockUnshare {
	if mmUnshare.mock.funcUnshare != nil {
		mmUnshare.mock.t.Fatalf("InitializationContextMock.Unshare mock is already set by Set")
	}

	if mmUnshare.defaultExpectation == nil {
		mmUnshare.defaultExpectation = &InitializationContextMockUnshareExpectation{}
	}

	mmUnshare.defaultExpectation.params = &InitializationContextMockUnshareParams{s1}
	for _, e := range mmUnshare.expectations {
		if minimock.Equal(e.params, mmUnshare.defaultExpectation.params) {
			mmUnshare.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnshare.defaultExpectation.params)
		}
	}

	return mmUnshare
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.Unshare
func (mmUnshare *mInitializationContextMockUnshare) Inspect(f func(s1 SharedDataLink)) *mInitializationContextMockUnshare {
	if mmUnshare.mock.inspectFuncUnshare != nil {
		mmUnshare.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.Unshare")
	}

	mmUnshare.mock.inspectFuncUnshare = f

	return mmUnshare
}

// Return sets up results that will be returned by InitializationContext.Unshare
func (mmUnshare *mInitializationContextMockUnshare) Return(b1 bool) *InitializationContextMock {
	if mmUnshare.mock.funcUnshare != nil {
		mmUnshare.mock.t.Fatalf("InitializationContextMock.Unshare mock is already set by Set")
	}

	if mmUnshare.defaultExpectation == nil {
		mmUnshare.defaultExpectation = &InitializationContextMockUnshareExpectation{mock: mmUnshare.mock}
	}
	mmUnshare.defaultExpectation.results = &InitializationContextMockUnshareResults{b1}
	return mmUnshare.mock
}

//Set uses given function f to mock the InitializationContext.Unshare method
func (mmUnshare *mInitializationContextMockUnshare) Set(f func(s1 SharedDataLink) (b1 bool)) *InitializationContextMock {
	if mmUnshare.defaultExpectation != nil {
		mmUnshare.mock.t.Fatalf("Default expectation is already set for the InitializationContext.Unshare method")
	}

	if len(mmUnshare.expectations) > 0 {
		mmUnshare.mock.t.Fatalf("Some expectations are already set for the InitializationContext.Unshare method")
	}

	mmUnshare.mock.funcUnshare = f
	return mmUnshare.mock
}

// When sets expectation for the InitializationContext.Unshare which will trigger the result defined by the following
// Then helper
func (mmUnshare *mInitializationContextMockUnshare) When(s1 SharedDataLink) *InitializationContextMockUnshareExpectation {
	if mmUnshare.mock.funcUnshare != nil {
		mmUnshare.mock.t.Fatalf("InitializationContextMock.Unshare mock is already set by Set")
	}

	expectation := &InitializationContextMockUnshareExpectation{
		mock:   mmUnshare.mock,
		params: &InitializationContextMockUnshareParams{s1},
	}
	mmUnshare.expectations = append(mmUnshare.expectations, expectation)
	return expectation
}

// Then sets up InitializationContext.Unshare return parameters for the expectation previously defined by the When method
func (e *InitializationContextMockUnshareExpectation) Then(b1 bool) *InitializationContextMock {
	e.results = &InitializationContextMockUnshareResults{b1}
	return e.mock
}

// Unshare implements InitializationContext
func (mmUnshare *InitializationContextMock) Unshare(s1 SharedDataLink) (b1 bool) {
	mm_atomic.AddUint64(&mmUnshare.beforeUnshareCounter, 1)
	defer mm_atomic.AddUint64(&mmUnshare.afterUnshareCounter, 1)

	if mmUnshare.inspectFuncUnshare != nil {
		mmUnshare.inspectFuncUnshare(s1)
	}

	mm_params := &InitializationContextMockUnshareParams{s1}

	// Record call args
	mmUnshare.UnshareMock.mutex.Lock()
	mmUnshare.UnshareMock.callArgs = append(mmUnshare.UnshareMock.callArgs, mm_params)
	mmUnshare.UnshareMock.mutex.Unlock()

	for _, e := range mmUnshare.UnshareMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmUnshare.UnshareMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnshare.UnshareMock.defaultExpectation.Counter, 1)
		mm_want := mmUnshare.UnshareMock.defaultExpectation.params
		mm_got := InitializationContextMockUnshareParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnshare.t.Errorf("InitializationContextMock.Unshare got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnshare.UnshareMock.defaultExpectation.results
		if mm_results == nil {
			mmUnshare.t.Fatal("No results are set for the InitializationContextMock.Unshare")
		}
		return (*mm_results).b1
	}
	if mmUnshare.funcUnshare != nil {
		return mmUnshare.funcUnshare(s1)
	}
	mmUnshare.t.Fatalf("Unexpected call to InitializationContextMock.Unshare. %v", s1)
	return
}

// UnshareAfterCounter returns a count of finished InitializationContextMock.Unshare invocations
func (mmUnshare *InitializationContextMock) UnshareAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnshare.afterUnshareCounter)
}

// UnshareBeforeCounter returns a count of InitializationContextMock.Unshare invocations
func (mmUnshare *InitializationContextMock) UnshareBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnshare.beforeUnshareCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.Unshare.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnshare *mInitializationContextMockUnshare) Calls() []*InitializationContextMockUnshareParams {
	mmUnshare.mutex.RLock()

	argCopy := make([]*InitializationContextMockUnshareParams, len(mmUnshare.callArgs))
	copy(argCopy, mmUnshare.callArgs)

	mmUnshare.mutex.RUnlock()

	return argCopy
}

// MinimockUnshareDone returns true if the count of the Unshare invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockUnshareDone() bool {
	for _, e := range m.UnshareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnshareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnshareCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnshare != nil && mm_atomic.LoadUint64(&m.afterUnshareCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnshareInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockUnshareInspect() {
	for _, e := range m.UnshareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.Unshare with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnshareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnshareCounter) < 1 {
		if m.UnshareMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.Unshare")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.Unshare with params: %#v", *m.UnshareMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnshare != nil && mm_atomic.LoadUint64(&m.afterUnshareCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.Unshare")
	}
}

type mInitializationContextMockUpdateDefaultStepLogger struct {
	mock               *InitializationContextMock
	defaultExpectation *InitializationContextMockUpdateDefaultStepLoggerExpectation
	expectations       []*InitializationContextMockUpdateDefaultStepLoggerExpectation

	callArgs []*InitializationContextMockUpdateDefaultStepLoggerParams
	mutex    sync.RWMutex
}

// InitializationContextMockUpdateDefaultStepLoggerExpectation specifies expectation struct of the InitializationContext.UpdateDefaultStepLogger
type InitializationContextMockUpdateDefaultStepLoggerExpectation struct {
	mock   *InitializationContextMock
	params *InitializationContextMockUpdateDefaultStepLoggerParams

	Counter uint64
}

// InitializationContextMockUpdateDefaultStepLoggerParams contains parameters of the InitializationContext.UpdateDefaultStepLogger
type InitializationContextMockUpdateDefaultStepLoggerParams struct {
	updateFn StepLoggerUpdateFunc
}

// Expect sets up expected params for InitializationContext.UpdateDefaultStepLogger
func (mmUpdateDefaultStepLogger *mInitializationContextMockUpdateDefaultStepLogger) Expect(updateFn StepLoggerUpdateFunc) *mInitializationContextMockUpdateDefaultStepLogger {
	if mmUpdateDefaultStepLogger.mock.funcUpdateDefaultStepLogger != nil {
		mmUpdateDefaultStepLogger.mock.t.Fatalf("InitializationContextMock.UpdateDefaultStepLogger mock is already set by Set")
	}

	if mmUpdateDefaultStepLogger.defaultExpectation == nil {
		mmUpdateDefaultStepLogger.defaultExpectation = &InitializationContextMockUpdateDefaultStepLoggerExpectation{}
	}

	mmUpdateDefaultStepLogger.defaultExpectation.params = &InitializationContextMockUpdateDefaultStepLoggerParams{updateFn}
	for _, e := range mmUpdateDefaultStepLogger.expectations {
		if minimock.Equal(e.params, mmUpdateDefaultStepLogger.defaultExpectation.params) {
			mmUpdateDefaultStepLogger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateDefaultStepLogger.defaultExpectation.params)
		}
	}

	return mmUpdateDefaultStepLogger
}

// Inspect accepts an inspector function that has same arguments as the InitializationContext.UpdateDefaultStepLogger
func (mmUpdateDefaultStepLogger *mInitializationContextMockUpdateDefaultStepLogger) Inspect(f func(updateFn StepLoggerUpdateFunc)) *mInitializationContextMockUpdateDefaultStepLogger {
	if mmUpdateDefaultStepLogger.mock.inspectFuncUpdateDefaultStepLogger != nil {
		mmUpdateDefaultStepLogger.mock.t.Fatalf("Inspect function is already set for InitializationContextMock.UpdateDefaultStepLogger")
	}

	mmUpdateDefaultStepLogger.mock.inspectFuncUpdateDefaultStepLogger = f

	return mmUpdateDefaultStepLogger
}

// Return sets up results that will be returned by InitializationContext.UpdateDefaultStepLogger
func (mmUpdateDefaultStepLogger *mInitializationContextMockUpdateDefaultStepLogger) Return() *InitializationContextMock {
	if mmUpdateDefaultStepLogger.mock.funcUpdateDefaultStepLogger != nil {
		mmUpdateDefaultStepLogger.mock.t.Fatalf("InitializationContextMock.UpdateDefaultStepLogger mock is already set by Set")
	}

	if mmUpdateDefaultStepLogger.defaultExpectation == nil {
		mmUpdateDefaultStepLogger.defaultExpectation = &InitializationContextMockUpdateDefaultStepLoggerExpectation{mock: mmUpdateDefaultStepLogger.mock}
	}

	return mmUpdateDefaultStepLogger.mock
}

//Set uses given function f to mock the InitializationContext.UpdateDefaultStepLogger method
func (mmUpdateDefaultStepLogger *mInitializationContextMockUpdateDefaultStepLogger) Set(f func(updateFn StepLoggerUpdateFunc)) *InitializationContextMock {
	if mmUpdateDefaultStepLogger.defaultExpectation != nil {
		mmUpdateDefaultStepLogger.mock.t.Fatalf("Default expectation is already set for the InitializationContext.UpdateDefaultStepLogger method")
	}

	if len(mmUpdateDefaultStepLogger.expectations) > 0 {
		mmUpdateDefaultStepLogger.mock.t.Fatalf("Some expectations are already set for the InitializationContext.UpdateDefaultStepLogger method")
	}

	mmUpdateDefaultStepLogger.mock.funcUpdateDefaultStepLogger = f
	return mmUpdateDefaultStepLogger.mock
}

// UpdateDefaultStepLogger implements InitializationContext
func (mmUpdateDefaultStepLogger *InitializationContextMock) UpdateDefaultStepLogger(updateFn StepLoggerUpdateFunc) {
	mm_atomic.AddUint64(&mmUpdateDefaultStepLogger.beforeUpdateDefaultStepLoggerCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateDefaultStepLogger.afterUpdateDefaultStepLoggerCounter, 1)

	if mmUpdateDefaultStepLogger.inspectFuncUpdateDefaultStepLogger != nil {
		mmUpdateDefaultStepLogger.inspectFuncUpdateDefaultStepLogger(updateFn)
	}

	mm_params := &InitializationContextMockUpdateDefaultStepLoggerParams{updateFn}

	// Record call args
	mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.mutex.Lock()
	mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.callArgs = append(mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.callArgs, mm_params)
	mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.mutex.Unlock()

	for _, e := range mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.defaultExpectation.params
		mm_got := InitializationContextMockUpdateDefaultStepLoggerParams{updateFn}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateDefaultStepLogger.t.Errorf("InitializationContextMock.UpdateDefaultStepLogger got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmUpdateDefaultStepLogger.funcUpdateDefaultStepLogger != nil {
		mmUpdateDefaultStepLogger.funcUpdateDefaultStepLogger(updateFn)
		return
	}
	mmUpdateDefaultStepLogger.t.Fatalf("Unexpected call to InitializationContextMock.UpdateDefaultStepLogger. %v", updateFn)

}

// UpdateDefaultStepLoggerAfterCounter returns a count of finished InitializationContextMock.UpdateDefaultStepLogger invocations
func (mmUpdateDefaultStepLogger *InitializationContextMock) UpdateDefaultStepLoggerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateDefaultStepLogger.afterUpdateDefaultStepLoggerCounter)
}

// UpdateDefaultStepLoggerBeforeCounter returns a count of InitializationContextMock.UpdateDefaultStepLogger invocations
func (mmUpdateDefaultStepLogger *InitializationContextMock) UpdateDefaultStepLoggerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateDefaultStepLogger.beforeUpdateDefaultStepLoggerCounter)
}

// Calls returns a list of arguments used in each call to InitializationContextMock.UpdateDefaultStepLogger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateDefaultStepLogger *mInitializationContextMockUpdateDefaultStepLogger) Calls() []*InitializationContextMockUpdateDefaultStepLoggerParams {
	mmUpdateDefaultStepLogger.mutex.RLock()

	argCopy := make([]*InitializationContextMockUpdateDefaultStepLoggerParams, len(mmUpdateDefaultStepLogger.callArgs))
	copy(argCopy, mmUpdateDefaultStepLogger.callArgs)

	mmUpdateDefaultStepLogger.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDefaultStepLoggerDone returns true if the count of the UpdateDefaultStepLogger invocations corresponds
// the number of defined expectations
func (m *InitializationContextMock) MinimockUpdateDefaultStepLoggerDone() bool {
	for _, e := range m.UpdateDefaultStepLoggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateDefaultStepLoggerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateDefaultStepLoggerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateDefaultStepLogger != nil && mm_atomic.LoadUint64(&m.afterUpdateDefaultStepLoggerCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateDefaultStepLoggerInspect logs each unmet expectation
func (m *InitializationContextMock) MinimockUpdateDefaultStepLoggerInspect() {
	for _, e := range m.UpdateDefaultStepLoggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InitializationContextMock.UpdateDefaultStepLogger with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateDefaultStepLoggerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateDefaultStepLoggerCounter) < 1 {
		if m.UpdateDefaultStepLoggerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InitializationContextMock.UpdateDefaultStepLogger")
		} else {
			m.t.Errorf("Expected call to InitializationContextMock.UpdateDefaultStepLogger with params: %#v", *m.UpdateDefaultStepLoggerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateDefaultStepLogger != nil && mm_atomic.LoadUint64(&m.afterUpdateDefaultStepLoggerCounter) < 1 {
		m.t.Error("Expected call to InitializationContextMock.UpdateDefaultStepLogger")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *InitializationContextMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAcquireInspect()

		m.MinimockAcquireAndReleaseInspect()

		m.MinimockAcquireForThisStepInspect()

		m.MinimockAcquireForThisStepAndReleaseInspect()

		m.MinimockApplyAdjustmentInspect()

		m.MinimockCallBargeInInspect()

		m.MinimockCallBargeInWithParamInspect()

		m.MinimockCheckInspect()

		m.MinimockErrorInspect()

		m.MinimockErrorfInspect()

		m.MinimockGetContextInspect()

		m.MinimockGetDefaultTerminationResultInspect()

		m.MinimockGetPublishedInspect()

		m.MinimockGetPublishedGlobalAliasInspect()

		m.MinimockGetPublishedGlobalAliasAndBargeInInspect()

		m.MinimockGetPublishedLinkInspect()

		m.MinimockJumpInspect()

		m.MinimockJumpExtInspect()

		m.MinimockLogInspect()

		m.MinimockNewBargeInInspect()

		m.MinimockNewBargeInWithParamInspect()

		m.MinimockParentLinkInspect()

		m.MinimockPublishInspect()

		m.MinimockPublishGlobalAliasInspect()

		m.MinimockPublishGlobalAliasAndBargeInInspect()

		m.MinimockReleaseInspect()

		m.MinimockReleaseAllInspect()

		m.MinimockSetDefaultErrorHandlerInspect()

		m.MinimockSetDefaultFlagsInspect()

		m.MinimockSetDefaultMigrationInspect()

		m.MinimockSetDefaultTerminationResultInspect()

		m.MinimockSetDynamicBoostInspect()

		m.MinimockSetLogTracingInspect()

		m.MinimockShareInspect()

		m.MinimockSlotLinkInspect()

		m.MinimockStopInspect()

		m.MinimockUnpublishInspect()

		m.MinimockUnpublishAllInspect()

		m.MinimockUnpublishGlobalAliasInspect()

		m.MinimockUnshareInspect()

		m.MinimockUpdateDefaultStepLoggerInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *InitializationContextMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *InitializationContextMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAcquireDone() &&
		m.MinimockAcquireAndReleaseDone() &&
		m.MinimockAcquireForThisStepDone() &&
		m.MinimockAcquireForThisStepAndReleaseDone() &&
		m.MinimockApplyAdjustmentDone() &&
		m.MinimockCallBargeInDone() &&
		m.MinimockCallBargeInWithParamDone() &&
		m.MinimockCheckDone() &&
		m.MinimockErrorDone() &&
		m.MinimockErrorfDone() &&
		m.MinimockGetContextDone() &&
		m.MinimockGetDefaultTerminationResultDone() &&
		m.MinimockGetPublishedDone() &&
		m.MinimockGetPublishedGlobalAliasDone() &&
		m.MinimockGetPublishedGlobalAliasAndBargeInDone() &&
		m.MinimockGetPublishedLinkDone() &&
		m.MinimockJumpDone() &&
		m.MinimockJumpExtDone() &&
		m.MinimockLogDone() &&
		m.MinimockNewBargeInDone() &&
		m.MinimockNewBargeInWithParamDone() &&
		m.MinimockParentLinkDone() &&
		m.MinimockPublishDone() &&
		m.MinimockPublishGlobalAliasDone() &&
		m.MinimockPublishGlobalAliasAndBargeInDone() &&
		m.MinimockReleaseDone() &&
		m.MinimockReleaseAllDone() &&
		m.MinimockSetDefaultErrorHandlerDone() &&
		m.MinimockSetDefaultFlagsDone() &&
		m.MinimockSetDefaultMigrationDone() &&
		m.MinimockSetDefaultTerminationResultDone() &&
		m.MinimockSetDynamicBoostDone() &&
		m.MinimockSetLogTracingDone() &&
		m.MinimockShareDone() &&
		m.MinimockSlotLinkDone() &&
		m.MinimockStopDone() &&
		m.MinimockUnpublishDone() &&
		m.MinimockUnpublishAllDone() &&
		m.MinimockUnpublishGlobalAliasDone() &&
		m.MinimockUnshareDone() &&
		m.MinimockUpdateDefaultStepLoggerDone()
}
