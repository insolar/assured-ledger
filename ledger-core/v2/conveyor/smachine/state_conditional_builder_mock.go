package smachine

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StateConditionalBuilderMock implements StateConditionalBuilder
type StateConditionalBuilderMock struct {
	t minimock.Tester

	funcGetDecision          func() (d1 Decision)
	inspectFuncGetDecision   func()
	afterGetDecisionCounter  uint64
	beforeGetDecisionCounter uint64
	GetDecisionMock          mStateConditionalBuilderMockGetDecision

	funcThenJump          func(s1 StateFunc) (s2 StateUpdate)
	inspectFuncThenJump   func(s1 StateFunc)
	afterThenJumpCounter  uint64
	beforeThenJumpCounter uint64
	ThenJumpMock          mStateConditionalBuilderMockThenJump

	funcThenJumpExt          func(s1 SlotStep) (s2 StateUpdate)
	inspectFuncThenJumpExt   func(s1 SlotStep)
	afterThenJumpExtCounter  uint64
	beforeThenJumpExtCounter uint64
	ThenJumpExtMock          mStateConditionalBuilderMockThenJumpExt

	funcThenRepeat          func() (s1 StateUpdate)
	inspectFuncThenRepeat   func()
	afterThenRepeatCounter  uint64
	beforeThenRepeatCounter uint64
	ThenRepeatMock          mStateConditionalBuilderMockThenRepeat

	funcThenRepeatOrElse          func() (s1 StateUpdate, b1 bool)
	inspectFuncThenRepeatOrElse   func()
	afterThenRepeatOrElseCounter  uint64
	beforeThenRepeatOrElseCounter uint64
	ThenRepeatOrElseMock          mStateConditionalBuilderMockThenRepeatOrElse

	funcThenRepeatOrJump          func(s1 StateFunc) (s2 StateUpdate)
	inspectFuncThenRepeatOrJump   func(s1 StateFunc)
	afterThenRepeatOrJumpCounter  uint64
	beforeThenRepeatOrJumpCounter uint64
	ThenRepeatOrJumpMock          mStateConditionalBuilderMockThenRepeatOrJump

	funcThenRepeatOrJumpExt          func(s1 SlotStep) (s2 StateUpdate)
	inspectFuncThenRepeatOrJumpExt   func(s1 SlotStep)
	afterThenRepeatOrJumpExtCounter  uint64
	beforeThenRepeatOrJumpExtCounter uint64
	ThenRepeatOrJumpExtMock          mStateConditionalBuilderMockThenRepeatOrJumpExt
}

// NewStateConditionalBuilderMock returns a mock for StateConditionalBuilder
func NewStateConditionalBuilderMock(t minimock.Tester) *StateConditionalBuilderMock {
	m := &StateConditionalBuilderMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetDecisionMock = mStateConditionalBuilderMockGetDecision{mock: m}

	m.ThenJumpMock = mStateConditionalBuilderMockThenJump{mock: m}
	m.ThenJumpMock.callArgs = []*StateConditionalBuilderMockThenJumpParams{}

	m.ThenJumpExtMock = mStateConditionalBuilderMockThenJumpExt{mock: m}
	m.ThenJumpExtMock.callArgs = []*StateConditionalBuilderMockThenJumpExtParams{}

	m.ThenRepeatMock = mStateConditionalBuilderMockThenRepeat{mock: m}

	m.ThenRepeatOrElseMock = mStateConditionalBuilderMockThenRepeatOrElse{mock: m}

	m.ThenRepeatOrJumpMock = mStateConditionalBuilderMockThenRepeatOrJump{mock: m}
	m.ThenRepeatOrJumpMock.callArgs = []*StateConditionalBuilderMockThenRepeatOrJumpParams{}

	m.ThenRepeatOrJumpExtMock = mStateConditionalBuilderMockThenRepeatOrJumpExt{mock: m}
	m.ThenRepeatOrJumpExtMock.callArgs = []*StateConditionalBuilderMockThenRepeatOrJumpExtParams{}

	return m
}

type mStateConditionalBuilderMockGetDecision struct {
	mock               *StateConditionalBuilderMock
	defaultExpectation *StateConditionalBuilderMockGetDecisionExpectation
	expectations       []*StateConditionalBuilderMockGetDecisionExpectation
}

// StateConditionalBuilderMockGetDecisionExpectation specifies expectation struct of the StateConditionalBuilder.GetDecision
type StateConditionalBuilderMockGetDecisionExpectation struct {
	mock *StateConditionalBuilderMock

	results *StateConditionalBuilderMockGetDecisionResults
	Counter uint64
}

// StateConditionalBuilderMockGetDecisionResults contains results of the StateConditionalBuilder.GetDecision
type StateConditionalBuilderMockGetDecisionResults struct {
	d1 Decision
}

// Expect sets up expected params for StateConditionalBuilder.GetDecision
func (mmGetDecision *mStateConditionalBuilderMockGetDecision) Expect() *mStateConditionalBuilderMockGetDecision {
	if mmGetDecision.mock.funcGetDecision != nil {
		mmGetDecision.mock.t.Fatalf("StateConditionalBuilderMock.GetDecision mock is already set by Set")
	}

	if mmGetDecision.defaultExpectation == nil {
		mmGetDecision.defaultExpectation = &StateConditionalBuilderMockGetDecisionExpectation{}
	}

	return mmGetDecision
}

// Inspect accepts an inspector function that has same arguments as the StateConditionalBuilder.GetDecision
func (mmGetDecision *mStateConditionalBuilderMockGetDecision) Inspect(f func()) *mStateConditionalBuilderMockGetDecision {
	if mmGetDecision.mock.inspectFuncGetDecision != nil {
		mmGetDecision.mock.t.Fatalf("Inspect function is already set for StateConditionalBuilderMock.GetDecision")
	}

	mmGetDecision.mock.inspectFuncGetDecision = f

	return mmGetDecision
}

// Return sets up results that will be returned by StateConditionalBuilder.GetDecision
func (mmGetDecision *mStateConditionalBuilderMockGetDecision) Return(d1 Decision) *StateConditionalBuilderMock {
	if mmGetDecision.mock.funcGetDecision != nil {
		mmGetDecision.mock.t.Fatalf("StateConditionalBuilderMock.GetDecision mock is already set by Set")
	}

	if mmGetDecision.defaultExpectation == nil {
		mmGetDecision.defaultExpectation = &StateConditionalBuilderMockGetDecisionExpectation{mock: mmGetDecision.mock}
	}
	mmGetDecision.defaultExpectation.results = &StateConditionalBuilderMockGetDecisionResults{d1}
	return mmGetDecision.mock
}

//Set uses given function f to mock the StateConditionalBuilder.GetDecision method
func (mmGetDecision *mStateConditionalBuilderMockGetDecision) Set(f func() (d1 Decision)) *StateConditionalBuilderMock {
	if mmGetDecision.defaultExpectation != nil {
		mmGetDecision.mock.t.Fatalf("Default expectation is already set for the StateConditionalBuilder.GetDecision method")
	}

	if len(mmGetDecision.expectations) > 0 {
		mmGetDecision.mock.t.Fatalf("Some expectations are already set for the StateConditionalBuilder.GetDecision method")
	}

	mmGetDecision.mock.funcGetDecision = f
	return mmGetDecision.mock
}

// GetDecision implements StateConditionalBuilder
func (mmGetDecision *StateConditionalBuilderMock) GetDecision() (d1 Decision) {
	mm_atomic.AddUint64(&mmGetDecision.beforeGetDecisionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDecision.afterGetDecisionCounter, 1)

	if mmGetDecision.inspectFuncGetDecision != nil {
		mmGetDecision.inspectFuncGetDecision()
	}

	if mmGetDecision.GetDecisionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDecision.GetDecisionMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDecision.GetDecisionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDecision.t.Fatal("No results are set for the StateConditionalBuilderMock.GetDecision")
		}
		return (*mm_results).d1
	}
	if mmGetDecision.funcGetDecision != nil {
		return mmGetDecision.funcGetDecision()
	}
	mmGetDecision.t.Fatalf("Unexpected call to StateConditionalBuilderMock.GetDecision.")
	return
}

// GetDecisionAfterCounter returns a count of finished StateConditionalBuilderMock.GetDecision invocations
func (mmGetDecision *StateConditionalBuilderMock) GetDecisionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDecision.afterGetDecisionCounter)
}

// GetDecisionBeforeCounter returns a count of StateConditionalBuilderMock.GetDecision invocations
func (mmGetDecision *StateConditionalBuilderMock) GetDecisionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDecision.beforeGetDecisionCounter)
}

// MinimockGetDecisionDone returns true if the count of the GetDecision invocations corresponds
// the number of defined expectations
func (m *StateConditionalBuilderMock) MinimockGetDecisionDone() bool {
	for _, e := range m.GetDecisionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDecisionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDecisionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDecision != nil && mm_atomic.LoadUint64(&m.afterGetDecisionCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDecisionInspect logs each unmet expectation
func (m *StateConditionalBuilderMock) MinimockGetDecisionInspect() {
	for _, e := range m.GetDecisionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StateConditionalBuilderMock.GetDecision")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDecisionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDecisionCounter) < 1 {
		m.t.Error("Expected call to StateConditionalBuilderMock.GetDecision")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDecision != nil && mm_atomic.LoadUint64(&m.afterGetDecisionCounter) < 1 {
		m.t.Error("Expected call to StateConditionalBuilderMock.GetDecision")
	}
}

type mStateConditionalBuilderMockThenJump struct {
	mock               *StateConditionalBuilderMock
	defaultExpectation *StateConditionalBuilderMockThenJumpExpectation
	expectations       []*StateConditionalBuilderMockThenJumpExpectation

	callArgs []*StateConditionalBuilderMockThenJumpParams
	mutex    sync.RWMutex
}

// StateConditionalBuilderMockThenJumpExpectation specifies expectation struct of the StateConditionalBuilder.ThenJump
type StateConditionalBuilderMockThenJumpExpectation struct {
	mock    *StateConditionalBuilderMock
	params  *StateConditionalBuilderMockThenJumpParams
	results *StateConditionalBuilderMockThenJumpResults
	Counter uint64
}

// StateConditionalBuilderMockThenJumpParams contains parameters of the StateConditionalBuilder.ThenJump
type StateConditionalBuilderMockThenJumpParams struct {
	s1 StateFunc
}

// StateConditionalBuilderMockThenJumpResults contains results of the StateConditionalBuilder.ThenJump
type StateConditionalBuilderMockThenJumpResults struct {
	s2 StateUpdate
}

// Expect sets up expected params for StateConditionalBuilder.ThenJump
func (mmThenJump *mStateConditionalBuilderMockThenJump) Expect(s1 StateFunc) *mStateConditionalBuilderMockThenJump {
	if mmThenJump.mock.funcThenJump != nil {
		mmThenJump.mock.t.Fatalf("StateConditionalBuilderMock.ThenJump mock is already set by Set")
	}

	if mmThenJump.defaultExpectation == nil {
		mmThenJump.defaultExpectation = &StateConditionalBuilderMockThenJumpExpectation{}
	}

	mmThenJump.defaultExpectation.params = &StateConditionalBuilderMockThenJumpParams{s1}
	for _, e := range mmThenJump.expectations {
		if minimock.Equal(e.params, mmThenJump.defaultExpectation.params) {
			mmThenJump.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmThenJump.defaultExpectation.params)
		}
	}

	return mmThenJump
}

// Inspect accepts an inspector function that has same arguments as the StateConditionalBuilder.ThenJump
func (mmThenJump *mStateConditionalBuilderMockThenJump) Inspect(f func(s1 StateFunc)) *mStateConditionalBuilderMockThenJump {
	if mmThenJump.mock.inspectFuncThenJump != nil {
		mmThenJump.mock.t.Fatalf("Inspect function is already set for StateConditionalBuilderMock.ThenJump")
	}

	mmThenJump.mock.inspectFuncThenJump = f

	return mmThenJump
}

// Return sets up results that will be returned by StateConditionalBuilder.ThenJump
func (mmThenJump *mStateConditionalBuilderMockThenJump) Return(s2 StateUpdate) *StateConditionalBuilderMock {
	if mmThenJump.mock.funcThenJump != nil {
		mmThenJump.mock.t.Fatalf("StateConditionalBuilderMock.ThenJump mock is already set by Set")
	}

	if mmThenJump.defaultExpectation == nil {
		mmThenJump.defaultExpectation = &StateConditionalBuilderMockThenJumpExpectation{mock: mmThenJump.mock}
	}
	mmThenJump.defaultExpectation.results = &StateConditionalBuilderMockThenJumpResults{s2}
	return mmThenJump.mock
}

//Set uses given function f to mock the StateConditionalBuilder.ThenJump method
func (mmThenJump *mStateConditionalBuilderMockThenJump) Set(f func(s1 StateFunc) (s2 StateUpdate)) *StateConditionalBuilderMock {
	if mmThenJump.defaultExpectation != nil {
		mmThenJump.mock.t.Fatalf("Default expectation is already set for the StateConditionalBuilder.ThenJump method")
	}

	if len(mmThenJump.expectations) > 0 {
		mmThenJump.mock.t.Fatalf("Some expectations are already set for the StateConditionalBuilder.ThenJump method")
	}

	mmThenJump.mock.funcThenJump = f
	return mmThenJump.mock
}

// When sets expectation for the StateConditionalBuilder.ThenJump which will trigger the result defined by the following
// Then helper
func (mmThenJump *mStateConditionalBuilderMockThenJump) When(s1 StateFunc) *StateConditionalBuilderMockThenJumpExpectation {
	if mmThenJump.mock.funcThenJump != nil {
		mmThenJump.mock.t.Fatalf("StateConditionalBuilderMock.ThenJump mock is already set by Set")
	}

	expectation := &StateConditionalBuilderMockThenJumpExpectation{
		mock:   mmThenJump.mock,
		params: &StateConditionalBuilderMockThenJumpParams{s1},
	}
	mmThenJump.expectations = append(mmThenJump.expectations, expectation)
	return expectation
}

// Then sets up StateConditionalBuilder.ThenJump return parameters for the expectation previously defined by the When method
func (e *StateConditionalBuilderMockThenJumpExpectation) Then(s2 StateUpdate) *StateConditionalBuilderMock {
	e.results = &StateConditionalBuilderMockThenJumpResults{s2}
	return e.mock
}

// ThenJump implements StateConditionalBuilder
func (mmThenJump *StateConditionalBuilderMock) ThenJump(s1 StateFunc) (s2 StateUpdate) {
	mm_atomic.AddUint64(&mmThenJump.beforeThenJumpCounter, 1)
	defer mm_atomic.AddUint64(&mmThenJump.afterThenJumpCounter, 1)

	if mmThenJump.inspectFuncThenJump != nil {
		mmThenJump.inspectFuncThenJump(s1)
	}

	mm_params := &StateConditionalBuilderMockThenJumpParams{s1}

	// Record call args
	mmThenJump.ThenJumpMock.mutex.Lock()
	mmThenJump.ThenJumpMock.callArgs = append(mmThenJump.ThenJumpMock.callArgs, mm_params)
	mmThenJump.ThenJumpMock.mutex.Unlock()

	for _, e := range mmThenJump.ThenJumpMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2
		}
	}

	if mmThenJump.ThenJumpMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmThenJump.ThenJumpMock.defaultExpectation.Counter, 1)
		mm_want := mmThenJump.ThenJumpMock.defaultExpectation.params
		mm_got := StateConditionalBuilderMockThenJumpParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmThenJump.t.Errorf("StateConditionalBuilderMock.ThenJump got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmThenJump.ThenJumpMock.defaultExpectation.results
		if mm_results == nil {
			mmThenJump.t.Fatal("No results are set for the StateConditionalBuilderMock.ThenJump")
		}
		return (*mm_results).s2
	}
	if mmThenJump.funcThenJump != nil {
		return mmThenJump.funcThenJump(s1)
	}
	mmThenJump.t.Fatalf("Unexpected call to StateConditionalBuilderMock.ThenJump. %v", s1)
	return
}

// ThenJumpAfterCounter returns a count of finished StateConditionalBuilderMock.ThenJump invocations
func (mmThenJump *StateConditionalBuilderMock) ThenJumpAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmThenJump.afterThenJumpCounter)
}

// ThenJumpBeforeCounter returns a count of StateConditionalBuilderMock.ThenJump invocations
func (mmThenJump *StateConditionalBuilderMock) ThenJumpBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmThenJump.beforeThenJumpCounter)
}

// Calls returns a list of arguments used in each call to StateConditionalBuilderMock.ThenJump.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmThenJump *mStateConditionalBuilderMockThenJump) Calls() []*StateConditionalBuilderMockThenJumpParams {
	mmThenJump.mutex.RLock()

	argCopy := make([]*StateConditionalBuilderMockThenJumpParams, len(mmThenJump.callArgs))
	copy(argCopy, mmThenJump.callArgs)

	mmThenJump.mutex.RUnlock()

	return argCopy
}

// MinimockThenJumpDone returns true if the count of the ThenJump invocations corresponds
// the number of defined expectations
func (m *StateConditionalBuilderMock) MinimockThenJumpDone() bool {
	for _, e := range m.ThenJumpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ThenJumpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterThenJumpCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcThenJump != nil && mm_atomic.LoadUint64(&m.afterThenJumpCounter) < 1 {
		return false
	}
	return true
}

// MinimockThenJumpInspect logs each unmet expectation
func (m *StateConditionalBuilderMock) MinimockThenJumpInspect() {
	for _, e := range m.ThenJumpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StateConditionalBuilderMock.ThenJump with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ThenJumpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterThenJumpCounter) < 1 {
		if m.ThenJumpMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StateConditionalBuilderMock.ThenJump")
		} else {
			m.t.Errorf("Expected call to StateConditionalBuilderMock.ThenJump with params: %#v", *m.ThenJumpMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcThenJump != nil && mm_atomic.LoadUint64(&m.afterThenJumpCounter) < 1 {
		m.t.Error("Expected call to StateConditionalBuilderMock.ThenJump")
	}
}

type mStateConditionalBuilderMockThenJumpExt struct {
	mock               *StateConditionalBuilderMock
	defaultExpectation *StateConditionalBuilderMockThenJumpExtExpectation
	expectations       []*StateConditionalBuilderMockThenJumpExtExpectation

	callArgs []*StateConditionalBuilderMockThenJumpExtParams
	mutex    sync.RWMutex
}

// StateConditionalBuilderMockThenJumpExtExpectation specifies expectation struct of the StateConditionalBuilder.ThenJumpExt
type StateConditionalBuilderMockThenJumpExtExpectation struct {
	mock    *StateConditionalBuilderMock
	params  *StateConditionalBuilderMockThenJumpExtParams
	results *StateConditionalBuilderMockThenJumpExtResults
	Counter uint64
}

// StateConditionalBuilderMockThenJumpExtParams contains parameters of the StateConditionalBuilder.ThenJumpExt
type StateConditionalBuilderMockThenJumpExtParams struct {
	s1 SlotStep
}

// StateConditionalBuilderMockThenJumpExtResults contains results of the StateConditionalBuilder.ThenJumpExt
type StateConditionalBuilderMockThenJumpExtResults struct {
	s2 StateUpdate
}

// Expect sets up expected params for StateConditionalBuilder.ThenJumpExt
func (mmThenJumpExt *mStateConditionalBuilderMockThenJumpExt) Expect(s1 SlotStep) *mStateConditionalBuilderMockThenJumpExt {
	if mmThenJumpExt.mock.funcThenJumpExt != nil {
		mmThenJumpExt.mock.t.Fatalf("StateConditionalBuilderMock.ThenJumpExt mock is already set by Set")
	}

	if mmThenJumpExt.defaultExpectation == nil {
		mmThenJumpExt.defaultExpectation = &StateConditionalBuilderMockThenJumpExtExpectation{}
	}

	mmThenJumpExt.defaultExpectation.params = &StateConditionalBuilderMockThenJumpExtParams{s1}
	for _, e := range mmThenJumpExt.expectations {
		if minimock.Equal(e.params, mmThenJumpExt.defaultExpectation.params) {
			mmThenJumpExt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmThenJumpExt.defaultExpectation.params)
		}
	}

	return mmThenJumpExt
}

// Inspect accepts an inspector function that has same arguments as the StateConditionalBuilder.ThenJumpExt
func (mmThenJumpExt *mStateConditionalBuilderMockThenJumpExt) Inspect(f func(s1 SlotStep)) *mStateConditionalBuilderMockThenJumpExt {
	if mmThenJumpExt.mock.inspectFuncThenJumpExt != nil {
		mmThenJumpExt.mock.t.Fatalf("Inspect function is already set for StateConditionalBuilderMock.ThenJumpExt")
	}

	mmThenJumpExt.mock.inspectFuncThenJumpExt = f

	return mmThenJumpExt
}

// Return sets up results that will be returned by StateConditionalBuilder.ThenJumpExt
func (mmThenJumpExt *mStateConditionalBuilderMockThenJumpExt) Return(s2 StateUpdate) *StateConditionalBuilderMock {
	if mmThenJumpExt.mock.funcThenJumpExt != nil {
		mmThenJumpExt.mock.t.Fatalf("StateConditionalBuilderMock.ThenJumpExt mock is already set by Set")
	}

	if mmThenJumpExt.defaultExpectation == nil {
		mmThenJumpExt.defaultExpectation = &StateConditionalBuilderMockThenJumpExtExpectation{mock: mmThenJumpExt.mock}
	}
	mmThenJumpExt.defaultExpectation.results = &StateConditionalBuilderMockThenJumpExtResults{s2}
	return mmThenJumpExt.mock
}

//Set uses given function f to mock the StateConditionalBuilder.ThenJumpExt method
func (mmThenJumpExt *mStateConditionalBuilderMockThenJumpExt) Set(f func(s1 SlotStep) (s2 StateUpdate)) *StateConditionalBuilderMock {
	if mmThenJumpExt.defaultExpectation != nil {
		mmThenJumpExt.mock.t.Fatalf("Default expectation is already set for the StateConditionalBuilder.ThenJumpExt method")
	}

	if len(mmThenJumpExt.expectations) > 0 {
		mmThenJumpExt.mock.t.Fatalf("Some expectations are already set for the StateConditionalBuilder.ThenJumpExt method")
	}

	mmThenJumpExt.mock.funcThenJumpExt = f
	return mmThenJumpExt.mock
}

// When sets expectation for the StateConditionalBuilder.ThenJumpExt which will trigger the result defined by the following
// Then helper
func (mmThenJumpExt *mStateConditionalBuilderMockThenJumpExt) When(s1 SlotStep) *StateConditionalBuilderMockThenJumpExtExpectation {
	if mmThenJumpExt.mock.funcThenJumpExt != nil {
		mmThenJumpExt.mock.t.Fatalf("StateConditionalBuilderMock.ThenJumpExt mock is already set by Set")
	}

	expectation := &StateConditionalBuilderMockThenJumpExtExpectation{
		mock:   mmThenJumpExt.mock,
		params: &StateConditionalBuilderMockThenJumpExtParams{s1},
	}
	mmThenJumpExt.expectations = append(mmThenJumpExt.expectations, expectation)
	return expectation
}

// Then sets up StateConditionalBuilder.ThenJumpExt return parameters for the expectation previously defined by the When method
func (e *StateConditionalBuilderMockThenJumpExtExpectation) Then(s2 StateUpdate) *StateConditionalBuilderMock {
	e.results = &StateConditionalBuilderMockThenJumpExtResults{s2}
	return e.mock
}

// ThenJumpExt implements StateConditionalBuilder
func (mmThenJumpExt *StateConditionalBuilderMock) ThenJumpExt(s1 SlotStep) (s2 StateUpdate) {
	mm_atomic.AddUint64(&mmThenJumpExt.beforeThenJumpExtCounter, 1)
	defer mm_atomic.AddUint64(&mmThenJumpExt.afterThenJumpExtCounter, 1)

	if mmThenJumpExt.inspectFuncThenJumpExt != nil {
		mmThenJumpExt.inspectFuncThenJumpExt(s1)
	}

	mm_params := &StateConditionalBuilderMockThenJumpExtParams{s1}

	// Record call args
	mmThenJumpExt.ThenJumpExtMock.mutex.Lock()
	mmThenJumpExt.ThenJumpExtMock.callArgs = append(mmThenJumpExt.ThenJumpExtMock.callArgs, mm_params)
	mmThenJumpExt.ThenJumpExtMock.mutex.Unlock()

	for _, e := range mmThenJumpExt.ThenJumpExtMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2
		}
	}

	if mmThenJumpExt.ThenJumpExtMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmThenJumpExt.ThenJumpExtMock.defaultExpectation.Counter, 1)
		mm_want := mmThenJumpExt.ThenJumpExtMock.defaultExpectation.params
		mm_got := StateConditionalBuilderMockThenJumpExtParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmThenJumpExt.t.Errorf("StateConditionalBuilderMock.ThenJumpExt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmThenJumpExt.ThenJumpExtMock.defaultExpectation.results
		if mm_results == nil {
			mmThenJumpExt.t.Fatal("No results are set for the StateConditionalBuilderMock.ThenJumpExt")
		}
		return (*mm_results).s2
	}
	if mmThenJumpExt.funcThenJumpExt != nil {
		return mmThenJumpExt.funcThenJumpExt(s1)
	}
	mmThenJumpExt.t.Fatalf("Unexpected call to StateConditionalBuilderMock.ThenJumpExt. %v", s1)
	return
}

// ThenJumpExtAfterCounter returns a count of finished StateConditionalBuilderMock.ThenJumpExt invocations
func (mmThenJumpExt *StateConditionalBuilderMock) ThenJumpExtAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmThenJumpExt.afterThenJumpExtCounter)
}

// ThenJumpExtBeforeCounter returns a count of StateConditionalBuilderMock.ThenJumpExt invocations
func (mmThenJumpExt *StateConditionalBuilderMock) ThenJumpExtBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmThenJumpExt.beforeThenJumpExtCounter)
}

// Calls returns a list of arguments used in each call to StateConditionalBuilderMock.ThenJumpExt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmThenJumpExt *mStateConditionalBuilderMockThenJumpExt) Calls() []*StateConditionalBuilderMockThenJumpExtParams {
	mmThenJumpExt.mutex.RLock()

	argCopy := make([]*StateConditionalBuilderMockThenJumpExtParams, len(mmThenJumpExt.callArgs))
	copy(argCopy, mmThenJumpExt.callArgs)

	mmThenJumpExt.mutex.RUnlock()

	return argCopy
}

// MinimockThenJumpExtDone returns true if the count of the ThenJumpExt invocations corresponds
// the number of defined expectations
func (m *StateConditionalBuilderMock) MinimockThenJumpExtDone() bool {
	for _, e := range m.ThenJumpExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ThenJumpExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterThenJumpExtCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcThenJumpExt != nil && mm_atomic.LoadUint64(&m.afterThenJumpExtCounter) < 1 {
		return false
	}
	return true
}

// MinimockThenJumpExtInspect logs each unmet expectation
func (m *StateConditionalBuilderMock) MinimockThenJumpExtInspect() {
	for _, e := range m.ThenJumpExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StateConditionalBuilderMock.ThenJumpExt with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ThenJumpExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterThenJumpExtCounter) < 1 {
		if m.ThenJumpExtMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StateConditionalBuilderMock.ThenJumpExt")
		} else {
			m.t.Errorf("Expected call to StateConditionalBuilderMock.ThenJumpExt with params: %#v", *m.ThenJumpExtMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcThenJumpExt != nil && mm_atomic.LoadUint64(&m.afterThenJumpExtCounter) < 1 {
		m.t.Error("Expected call to StateConditionalBuilderMock.ThenJumpExt")
	}
}

type mStateConditionalBuilderMockThenRepeat struct {
	mock               *StateConditionalBuilderMock
	defaultExpectation *StateConditionalBuilderMockThenRepeatExpectation
	expectations       []*StateConditionalBuilderMockThenRepeatExpectation
}

// StateConditionalBuilderMockThenRepeatExpectation specifies expectation struct of the StateConditionalBuilder.ThenRepeat
type StateConditionalBuilderMockThenRepeatExpectation struct {
	mock *StateConditionalBuilderMock

	results *StateConditionalBuilderMockThenRepeatResults
	Counter uint64
}

// StateConditionalBuilderMockThenRepeatResults contains results of the StateConditionalBuilder.ThenRepeat
type StateConditionalBuilderMockThenRepeatResults struct {
	s1 StateUpdate
}

// Expect sets up expected params for StateConditionalBuilder.ThenRepeat
func (mmThenRepeat *mStateConditionalBuilderMockThenRepeat) Expect() *mStateConditionalBuilderMockThenRepeat {
	if mmThenRepeat.mock.funcThenRepeat != nil {
		mmThenRepeat.mock.t.Fatalf("StateConditionalBuilderMock.ThenRepeat mock is already set by Set")
	}

	if mmThenRepeat.defaultExpectation == nil {
		mmThenRepeat.defaultExpectation = &StateConditionalBuilderMockThenRepeatExpectation{}
	}

	return mmThenRepeat
}

// Inspect accepts an inspector function that has same arguments as the StateConditionalBuilder.ThenRepeat
func (mmThenRepeat *mStateConditionalBuilderMockThenRepeat) Inspect(f func()) *mStateConditionalBuilderMockThenRepeat {
	if mmThenRepeat.mock.inspectFuncThenRepeat != nil {
		mmThenRepeat.mock.t.Fatalf("Inspect function is already set for StateConditionalBuilderMock.ThenRepeat")
	}

	mmThenRepeat.mock.inspectFuncThenRepeat = f

	return mmThenRepeat
}

// Return sets up results that will be returned by StateConditionalBuilder.ThenRepeat
func (mmThenRepeat *mStateConditionalBuilderMockThenRepeat) Return(s1 StateUpdate) *StateConditionalBuilderMock {
	if mmThenRepeat.mock.funcThenRepeat != nil {
		mmThenRepeat.mock.t.Fatalf("StateConditionalBuilderMock.ThenRepeat mock is already set by Set")
	}

	if mmThenRepeat.defaultExpectation == nil {
		mmThenRepeat.defaultExpectation = &StateConditionalBuilderMockThenRepeatExpectation{mock: mmThenRepeat.mock}
	}
	mmThenRepeat.defaultExpectation.results = &StateConditionalBuilderMockThenRepeatResults{s1}
	return mmThenRepeat.mock
}

//Set uses given function f to mock the StateConditionalBuilder.ThenRepeat method
func (mmThenRepeat *mStateConditionalBuilderMockThenRepeat) Set(f func() (s1 StateUpdate)) *StateConditionalBuilderMock {
	if mmThenRepeat.defaultExpectation != nil {
		mmThenRepeat.mock.t.Fatalf("Default expectation is already set for the StateConditionalBuilder.ThenRepeat method")
	}

	if len(mmThenRepeat.expectations) > 0 {
		mmThenRepeat.mock.t.Fatalf("Some expectations are already set for the StateConditionalBuilder.ThenRepeat method")
	}

	mmThenRepeat.mock.funcThenRepeat = f
	return mmThenRepeat.mock
}

// ThenRepeat implements StateConditionalBuilder
func (mmThenRepeat *StateConditionalBuilderMock) ThenRepeat() (s1 StateUpdate) {
	mm_atomic.AddUint64(&mmThenRepeat.beforeThenRepeatCounter, 1)
	defer mm_atomic.AddUint64(&mmThenRepeat.afterThenRepeatCounter, 1)

	if mmThenRepeat.inspectFuncThenRepeat != nil {
		mmThenRepeat.inspectFuncThenRepeat()
	}

	if mmThenRepeat.ThenRepeatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmThenRepeat.ThenRepeatMock.defaultExpectation.Counter, 1)

		mm_results := mmThenRepeat.ThenRepeatMock.defaultExpectation.results
		if mm_results == nil {
			mmThenRepeat.t.Fatal("No results are set for the StateConditionalBuilderMock.ThenRepeat")
		}
		return (*mm_results).s1
	}
	if mmThenRepeat.funcThenRepeat != nil {
		return mmThenRepeat.funcThenRepeat()
	}
	mmThenRepeat.t.Fatalf("Unexpected call to StateConditionalBuilderMock.ThenRepeat.")
	return
}

// ThenRepeatAfterCounter returns a count of finished StateConditionalBuilderMock.ThenRepeat invocations
func (mmThenRepeat *StateConditionalBuilderMock) ThenRepeatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmThenRepeat.afterThenRepeatCounter)
}

// ThenRepeatBeforeCounter returns a count of StateConditionalBuilderMock.ThenRepeat invocations
func (mmThenRepeat *StateConditionalBuilderMock) ThenRepeatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmThenRepeat.beforeThenRepeatCounter)
}

// MinimockThenRepeatDone returns true if the count of the ThenRepeat invocations corresponds
// the number of defined expectations
func (m *StateConditionalBuilderMock) MinimockThenRepeatDone() bool {
	for _, e := range m.ThenRepeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ThenRepeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterThenRepeatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcThenRepeat != nil && mm_atomic.LoadUint64(&m.afterThenRepeatCounter) < 1 {
		return false
	}
	return true
}

// MinimockThenRepeatInspect logs each unmet expectation
func (m *StateConditionalBuilderMock) MinimockThenRepeatInspect() {
	for _, e := range m.ThenRepeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StateConditionalBuilderMock.ThenRepeat")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ThenRepeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterThenRepeatCounter) < 1 {
		m.t.Error("Expected call to StateConditionalBuilderMock.ThenRepeat")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcThenRepeat != nil && mm_atomic.LoadUint64(&m.afterThenRepeatCounter) < 1 {
		m.t.Error("Expected call to StateConditionalBuilderMock.ThenRepeat")
	}
}

type mStateConditionalBuilderMockThenRepeatOrElse struct {
	mock               *StateConditionalBuilderMock
	defaultExpectation *StateConditionalBuilderMockThenRepeatOrElseExpectation
	expectations       []*StateConditionalBuilderMockThenRepeatOrElseExpectation
}

// StateConditionalBuilderMockThenRepeatOrElseExpectation specifies expectation struct of the StateConditionalBuilder.ThenRepeatOrElse
type StateConditionalBuilderMockThenRepeatOrElseExpectation struct {
	mock *StateConditionalBuilderMock

	results *StateConditionalBuilderMockThenRepeatOrElseResults
	Counter uint64
}

// StateConditionalBuilderMockThenRepeatOrElseResults contains results of the StateConditionalBuilder.ThenRepeatOrElse
type StateConditionalBuilderMockThenRepeatOrElseResults struct {
	s1 StateUpdate
	b1 bool
}

// Expect sets up expected params for StateConditionalBuilder.ThenRepeatOrElse
func (mmThenRepeatOrElse *mStateConditionalBuilderMockThenRepeatOrElse) Expect() *mStateConditionalBuilderMockThenRepeatOrElse {
	if mmThenRepeatOrElse.mock.funcThenRepeatOrElse != nil {
		mmThenRepeatOrElse.mock.t.Fatalf("StateConditionalBuilderMock.ThenRepeatOrElse mock is already set by Set")
	}

	if mmThenRepeatOrElse.defaultExpectation == nil {
		mmThenRepeatOrElse.defaultExpectation = &StateConditionalBuilderMockThenRepeatOrElseExpectation{}
	}

	return mmThenRepeatOrElse
}

// Inspect accepts an inspector function that has same arguments as the StateConditionalBuilder.ThenRepeatOrElse
func (mmThenRepeatOrElse *mStateConditionalBuilderMockThenRepeatOrElse) Inspect(f func()) *mStateConditionalBuilderMockThenRepeatOrElse {
	if mmThenRepeatOrElse.mock.inspectFuncThenRepeatOrElse != nil {
		mmThenRepeatOrElse.mock.t.Fatalf("Inspect function is already set for StateConditionalBuilderMock.ThenRepeatOrElse")
	}

	mmThenRepeatOrElse.mock.inspectFuncThenRepeatOrElse = f

	return mmThenRepeatOrElse
}

// Return sets up results that will be returned by StateConditionalBuilder.ThenRepeatOrElse
func (mmThenRepeatOrElse *mStateConditionalBuilderMockThenRepeatOrElse) Return(s1 StateUpdate, b1 bool) *StateConditionalBuilderMock {
	if mmThenRepeatOrElse.mock.funcThenRepeatOrElse != nil {
		mmThenRepeatOrElse.mock.t.Fatalf("StateConditionalBuilderMock.ThenRepeatOrElse mock is already set by Set")
	}

	if mmThenRepeatOrElse.defaultExpectation == nil {
		mmThenRepeatOrElse.defaultExpectation = &StateConditionalBuilderMockThenRepeatOrElseExpectation{mock: mmThenRepeatOrElse.mock}
	}
	mmThenRepeatOrElse.defaultExpectation.results = &StateConditionalBuilderMockThenRepeatOrElseResults{s1, b1}
	return mmThenRepeatOrElse.mock
}

//Set uses given function f to mock the StateConditionalBuilder.ThenRepeatOrElse method
func (mmThenRepeatOrElse *mStateConditionalBuilderMockThenRepeatOrElse) Set(f func() (s1 StateUpdate, b1 bool)) *StateConditionalBuilderMock {
	if mmThenRepeatOrElse.defaultExpectation != nil {
		mmThenRepeatOrElse.mock.t.Fatalf("Default expectation is already set for the StateConditionalBuilder.ThenRepeatOrElse method")
	}

	if len(mmThenRepeatOrElse.expectations) > 0 {
		mmThenRepeatOrElse.mock.t.Fatalf("Some expectations are already set for the StateConditionalBuilder.ThenRepeatOrElse method")
	}

	mmThenRepeatOrElse.mock.funcThenRepeatOrElse = f
	return mmThenRepeatOrElse.mock
}

// ThenRepeatOrElse implements StateConditionalBuilder
func (mmThenRepeatOrElse *StateConditionalBuilderMock) ThenRepeatOrElse() (s1 StateUpdate, b1 bool) {
	mm_atomic.AddUint64(&mmThenRepeatOrElse.beforeThenRepeatOrElseCounter, 1)
	defer mm_atomic.AddUint64(&mmThenRepeatOrElse.afterThenRepeatOrElseCounter, 1)

	if mmThenRepeatOrElse.inspectFuncThenRepeatOrElse != nil {
		mmThenRepeatOrElse.inspectFuncThenRepeatOrElse()
	}

	if mmThenRepeatOrElse.ThenRepeatOrElseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmThenRepeatOrElse.ThenRepeatOrElseMock.defaultExpectation.Counter, 1)

		mm_results := mmThenRepeatOrElse.ThenRepeatOrElseMock.defaultExpectation.results
		if mm_results == nil {
			mmThenRepeatOrElse.t.Fatal("No results are set for the StateConditionalBuilderMock.ThenRepeatOrElse")
		}
		return (*mm_results).s1, (*mm_results).b1
	}
	if mmThenRepeatOrElse.funcThenRepeatOrElse != nil {
		return mmThenRepeatOrElse.funcThenRepeatOrElse()
	}
	mmThenRepeatOrElse.t.Fatalf("Unexpected call to StateConditionalBuilderMock.ThenRepeatOrElse.")
	return
}

// ThenRepeatOrElseAfterCounter returns a count of finished StateConditionalBuilderMock.ThenRepeatOrElse invocations
func (mmThenRepeatOrElse *StateConditionalBuilderMock) ThenRepeatOrElseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmThenRepeatOrElse.afterThenRepeatOrElseCounter)
}

// ThenRepeatOrElseBeforeCounter returns a count of StateConditionalBuilderMock.ThenRepeatOrElse invocations
func (mmThenRepeatOrElse *StateConditionalBuilderMock) ThenRepeatOrElseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmThenRepeatOrElse.beforeThenRepeatOrElseCounter)
}

// MinimockThenRepeatOrElseDone returns true if the count of the ThenRepeatOrElse invocations corresponds
// the number of defined expectations
func (m *StateConditionalBuilderMock) MinimockThenRepeatOrElseDone() bool {
	for _, e := range m.ThenRepeatOrElseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ThenRepeatOrElseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterThenRepeatOrElseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcThenRepeatOrElse != nil && mm_atomic.LoadUint64(&m.afterThenRepeatOrElseCounter) < 1 {
		return false
	}
	return true
}

// MinimockThenRepeatOrElseInspect logs each unmet expectation
func (m *StateConditionalBuilderMock) MinimockThenRepeatOrElseInspect() {
	for _, e := range m.ThenRepeatOrElseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StateConditionalBuilderMock.ThenRepeatOrElse")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ThenRepeatOrElseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterThenRepeatOrElseCounter) < 1 {
		m.t.Error("Expected call to StateConditionalBuilderMock.ThenRepeatOrElse")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcThenRepeatOrElse != nil && mm_atomic.LoadUint64(&m.afterThenRepeatOrElseCounter) < 1 {
		m.t.Error("Expected call to StateConditionalBuilderMock.ThenRepeatOrElse")
	}
}

type mStateConditionalBuilderMockThenRepeatOrJump struct {
	mock               *StateConditionalBuilderMock
	defaultExpectation *StateConditionalBuilderMockThenRepeatOrJumpExpectation
	expectations       []*StateConditionalBuilderMockThenRepeatOrJumpExpectation

	callArgs []*StateConditionalBuilderMockThenRepeatOrJumpParams
	mutex    sync.RWMutex
}

// StateConditionalBuilderMockThenRepeatOrJumpExpectation specifies expectation struct of the StateConditionalBuilder.ThenRepeatOrJump
type StateConditionalBuilderMockThenRepeatOrJumpExpectation struct {
	mock    *StateConditionalBuilderMock
	params  *StateConditionalBuilderMockThenRepeatOrJumpParams
	results *StateConditionalBuilderMockThenRepeatOrJumpResults
	Counter uint64
}

// StateConditionalBuilderMockThenRepeatOrJumpParams contains parameters of the StateConditionalBuilder.ThenRepeatOrJump
type StateConditionalBuilderMockThenRepeatOrJumpParams struct {
	s1 StateFunc
}

// StateConditionalBuilderMockThenRepeatOrJumpResults contains results of the StateConditionalBuilder.ThenRepeatOrJump
type StateConditionalBuilderMockThenRepeatOrJumpResults struct {
	s2 StateUpdate
}

// Expect sets up expected params for StateConditionalBuilder.ThenRepeatOrJump
func (mmThenRepeatOrJump *mStateConditionalBuilderMockThenRepeatOrJump) Expect(s1 StateFunc) *mStateConditionalBuilderMockThenRepeatOrJump {
	if mmThenRepeatOrJump.mock.funcThenRepeatOrJump != nil {
		mmThenRepeatOrJump.mock.t.Fatalf("StateConditionalBuilderMock.ThenRepeatOrJump mock is already set by Set")
	}

	if mmThenRepeatOrJump.defaultExpectation == nil {
		mmThenRepeatOrJump.defaultExpectation = &StateConditionalBuilderMockThenRepeatOrJumpExpectation{}
	}

	mmThenRepeatOrJump.defaultExpectation.params = &StateConditionalBuilderMockThenRepeatOrJumpParams{s1}
	for _, e := range mmThenRepeatOrJump.expectations {
		if minimock.Equal(e.params, mmThenRepeatOrJump.defaultExpectation.params) {
			mmThenRepeatOrJump.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmThenRepeatOrJump.defaultExpectation.params)
		}
	}

	return mmThenRepeatOrJump
}

// Inspect accepts an inspector function that has same arguments as the StateConditionalBuilder.ThenRepeatOrJump
func (mmThenRepeatOrJump *mStateConditionalBuilderMockThenRepeatOrJump) Inspect(f func(s1 StateFunc)) *mStateConditionalBuilderMockThenRepeatOrJump {
	if mmThenRepeatOrJump.mock.inspectFuncThenRepeatOrJump != nil {
		mmThenRepeatOrJump.mock.t.Fatalf("Inspect function is already set for StateConditionalBuilderMock.ThenRepeatOrJump")
	}

	mmThenRepeatOrJump.mock.inspectFuncThenRepeatOrJump = f

	return mmThenRepeatOrJump
}

// Return sets up results that will be returned by StateConditionalBuilder.ThenRepeatOrJump
func (mmThenRepeatOrJump *mStateConditionalBuilderMockThenRepeatOrJump) Return(s2 StateUpdate) *StateConditionalBuilderMock {
	if mmThenRepeatOrJump.mock.funcThenRepeatOrJump != nil {
		mmThenRepeatOrJump.mock.t.Fatalf("StateConditionalBuilderMock.ThenRepeatOrJump mock is already set by Set")
	}

	if mmThenRepeatOrJump.defaultExpectation == nil {
		mmThenRepeatOrJump.defaultExpectation = &StateConditionalBuilderMockThenRepeatOrJumpExpectation{mock: mmThenRepeatOrJump.mock}
	}
	mmThenRepeatOrJump.defaultExpectation.results = &StateConditionalBuilderMockThenRepeatOrJumpResults{s2}
	return mmThenRepeatOrJump.mock
}

//Set uses given function f to mock the StateConditionalBuilder.ThenRepeatOrJump method
func (mmThenRepeatOrJump *mStateConditionalBuilderMockThenRepeatOrJump) Set(f func(s1 StateFunc) (s2 StateUpdate)) *StateConditionalBuilderMock {
	if mmThenRepeatOrJump.defaultExpectation != nil {
		mmThenRepeatOrJump.mock.t.Fatalf("Default expectation is already set for the StateConditionalBuilder.ThenRepeatOrJump method")
	}

	if len(mmThenRepeatOrJump.expectations) > 0 {
		mmThenRepeatOrJump.mock.t.Fatalf("Some expectations are already set for the StateConditionalBuilder.ThenRepeatOrJump method")
	}

	mmThenRepeatOrJump.mock.funcThenRepeatOrJump = f
	return mmThenRepeatOrJump.mock
}

// When sets expectation for the StateConditionalBuilder.ThenRepeatOrJump which will trigger the result defined by the following
// Then helper
func (mmThenRepeatOrJump *mStateConditionalBuilderMockThenRepeatOrJump) When(s1 StateFunc) *StateConditionalBuilderMockThenRepeatOrJumpExpectation {
	if mmThenRepeatOrJump.mock.funcThenRepeatOrJump != nil {
		mmThenRepeatOrJump.mock.t.Fatalf("StateConditionalBuilderMock.ThenRepeatOrJump mock is already set by Set")
	}

	expectation := &StateConditionalBuilderMockThenRepeatOrJumpExpectation{
		mock:   mmThenRepeatOrJump.mock,
		params: &StateConditionalBuilderMockThenRepeatOrJumpParams{s1},
	}
	mmThenRepeatOrJump.expectations = append(mmThenRepeatOrJump.expectations, expectation)
	return expectation
}

// Then sets up StateConditionalBuilder.ThenRepeatOrJump return parameters for the expectation previously defined by the When method
func (e *StateConditionalBuilderMockThenRepeatOrJumpExpectation) Then(s2 StateUpdate) *StateConditionalBuilderMock {
	e.results = &StateConditionalBuilderMockThenRepeatOrJumpResults{s2}
	return e.mock
}

// ThenRepeatOrJump implements StateConditionalBuilder
func (mmThenRepeatOrJump *StateConditionalBuilderMock) ThenRepeatOrJump(s1 StateFunc) (s2 StateUpdate) {
	mm_atomic.AddUint64(&mmThenRepeatOrJump.beforeThenRepeatOrJumpCounter, 1)
	defer mm_atomic.AddUint64(&mmThenRepeatOrJump.afterThenRepeatOrJumpCounter, 1)

	if mmThenRepeatOrJump.inspectFuncThenRepeatOrJump != nil {
		mmThenRepeatOrJump.inspectFuncThenRepeatOrJump(s1)
	}

	mm_params := &StateConditionalBuilderMockThenRepeatOrJumpParams{s1}

	// Record call args
	mmThenRepeatOrJump.ThenRepeatOrJumpMock.mutex.Lock()
	mmThenRepeatOrJump.ThenRepeatOrJumpMock.callArgs = append(mmThenRepeatOrJump.ThenRepeatOrJumpMock.callArgs, mm_params)
	mmThenRepeatOrJump.ThenRepeatOrJumpMock.mutex.Unlock()

	for _, e := range mmThenRepeatOrJump.ThenRepeatOrJumpMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2
		}
	}

	if mmThenRepeatOrJump.ThenRepeatOrJumpMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmThenRepeatOrJump.ThenRepeatOrJumpMock.defaultExpectation.Counter, 1)
		mm_want := mmThenRepeatOrJump.ThenRepeatOrJumpMock.defaultExpectation.params
		mm_got := StateConditionalBuilderMockThenRepeatOrJumpParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmThenRepeatOrJump.t.Errorf("StateConditionalBuilderMock.ThenRepeatOrJump got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmThenRepeatOrJump.ThenRepeatOrJumpMock.defaultExpectation.results
		if mm_results == nil {
			mmThenRepeatOrJump.t.Fatal("No results are set for the StateConditionalBuilderMock.ThenRepeatOrJump")
		}
		return (*mm_results).s2
	}
	if mmThenRepeatOrJump.funcThenRepeatOrJump != nil {
		return mmThenRepeatOrJump.funcThenRepeatOrJump(s1)
	}
	mmThenRepeatOrJump.t.Fatalf("Unexpected call to StateConditionalBuilderMock.ThenRepeatOrJump. %v", s1)
	return
}

// ThenRepeatOrJumpAfterCounter returns a count of finished StateConditionalBuilderMock.ThenRepeatOrJump invocations
func (mmThenRepeatOrJump *StateConditionalBuilderMock) ThenRepeatOrJumpAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmThenRepeatOrJump.afterThenRepeatOrJumpCounter)
}

// ThenRepeatOrJumpBeforeCounter returns a count of StateConditionalBuilderMock.ThenRepeatOrJump invocations
func (mmThenRepeatOrJump *StateConditionalBuilderMock) ThenRepeatOrJumpBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmThenRepeatOrJump.beforeThenRepeatOrJumpCounter)
}

// Calls returns a list of arguments used in each call to StateConditionalBuilderMock.ThenRepeatOrJump.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmThenRepeatOrJump *mStateConditionalBuilderMockThenRepeatOrJump) Calls() []*StateConditionalBuilderMockThenRepeatOrJumpParams {
	mmThenRepeatOrJump.mutex.RLock()

	argCopy := make([]*StateConditionalBuilderMockThenRepeatOrJumpParams, len(mmThenRepeatOrJump.callArgs))
	copy(argCopy, mmThenRepeatOrJump.callArgs)

	mmThenRepeatOrJump.mutex.RUnlock()

	return argCopy
}

// MinimockThenRepeatOrJumpDone returns true if the count of the ThenRepeatOrJump invocations corresponds
// the number of defined expectations
func (m *StateConditionalBuilderMock) MinimockThenRepeatOrJumpDone() bool {
	for _, e := range m.ThenRepeatOrJumpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ThenRepeatOrJumpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterThenRepeatOrJumpCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcThenRepeatOrJump != nil && mm_atomic.LoadUint64(&m.afterThenRepeatOrJumpCounter) < 1 {
		return false
	}
	return true
}

// MinimockThenRepeatOrJumpInspect logs each unmet expectation
func (m *StateConditionalBuilderMock) MinimockThenRepeatOrJumpInspect() {
	for _, e := range m.ThenRepeatOrJumpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StateConditionalBuilderMock.ThenRepeatOrJump with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ThenRepeatOrJumpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterThenRepeatOrJumpCounter) < 1 {
		if m.ThenRepeatOrJumpMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StateConditionalBuilderMock.ThenRepeatOrJump")
		} else {
			m.t.Errorf("Expected call to StateConditionalBuilderMock.ThenRepeatOrJump with params: %#v", *m.ThenRepeatOrJumpMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcThenRepeatOrJump != nil && mm_atomic.LoadUint64(&m.afterThenRepeatOrJumpCounter) < 1 {
		m.t.Error("Expected call to StateConditionalBuilderMock.ThenRepeatOrJump")
	}
}

type mStateConditionalBuilderMockThenRepeatOrJumpExt struct {
	mock               *StateConditionalBuilderMock
	defaultExpectation *StateConditionalBuilderMockThenRepeatOrJumpExtExpectation
	expectations       []*StateConditionalBuilderMockThenRepeatOrJumpExtExpectation

	callArgs []*StateConditionalBuilderMockThenRepeatOrJumpExtParams
	mutex    sync.RWMutex
}

// StateConditionalBuilderMockThenRepeatOrJumpExtExpectation specifies expectation struct of the StateConditionalBuilder.ThenRepeatOrJumpExt
type StateConditionalBuilderMockThenRepeatOrJumpExtExpectation struct {
	mock    *StateConditionalBuilderMock
	params  *StateConditionalBuilderMockThenRepeatOrJumpExtParams
	results *StateConditionalBuilderMockThenRepeatOrJumpExtResults
	Counter uint64
}

// StateConditionalBuilderMockThenRepeatOrJumpExtParams contains parameters of the StateConditionalBuilder.ThenRepeatOrJumpExt
type StateConditionalBuilderMockThenRepeatOrJumpExtParams struct {
	s1 SlotStep
}

// StateConditionalBuilderMockThenRepeatOrJumpExtResults contains results of the StateConditionalBuilder.ThenRepeatOrJumpExt
type StateConditionalBuilderMockThenRepeatOrJumpExtResults struct {
	s2 StateUpdate
}

// Expect sets up expected params for StateConditionalBuilder.ThenRepeatOrJumpExt
func (mmThenRepeatOrJumpExt *mStateConditionalBuilderMockThenRepeatOrJumpExt) Expect(s1 SlotStep) *mStateConditionalBuilderMockThenRepeatOrJumpExt {
	if mmThenRepeatOrJumpExt.mock.funcThenRepeatOrJumpExt != nil {
		mmThenRepeatOrJumpExt.mock.t.Fatalf("StateConditionalBuilderMock.ThenRepeatOrJumpExt mock is already set by Set")
	}

	if mmThenRepeatOrJumpExt.defaultExpectation == nil {
		mmThenRepeatOrJumpExt.defaultExpectation = &StateConditionalBuilderMockThenRepeatOrJumpExtExpectation{}
	}

	mmThenRepeatOrJumpExt.defaultExpectation.params = &StateConditionalBuilderMockThenRepeatOrJumpExtParams{s1}
	for _, e := range mmThenRepeatOrJumpExt.expectations {
		if minimock.Equal(e.params, mmThenRepeatOrJumpExt.defaultExpectation.params) {
			mmThenRepeatOrJumpExt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmThenRepeatOrJumpExt.defaultExpectation.params)
		}
	}

	return mmThenRepeatOrJumpExt
}

// Inspect accepts an inspector function that has same arguments as the StateConditionalBuilder.ThenRepeatOrJumpExt
func (mmThenRepeatOrJumpExt *mStateConditionalBuilderMockThenRepeatOrJumpExt) Inspect(f func(s1 SlotStep)) *mStateConditionalBuilderMockThenRepeatOrJumpExt {
	if mmThenRepeatOrJumpExt.mock.inspectFuncThenRepeatOrJumpExt != nil {
		mmThenRepeatOrJumpExt.mock.t.Fatalf("Inspect function is already set for StateConditionalBuilderMock.ThenRepeatOrJumpExt")
	}

	mmThenRepeatOrJumpExt.mock.inspectFuncThenRepeatOrJumpExt = f

	return mmThenRepeatOrJumpExt
}

// Return sets up results that will be returned by StateConditionalBuilder.ThenRepeatOrJumpExt
func (mmThenRepeatOrJumpExt *mStateConditionalBuilderMockThenRepeatOrJumpExt) Return(s2 StateUpdate) *StateConditionalBuilderMock {
	if mmThenRepeatOrJumpExt.mock.funcThenRepeatOrJumpExt != nil {
		mmThenRepeatOrJumpExt.mock.t.Fatalf("StateConditionalBuilderMock.ThenRepeatOrJumpExt mock is already set by Set")
	}

	if mmThenRepeatOrJumpExt.defaultExpectation == nil {
		mmThenRepeatOrJumpExt.defaultExpectation = &StateConditionalBuilderMockThenRepeatOrJumpExtExpectation{mock: mmThenRepeatOrJumpExt.mock}
	}
	mmThenRepeatOrJumpExt.defaultExpectation.results = &StateConditionalBuilderMockThenRepeatOrJumpExtResults{s2}
	return mmThenRepeatOrJumpExt.mock
}

//Set uses given function f to mock the StateConditionalBuilder.ThenRepeatOrJumpExt method
func (mmThenRepeatOrJumpExt *mStateConditionalBuilderMockThenRepeatOrJumpExt) Set(f func(s1 SlotStep) (s2 StateUpdate)) *StateConditionalBuilderMock {
	if mmThenRepeatOrJumpExt.defaultExpectation != nil {
		mmThenRepeatOrJumpExt.mock.t.Fatalf("Default expectation is already set for the StateConditionalBuilder.ThenRepeatOrJumpExt method")
	}

	if len(mmThenRepeatOrJumpExt.expectations) > 0 {
		mmThenRepeatOrJumpExt.mock.t.Fatalf("Some expectations are already set for the StateConditionalBuilder.ThenRepeatOrJumpExt method")
	}

	mmThenRepeatOrJumpExt.mock.funcThenRepeatOrJumpExt = f
	return mmThenRepeatOrJumpExt.mock
}

// When sets expectation for the StateConditionalBuilder.ThenRepeatOrJumpExt which will trigger the result defined by the following
// Then helper
func (mmThenRepeatOrJumpExt *mStateConditionalBuilderMockThenRepeatOrJumpExt) When(s1 SlotStep) *StateConditionalBuilderMockThenRepeatOrJumpExtExpectation {
	if mmThenRepeatOrJumpExt.mock.funcThenRepeatOrJumpExt != nil {
		mmThenRepeatOrJumpExt.mock.t.Fatalf("StateConditionalBuilderMock.ThenRepeatOrJumpExt mock is already set by Set")
	}

	expectation := &StateConditionalBuilderMockThenRepeatOrJumpExtExpectation{
		mock:   mmThenRepeatOrJumpExt.mock,
		params: &StateConditionalBuilderMockThenRepeatOrJumpExtParams{s1},
	}
	mmThenRepeatOrJumpExt.expectations = append(mmThenRepeatOrJumpExt.expectations, expectation)
	return expectation
}

// Then sets up StateConditionalBuilder.ThenRepeatOrJumpExt return parameters for the expectation previously defined by the When method
func (e *StateConditionalBuilderMockThenRepeatOrJumpExtExpectation) Then(s2 StateUpdate) *StateConditionalBuilderMock {
	e.results = &StateConditionalBuilderMockThenRepeatOrJumpExtResults{s2}
	return e.mock
}

// ThenRepeatOrJumpExt implements StateConditionalBuilder
func (mmThenRepeatOrJumpExt *StateConditionalBuilderMock) ThenRepeatOrJumpExt(s1 SlotStep) (s2 StateUpdate) {
	mm_atomic.AddUint64(&mmThenRepeatOrJumpExt.beforeThenRepeatOrJumpExtCounter, 1)
	defer mm_atomic.AddUint64(&mmThenRepeatOrJumpExt.afterThenRepeatOrJumpExtCounter, 1)

	if mmThenRepeatOrJumpExt.inspectFuncThenRepeatOrJumpExt != nil {
		mmThenRepeatOrJumpExt.inspectFuncThenRepeatOrJumpExt(s1)
	}

	mm_params := &StateConditionalBuilderMockThenRepeatOrJumpExtParams{s1}

	// Record call args
	mmThenRepeatOrJumpExt.ThenRepeatOrJumpExtMock.mutex.Lock()
	mmThenRepeatOrJumpExt.ThenRepeatOrJumpExtMock.callArgs = append(mmThenRepeatOrJumpExt.ThenRepeatOrJumpExtMock.callArgs, mm_params)
	mmThenRepeatOrJumpExt.ThenRepeatOrJumpExtMock.mutex.Unlock()

	for _, e := range mmThenRepeatOrJumpExt.ThenRepeatOrJumpExtMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2
		}
	}

	if mmThenRepeatOrJumpExt.ThenRepeatOrJumpExtMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmThenRepeatOrJumpExt.ThenRepeatOrJumpExtMock.defaultExpectation.Counter, 1)
		mm_want := mmThenRepeatOrJumpExt.ThenRepeatOrJumpExtMock.defaultExpectation.params
		mm_got := StateConditionalBuilderMockThenRepeatOrJumpExtParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmThenRepeatOrJumpExt.t.Errorf("StateConditionalBuilderMock.ThenRepeatOrJumpExt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmThenRepeatOrJumpExt.ThenRepeatOrJumpExtMock.defaultExpectation.results
		if mm_results == nil {
			mmThenRepeatOrJumpExt.t.Fatal("No results are set for the StateConditionalBuilderMock.ThenRepeatOrJumpExt")
		}
		return (*mm_results).s2
	}
	if mmThenRepeatOrJumpExt.funcThenRepeatOrJumpExt != nil {
		return mmThenRepeatOrJumpExt.funcThenRepeatOrJumpExt(s1)
	}
	mmThenRepeatOrJumpExt.t.Fatalf("Unexpected call to StateConditionalBuilderMock.ThenRepeatOrJumpExt. %v", s1)
	return
}

// ThenRepeatOrJumpExtAfterCounter returns a count of finished StateConditionalBuilderMock.ThenRepeatOrJumpExt invocations
func (mmThenRepeatOrJumpExt *StateConditionalBuilderMock) ThenRepeatOrJumpExtAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmThenRepeatOrJumpExt.afterThenRepeatOrJumpExtCounter)
}

// ThenRepeatOrJumpExtBeforeCounter returns a count of StateConditionalBuilderMock.ThenRepeatOrJumpExt invocations
func (mmThenRepeatOrJumpExt *StateConditionalBuilderMock) ThenRepeatOrJumpExtBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmThenRepeatOrJumpExt.beforeThenRepeatOrJumpExtCounter)
}

// Calls returns a list of arguments used in each call to StateConditionalBuilderMock.ThenRepeatOrJumpExt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmThenRepeatOrJumpExt *mStateConditionalBuilderMockThenRepeatOrJumpExt) Calls() []*StateConditionalBuilderMockThenRepeatOrJumpExtParams {
	mmThenRepeatOrJumpExt.mutex.RLock()

	argCopy := make([]*StateConditionalBuilderMockThenRepeatOrJumpExtParams, len(mmThenRepeatOrJumpExt.callArgs))
	copy(argCopy, mmThenRepeatOrJumpExt.callArgs)

	mmThenRepeatOrJumpExt.mutex.RUnlock()

	return argCopy
}

// MinimockThenRepeatOrJumpExtDone returns true if the count of the ThenRepeatOrJumpExt invocations corresponds
// the number of defined expectations
func (m *StateConditionalBuilderMock) MinimockThenRepeatOrJumpExtDone() bool {
	for _, e := range m.ThenRepeatOrJumpExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ThenRepeatOrJumpExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterThenRepeatOrJumpExtCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcThenRepeatOrJumpExt != nil && mm_atomic.LoadUint64(&m.afterThenRepeatOrJumpExtCounter) < 1 {
		return false
	}
	return true
}

// MinimockThenRepeatOrJumpExtInspect logs each unmet expectation
func (m *StateConditionalBuilderMock) MinimockThenRepeatOrJumpExtInspect() {
	for _, e := range m.ThenRepeatOrJumpExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StateConditionalBuilderMock.ThenRepeatOrJumpExt with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ThenRepeatOrJumpExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterThenRepeatOrJumpExtCounter) < 1 {
		if m.ThenRepeatOrJumpExtMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StateConditionalBuilderMock.ThenRepeatOrJumpExt")
		} else {
			m.t.Errorf("Expected call to StateConditionalBuilderMock.ThenRepeatOrJumpExt with params: %#v", *m.ThenRepeatOrJumpExtMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcThenRepeatOrJumpExt != nil && mm_atomic.LoadUint64(&m.afterThenRepeatOrJumpExtCounter) < 1 {
		m.t.Error("Expected call to StateConditionalBuilderMock.ThenRepeatOrJumpExt")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StateConditionalBuilderMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetDecisionInspect()

		m.MinimockThenJumpInspect()

		m.MinimockThenJumpExtInspect()

		m.MinimockThenRepeatInspect()

		m.MinimockThenRepeatOrElseInspect()

		m.MinimockThenRepeatOrJumpInspect()

		m.MinimockThenRepeatOrJumpExtInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StateConditionalBuilderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StateConditionalBuilderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetDecisionDone() &&
		m.MinimockThenJumpDone() &&
		m.MinimockThenJumpExtDone() &&
		m.MinimockThenRepeatDone() &&
		m.MinimockThenRepeatOrElseDone() &&
		m.MinimockThenRepeatOrJumpDone() &&
		m.MinimockThenRepeatOrJumpExtDone()
}
