package longbits

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// FoldableReaderMock implements FoldableReader
type FoldableReaderMock struct {
	t minimock.Tester

	funcAsByteString          func() (b1 ByteString)
	inspectFuncAsByteString   func()
	afterAsByteStringCounter  uint64
	beforeAsByteStringCounter uint64
	AsByteStringMock          mFoldableReaderMockAsByteString

	funcCopyTo          func(p []byte) (i1 int)
	inspectFuncCopyTo   func(p []byte)
	afterCopyToCounter  uint64
	beforeCopyToCounter uint64
	CopyToMock          mFoldableReaderMockCopyTo

	funcFixedByteSize          func() (i1 int)
	inspectFuncFixedByteSize   func()
	afterFixedByteSizeCounter  uint64
	beforeFixedByteSizeCounter uint64
	FixedByteSizeMock          mFoldableReaderMockFixedByteSize

	funcFoldToUint64          func() (u1 uint64)
	inspectFuncFoldToUint64   func()
	afterFoldToUint64Counter  uint64
	beforeFoldToUint64Counter uint64
	FoldToUint64Mock          mFoldableReaderMockFoldToUint64

	funcWriteTo          func(w io.Writer) (n int64, err error)
	inspectFuncWriteTo   func(w io.Writer)
	afterWriteToCounter  uint64
	beforeWriteToCounter uint64
	WriteToMock          mFoldableReaderMockWriteTo
}

// NewFoldableReaderMock returns a mock for FoldableReader
func NewFoldableReaderMock(t minimock.Tester) *FoldableReaderMock {
	m := &FoldableReaderMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AsByteStringMock = mFoldableReaderMockAsByteString{mock: m}

	m.CopyToMock = mFoldableReaderMockCopyTo{mock: m}
	m.CopyToMock.callArgs = []*FoldableReaderMockCopyToParams{}

	m.FixedByteSizeMock = mFoldableReaderMockFixedByteSize{mock: m}

	m.FoldToUint64Mock = mFoldableReaderMockFoldToUint64{mock: m}

	m.WriteToMock = mFoldableReaderMockWriteTo{mock: m}
	m.WriteToMock.callArgs = []*FoldableReaderMockWriteToParams{}

	return m
}

type mFoldableReaderMockAsByteString struct {
	mock               *FoldableReaderMock
	defaultExpectation *FoldableReaderMockAsByteStringExpectation
	expectations       []*FoldableReaderMockAsByteStringExpectation
}

// FoldableReaderMockAsByteStringExpectation specifies expectation struct of the FoldableReader.AsByteString
type FoldableReaderMockAsByteStringExpectation struct {
	mock *FoldableReaderMock

	results *FoldableReaderMockAsByteStringResults
	Counter uint64
}

// FoldableReaderMockAsByteStringResults contains results of the FoldableReader.AsByteString
type FoldableReaderMockAsByteStringResults struct {
	b1 ByteString
}

// Expect sets up expected params for FoldableReader.AsByteString
func (mmAsByteString *mFoldableReaderMockAsByteString) Expect() *mFoldableReaderMockAsByteString {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("FoldableReaderMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &FoldableReaderMockAsByteStringExpectation{}
	}

	return mmAsByteString
}

// Inspect accepts an inspector function that has same arguments as the FoldableReader.AsByteString
func (mmAsByteString *mFoldableReaderMockAsByteString) Inspect(f func()) *mFoldableReaderMockAsByteString {
	if mmAsByteString.mock.inspectFuncAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("Inspect function is already set for FoldableReaderMock.AsByteString")
	}

	mmAsByteString.mock.inspectFuncAsByteString = f

	return mmAsByteString
}

// Return sets up results that will be returned by FoldableReader.AsByteString
func (mmAsByteString *mFoldableReaderMockAsByteString) Return(b1 ByteString) *FoldableReaderMock {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("FoldableReaderMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &FoldableReaderMockAsByteStringExpectation{mock: mmAsByteString.mock}
	}
	mmAsByteString.defaultExpectation.results = &FoldableReaderMockAsByteStringResults{b1}
	return mmAsByteString.mock
}

//Set uses given function f to mock the FoldableReader.AsByteString method
func (mmAsByteString *mFoldableReaderMockAsByteString) Set(f func() (b1 ByteString)) *FoldableReaderMock {
	if mmAsByteString.defaultExpectation != nil {
		mmAsByteString.mock.t.Fatalf("Default expectation is already set for the FoldableReader.AsByteString method")
	}

	if len(mmAsByteString.expectations) > 0 {
		mmAsByteString.mock.t.Fatalf("Some expectations are already set for the FoldableReader.AsByteString method")
	}

	mmAsByteString.mock.funcAsByteString = f
	return mmAsByteString.mock
}

// AsByteString implements FoldableReader
func (mmAsByteString *FoldableReaderMock) AsByteString() (b1 ByteString) {
	mm_atomic.AddUint64(&mmAsByteString.beforeAsByteStringCounter, 1)
	defer mm_atomic.AddUint64(&mmAsByteString.afterAsByteStringCounter, 1)

	if mmAsByteString.inspectFuncAsByteString != nil {
		mmAsByteString.inspectFuncAsByteString()
	}

	if mmAsByteString.AsByteStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsByteString.AsByteStringMock.defaultExpectation.Counter, 1)

		mm_results := mmAsByteString.AsByteStringMock.defaultExpectation.results
		if mm_results == nil {
			mmAsByteString.t.Fatal("No results are set for the FoldableReaderMock.AsByteString")
		}
		return (*mm_results).b1
	}
	if mmAsByteString.funcAsByteString != nil {
		return mmAsByteString.funcAsByteString()
	}
	mmAsByteString.t.Fatalf("Unexpected call to FoldableReaderMock.AsByteString.")
	return
}

// AsByteStringAfterCounter returns a count of finished FoldableReaderMock.AsByteString invocations
func (mmAsByteString *FoldableReaderMock) AsByteStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.afterAsByteStringCounter)
}

// AsByteStringBeforeCounter returns a count of FoldableReaderMock.AsByteString invocations
func (mmAsByteString *FoldableReaderMock) AsByteStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.beforeAsByteStringCounter)
}

// MinimockAsByteStringDone returns true if the count of the AsByteString invocations corresponds
// the number of defined expectations
func (m *FoldableReaderMock) MinimockAsByteStringDone() bool {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsByteStringInspect logs each unmet expectation
func (m *FoldableReaderMock) MinimockAsByteStringInspect() {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FoldableReaderMock.AsByteString")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to FoldableReaderMock.AsByteString")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to FoldableReaderMock.AsByteString")
	}
}

type mFoldableReaderMockCopyTo struct {
	mock               *FoldableReaderMock
	defaultExpectation *FoldableReaderMockCopyToExpectation
	expectations       []*FoldableReaderMockCopyToExpectation

	callArgs []*FoldableReaderMockCopyToParams
	mutex    sync.RWMutex
}

// FoldableReaderMockCopyToExpectation specifies expectation struct of the FoldableReader.CopyTo
type FoldableReaderMockCopyToExpectation struct {
	mock    *FoldableReaderMock
	params  *FoldableReaderMockCopyToParams
	results *FoldableReaderMockCopyToResults
	Counter uint64
}

// FoldableReaderMockCopyToParams contains parameters of the FoldableReader.CopyTo
type FoldableReaderMockCopyToParams struct {
	p []byte
}

// FoldableReaderMockCopyToResults contains results of the FoldableReader.CopyTo
type FoldableReaderMockCopyToResults struct {
	i1 int
}

// Expect sets up expected params for FoldableReader.CopyTo
func (mmCopyTo *mFoldableReaderMockCopyTo) Expect(p []byte) *mFoldableReaderMockCopyTo {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("FoldableReaderMock.CopyTo mock is already set by Set")
	}

	if mmCopyTo.defaultExpectation == nil {
		mmCopyTo.defaultExpectation = &FoldableReaderMockCopyToExpectation{}
	}

	mmCopyTo.defaultExpectation.params = &FoldableReaderMockCopyToParams{p}
	for _, e := range mmCopyTo.expectations {
		if minimock.Equal(e.params, mmCopyTo.defaultExpectation.params) {
			mmCopyTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCopyTo.defaultExpectation.params)
		}
	}

	return mmCopyTo
}

// Inspect accepts an inspector function that has same arguments as the FoldableReader.CopyTo
func (mmCopyTo *mFoldableReaderMockCopyTo) Inspect(f func(p []byte)) *mFoldableReaderMockCopyTo {
	if mmCopyTo.mock.inspectFuncCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("Inspect function is already set for FoldableReaderMock.CopyTo")
	}

	mmCopyTo.mock.inspectFuncCopyTo = f

	return mmCopyTo
}

// Return sets up results that will be returned by FoldableReader.CopyTo
func (mmCopyTo *mFoldableReaderMockCopyTo) Return(i1 int) *FoldableReaderMock {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("FoldableReaderMock.CopyTo mock is already set by Set")
	}

	if mmCopyTo.defaultExpectation == nil {
		mmCopyTo.defaultExpectation = &FoldableReaderMockCopyToExpectation{mock: mmCopyTo.mock}
	}
	mmCopyTo.defaultExpectation.results = &FoldableReaderMockCopyToResults{i1}
	return mmCopyTo.mock
}

//Set uses given function f to mock the FoldableReader.CopyTo method
func (mmCopyTo *mFoldableReaderMockCopyTo) Set(f func(p []byte) (i1 int)) *FoldableReaderMock {
	if mmCopyTo.defaultExpectation != nil {
		mmCopyTo.mock.t.Fatalf("Default expectation is already set for the FoldableReader.CopyTo method")
	}

	if len(mmCopyTo.expectations) > 0 {
		mmCopyTo.mock.t.Fatalf("Some expectations are already set for the FoldableReader.CopyTo method")
	}

	mmCopyTo.mock.funcCopyTo = f
	return mmCopyTo.mock
}

// When sets expectation for the FoldableReader.CopyTo which will trigger the result defined by the following
// Then helper
func (mmCopyTo *mFoldableReaderMockCopyTo) When(p []byte) *FoldableReaderMockCopyToExpectation {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("FoldableReaderMock.CopyTo mock is already set by Set")
	}

	expectation := &FoldableReaderMockCopyToExpectation{
		mock:   mmCopyTo.mock,
		params: &FoldableReaderMockCopyToParams{p},
	}
	mmCopyTo.expectations = append(mmCopyTo.expectations, expectation)
	return expectation
}

// Then sets up FoldableReader.CopyTo return parameters for the expectation previously defined by the When method
func (e *FoldableReaderMockCopyToExpectation) Then(i1 int) *FoldableReaderMock {
	e.results = &FoldableReaderMockCopyToResults{i1}
	return e.mock
}

// CopyTo implements FoldableReader
func (mmCopyTo *FoldableReaderMock) CopyTo(p []byte) (i1 int) {
	mm_atomic.AddUint64(&mmCopyTo.beforeCopyToCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyTo.afterCopyToCounter, 1)

	if mmCopyTo.inspectFuncCopyTo != nil {
		mmCopyTo.inspectFuncCopyTo(p)
	}

	mm_params := &FoldableReaderMockCopyToParams{p}

	// Record call args
	mmCopyTo.CopyToMock.mutex.Lock()
	mmCopyTo.CopyToMock.callArgs = append(mmCopyTo.CopyToMock.callArgs, mm_params)
	mmCopyTo.CopyToMock.mutex.Unlock()

	for _, e := range mmCopyTo.CopyToMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1
		}
	}

	if mmCopyTo.CopyToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyTo.CopyToMock.defaultExpectation.Counter, 1)
		mm_want := mmCopyTo.CopyToMock.defaultExpectation.params
		mm_got := FoldableReaderMockCopyToParams{p}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCopyTo.t.Errorf("FoldableReaderMock.CopyTo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCopyTo.CopyToMock.defaultExpectation.results
		if mm_results == nil {
			mmCopyTo.t.Fatal("No results are set for the FoldableReaderMock.CopyTo")
		}
		return (*mm_results).i1
	}
	if mmCopyTo.funcCopyTo != nil {
		return mmCopyTo.funcCopyTo(p)
	}
	mmCopyTo.t.Fatalf("Unexpected call to FoldableReaderMock.CopyTo. %v", p)
	return
}

// CopyToAfterCounter returns a count of finished FoldableReaderMock.CopyTo invocations
func (mmCopyTo *FoldableReaderMock) CopyToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyTo.afterCopyToCounter)
}

// CopyToBeforeCounter returns a count of FoldableReaderMock.CopyTo invocations
func (mmCopyTo *FoldableReaderMock) CopyToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyTo.beforeCopyToCounter)
}

// Calls returns a list of arguments used in each call to FoldableReaderMock.CopyTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCopyTo *mFoldableReaderMockCopyTo) Calls() []*FoldableReaderMockCopyToParams {
	mmCopyTo.mutex.RLock()

	argCopy := make([]*FoldableReaderMockCopyToParams, len(mmCopyTo.callArgs))
	copy(argCopy, mmCopyTo.callArgs)

	mmCopyTo.mutex.RUnlock()

	return argCopy
}

// MinimockCopyToDone returns true if the count of the CopyTo invocations corresponds
// the number of defined expectations
func (m *FoldableReaderMock) MinimockCopyToDone() bool {
	for _, e := range m.CopyToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyTo != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyToInspect logs each unmet expectation
func (m *FoldableReaderMock) MinimockCopyToInspect() {
	for _, e := range m.CopyToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FoldableReaderMock.CopyTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		if m.CopyToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FoldableReaderMock.CopyTo")
		} else {
			m.t.Errorf("Expected call to FoldableReaderMock.CopyTo with params: %#v", *m.CopyToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyTo != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		m.t.Error("Expected call to FoldableReaderMock.CopyTo")
	}
}

type mFoldableReaderMockFixedByteSize struct {
	mock               *FoldableReaderMock
	defaultExpectation *FoldableReaderMockFixedByteSizeExpectation
	expectations       []*FoldableReaderMockFixedByteSizeExpectation
}

// FoldableReaderMockFixedByteSizeExpectation specifies expectation struct of the FoldableReader.FixedByteSize
type FoldableReaderMockFixedByteSizeExpectation struct {
	mock *FoldableReaderMock

	results *FoldableReaderMockFixedByteSizeResults
	Counter uint64
}

// FoldableReaderMockFixedByteSizeResults contains results of the FoldableReader.FixedByteSize
type FoldableReaderMockFixedByteSizeResults struct {
	i1 int
}

// Expect sets up expected params for FoldableReader.FixedByteSize
func (mmFixedByteSize *mFoldableReaderMockFixedByteSize) Expect() *mFoldableReaderMockFixedByteSize {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("FoldableReaderMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &FoldableReaderMockFixedByteSizeExpectation{}
	}

	return mmFixedByteSize
}

// Inspect accepts an inspector function that has same arguments as the FoldableReader.FixedByteSize
func (mmFixedByteSize *mFoldableReaderMockFixedByteSize) Inspect(f func()) *mFoldableReaderMockFixedByteSize {
	if mmFixedByteSize.mock.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("Inspect function is already set for FoldableReaderMock.FixedByteSize")
	}

	mmFixedByteSize.mock.inspectFuncFixedByteSize = f

	return mmFixedByteSize
}

// Return sets up results that will be returned by FoldableReader.FixedByteSize
func (mmFixedByteSize *mFoldableReaderMockFixedByteSize) Return(i1 int) *FoldableReaderMock {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("FoldableReaderMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &FoldableReaderMockFixedByteSizeExpectation{mock: mmFixedByteSize.mock}
	}
	mmFixedByteSize.defaultExpectation.results = &FoldableReaderMockFixedByteSizeResults{i1}
	return mmFixedByteSize.mock
}

//Set uses given function f to mock the FoldableReader.FixedByteSize method
func (mmFixedByteSize *mFoldableReaderMockFixedByteSize) Set(f func() (i1 int)) *FoldableReaderMock {
	if mmFixedByteSize.defaultExpectation != nil {
		mmFixedByteSize.mock.t.Fatalf("Default expectation is already set for the FoldableReader.FixedByteSize method")
	}

	if len(mmFixedByteSize.expectations) > 0 {
		mmFixedByteSize.mock.t.Fatalf("Some expectations are already set for the FoldableReader.FixedByteSize method")
	}

	mmFixedByteSize.mock.funcFixedByteSize = f
	return mmFixedByteSize.mock
}

// FixedByteSize implements FoldableReader
func (mmFixedByteSize *FoldableReaderMock) FixedByteSize() (i1 int) {
	mm_atomic.AddUint64(&mmFixedByteSize.beforeFixedByteSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmFixedByteSize.afterFixedByteSizeCounter, 1)

	if mmFixedByteSize.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.inspectFuncFixedByteSize()
	}

	if mmFixedByteSize.FixedByteSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFixedByteSize.FixedByteSizeMock.defaultExpectation.Counter, 1)

		mm_results := mmFixedByteSize.FixedByteSizeMock.defaultExpectation.results
		if mm_results == nil {
			mmFixedByteSize.t.Fatal("No results are set for the FoldableReaderMock.FixedByteSize")
		}
		return (*mm_results).i1
	}
	if mmFixedByteSize.funcFixedByteSize != nil {
		return mmFixedByteSize.funcFixedByteSize()
	}
	mmFixedByteSize.t.Fatalf("Unexpected call to FoldableReaderMock.FixedByteSize.")
	return
}

// FixedByteSizeAfterCounter returns a count of finished FoldableReaderMock.FixedByteSize invocations
func (mmFixedByteSize *FoldableReaderMock) FixedByteSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.afterFixedByteSizeCounter)
}

// FixedByteSizeBeforeCounter returns a count of FoldableReaderMock.FixedByteSize invocations
func (mmFixedByteSize *FoldableReaderMock) FixedByteSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.beforeFixedByteSizeCounter)
}

// MinimockFixedByteSizeDone returns true if the count of the FixedByteSize invocations corresponds
// the number of defined expectations
func (m *FoldableReaderMock) MinimockFixedByteSizeDone() bool {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockFixedByteSizeInspect logs each unmet expectation
func (m *FoldableReaderMock) MinimockFixedByteSizeInspect() {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FoldableReaderMock.FixedByteSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to FoldableReaderMock.FixedByteSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to FoldableReaderMock.FixedByteSize")
	}
}

type mFoldableReaderMockFoldToUint64 struct {
	mock               *FoldableReaderMock
	defaultExpectation *FoldableReaderMockFoldToUint64Expectation
	expectations       []*FoldableReaderMockFoldToUint64Expectation
}

// FoldableReaderMockFoldToUint64Expectation specifies expectation struct of the FoldableReader.FoldToUint64
type FoldableReaderMockFoldToUint64Expectation struct {
	mock *FoldableReaderMock

	results *FoldableReaderMockFoldToUint64Results
	Counter uint64
}

// FoldableReaderMockFoldToUint64Results contains results of the FoldableReader.FoldToUint64
type FoldableReaderMockFoldToUint64Results struct {
	u1 uint64
}

// Expect sets up expected params for FoldableReader.FoldToUint64
func (mmFoldToUint64 *mFoldableReaderMockFoldToUint64) Expect() *mFoldableReaderMockFoldToUint64 {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("FoldableReaderMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &FoldableReaderMockFoldToUint64Expectation{}
	}

	return mmFoldToUint64
}

// Inspect accepts an inspector function that has same arguments as the FoldableReader.FoldToUint64
func (mmFoldToUint64 *mFoldableReaderMockFoldToUint64) Inspect(f func()) *mFoldableReaderMockFoldToUint64 {
	if mmFoldToUint64.mock.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("Inspect function is already set for FoldableReaderMock.FoldToUint64")
	}

	mmFoldToUint64.mock.inspectFuncFoldToUint64 = f

	return mmFoldToUint64
}

// Return sets up results that will be returned by FoldableReader.FoldToUint64
func (mmFoldToUint64 *mFoldableReaderMockFoldToUint64) Return(u1 uint64) *FoldableReaderMock {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("FoldableReaderMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &FoldableReaderMockFoldToUint64Expectation{mock: mmFoldToUint64.mock}
	}
	mmFoldToUint64.defaultExpectation.results = &FoldableReaderMockFoldToUint64Results{u1}
	return mmFoldToUint64.mock
}

//Set uses given function f to mock the FoldableReader.FoldToUint64 method
func (mmFoldToUint64 *mFoldableReaderMockFoldToUint64) Set(f func() (u1 uint64)) *FoldableReaderMock {
	if mmFoldToUint64.defaultExpectation != nil {
		mmFoldToUint64.mock.t.Fatalf("Default expectation is already set for the FoldableReader.FoldToUint64 method")
	}

	if len(mmFoldToUint64.expectations) > 0 {
		mmFoldToUint64.mock.t.Fatalf("Some expectations are already set for the FoldableReader.FoldToUint64 method")
	}

	mmFoldToUint64.mock.funcFoldToUint64 = f
	return mmFoldToUint64.mock
}

// FoldToUint64 implements FoldableReader
func (mmFoldToUint64 *FoldableReaderMock) FoldToUint64() (u1 uint64) {
	mm_atomic.AddUint64(&mmFoldToUint64.beforeFoldToUint64Counter, 1)
	defer mm_atomic.AddUint64(&mmFoldToUint64.afterFoldToUint64Counter, 1)

	if mmFoldToUint64.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.inspectFuncFoldToUint64()
	}

	if mmFoldToUint64.FoldToUint64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFoldToUint64.FoldToUint64Mock.defaultExpectation.Counter, 1)

		mm_results := mmFoldToUint64.FoldToUint64Mock.defaultExpectation.results
		if mm_results == nil {
			mmFoldToUint64.t.Fatal("No results are set for the FoldableReaderMock.FoldToUint64")
		}
		return (*mm_results).u1
	}
	if mmFoldToUint64.funcFoldToUint64 != nil {
		return mmFoldToUint64.funcFoldToUint64()
	}
	mmFoldToUint64.t.Fatalf("Unexpected call to FoldableReaderMock.FoldToUint64.")
	return
}

// FoldToUint64AfterCounter returns a count of finished FoldableReaderMock.FoldToUint64 invocations
func (mmFoldToUint64 *FoldableReaderMock) FoldToUint64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.afterFoldToUint64Counter)
}

// FoldToUint64BeforeCounter returns a count of FoldableReaderMock.FoldToUint64 invocations
func (mmFoldToUint64 *FoldableReaderMock) FoldToUint64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.beforeFoldToUint64Counter)
}

// MinimockFoldToUint64Done returns true if the count of the FoldToUint64 invocations corresponds
// the number of defined expectations
func (m *FoldableReaderMock) MinimockFoldToUint64Done() bool {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	return true
}

// MinimockFoldToUint64Inspect logs each unmet expectation
func (m *FoldableReaderMock) MinimockFoldToUint64Inspect() {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FoldableReaderMock.FoldToUint64")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to FoldableReaderMock.FoldToUint64")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to FoldableReaderMock.FoldToUint64")
	}
}

type mFoldableReaderMockWriteTo struct {
	mock               *FoldableReaderMock
	defaultExpectation *FoldableReaderMockWriteToExpectation
	expectations       []*FoldableReaderMockWriteToExpectation

	callArgs []*FoldableReaderMockWriteToParams
	mutex    sync.RWMutex
}

// FoldableReaderMockWriteToExpectation specifies expectation struct of the FoldableReader.WriteTo
type FoldableReaderMockWriteToExpectation struct {
	mock    *FoldableReaderMock
	params  *FoldableReaderMockWriteToParams
	results *FoldableReaderMockWriteToResults
	Counter uint64
}

// FoldableReaderMockWriteToParams contains parameters of the FoldableReader.WriteTo
type FoldableReaderMockWriteToParams struct {
	w io.Writer
}

// FoldableReaderMockWriteToResults contains results of the FoldableReader.WriteTo
type FoldableReaderMockWriteToResults struct {
	n   int64
	err error
}

// Expect sets up expected params for FoldableReader.WriteTo
func (mmWriteTo *mFoldableReaderMockWriteTo) Expect(w io.Writer) *mFoldableReaderMockWriteTo {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("FoldableReaderMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &FoldableReaderMockWriteToExpectation{}
	}

	mmWriteTo.defaultExpectation.params = &FoldableReaderMockWriteToParams{w}
	for _, e := range mmWriteTo.expectations {
		if minimock.Equal(e.params, mmWriteTo.defaultExpectation.params) {
			mmWriteTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteTo.defaultExpectation.params)
		}
	}

	return mmWriteTo
}

// Inspect accepts an inspector function that has same arguments as the FoldableReader.WriteTo
func (mmWriteTo *mFoldableReaderMockWriteTo) Inspect(f func(w io.Writer)) *mFoldableReaderMockWriteTo {
	if mmWriteTo.mock.inspectFuncWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("Inspect function is already set for FoldableReaderMock.WriteTo")
	}

	mmWriteTo.mock.inspectFuncWriteTo = f

	return mmWriteTo
}

// Return sets up results that will be returned by FoldableReader.WriteTo
func (mmWriteTo *mFoldableReaderMockWriteTo) Return(n int64, err error) *FoldableReaderMock {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("FoldableReaderMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &FoldableReaderMockWriteToExpectation{mock: mmWriteTo.mock}
	}
	mmWriteTo.defaultExpectation.results = &FoldableReaderMockWriteToResults{n, err}
	return mmWriteTo.mock
}

//Set uses given function f to mock the FoldableReader.WriteTo method
func (mmWriteTo *mFoldableReaderMockWriteTo) Set(f func(w io.Writer) (n int64, err error)) *FoldableReaderMock {
	if mmWriteTo.defaultExpectation != nil {
		mmWriteTo.mock.t.Fatalf("Default expectation is already set for the FoldableReader.WriteTo method")
	}

	if len(mmWriteTo.expectations) > 0 {
		mmWriteTo.mock.t.Fatalf("Some expectations are already set for the FoldableReader.WriteTo method")
	}

	mmWriteTo.mock.funcWriteTo = f
	return mmWriteTo.mock
}

// When sets expectation for the FoldableReader.WriteTo which will trigger the result defined by the following
// Then helper
func (mmWriteTo *mFoldableReaderMockWriteTo) When(w io.Writer) *FoldableReaderMockWriteToExpectation {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("FoldableReaderMock.WriteTo mock is already set by Set")
	}

	expectation := &FoldableReaderMockWriteToExpectation{
		mock:   mmWriteTo.mock,
		params: &FoldableReaderMockWriteToParams{w},
	}
	mmWriteTo.expectations = append(mmWriteTo.expectations, expectation)
	return expectation
}

// Then sets up FoldableReader.WriteTo return parameters for the expectation previously defined by the When method
func (e *FoldableReaderMockWriteToExpectation) Then(n int64, err error) *FoldableReaderMock {
	e.results = &FoldableReaderMockWriteToResults{n, err}
	return e.mock
}

// WriteTo implements FoldableReader
func (mmWriteTo *FoldableReaderMock) WriteTo(w io.Writer) (n int64, err error) {
	mm_atomic.AddUint64(&mmWriteTo.beforeWriteToCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteTo.afterWriteToCounter, 1)

	if mmWriteTo.inspectFuncWriteTo != nil {
		mmWriteTo.inspectFuncWriteTo(w)
	}

	mm_params := &FoldableReaderMockWriteToParams{w}

	// Record call args
	mmWriteTo.WriteToMock.mutex.Lock()
	mmWriteTo.WriteToMock.callArgs = append(mmWriteTo.WriteToMock.callArgs, mm_params)
	mmWriteTo.WriteToMock.mutex.Unlock()

	for _, e := range mmWriteTo.WriteToMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWriteTo.WriteToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteTo.WriteToMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteTo.WriteToMock.defaultExpectation.params
		mm_got := FoldableReaderMockWriteToParams{w}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteTo.t.Errorf("FoldableReaderMock.WriteTo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWriteTo.WriteToMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteTo.t.Fatal("No results are set for the FoldableReaderMock.WriteTo")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmWriteTo.funcWriteTo != nil {
		return mmWriteTo.funcWriteTo(w)
	}
	mmWriteTo.t.Fatalf("Unexpected call to FoldableReaderMock.WriteTo. %v", w)
	return
}

// WriteToAfterCounter returns a count of finished FoldableReaderMock.WriteTo invocations
func (mmWriteTo *FoldableReaderMock) WriteToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.afterWriteToCounter)
}

// WriteToBeforeCounter returns a count of FoldableReaderMock.WriteTo invocations
func (mmWriteTo *FoldableReaderMock) WriteToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.beforeWriteToCounter)
}

// Calls returns a list of arguments used in each call to FoldableReaderMock.WriteTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteTo *mFoldableReaderMockWriteTo) Calls() []*FoldableReaderMockWriteToParams {
	mmWriteTo.mutex.RLock()

	argCopy := make([]*FoldableReaderMockWriteToParams, len(mmWriteTo.callArgs))
	copy(argCopy, mmWriteTo.callArgs)

	mmWriteTo.mutex.RUnlock()

	return argCopy
}

// MinimockWriteToDone returns true if the count of the WriteTo invocations corresponds
// the number of defined expectations
func (m *FoldableReaderMock) MinimockWriteToDone() bool {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteToInspect logs each unmet expectation
func (m *FoldableReaderMock) MinimockWriteToInspect() {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FoldableReaderMock.WriteTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		if m.WriteToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FoldableReaderMock.WriteTo")
		} else {
			m.t.Errorf("Expected call to FoldableReaderMock.WriteTo with params: %#v", *m.WriteToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		m.t.Error("Expected call to FoldableReaderMock.WriteTo")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FoldableReaderMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAsByteStringInspect()

		m.MinimockCopyToInspect()

		m.MinimockFixedByteSizeInspect()

		m.MinimockFoldToUint64Inspect()

		m.MinimockWriteToInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FoldableReaderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FoldableReaderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAsByteStringDone() &&
		m.MinimockCopyToDone() &&
		m.MinimockFixedByteSizeDone() &&
		m.MinimockFoldToUint64Done() &&
		m.MinimockWriteToDone()
}
