package cryptkit

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// DataSignerMock implements DataSigner
type DataSignerMock struct {
	t minimock.Tester

	funcDigestData          func(r1 io.Reader) (d1 Digest)
	inspectFuncDigestData   func(r1 io.Reader)
	afterDigestDataCounter  uint64
	beforeDigestDataCounter uint64
	DigestDataMock          mDataSignerMockDigestData

	funcGetDigestMethod          func() (d1 DigestMethod)
	inspectFuncGetDigestMethod   func()
	afterGetDigestMethodCounter  uint64
	beforeGetDigestMethodCounter uint64
	GetDigestMethodMock          mDataSignerMockGetDigestMethod

	funcGetDigestSize          func() (i1 int)
	inspectFuncGetDigestSize   func()
	afterGetDigestSizeCounter  uint64
	beforeGetDigestSizeCounter uint64
	GetDigestSizeMock          mDataSignerMockGetDigestSize

	funcGetSignatureMethod          func() (s1 SignatureMethod)
	inspectFuncGetSignatureMethod   func()
	afterGetSignatureMethodCounter  uint64
	beforeGetSignatureMethodCounter uint64
	GetSignatureMethodMock          mDataSignerMockGetSignatureMethod

	funcGetSigningMethod          func() (s1 SigningMethod)
	inspectFuncGetSigningMethod   func()
	afterGetSigningMethodCounter  uint64
	beforeGetSigningMethodCounter uint64
	GetSigningMethodMock          mDataSignerMockGetSigningMethod

	funcSignData          func(reader io.Reader) (s1 SignedDigest)
	inspectFuncSignData   func(reader io.Reader)
	afterSignDataCounter  uint64
	beforeSignDataCounter uint64
	SignDataMock          mDataSignerMockSignData

	funcSignDigest          func(digest Digest) (s1 Signature)
	inspectFuncSignDigest   func(digest Digest)
	afterSignDigestCounter  uint64
	beforeSignDigestCounter uint64
	SignDigestMock          mDataSignerMockSignDigest
}

// NewDataSignerMock returns a mock for DataSigner
func NewDataSignerMock(t minimock.Tester) *DataSignerMock {
	m := &DataSignerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DigestDataMock = mDataSignerMockDigestData{mock: m}
	m.DigestDataMock.callArgs = []*DataSignerMockDigestDataParams{}

	m.GetDigestMethodMock = mDataSignerMockGetDigestMethod{mock: m}

	m.GetDigestSizeMock = mDataSignerMockGetDigestSize{mock: m}

	m.GetSignatureMethodMock = mDataSignerMockGetSignatureMethod{mock: m}

	m.GetSigningMethodMock = mDataSignerMockGetSigningMethod{mock: m}

	m.SignDataMock = mDataSignerMockSignData{mock: m}
	m.SignDataMock.callArgs = []*DataSignerMockSignDataParams{}

	m.SignDigestMock = mDataSignerMockSignDigest{mock: m}
	m.SignDigestMock.callArgs = []*DataSignerMockSignDigestParams{}

	return m
}

type mDataSignerMockDigestData struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockDigestDataExpectation
	expectations       []*DataSignerMockDigestDataExpectation

	callArgs []*DataSignerMockDigestDataParams
	mutex    sync.RWMutex
}

// DataSignerMockDigestDataExpectation specifies expectation struct of the DataSigner.DigestData
type DataSignerMockDigestDataExpectation struct {
	mock    *DataSignerMock
	params  *DataSignerMockDigestDataParams
	results *DataSignerMockDigestDataResults
	Counter uint64
}

// DataSignerMockDigestDataParams contains parameters of the DataSigner.DigestData
type DataSignerMockDigestDataParams struct {
	r1 io.Reader
}

// DataSignerMockDigestDataResults contains results of the DataSigner.DigestData
type DataSignerMockDigestDataResults struct {
	d1 Digest
}

// Expect sets up expected params for DataSigner.DigestData
func (mmDigestData *mDataSignerMockDigestData) Expect(r1 io.Reader) *mDataSignerMockDigestData {
	if mmDigestData.mock.funcDigestData != nil {
		mmDigestData.mock.t.Fatalf("DataSignerMock.DigestData mock is already set by Set")
	}

	if mmDigestData.defaultExpectation == nil {
		mmDigestData.defaultExpectation = &DataSignerMockDigestDataExpectation{}
	}

	mmDigestData.defaultExpectation.params = &DataSignerMockDigestDataParams{r1}
	for _, e := range mmDigestData.expectations {
		if minimock.Equal(e.params, mmDigestData.defaultExpectation.params) {
			mmDigestData.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDigestData.defaultExpectation.params)
		}
	}

	return mmDigestData
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.DigestData
func (mmDigestData *mDataSignerMockDigestData) Inspect(f func(r1 io.Reader)) *mDataSignerMockDigestData {
	if mmDigestData.mock.inspectFuncDigestData != nil {
		mmDigestData.mock.t.Fatalf("Inspect function is already set for DataSignerMock.DigestData")
	}

	mmDigestData.mock.inspectFuncDigestData = f

	return mmDigestData
}

// Return sets up results that will be returned by DataSigner.DigestData
func (mmDigestData *mDataSignerMockDigestData) Return(d1 Digest) *DataSignerMock {
	if mmDigestData.mock.funcDigestData != nil {
		mmDigestData.mock.t.Fatalf("DataSignerMock.DigestData mock is already set by Set")
	}

	if mmDigestData.defaultExpectation == nil {
		mmDigestData.defaultExpectation = &DataSignerMockDigestDataExpectation{mock: mmDigestData.mock}
	}
	mmDigestData.defaultExpectation.results = &DataSignerMockDigestDataResults{d1}
	return mmDigestData.mock
}

//Set uses given function f to mock the DataSigner.DigestData method
func (mmDigestData *mDataSignerMockDigestData) Set(f func(r1 io.Reader) (d1 Digest)) *DataSignerMock {
	if mmDigestData.defaultExpectation != nil {
		mmDigestData.mock.t.Fatalf("Default expectation is already set for the DataSigner.DigestData method")
	}

	if len(mmDigestData.expectations) > 0 {
		mmDigestData.mock.t.Fatalf("Some expectations are already set for the DataSigner.DigestData method")
	}

	mmDigestData.mock.funcDigestData = f
	return mmDigestData.mock
}

// When sets expectation for the DataSigner.DigestData which will trigger the result defined by the following
// Then helper
func (mmDigestData *mDataSignerMockDigestData) When(r1 io.Reader) *DataSignerMockDigestDataExpectation {
	if mmDigestData.mock.funcDigestData != nil {
		mmDigestData.mock.t.Fatalf("DataSignerMock.DigestData mock is already set by Set")
	}

	expectation := &DataSignerMockDigestDataExpectation{
		mock:   mmDigestData.mock,
		params: &DataSignerMockDigestDataParams{r1},
	}
	mmDigestData.expectations = append(mmDigestData.expectations, expectation)
	return expectation
}

// Then sets up DataSigner.DigestData return parameters for the expectation previously defined by the When method
func (e *DataSignerMockDigestDataExpectation) Then(d1 Digest) *DataSignerMock {
	e.results = &DataSignerMockDigestDataResults{d1}
	return e.mock
}

// DigestData implements DataSigner
func (mmDigestData *DataSignerMock) DigestData(r1 io.Reader) (d1 Digest) {
	mm_atomic.AddUint64(&mmDigestData.beforeDigestDataCounter, 1)
	defer mm_atomic.AddUint64(&mmDigestData.afterDigestDataCounter, 1)

	if mmDigestData.inspectFuncDigestData != nil {
		mmDigestData.inspectFuncDigestData(r1)
	}

	mm_params := &DataSignerMockDigestDataParams{r1}

	// Record call args
	mmDigestData.DigestDataMock.mutex.Lock()
	mmDigestData.DigestDataMock.callArgs = append(mmDigestData.DigestDataMock.callArgs, mm_params)
	mmDigestData.DigestDataMock.mutex.Unlock()

	for _, e := range mmDigestData.DigestDataMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.d1
		}
	}

	if mmDigestData.DigestDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDigestData.DigestDataMock.defaultExpectation.Counter, 1)
		mm_want := mmDigestData.DigestDataMock.defaultExpectation.params
		mm_got := DataSignerMockDigestDataParams{r1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDigestData.t.Errorf("DataSignerMock.DigestData got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDigestData.DigestDataMock.defaultExpectation.results
		if mm_results == nil {
			mmDigestData.t.Fatal("No results are set for the DataSignerMock.DigestData")
		}
		return (*mm_results).d1
	}
	if mmDigestData.funcDigestData != nil {
		return mmDigestData.funcDigestData(r1)
	}
	mmDigestData.t.Fatalf("Unexpected call to DataSignerMock.DigestData. %v", r1)
	return
}

// DigestDataAfterCounter returns a count of finished DataSignerMock.DigestData invocations
func (mmDigestData *DataSignerMock) DigestDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDigestData.afterDigestDataCounter)
}

// DigestDataBeforeCounter returns a count of DataSignerMock.DigestData invocations
func (mmDigestData *DataSignerMock) DigestDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDigestData.beforeDigestDataCounter)
}

// Calls returns a list of arguments used in each call to DataSignerMock.DigestData.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDigestData *mDataSignerMockDigestData) Calls() []*DataSignerMockDigestDataParams {
	mmDigestData.mutex.RLock()

	argCopy := make([]*DataSignerMockDigestDataParams, len(mmDigestData.callArgs))
	copy(argCopy, mmDigestData.callArgs)

	mmDigestData.mutex.RUnlock()

	return argCopy
}

// MinimockDigestDataDone returns true if the count of the DigestData invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockDigestDataDone() bool {
	for _, e := range m.DigestDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DigestDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDigestDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDigestData != nil && mm_atomic.LoadUint64(&m.afterDigestDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockDigestDataInspect logs each unmet expectation
func (m *DataSignerMock) MinimockDigestDataInspect() {
	for _, e := range m.DigestDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DataSignerMock.DigestData with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DigestDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDigestDataCounter) < 1 {
		if m.DigestDataMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DataSignerMock.DigestData")
		} else {
			m.t.Errorf("Expected call to DataSignerMock.DigestData with params: %#v", *m.DigestDataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDigestData != nil && mm_atomic.LoadUint64(&m.afterDigestDataCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.DigestData")
	}
}

type mDataSignerMockGetDigestMethod struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockGetDigestMethodExpectation
	expectations       []*DataSignerMockGetDigestMethodExpectation
}

// DataSignerMockGetDigestMethodExpectation specifies expectation struct of the DataSigner.GetDigestMethod
type DataSignerMockGetDigestMethodExpectation struct {
	mock *DataSignerMock

	results *DataSignerMockGetDigestMethodResults
	Counter uint64
}

// DataSignerMockGetDigestMethodResults contains results of the DataSigner.GetDigestMethod
type DataSignerMockGetDigestMethodResults struct {
	d1 DigestMethod
}

// Expect sets up expected params for DataSigner.GetDigestMethod
func (mmGetDigestMethod *mDataSignerMockGetDigestMethod) Expect() *mDataSignerMockGetDigestMethod {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("DataSignerMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &DataSignerMockGetDigestMethodExpectation{}
	}

	return mmGetDigestMethod
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.GetDigestMethod
func (mmGetDigestMethod *mDataSignerMockGetDigestMethod) Inspect(f func()) *mDataSignerMockGetDigestMethod {
	if mmGetDigestMethod.mock.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("Inspect function is already set for DataSignerMock.GetDigestMethod")
	}

	mmGetDigestMethod.mock.inspectFuncGetDigestMethod = f

	return mmGetDigestMethod
}

// Return sets up results that will be returned by DataSigner.GetDigestMethod
func (mmGetDigestMethod *mDataSignerMockGetDigestMethod) Return(d1 DigestMethod) *DataSignerMock {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("DataSignerMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &DataSignerMockGetDigestMethodExpectation{mock: mmGetDigestMethod.mock}
	}
	mmGetDigestMethod.defaultExpectation.results = &DataSignerMockGetDigestMethodResults{d1}
	return mmGetDigestMethod.mock
}

//Set uses given function f to mock the DataSigner.GetDigestMethod method
func (mmGetDigestMethod *mDataSignerMockGetDigestMethod) Set(f func() (d1 DigestMethod)) *DataSignerMock {
	if mmGetDigestMethod.defaultExpectation != nil {
		mmGetDigestMethod.mock.t.Fatalf("Default expectation is already set for the DataSigner.GetDigestMethod method")
	}

	if len(mmGetDigestMethod.expectations) > 0 {
		mmGetDigestMethod.mock.t.Fatalf("Some expectations are already set for the DataSigner.GetDigestMethod method")
	}

	mmGetDigestMethod.mock.funcGetDigestMethod = f
	return mmGetDigestMethod.mock
}

// GetDigestMethod implements DataSigner
func (mmGetDigestMethod *DataSignerMock) GetDigestMethod() (d1 DigestMethod) {
	mm_atomic.AddUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestMethod.afterGetDigestMethodCounter, 1)

	if mmGetDigestMethod.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.inspectFuncGetDigestMethod()
	}

	if mmGetDigestMethod.GetDigestMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDigestMethod.t.Fatal("No results are set for the DataSignerMock.GetDigestMethod")
		}
		return (*mm_results).d1
	}
	if mmGetDigestMethod.funcGetDigestMethod != nil {
		return mmGetDigestMethod.funcGetDigestMethod()
	}
	mmGetDigestMethod.t.Fatalf("Unexpected call to DataSignerMock.GetDigestMethod.")
	return
}

// GetDigestMethodAfterCounter returns a count of finished DataSignerMock.GetDigestMethod invocations
func (mmGetDigestMethod *DataSignerMock) GetDigestMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.afterGetDigestMethodCounter)
}

// GetDigestMethodBeforeCounter returns a count of DataSignerMock.GetDigestMethod invocations
func (mmGetDigestMethod *DataSignerMock) GetDigestMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter)
}

// MinimockGetDigestMethodDone returns true if the count of the GetDigestMethod invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockGetDigestMethodDone() bool {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestMethodInspect logs each unmet expectation
func (m *DataSignerMock) MinimockGetDigestMethodInspect() {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DataSignerMock.GetDigestMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetDigestMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetDigestMethod")
	}
}

type mDataSignerMockGetDigestSize struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockGetDigestSizeExpectation
	expectations       []*DataSignerMockGetDigestSizeExpectation
}

// DataSignerMockGetDigestSizeExpectation specifies expectation struct of the DataSigner.GetDigestSize
type DataSignerMockGetDigestSizeExpectation struct {
	mock *DataSignerMock

	results *DataSignerMockGetDigestSizeResults
	Counter uint64
}

// DataSignerMockGetDigestSizeResults contains results of the DataSigner.GetDigestSize
type DataSignerMockGetDigestSizeResults struct {
	i1 int
}

// Expect sets up expected params for DataSigner.GetDigestSize
func (mmGetDigestSize *mDataSignerMockGetDigestSize) Expect() *mDataSignerMockGetDigestSize {
	if mmGetDigestSize.mock.funcGetDigestSize != nil {
		mmGetDigestSize.mock.t.Fatalf("DataSignerMock.GetDigestSize mock is already set by Set")
	}

	if mmGetDigestSize.defaultExpectation == nil {
		mmGetDigestSize.defaultExpectation = &DataSignerMockGetDigestSizeExpectation{}
	}

	return mmGetDigestSize
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.GetDigestSize
func (mmGetDigestSize *mDataSignerMockGetDigestSize) Inspect(f func()) *mDataSignerMockGetDigestSize {
	if mmGetDigestSize.mock.inspectFuncGetDigestSize != nil {
		mmGetDigestSize.mock.t.Fatalf("Inspect function is already set for DataSignerMock.GetDigestSize")
	}

	mmGetDigestSize.mock.inspectFuncGetDigestSize = f

	return mmGetDigestSize
}

// Return sets up results that will be returned by DataSigner.GetDigestSize
func (mmGetDigestSize *mDataSignerMockGetDigestSize) Return(i1 int) *DataSignerMock {
	if mmGetDigestSize.mock.funcGetDigestSize != nil {
		mmGetDigestSize.mock.t.Fatalf("DataSignerMock.GetDigestSize mock is already set by Set")
	}

	if mmGetDigestSize.defaultExpectation == nil {
		mmGetDigestSize.defaultExpectation = &DataSignerMockGetDigestSizeExpectation{mock: mmGetDigestSize.mock}
	}
	mmGetDigestSize.defaultExpectation.results = &DataSignerMockGetDigestSizeResults{i1}
	return mmGetDigestSize.mock
}

//Set uses given function f to mock the DataSigner.GetDigestSize method
func (mmGetDigestSize *mDataSignerMockGetDigestSize) Set(f func() (i1 int)) *DataSignerMock {
	if mmGetDigestSize.defaultExpectation != nil {
		mmGetDigestSize.mock.t.Fatalf("Default expectation is already set for the DataSigner.GetDigestSize method")
	}

	if len(mmGetDigestSize.expectations) > 0 {
		mmGetDigestSize.mock.t.Fatalf("Some expectations are already set for the DataSigner.GetDigestSize method")
	}

	mmGetDigestSize.mock.funcGetDigestSize = f
	return mmGetDigestSize.mock
}

// GetDigestSize implements DataSigner
func (mmGetDigestSize *DataSignerMock) GetDigestSize() (i1 int) {
	mm_atomic.AddUint64(&mmGetDigestSize.beforeGetDigestSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestSize.afterGetDigestSizeCounter, 1)

	if mmGetDigestSize.inspectFuncGetDigestSize != nil {
		mmGetDigestSize.inspectFuncGetDigestSize()
	}

	if mmGetDigestSize.GetDigestSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestSize.GetDigestSizeMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDigestSize.GetDigestSizeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDigestSize.t.Fatal("No results are set for the DataSignerMock.GetDigestSize")
		}
		return (*mm_results).i1
	}
	if mmGetDigestSize.funcGetDigestSize != nil {
		return mmGetDigestSize.funcGetDigestSize()
	}
	mmGetDigestSize.t.Fatalf("Unexpected call to DataSignerMock.GetDigestSize.")
	return
}

// GetDigestSizeAfterCounter returns a count of finished DataSignerMock.GetDigestSize invocations
func (mmGetDigestSize *DataSignerMock) GetDigestSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestSize.afterGetDigestSizeCounter)
}

// GetDigestSizeBeforeCounter returns a count of DataSignerMock.GetDigestSize invocations
func (mmGetDigestSize *DataSignerMock) GetDigestSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestSize.beforeGetDigestSizeCounter)
}

// MinimockGetDigestSizeDone returns true if the count of the GetDigestSize invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockGetDigestSizeDone() bool {
	for _, e := range m.GetDigestSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestSize != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestSizeInspect logs each unmet expectation
func (m *DataSignerMock) MinimockGetDigestSizeInspect() {
	for _, e := range m.GetDigestSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DataSignerMock.GetDigestSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetDigestSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestSize != nil && mm_atomic.LoadUint64(&m.afterGetDigestSizeCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetDigestSize")
	}
}

type mDataSignerMockGetSignatureMethod struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockGetSignatureMethodExpectation
	expectations       []*DataSignerMockGetSignatureMethodExpectation
}

// DataSignerMockGetSignatureMethodExpectation specifies expectation struct of the DataSigner.GetSignatureMethod
type DataSignerMockGetSignatureMethodExpectation struct {
	mock *DataSignerMock

	results *DataSignerMockGetSignatureMethodResults
	Counter uint64
}

// DataSignerMockGetSignatureMethodResults contains results of the DataSigner.GetSignatureMethod
type DataSignerMockGetSignatureMethodResults struct {
	s1 SignatureMethod
}

// Expect sets up expected params for DataSigner.GetSignatureMethod
func (mmGetSignatureMethod *mDataSignerMockGetSignatureMethod) Expect() *mDataSignerMockGetSignatureMethod {
	if mmGetSignatureMethod.mock.funcGetSignatureMethod != nil {
		mmGetSignatureMethod.mock.t.Fatalf("DataSignerMock.GetSignatureMethod mock is already set by Set")
	}

	if mmGetSignatureMethod.defaultExpectation == nil {
		mmGetSignatureMethod.defaultExpectation = &DataSignerMockGetSignatureMethodExpectation{}
	}

	return mmGetSignatureMethod
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.GetSignatureMethod
func (mmGetSignatureMethod *mDataSignerMockGetSignatureMethod) Inspect(f func()) *mDataSignerMockGetSignatureMethod {
	if mmGetSignatureMethod.mock.inspectFuncGetSignatureMethod != nil {
		mmGetSignatureMethod.mock.t.Fatalf("Inspect function is already set for DataSignerMock.GetSignatureMethod")
	}

	mmGetSignatureMethod.mock.inspectFuncGetSignatureMethod = f

	return mmGetSignatureMethod
}

// Return sets up results that will be returned by DataSigner.GetSignatureMethod
func (mmGetSignatureMethod *mDataSignerMockGetSignatureMethod) Return(s1 SignatureMethod) *DataSignerMock {
	if mmGetSignatureMethod.mock.funcGetSignatureMethod != nil {
		mmGetSignatureMethod.mock.t.Fatalf("DataSignerMock.GetSignatureMethod mock is already set by Set")
	}

	if mmGetSignatureMethod.defaultExpectation == nil {
		mmGetSignatureMethod.defaultExpectation = &DataSignerMockGetSignatureMethodExpectation{mock: mmGetSignatureMethod.mock}
	}
	mmGetSignatureMethod.defaultExpectation.results = &DataSignerMockGetSignatureMethodResults{s1}
	return mmGetSignatureMethod.mock
}

//Set uses given function f to mock the DataSigner.GetSignatureMethod method
func (mmGetSignatureMethod *mDataSignerMockGetSignatureMethod) Set(f func() (s1 SignatureMethod)) *DataSignerMock {
	if mmGetSignatureMethod.defaultExpectation != nil {
		mmGetSignatureMethod.mock.t.Fatalf("Default expectation is already set for the DataSigner.GetSignatureMethod method")
	}

	if len(mmGetSignatureMethod.expectations) > 0 {
		mmGetSignatureMethod.mock.t.Fatalf("Some expectations are already set for the DataSigner.GetSignatureMethod method")
	}

	mmGetSignatureMethod.mock.funcGetSignatureMethod = f
	return mmGetSignatureMethod.mock
}

// GetSignatureMethod implements DataSigner
func (mmGetSignatureMethod *DataSignerMock) GetSignatureMethod() (s1 SignatureMethod) {
	mm_atomic.AddUint64(&mmGetSignatureMethod.beforeGetSignatureMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSignatureMethod.afterGetSignatureMethodCounter, 1)

	if mmGetSignatureMethod.inspectFuncGetSignatureMethod != nil {
		mmGetSignatureMethod.inspectFuncGetSignatureMethod()
	}

	if mmGetSignatureMethod.GetSignatureMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSignatureMethod.GetSignatureMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetSignatureMethod.GetSignatureMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSignatureMethod.t.Fatal("No results are set for the DataSignerMock.GetSignatureMethod")
		}
		return (*mm_results).s1
	}
	if mmGetSignatureMethod.funcGetSignatureMethod != nil {
		return mmGetSignatureMethod.funcGetSignatureMethod()
	}
	mmGetSignatureMethod.t.Fatalf("Unexpected call to DataSignerMock.GetSignatureMethod.")
	return
}

// GetSignatureMethodAfterCounter returns a count of finished DataSignerMock.GetSignatureMethod invocations
func (mmGetSignatureMethod *DataSignerMock) GetSignatureMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureMethod.afterGetSignatureMethodCounter)
}

// GetSignatureMethodBeforeCounter returns a count of DataSignerMock.GetSignatureMethod invocations
func (mmGetSignatureMethod *DataSignerMock) GetSignatureMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureMethod.beforeGetSignatureMethodCounter)
}

// MinimockGetSignatureMethodDone returns true if the count of the GetSignatureMethod invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockGetSignatureMethodDone() bool {
	for _, e := range m.GetSignatureMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSignatureMethodInspect logs each unmet expectation
func (m *DataSignerMock) MinimockGetSignatureMethodInspect() {
	for _, e := range m.GetSignatureMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DataSignerMock.GetSignatureMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetSignatureMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetSignatureMethod")
	}
}

type mDataSignerMockGetSigningMethod struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockGetSigningMethodExpectation
	expectations       []*DataSignerMockGetSigningMethodExpectation
}

// DataSignerMockGetSigningMethodExpectation specifies expectation struct of the DataSigner.GetSigningMethod
type DataSignerMockGetSigningMethodExpectation struct {
	mock *DataSignerMock

	results *DataSignerMockGetSigningMethodResults
	Counter uint64
}

// DataSignerMockGetSigningMethodResults contains results of the DataSigner.GetSigningMethod
type DataSignerMockGetSigningMethodResults struct {
	s1 SigningMethod
}

// Expect sets up expected params for DataSigner.GetSigningMethod
func (mmGetSigningMethod *mDataSignerMockGetSigningMethod) Expect() *mDataSignerMockGetSigningMethod {
	if mmGetSigningMethod.mock.funcGetSigningMethod != nil {
		mmGetSigningMethod.mock.t.Fatalf("DataSignerMock.GetSigningMethod mock is already set by Set")
	}

	if mmGetSigningMethod.defaultExpectation == nil {
		mmGetSigningMethod.defaultExpectation = &DataSignerMockGetSigningMethodExpectation{}
	}

	return mmGetSigningMethod
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.GetSigningMethod
func (mmGetSigningMethod *mDataSignerMockGetSigningMethod) Inspect(f func()) *mDataSignerMockGetSigningMethod {
	if mmGetSigningMethod.mock.inspectFuncGetSigningMethod != nil {
		mmGetSigningMethod.mock.t.Fatalf("Inspect function is already set for DataSignerMock.GetSigningMethod")
	}

	mmGetSigningMethod.mock.inspectFuncGetSigningMethod = f

	return mmGetSigningMethod
}

// Return sets up results that will be returned by DataSigner.GetSigningMethod
func (mmGetSigningMethod *mDataSignerMockGetSigningMethod) Return(s1 SigningMethod) *DataSignerMock {
	if mmGetSigningMethod.mock.funcGetSigningMethod != nil {
		mmGetSigningMethod.mock.t.Fatalf("DataSignerMock.GetSigningMethod mock is already set by Set")
	}

	if mmGetSigningMethod.defaultExpectation == nil {
		mmGetSigningMethod.defaultExpectation = &DataSignerMockGetSigningMethodExpectation{mock: mmGetSigningMethod.mock}
	}
	mmGetSigningMethod.defaultExpectation.results = &DataSignerMockGetSigningMethodResults{s1}
	return mmGetSigningMethod.mock
}

//Set uses given function f to mock the DataSigner.GetSigningMethod method
func (mmGetSigningMethod *mDataSignerMockGetSigningMethod) Set(f func() (s1 SigningMethod)) *DataSignerMock {
	if mmGetSigningMethod.defaultExpectation != nil {
		mmGetSigningMethod.mock.t.Fatalf("Default expectation is already set for the DataSigner.GetSigningMethod method")
	}

	if len(mmGetSigningMethod.expectations) > 0 {
		mmGetSigningMethod.mock.t.Fatalf("Some expectations are already set for the DataSigner.GetSigningMethod method")
	}

	mmGetSigningMethod.mock.funcGetSigningMethod = f
	return mmGetSigningMethod.mock
}

// GetSigningMethod implements DataSigner
func (mmGetSigningMethod *DataSignerMock) GetSigningMethod() (s1 SigningMethod) {
	mm_atomic.AddUint64(&mmGetSigningMethod.beforeGetSigningMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSigningMethod.afterGetSigningMethodCounter, 1)

	if mmGetSigningMethod.inspectFuncGetSigningMethod != nil {
		mmGetSigningMethod.inspectFuncGetSigningMethod()
	}

	if mmGetSigningMethod.GetSigningMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSigningMethod.GetSigningMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetSigningMethod.GetSigningMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSigningMethod.t.Fatal("No results are set for the DataSignerMock.GetSigningMethod")
		}
		return (*mm_results).s1
	}
	if mmGetSigningMethod.funcGetSigningMethod != nil {
		return mmGetSigningMethod.funcGetSigningMethod()
	}
	mmGetSigningMethod.t.Fatalf("Unexpected call to DataSignerMock.GetSigningMethod.")
	return
}

// GetSigningMethodAfterCounter returns a count of finished DataSignerMock.GetSigningMethod invocations
func (mmGetSigningMethod *DataSignerMock) GetSigningMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSigningMethod.afterGetSigningMethodCounter)
}

// GetSigningMethodBeforeCounter returns a count of DataSignerMock.GetSigningMethod invocations
func (mmGetSigningMethod *DataSignerMock) GetSigningMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSigningMethod.beforeGetSigningMethodCounter)
}

// MinimockGetSigningMethodDone returns true if the count of the GetSigningMethod invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockGetSigningMethodDone() bool {
	for _, e := range m.GetSigningMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSigningMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSigningMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSigningMethod != nil && mm_atomic.LoadUint64(&m.afterGetSigningMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSigningMethodInspect logs each unmet expectation
func (m *DataSignerMock) MinimockGetSigningMethodInspect() {
	for _, e := range m.GetSigningMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DataSignerMock.GetSigningMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSigningMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSigningMethodCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetSigningMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSigningMethod != nil && mm_atomic.LoadUint64(&m.afterGetSigningMethodCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetSigningMethod")
	}
}

type mDataSignerMockSignData struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockSignDataExpectation
	expectations       []*DataSignerMockSignDataExpectation

	callArgs []*DataSignerMockSignDataParams
	mutex    sync.RWMutex
}

// DataSignerMockSignDataExpectation specifies expectation struct of the DataSigner.SignData
type DataSignerMockSignDataExpectation struct {
	mock    *DataSignerMock
	params  *DataSignerMockSignDataParams
	results *DataSignerMockSignDataResults
	Counter uint64
}

// DataSignerMockSignDataParams contains parameters of the DataSigner.SignData
type DataSignerMockSignDataParams struct {
	reader io.Reader
}

// DataSignerMockSignDataResults contains results of the DataSigner.SignData
type DataSignerMockSignDataResults struct {
	s1 SignedDigest
}

// Expect sets up expected params for DataSigner.SignData
func (mmSignData *mDataSignerMockSignData) Expect(reader io.Reader) *mDataSignerMockSignData {
	if mmSignData.mock.funcSignData != nil {
		mmSignData.mock.t.Fatalf("DataSignerMock.SignData mock is already set by Set")
	}

	if mmSignData.defaultExpectation == nil {
		mmSignData.defaultExpectation = &DataSignerMockSignDataExpectation{}
	}

	mmSignData.defaultExpectation.params = &DataSignerMockSignDataParams{reader}
	for _, e := range mmSignData.expectations {
		if minimock.Equal(e.params, mmSignData.defaultExpectation.params) {
			mmSignData.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSignData.defaultExpectation.params)
		}
	}

	return mmSignData
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.SignData
func (mmSignData *mDataSignerMockSignData) Inspect(f func(reader io.Reader)) *mDataSignerMockSignData {
	if mmSignData.mock.inspectFuncSignData != nil {
		mmSignData.mock.t.Fatalf("Inspect function is already set for DataSignerMock.SignData")
	}

	mmSignData.mock.inspectFuncSignData = f

	return mmSignData
}

// Return sets up results that will be returned by DataSigner.SignData
func (mmSignData *mDataSignerMockSignData) Return(s1 SignedDigest) *DataSignerMock {
	if mmSignData.mock.funcSignData != nil {
		mmSignData.mock.t.Fatalf("DataSignerMock.SignData mock is already set by Set")
	}

	if mmSignData.defaultExpectation == nil {
		mmSignData.defaultExpectation = &DataSignerMockSignDataExpectation{mock: mmSignData.mock}
	}
	mmSignData.defaultExpectation.results = &DataSignerMockSignDataResults{s1}
	return mmSignData.mock
}

//Set uses given function f to mock the DataSigner.SignData method
func (mmSignData *mDataSignerMockSignData) Set(f func(reader io.Reader) (s1 SignedDigest)) *DataSignerMock {
	if mmSignData.defaultExpectation != nil {
		mmSignData.mock.t.Fatalf("Default expectation is already set for the DataSigner.SignData method")
	}

	if len(mmSignData.expectations) > 0 {
		mmSignData.mock.t.Fatalf("Some expectations are already set for the DataSigner.SignData method")
	}

	mmSignData.mock.funcSignData = f
	return mmSignData.mock
}

// When sets expectation for the DataSigner.SignData which will trigger the result defined by the following
// Then helper
func (mmSignData *mDataSignerMockSignData) When(reader io.Reader) *DataSignerMockSignDataExpectation {
	if mmSignData.mock.funcSignData != nil {
		mmSignData.mock.t.Fatalf("DataSignerMock.SignData mock is already set by Set")
	}

	expectation := &DataSignerMockSignDataExpectation{
		mock:   mmSignData.mock,
		params: &DataSignerMockSignDataParams{reader},
	}
	mmSignData.expectations = append(mmSignData.expectations, expectation)
	return expectation
}

// Then sets up DataSigner.SignData return parameters for the expectation previously defined by the When method
func (e *DataSignerMockSignDataExpectation) Then(s1 SignedDigest) *DataSignerMock {
	e.results = &DataSignerMockSignDataResults{s1}
	return e.mock
}

// SignData implements DataSigner
func (mmSignData *DataSignerMock) SignData(reader io.Reader) (s1 SignedDigest) {
	mm_atomic.AddUint64(&mmSignData.beforeSignDataCounter, 1)
	defer mm_atomic.AddUint64(&mmSignData.afterSignDataCounter, 1)

	if mmSignData.inspectFuncSignData != nil {
		mmSignData.inspectFuncSignData(reader)
	}

	mm_params := &DataSignerMockSignDataParams{reader}

	// Record call args
	mmSignData.SignDataMock.mutex.Lock()
	mmSignData.SignDataMock.callArgs = append(mmSignData.SignDataMock.callArgs, mm_params)
	mmSignData.SignDataMock.mutex.Unlock()

	for _, e := range mmSignData.SignDataMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSignData.SignDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSignData.SignDataMock.defaultExpectation.Counter, 1)
		mm_want := mmSignData.SignDataMock.defaultExpectation.params
		mm_got := DataSignerMockSignDataParams{reader}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSignData.t.Errorf("DataSignerMock.SignData got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSignData.SignDataMock.defaultExpectation.results
		if mm_results == nil {
			mmSignData.t.Fatal("No results are set for the DataSignerMock.SignData")
		}
		return (*mm_results).s1
	}
	if mmSignData.funcSignData != nil {
		return mmSignData.funcSignData(reader)
	}
	mmSignData.t.Fatalf("Unexpected call to DataSignerMock.SignData. %v", reader)
	return
}

// SignDataAfterCounter returns a count of finished DataSignerMock.SignData invocations
func (mmSignData *DataSignerMock) SignDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignData.afterSignDataCounter)
}

// SignDataBeforeCounter returns a count of DataSignerMock.SignData invocations
func (mmSignData *DataSignerMock) SignDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignData.beforeSignDataCounter)
}

// Calls returns a list of arguments used in each call to DataSignerMock.SignData.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSignData *mDataSignerMockSignData) Calls() []*DataSignerMockSignDataParams {
	mmSignData.mutex.RLock()

	argCopy := make([]*DataSignerMockSignDataParams, len(mmSignData.callArgs))
	copy(argCopy, mmSignData.callArgs)

	mmSignData.mutex.RUnlock()

	return argCopy
}

// MinimockSignDataDone returns true if the count of the SignData invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockSignDataDone() bool {
	for _, e := range m.SignDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignData != nil && mm_atomic.LoadUint64(&m.afterSignDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockSignDataInspect logs each unmet expectation
func (m *DataSignerMock) MinimockSignDataInspect() {
	for _, e := range m.SignDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DataSignerMock.SignData with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignDataCounter) < 1 {
		if m.SignDataMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DataSignerMock.SignData")
		} else {
			m.t.Errorf("Expected call to DataSignerMock.SignData with params: %#v", *m.SignDataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignData != nil && mm_atomic.LoadUint64(&m.afterSignDataCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.SignData")
	}
}

type mDataSignerMockSignDigest struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockSignDigestExpectation
	expectations       []*DataSignerMockSignDigestExpectation

	callArgs []*DataSignerMockSignDigestParams
	mutex    sync.RWMutex
}

// DataSignerMockSignDigestExpectation specifies expectation struct of the DataSigner.SignDigest
type DataSignerMockSignDigestExpectation struct {
	mock    *DataSignerMock
	params  *DataSignerMockSignDigestParams
	results *DataSignerMockSignDigestResults
	Counter uint64
}

// DataSignerMockSignDigestParams contains parameters of the DataSigner.SignDigest
type DataSignerMockSignDigestParams struct {
	digest Digest
}

// DataSignerMockSignDigestResults contains results of the DataSigner.SignDigest
type DataSignerMockSignDigestResults struct {
	s1 Signature
}

// Expect sets up expected params for DataSigner.SignDigest
func (mmSignDigest *mDataSignerMockSignDigest) Expect(digest Digest) *mDataSignerMockSignDigest {
	if mmSignDigest.mock.funcSignDigest != nil {
		mmSignDigest.mock.t.Fatalf("DataSignerMock.SignDigest mock is already set by Set")
	}

	if mmSignDigest.defaultExpectation == nil {
		mmSignDigest.defaultExpectation = &DataSignerMockSignDigestExpectation{}
	}

	mmSignDigest.defaultExpectation.params = &DataSignerMockSignDigestParams{digest}
	for _, e := range mmSignDigest.expectations {
		if minimock.Equal(e.params, mmSignDigest.defaultExpectation.params) {
			mmSignDigest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSignDigest.defaultExpectation.params)
		}
	}

	return mmSignDigest
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.SignDigest
func (mmSignDigest *mDataSignerMockSignDigest) Inspect(f func(digest Digest)) *mDataSignerMockSignDigest {
	if mmSignDigest.mock.inspectFuncSignDigest != nil {
		mmSignDigest.mock.t.Fatalf("Inspect function is already set for DataSignerMock.SignDigest")
	}

	mmSignDigest.mock.inspectFuncSignDigest = f

	return mmSignDigest
}

// Return sets up results that will be returned by DataSigner.SignDigest
func (mmSignDigest *mDataSignerMockSignDigest) Return(s1 Signature) *DataSignerMock {
	if mmSignDigest.mock.funcSignDigest != nil {
		mmSignDigest.mock.t.Fatalf("DataSignerMock.SignDigest mock is already set by Set")
	}

	if mmSignDigest.defaultExpectation == nil {
		mmSignDigest.defaultExpectation = &DataSignerMockSignDigestExpectation{mock: mmSignDigest.mock}
	}
	mmSignDigest.defaultExpectation.results = &DataSignerMockSignDigestResults{s1}
	return mmSignDigest.mock
}

//Set uses given function f to mock the DataSigner.SignDigest method
func (mmSignDigest *mDataSignerMockSignDigest) Set(f func(digest Digest) (s1 Signature)) *DataSignerMock {
	if mmSignDigest.defaultExpectation != nil {
		mmSignDigest.mock.t.Fatalf("Default expectation is already set for the DataSigner.SignDigest method")
	}

	if len(mmSignDigest.expectations) > 0 {
		mmSignDigest.mock.t.Fatalf("Some expectations are already set for the DataSigner.SignDigest method")
	}

	mmSignDigest.mock.funcSignDigest = f
	return mmSignDigest.mock
}

// When sets expectation for the DataSigner.SignDigest which will trigger the result defined by the following
// Then helper
func (mmSignDigest *mDataSignerMockSignDigest) When(digest Digest) *DataSignerMockSignDigestExpectation {
	if mmSignDigest.mock.funcSignDigest != nil {
		mmSignDigest.mock.t.Fatalf("DataSignerMock.SignDigest mock is already set by Set")
	}

	expectation := &DataSignerMockSignDigestExpectation{
		mock:   mmSignDigest.mock,
		params: &DataSignerMockSignDigestParams{digest},
	}
	mmSignDigest.expectations = append(mmSignDigest.expectations, expectation)
	return expectation
}

// Then sets up DataSigner.SignDigest return parameters for the expectation previously defined by the When method
func (e *DataSignerMockSignDigestExpectation) Then(s1 Signature) *DataSignerMock {
	e.results = &DataSignerMockSignDigestResults{s1}
	return e.mock
}

// SignDigest implements DataSigner
func (mmSignDigest *DataSignerMock) SignDigest(digest Digest) (s1 Signature) {
	mm_atomic.AddUint64(&mmSignDigest.beforeSignDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmSignDigest.afterSignDigestCounter, 1)

	if mmSignDigest.inspectFuncSignDigest != nil {
		mmSignDigest.inspectFuncSignDigest(digest)
	}

	mm_params := &DataSignerMockSignDigestParams{digest}

	// Record call args
	mmSignDigest.SignDigestMock.mutex.Lock()
	mmSignDigest.SignDigestMock.callArgs = append(mmSignDigest.SignDigestMock.callArgs, mm_params)
	mmSignDigest.SignDigestMock.mutex.Unlock()

	for _, e := range mmSignDigest.SignDigestMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSignDigest.SignDigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSignDigest.SignDigestMock.defaultExpectation.Counter, 1)
		mm_want := mmSignDigest.SignDigestMock.defaultExpectation.params
		mm_got := DataSignerMockSignDigestParams{digest}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSignDigest.t.Errorf("DataSignerMock.SignDigest got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSignDigest.SignDigestMock.defaultExpectation.results
		if mm_results == nil {
			mmSignDigest.t.Fatal("No results are set for the DataSignerMock.SignDigest")
		}
		return (*mm_results).s1
	}
	if mmSignDigest.funcSignDigest != nil {
		return mmSignDigest.funcSignDigest(digest)
	}
	mmSignDigest.t.Fatalf("Unexpected call to DataSignerMock.SignDigest. %v", digest)
	return
}

// SignDigestAfterCounter returns a count of finished DataSignerMock.SignDigest invocations
func (mmSignDigest *DataSignerMock) SignDigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignDigest.afterSignDigestCounter)
}

// SignDigestBeforeCounter returns a count of DataSignerMock.SignDigest invocations
func (mmSignDigest *DataSignerMock) SignDigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignDigest.beforeSignDigestCounter)
}

// Calls returns a list of arguments used in each call to DataSignerMock.SignDigest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSignDigest *mDataSignerMockSignDigest) Calls() []*DataSignerMockSignDigestParams {
	mmSignDigest.mutex.RLock()

	argCopy := make([]*DataSignerMockSignDigestParams, len(mmSignDigest.callArgs))
	copy(argCopy, mmSignDigest.callArgs)

	mmSignDigest.mutex.RUnlock()

	return argCopy
}

// MinimockSignDigestDone returns true if the count of the SignDigest invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockSignDigestDone() bool {
	for _, e := range m.SignDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignDigestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignDigestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignDigest != nil && mm_atomic.LoadUint64(&m.afterSignDigestCounter) < 1 {
		return false
	}
	return true
}

// MinimockSignDigestInspect logs each unmet expectation
func (m *DataSignerMock) MinimockSignDigestInspect() {
	for _, e := range m.SignDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DataSignerMock.SignDigest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignDigestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignDigestCounter) < 1 {
		if m.SignDigestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DataSignerMock.SignDigest")
		} else {
			m.t.Errorf("Expected call to DataSignerMock.SignDigest with params: %#v", *m.SignDigestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignDigest != nil && mm_atomic.LoadUint64(&m.afterSignDigestCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.SignDigest")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DataSignerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDigestDataInspect()

		m.MinimockGetDigestMethodInspect()

		m.MinimockGetDigestSizeInspect()

		m.MinimockGetSignatureMethodInspect()

		m.MinimockGetSigningMethodInspect()

		m.MinimockSignDataInspect()

		m.MinimockSignDigestInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DataSignerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DataSignerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDigestDataDone() &&
		m.MinimockGetDigestMethodDone() &&
		m.MinimockGetDigestSizeDone() &&
		m.MinimockGetSignatureMethodDone() &&
		m.MinimockGetSigningMethodDone() &&
		m.MinimockSignDataDone() &&
		m.MinimockSignDigestDone()
}
