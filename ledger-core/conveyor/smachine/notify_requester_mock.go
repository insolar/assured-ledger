package smachine

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// NotifyRequesterMock implements NotifyRequester
type NotifyRequesterMock struct {
	t minimock.Tester

	funcDelayedSend          func() (c1 CallConditionalBuilder)
	inspectFuncDelayedSend   func()
	afterDelayedSendCounter  uint64
	beforeDelayedSendCounter uint64
	DelayedSendMock          mNotifyRequesterMockDelayedSend

	funcSend          func()
	inspectFuncSend   func()
	afterSendCounter  uint64
	beforeSendCounter uint64
	SendMock          mNotifyRequesterMockSend

	funcWithLog          func(isLogging bool) (n1 NotifyRequester)
	inspectFuncWithLog   func(isLogging bool)
	afterWithLogCounter  uint64
	beforeWithLogCounter uint64
	WithLogMock          mNotifyRequesterMockWithLog
}

// NewNotifyRequesterMock returns a mock for NotifyRequester
func NewNotifyRequesterMock(t minimock.Tester) *NotifyRequesterMock {
	m := &NotifyRequesterMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DelayedSendMock = mNotifyRequesterMockDelayedSend{mock: m}

	m.SendMock = mNotifyRequesterMockSend{mock: m}

	m.WithLogMock = mNotifyRequesterMockWithLog{mock: m}
	m.WithLogMock.callArgs = []*NotifyRequesterMockWithLogParams{}

	return m
}

type mNotifyRequesterMockDelayedSend struct {
	mock               *NotifyRequesterMock
	defaultExpectation *NotifyRequesterMockDelayedSendExpectation
	expectations       []*NotifyRequesterMockDelayedSendExpectation
}

// NotifyRequesterMockDelayedSendExpectation specifies expectation struct of the NotifyRequester.DelayedSend
type NotifyRequesterMockDelayedSendExpectation struct {
	mock *NotifyRequesterMock

	results *NotifyRequesterMockDelayedSendResults
	Counter uint64
}

// NotifyRequesterMockDelayedSendResults contains results of the NotifyRequester.DelayedSend
type NotifyRequesterMockDelayedSendResults struct {
	c1 CallConditionalBuilder
}

// Expect sets up expected params for NotifyRequester.DelayedSend
func (mmDelayedSend *mNotifyRequesterMockDelayedSend) Expect() *mNotifyRequesterMockDelayedSend {
	if mmDelayedSend.mock.funcDelayedSend != nil {
		mmDelayedSend.mock.t.Fatalf("NotifyRequesterMock.DelayedSend mock is already set by Set")
	}

	if mmDelayedSend.defaultExpectation == nil {
		mmDelayedSend.defaultExpectation = &NotifyRequesterMockDelayedSendExpectation{}
	}

	return mmDelayedSend
}

// Inspect accepts an inspector function that has same arguments as the NotifyRequester.DelayedSend
func (mmDelayedSend *mNotifyRequesterMockDelayedSend) Inspect(f func()) *mNotifyRequesterMockDelayedSend {
	if mmDelayedSend.mock.inspectFuncDelayedSend != nil {
		mmDelayedSend.mock.t.Fatalf("Inspect function is already set for NotifyRequesterMock.DelayedSend")
	}

	mmDelayedSend.mock.inspectFuncDelayedSend = f

	return mmDelayedSend
}

// Return sets up results that will be returned by NotifyRequester.DelayedSend
func (mmDelayedSend *mNotifyRequesterMockDelayedSend) Return(c1 CallConditionalBuilder) *NotifyRequesterMock {
	if mmDelayedSend.mock.funcDelayedSend != nil {
		mmDelayedSend.mock.t.Fatalf("NotifyRequesterMock.DelayedSend mock is already set by Set")
	}

	if mmDelayedSend.defaultExpectation == nil {
		mmDelayedSend.defaultExpectation = &NotifyRequesterMockDelayedSendExpectation{mock: mmDelayedSend.mock}
	}
	mmDelayedSend.defaultExpectation.results = &NotifyRequesterMockDelayedSendResults{c1}
	return mmDelayedSend.mock
}

//Set uses given function f to mock the NotifyRequester.DelayedSend method
func (mmDelayedSend *mNotifyRequesterMockDelayedSend) Set(f func() (c1 CallConditionalBuilder)) *NotifyRequesterMock {
	if mmDelayedSend.defaultExpectation != nil {
		mmDelayedSend.mock.t.Fatalf("Default expectation is already set for the NotifyRequester.DelayedSend method")
	}

	if len(mmDelayedSend.expectations) > 0 {
		mmDelayedSend.mock.t.Fatalf("Some expectations are already set for the NotifyRequester.DelayedSend method")
	}

	mmDelayedSend.mock.funcDelayedSend = f
	return mmDelayedSend.mock
}

// DelayedSend implements NotifyRequester
func (mmDelayedSend *NotifyRequesterMock) DelayedSend() (c1 CallConditionalBuilder) {
	mm_atomic.AddUint64(&mmDelayedSend.beforeDelayedSendCounter, 1)
	defer mm_atomic.AddUint64(&mmDelayedSend.afterDelayedSendCounter, 1)

	if mmDelayedSend.inspectFuncDelayedSend != nil {
		mmDelayedSend.inspectFuncDelayedSend()
	}

	if mmDelayedSend.DelayedSendMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelayedSend.DelayedSendMock.defaultExpectation.Counter, 1)

		mm_results := mmDelayedSend.DelayedSendMock.defaultExpectation.results
		if mm_results == nil {
			mmDelayedSend.t.Fatal("No results are set for the NotifyRequesterMock.DelayedSend")
		}
		return (*mm_results).c1
	}
	if mmDelayedSend.funcDelayedSend != nil {
		return mmDelayedSend.funcDelayedSend()
	}
	mmDelayedSend.t.Fatalf("Unexpected call to NotifyRequesterMock.DelayedSend.")
	return
}

// DelayedSendAfterCounter returns a count of finished NotifyRequesterMock.DelayedSend invocations
func (mmDelayedSend *NotifyRequesterMock) DelayedSendAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelayedSend.afterDelayedSendCounter)
}

// DelayedSendBeforeCounter returns a count of NotifyRequesterMock.DelayedSend invocations
func (mmDelayedSend *NotifyRequesterMock) DelayedSendBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelayedSend.beforeDelayedSendCounter)
}

// MinimockDelayedSendDone returns true if the count of the DelayedSend invocations corresponds
// the number of defined expectations
func (m *NotifyRequesterMock) MinimockDelayedSendDone() bool {
	for _, e := range m.DelayedSendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DelayedSendMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDelayedSendCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelayedSend != nil && mm_atomic.LoadUint64(&m.afterDelayedSendCounter) < 1 {
		return false
	}
	return true
}

// MinimockDelayedSendInspect logs each unmet expectation
func (m *NotifyRequesterMock) MinimockDelayedSendInspect() {
	for _, e := range m.DelayedSendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NotifyRequesterMock.DelayedSend")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DelayedSendMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDelayedSendCounter) < 1 {
		m.t.Error("Expected call to NotifyRequesterMock.DelayedSend")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelayedSend != nil && mm_atomic.LoadUint64(&m.afterDelayedSendCounter) < 1 {
		m.t.Error("Expected call to NotifyRequesterMock.DelayedSend")
	}
}

type mNotifyRequesterMockSend struct {
	mock               *NotifyRequesterMock
	defaultExpectation *NotifyRequesterMockSendExpectation
	expectations       []*NotifyRequesterMockSendExpectation
}

// NotifyRequesterMockSendExpectation specifies expectation struct of the NotifyRequester.Send
type NotifyRequesterMockSendExpectation struct {
	mock *NotifyRequesterMock

	Counter uint64
}

// Expect sets up expected params for NotifyRequester.Send
func (mmSend *mNotifyRequesterMockSend) Expect() *mNotifyRequesterMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("NotifyRequesterMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &NotifyRequesterMockSendExpectation{}
	}

	return mmSend
}

// Inspect accepts an inspector function that has same arguments as the NotifyRequester.Send
func (mmSend *mNotifyRequesterMockSend) Inspect(f func()) *mNotifyRequesterMockSend {
	if mmSend.mock.inspectFuncSend != nil {
		mmSend.mock.t.Fatalf("Inspect function is already set for NotifyRequesterMock.Send")
	}

	mmSend.mock.inspectFuncSend = f

	return mmSend
}

// Return sets up results that will be returned by NotifyRequester.Send
func (mmSend *mNotifyRequesterMockSend) Return() *NotifyRequesterMock {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("NotifyRequesterMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &NotifyRequesterMockSendExpectation{mock: mmSend.mock}
	}

	return mmSend.mock
}

//Set uses given function f to mock the NotifyRequester.Send method
func (mmSend *mNotifyRequesterMockSend) Set(f func()) *NotifyRequesterMock {
	if mmSend.defaultExpectation != nil {
		mmSend.mock.t.Fatalf("Default expectation is already set for the NotifyRequester.Send method")
	}

	if len(mmSend.expectations) > 0 {
		mmSend.mock.t.Fatalf("Some expectations are already set for the NotifyRequester.Send method")
	}

	mmSend.mock.funcSend = f
	return mmSend.mock
}

// Send implements NotifyRequester
func (mmSend *NotifyRequesterMock) Send() {
	mm_atomic.AddUint64(&mmSend.beforeSendCounter, 1)
	defer mm_atomic.AddUint64(&mmSend.afterSendCounter, 1)

	if mmSend.inspectFuncSend != nil {
		mmSend.inspectFuncSend()
	}

	if mmSend.SendMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSend.SendMock.defaultExpectation.Counter, 1)

		return

	}
	if mmSend.funcSend != nil {
		mmSend.funcSend()
		return
	}
	mmSend.t.Fatalf("Unexpected call to NotifyRequesterMock.Send.")

}

// SendAfterCounter returns a count of finished NotifyRequesterMock.Send invocations
func (mmSend *NotifyRequesterMock) SendAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSend.afterSendCounter)
}

// SendBeforeCounter returns a count of NotifyRequesterMock.Send invocations
func (mmSend *NotifyRequesterMock) SendBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSend.beforeSendCounter)
}

// MinimockSendDone returns true if the count of the Send invocations corresponds
// the number of defined expectations
func (m *NotifyRequesterMock) MinimockSendDone() bool {
	for _, e := range m.SendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSend != nil && mm_atomic.LoadUint64(&m.afterSendCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendInspect logs each unmet expectation
func (m *NotifyRequesterMock) MinimockSendInspect() {
	for _, e := range m.SendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NotifyRequesterMock.Send")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendCounter) < 1 {
		m.t.Error("Expected call to NotifyRequesterMock.Send")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSend != nil && mm_atomic.LoadUint64(&m.afterSendCounter) < 1 {
		m.t.Error("Expected call to NotifyRequesterMock.Send")
	}
}

type mNotifyRequesterMockWithLog struct {
	mock               *NotifyRequesterMock
	defaultExpectation *NotifyRequesterMockWithLogExpectation
	expectations       []*NotifyRequesterMockWithLogExpectation

	callArgs []*NotifyRequesterMockWithLogParams
	mutex    sync.RWMutex
}

// NotifyRequesterMockWithLogExpectation specifies expectation struct of the NotifyRequester.WithLog
type NotifyRequesterMockWithLogExpectation struct {
	mock    *NotifyRequesterMock
	params  *NotifyRequesterMockWithLogParams
	results *NotifyRequesterMockWithLogResults
	Counter uint64
}

// NotifyRequesterMockWithLogParams contains parameters of the NotifyRequester.WithLog
type NotifyRequesterMockWithLogParams struct {
	isLogging bool
}

// NotifyRequesterMockWithLogResults contains results of the NotifyRequester.WithLog
type NotifyRequesterMockWithLogResults struct {
	n1 NotifyRequester
}

// Expect sets up expected params for NotifyRequester.WithLog
func (mmWithLog *mNotifyRequesterMockWithLog) Expect(isLogging bool) *mNotifyRequesterMockWithLog {
	if mmWithLog.mock.funcWithLog != nil {
		mmWithLog.mock.t.Fatalf("NotifyRequesterMock.WithLog mock is already set by Set")
	}

	if mmWithLog.defaultExpectation == nil {
		mmWithLog.defaultExpectation = &NotifyRequesterMockWithLogExpectation{}
	}

	mmWithLog.defaultExpectation.params = &NotifyRequesterMockWithLogParams{isLogging}
	for _, e := range mmWithLog.expectations {
		if minimock.Equal(e.params, mmWithLog.defaultExpectation.params) {
			mmWithLog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithLog.defaultExpectation.params)
		}
	}

	return mmWithLog
}

// Inspect accepts an inspector function that has same arguments as the NotifyRequester.WithLog
func (mmWithLog *mNotifyRequesterMockWithLog) Inspect(f func(isLogging bool)) *mNotifyRequesterMockWithLog {
	if mmWithLog.mock.inspectFuncWithLog != nil {
		mmWithLog.mock.t.Fatalf("Inspect function is already set for NotifyRequesterMock.WithLog")
	}

	mmWithLog.mock.inspectFuncWithLog = f

	return mmWithLog
}

// Return sets up results that will be returned by NotifyRequester.WithLog
func (mmWithLog *mNotifyRequesterMockWithLog) Return(n1 NotifyRequester) *NotifyRequesterMock {
	if mmWithLog.mock.funcWithLog != nil {
		mmWithLog.mock.t.Fatalf("NotifyRequesterMock.WithLog mock is already set by Set")
	}

	if mmWithLog.defaultExpectation == nil {
		mmWithLog.defaultExpectation = &NotifyRequesterMockWithLogExpectation{mock: mmWithLog.mock}
	}
	mmWithLog.defaultExpectation.results = &NotifyRequesterMockWithLogResults{n1}
	return mmWithLog.mock
}

//Set uses given function f to mock the NotifyRequester.WithLog method
func (mmWithLog *mNotifyRequesterMockWithLog) Set(f func(isLogging bool) (n1 NotifyRequester)) *NotifyRequesterMock {
	if mmWithLog.defaultExpectation != nil {
		mmWithLog.mock.t.Fatalf("Default expectation is already set for the NotifyRequester.WithLog method")
	}

	if len(mmWithLog.expectations) > 0 {
		mmWithLog.mock.t.Fatalf("Some expectations are already set for the NotifyRequester.WithLog method")
	}

	mmWithLog.mock.funcWithLog = f
	return mmWithLog.mock
}

// When sets expectation for the NotifyRequester.WithLog which will trigger the result defined by the following
// Then helper
func (mmWithLog *mNotifyRequesterMockWithLog) When(isLogging bool) *NotifyRequesterMockWithLogExpectation {
	if mmWithLog.mock.funcWithLog != nil {
		mmWithLog.mock.t.Fatalf("NotifyRequesterMock.WithLog mock is already set by Set")
	}

	expectation := &NotifyRequesterMockWithLogExpectation{
		mock:   mmWithLog.mock,
		params: &NotifyRequesterMockWithLogParams{isLogging},
	}
	mmWithLog.expectations = append(mmWithLog.expectations, expectation)
	return expectation
}

// Then sets up NotifyRequester.WithLog return parameters for the expectation previously defined by the When method
func (e *NotifyRequesterMockWithLogExpectation) Then(n1 NotifyRequester) *NotifyRequesterMock {
	e.results = &NotifyRequesterMockWithLogResults{n1}
	return e.mock
}

// WithLog implements NotifyRequester
func (mmWithLog *NotifyRequesterMock) WithLog(isLogging bool) (n1 NotifyRequester) {
	mm_atomic.AddUint64(&mmWithLog.beforeWithLogCounter, 1)
	defer mm_atomic.AddUint64(&mmWithLog.afterWithLogCounter, 1)

	if mmWithLog.inspectFuncWithLog != nil {
		mmWithLog.inspectFuncWithLog(isLogging)
	}

	mm_params := &NotifyRequesterMockWithLogParams{isLogging}

	// Record call args
	mmWithLog.WithLogMock.mutex.Lock()
	mmWithLog.WithLogMock.callArgs = append(mmWithLog.WithLogMock.callArgs, mm_params)
	mmWithLog.WithLogMock.mutex.Unlock()

	for _, e := range mmWithLog.WithLogMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n1
		}
	}

	if mmWithLog.WithLogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithLog.WithLogMock.defaultExpectation.Counter, 1)
		mm_want := mmWithLog.WithLogMock.defaultExpectation.params
		mm_got := NotifyRequesterMockWithLogParams{isLogging}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithLog.t.Errorf("NotifyRequesterMock.WithLog got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithLog.WithLogMock.defaultExpectation.results
		if mm_results == nil {
			mmWithLog.t.Fatal("No results are set for the NotifyRequesterMock.WithLog")
		}
		return (*mm_results).n1
	}
	if mmWithLog.funcWithLog != nil {
		return mmWithLog.funcWithLog(isLogging)
	}
	mmWithLog.t.Fatalf("Unexpected call to NotifyRequesterMock.WithLog. %v", isLogging)
	return
}

// WithLogAfterCounter returns a count of finished NotifyRequesterMock.WithLog invocations
func (mmWithLog *NotifyRequesterMock) WithLogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithLog.afterWithLogCounter)
}

// WithLogBeforeCounter returns a count of NotifyRequesterMock.WithLog invocations
func (mmWithLog *NotifyRequesterMock) WithLogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithLog.beforeWithLogCounter)
}

// Calls returns a list of arguments used in each call to NotifyRequesterMock.WithLog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithLog *mNotifyRequesterMockWithLog) Calls() []*NotifyRequesterMockWithLogParams {
	mmWithLog.mutex.RLock()

	argCopy := make([]*NotifyRequesterMockWithLogParams, len(mmWithLog.callArgs))
	copy(argCopy, mmWithLog.callArgs)

	mmWithLog.mutex.RUnlock()

	return argCopy
}

// MinimockWithLogDone returns true if the count of the WithLog invocations corresponds
// the number of defined expectations
func (m *NotifyRequesterMock) MinimockWithLogDone() bool {
	for _, e := range m.WithLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithLogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithLogCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithLog != nil && mm_atomic.LoadUint64(&m.afterWithLogCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithLogInspect logs each unmet expectation
func (m *NotifyRequesterMock) MinimockWithLogInspect() {
	for _, e := range m.WithLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NotifyRequesterMock.WithLog with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithLogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithLogCounter) < 1 {
		if m.WithLogMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NotifyRequesterMock.WithLog")
		} else {
			m.t.Errorf("Expected call to NotifyRequesterMock.WithLog with params: %#v", *m.WithLogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithLog != nil && mm_atomic.LoadUint64(&m.afterWithLogCounter) < 1 {
		m.t.Error("Expected call to NotifyRequesterMock.WithLog")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *NotifyRequesterMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDelayedSendInspect()

		m.MinimockSendInspect()

		m.MinimockWithLogInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *NotifyRequesterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *NotifyRequesterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDelayedSendDone() &&
		m.MinimockSendDone() &&
		m.MinimockWithLogDone()
}
