package smachine

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ExecutionContextMock implements ExecutionContext
type ExecutionContextMock struct {
	t minimock.Tester

	funcAcquire          func(s1 SyncLink) (b1 BoolDecision)
	inspectFuncAcquire   func(s1 SyncLink)
	afterAcquireCounter  uint64
	beforeAcquireCounter uint64
	AcquireMock          mExecutionContextMockAcquire

	funcAcquireAndRelease          func(s1 SyncLink) (b1 BoolDecision)
	inspectFuncAcquireAndRelease   func(s1 SyncLink)
	afterAcquireAndReleaseCounter  uint64
	beforeAcquireAndReleaseCounter uint64
	AcquireAndReleaseMock          mExecutionContextMockAcquireAndRelease

	funcAcquireExt          func(s1 SyncLink, a1 AcquireFlags) (b1 BoolDecision)
	inspectFuncAcquireExt   func(s1 SyncLink, a1 AcquireFlags)
	afterAcquireExtCounter  uint64
	beforeAcquireExtCounter uint64
	AcquireExtMock          mExecutionContextMockAcquireExt

	funcAcquireForThisStep          func(s1 SyncLink) (b1 BoolDecision)
	inspectFuncAcquireForThisStep   func(s1 SyncLink)
	afterAcquireForThisStepCounter  uint64
	beforeAcquireForThisStepCounter uint64
	AcquireForThisStepMock          mExecutionContextMockAcquireForThisStep

	funcAcquireForThisStepAndRelease          func(s1 SyncLink) (b1 BoolDecision)
	inspectFuncAcquireForThisStepAndRelease   func(s1 SyncLink)
	afterAcquireForThisStepAndReleaseCounter  uint64
	beforeAcquireForThisStepAndReleaseCounter uint64
	AcquireForThisStepAndReleaseMock          mExecutionContextMockAcquireForThisStepAndRelease

	funcApplyAdjustment          func(s1 SyncAdjustment) (b1 bool)
	inspectFuncApplyAdjustment   func(s1 SyncAdjustment)
	afterApplyAdjustmentCounter  uint64
	beforeApplyAdjustmentCounter uint64
	ApplyAdjustmentMock          mExecutionContextMockApplyAdjustment

	funcCallBargeIn          func(b BargeIn) (b1 bool)
	inspectFuncCallBargeIn   func(b BargeIn)
	afterCallBargeInCounter  uint64
	beforeCallBargeInCounter uint64
	CallBargeInMock          mExecutionContextMockCallBargeIn

	funcCallBargeInWithParam          func(b BargeInWithParam, param interface{}) (b1 bool)
	inspectFuncCallBargeInWithParam   func(b BargeInWithParam, param interface{})
	afterCallBargeInWithParamCounter  uint64
	beforeCallBargeInWithParamCounter uint64
	CallBargeInWithParamMock          mExecutionContextMockCallBargeInWithParam

	funcCallSubroutine          func(s1 SubroutineStateMachine, m1 MigrateFunc, s2 SubroutineExitFunc) (s3 StateUpdate)
	inspectFuncCallSubroutine   func(s1 SubroutineStateMachine, m1 MigrateFunc, s2 SubroutineExitFunc)
	afterCallSubroutineCounter  uint64
	beforeCallSubroutineCounter uint64
	CallSubroutineMock          mExecutionContextMockCallSubroutine

	funcCheck          func(s1 SyncLink) (b1 BoolDecision)
	inspectFuncCheck   func(s1 SyncLink)
	afterCheckCounter  uint64
	beforeCheckCounter uint64
	CheckMock          mExecutionContextMockCheck

	funcError          func(e1 error) (s1 StateUpdate)
	inspectFuncError   func(e1 error)
	afterErrorCounter  uint64
	beforeErrorCounter uint64
	ErrorMock          mExecutionContextMockError

	funcGetContext          func() (c1 context.Context)
	inspectFuncGetContext   func()
	afterGetContextCounter  uint64
	beforeGetContextCounter uint64
	GetContextMock          mExecutionContextMockGetContext

	funcGetPendingCallCount          func() (i1 int)
	inspectFuncGetPendingCallCount   func()
	afterGetPendingCallCountCounter  uint64
	beforeGetPendingCallCountCounter uint64
	GetPendingCallCountMock          mExecutionContextMockGetPendingCallCount

	funcGetPublished          func(key interface{}) (p1 interface{})
	inspectFuncGetPublished   func(key interface{})
	afterGetPublishedCounter  uint64
	beforeGetPublishedCounter uint64
	GetPublishedMock          mExecutionContextMockGetPublished

	funcGetPublishedGlobalAlias          func(key interface{}) (s1 SlotLink)
	inspectFuncGetPublishedGlobalAlias   func(key interface{})
	afterGetPublishedGlobalAliasCounter  uint64
	beforeGetPublishedGlobalAliasCounter uint64
	GetPublishedGlobalAliasMock          mExecutionContextMockGetPublishedGlobalAlias

	funcGetPublishedGlobalAliasAndBargeIn          func(key interface{}) (s1 SlotLink, b1 BargeInHolder)
	inspectFuncGetPublishedGlobalAliasAndBargeIn   func(key interface{})
	afterGetPublishedGlobalAliasAndBargeInCounter  uint64
	beforeGetPublishedGlobalAliasAndBargeInCounter uint64
	GetPublishedGlobalAliasAndBargeInMock          mExecutionContextMockGetPublishedGlobalAliasAndBargeIn

	funcGetPublishedLink          func(key interface{}) (s1 SharedDataLink)
	inspectFuncGetPublishedLink   func(key interface{})
	afterGetPublishedLinkCounter  uint64
	beforeGetPublishedLinkCounter uint64
	GetPublishedLinkMock          mExecutionContextMockGetPublishedLink

	funcGetTerminationResult          func() (p1 interface{})
	inspectFuncGetTerminationResult   func()
	afterGetTerminationResultCounter  uint64
	beforeGetTerminationResultCounter uint64
	GetTerminationResultMock          mExecutionContextMockGetTerminationResult

	funcInitChild          func(c1 CreateFunc) (s1 SlotLink)
	inspectFuncInitChild   func(c1 CreateFunc)
	afterInitChildCounter  uint64
	beforeInitChildCounter uint64
	InitChildMock          mExecutionContextMockInitChild

	funcInitChildExt          func(c1 CreateFunc, c2 CreateDefaultValues, p1 PostInitFunc) (s1 SlotLink)
	inspectFuncInitChildExt   func(c1 CreateFunc, c2 CreateDefaultValues, p1 PostInitFunc)
	afterInitChildExtCounter  uint64
	beforeInitChildExtCounter uint64
	InitChildExtMock          mExecutionContextMockInitChildExt

	funcInitChildWithPostInit          func(c1 CreateFunc, p1 PostInitFunc) (s1 SlotLink)
	inspectFuncInitChildWithPostInit   func(c1 CreateFunc, p1 PostInitFunc)
	afterInitChildWithPostInitCounter  uint64
	beforeInitChildWithPostInitCounter uint64
	InitChildWithPostInitMock          mExecutionContextMockInitChildWithPostInit

	funcInitiateLongRun          func(l1 LongRunFlags)
	inspectFuncInitiateLongRun   func(l1 LongRunFlags)
	afterInitiateLongRunCounter  uint64
	beforeInitiateLongRunCounter uint64
	InitiateLongRunMock          mExecutionContextMockInitiateLongRun

	funcJump          func(s1 StateFunc) (s2 StateUpdate)
	inspectFuncJump   func(s1 StateFunc)
	afterJumpCounter  uint64
	beforeJumpCounter uint64
	JumpMock          mExecutionContextMockJump

	funcJumpExt          func(s1 SlotStep) (s2 StateUpdate)
	inspectFuncJumpExt   func(s1 SlotStep)
	afterJumpExtCounter  uint64
	beforeJumpExtCounter uint64
	JumpExtMock          mExecutionContextMockJumpExt

	funcLog          func() (l1 Logger)
	inspectFuncLog   func()
	afterLogCounter  uint64
	beforeLogCounter uint64
	LogMock          mExecutionContextMockLog

	funcLogAsync          func() (l1 Logger)
	inspectFuncLogAsync   func()
	afterLogAsyncCounter  uint64
	beforeLogAsyncCounter uint64
	LogAsyncMock          mExecutionContextMockLogAsync

	funcNewBargeIn          func() (b1 BargeInBuilder)
	inspectFuncNewBargeIn   func()
	afterNewBargeInCounter  uint64
	beforeNewBargeInCounter uint64
	NewBargeInMock          mExecutionContextMockNewBargeIn

	funcNewBargeInThisStepOnly          func() (b1 BargeInBuilder)
	inspectFuncNewBargeInThisStepOnly   func()
	afterNewBargeInThisStepOnlyCounter  uint64
	beforeNewBargeInThisStepOnlyCounter uint64
	NewBargeInThisStepOnlyMock          mExecutionContextMockNewBargeInThisStepOnly

	funcNewBargeInWithParam          func(b1 BargeInApplyFunc) (b2 BargeInWithParam)
	inspectFuncNewBargeInWithParam   func(b1 BargeInApplyFunc)
	afterNewBargeInWithParamCounter  uint64
	beforeNewBargeInWithParamCounter uint64
	NewBargeInWithParamMock          mExecutionContextMockNewBargeInWithParam

	funcNewChild          func(c1 CreateFunc) (s1 SlotLink)
	inspectFuncNewChild   func(c1 CreateFunc)
	afterNewChildCounter  uint64
	beforeNewChildCounter uint64
	NewChildMock          mExecutionContextMockNewChild

	funcNewChildExt          func(c1 CreateFunc, c2 CreateDefaultValues) (s1 SlotLink)
	inspectFuncNewChildExt   func(c1 CreateFunc, c2 CreateDefaultValues)
	afterNewChildExtCounter  uint64
	beforeNewChildExtCounter uint64
	NewChildExtMock          mExecutionContextMockNewChildExt

	funcOverrideDynamicBoost          func(b1 bool)
	inspectFuncOverrideDynamicBoost   func(b1 bool)
	afterOverrideDynamicBoostCounter  uint64
	beforeOverrideDynamicBoostCounter uint64
	OverrideDynamicBoostMock          mExecutionContextMockOverrideDynamicBoost

	funcParentLink          func() (s1 SlotLink)
	inspectFuncParentLink   func()
	afterParentLinkCounter  uint64
	beforeParentLinkCounter uint64
	ParentLinkMock          mExecutionContextMockParentLink

	funcPoll          func() (c1 ConditionalBuilder)
	inspectFuncPoll   func()
	afterPollCounter  uint64
	beforePollCounter uint64
	PollMock          mExecutionContextMockPoll

	funcPublish          func(key interface{}, data interface{}) (b1 bool)
	inspectFuncPublish   func(key interface{}, data interface{})
	afterPublishCounter  uint64
	beforePublishCounter uint64
	PublishMock          mExecutionContextMockPublish

	funcPublishGlobalAlias          func(key interface{}) (b1 bool)
	inspectFuncPublishGlobalAlias   func(key interface{})
	afterPublishGlobalAliasCounter  uint64
	beforePublishGlobalAliasCounter uint64
	PublishGlobalAliasMock          mExecutionContextMockPublishGlobalAlias

	funcPublishGlobalAliasAndBargeIn          func(key interface{}, handler BargeInHolder) (b1 bool)
	inspectFuncPublishGlobalAliasAndBargeIn   func(key interface{}, handler BargeInHolder)
	afterPublishGlobalAliasAndBargeInCounter  uint64
	beforePublishGlobalAliasAndBargeInCounter uint64
	PublishGlobalAliasAndBargeInMock          mExecutionContextMockPublishGlobalAliasAndBargeIn

	funcPublishReplacement          func(key interface{}, data interface{}) (b1 bool)
	inspectFuncPublishReplacement   func(key interface{}, data interface{})
	afterPublishReplacementCounter  uint64
	beforePublishReplacementCounter uint64
	PublishReplacementMock          mExecutionContextMockPublishReplacement

	funcRelease          func(s1 SyncLink) (b1 bool)
	inspectFuncRelease   func(s1 SyncLink)
	afterReleaseCounter  uint64
	beforeReleaseCounter uint64
	ReleaseMock          mExecutionContextMockRelease

	funcReleaseAll          func() (b1 bool)
	inspectFuncReleaseAll   func()
	afterReleaseAllCounter  uint64
	beforeReleaseAllCounter uint64
	ReleaseAllMock          mExecutionContextMockReleaseAll

	funcRepeat          func(limitPerCycle int) (s1 StateUpdate)
	inspectFuncRepeat   func(limitPerCycle int)
	afterRepeatCounter  uint64
	beforeRepeatCounter uint64
	RepeatMock          mExecutionContextMockRepeat

	funcReplace          func(c1 CreateFunc) (s1 StateUpdate)
	inspectFuncReplace   func(c1 CreateFunc)
	afterReplaceCounter  uint64
	beforeReplaceCounter uint64
	ReplaceMock          mExecutionContextMockReplace

	funcReplaceExt          func(c1 CreateFunc, c2 CreateDefaultValues) (s1 StateUpdate)
	inspectFuncReplaceExt   func(c1 CreateFunc, c2 CreateDefaultValues)
	afterReplaceExtCounter  uint64
	beforeReplaceExtCounter uint64
	ReplaceExtMock          mExecutionContextMockReplaceExt

	funcReplaceWith          func(s1 StateMachine) (s2 StateUpdate)
	inspectFuncReplaceWith   func(s1 StateMachine)
	afterReplaceWithCounter  uint64
	beforeReplaceWithCounter uint64
	ReplaceWithMock          mExecutionContextMockReplaceWith

	funcRestoreStep          func(s1 SlotStep) (s2 StateUpdate)
	inspectFuncRestoreStep   func(s1 SlotStep)
	afterRestoreStepCounter  uint64
	beforeRestoreStepCounter uint64
	RestoreStepMock          mExecutionContextMockRestoreStep

	funcSetDefaultErrorHandler          func(e1 ErrorHandlerFunc)
	inspectFuncSetDefaultErrorHandler   func(e1 ErrorHandlerFunc)
	afterSetDefaultErrorHandlerCounter  uint64
	beforeSetDefaultErrorHandlerCounter uint64
	SetDefaultErrorHandlerMock          mExecutionContextMockSetDefaultErrorHandler

	funcSetDefaultFlags          func(s1 StepFlags)
	inspectFuncSetDefaultFlags   func(s1 StepFlags)
	afterSetDefaultFlagsCounter  uint64
	beforeSetDefaultFlagsCounter uint64
	SetDefaultFlagsMock          mExecutionContextMockSetDefaultFlags

	funcSetDefaultMigration          func(m1 MigrateFunc)
	inspectFuncSetDefaultMigration   func(m1 MigrateFunc)
	afterSetDefaultMigrationCounter  uint64
	beforeSetDefaultMigrationCounter uint64
	SetDefaultMigrationMock          mExecutionContextMockSetDefaultMigration

	funcSetFinalizer          func(f1 FinalizeFunc)
	inspectFuncSetFinalizer   func(f1 FinalizeFunc)
	afterSetFinalizerCounter  uint64
	beforeSetFinalizerCounter uint64
	SetFinalizerMock          mExecutionContextMockSetFinalizer

	funcSetLogTracing          func(b1 bool)
	inspectFuncSetLogTracing   func(b1 bool)
	afterSetLogTracingCounter  uint64
	beforeSetLogTracingCounter uint64
	SetLogTracingMock          mExecutionContextMockSetLogTracing

	funcSetTerminationResult          func(p1 interface{})
	inspectFuncSetTerminationResult   func(p1 interface{})
	afterSetTerminationResultCounter  uint64
	beforeSetTerminationResultCounter uint64
	SetTerminationResultMock          mExecutionContextMockSetTerminationResult

	funcShare          func(data interface{}, flags ShareDataFlags) (s1 SharedDataLink)
	inspectFuncShare   func(data interface{}, flags ShareDataFlags)
	afterShareCounter  uint64
	beforeShareCounter uint64
	ShareMock          mExecutionContextMockShare

	funcSleep          func() (c1 ConditionalBuilder)
	inspectFuncSleep   func()
	afterSleepCounter  uint64
	beforeSleepCounter uint64
	SleepMock          mExecutionContextMockSleep

	funcSlotLink          func() (s1 SlotLink)
	inspectFuncSlotLink   func()
	afterSlotLinkCounter  uint64
	beforeSlotLinkCounter uint64
	SlotLinkMock          mExecutionContextMockSlotLink

	funcStepLink          func() (s1 StepLink)
	inspectFuncStepLink   func()
	afterStepLinkCounter  uint64
	beforeStepLinkCounter uint64
	StepLinkMock          mExecutionContextMockStepLink

	funcStop          func() (s1 StateUpdate)
	inspectFuncStop   func()
	afterStopCounter  uint64
	beforeStopCounter uint64
	StopMock          mExecutionContextMockStop

	funcUnpublish          func(key interface{}) (b1 bool)
	inspectFuncUnpublish   func(key interface{})
	afterUnpublishCounter  uint64
	beforeUnpublishCounter uint64
	UnpublishMock          mExecutionContextMockUnpublish

	funcUnpublishAll          func()
	inspectFuncUnpublishAll   func()
	afterUnpublishAllCounter  uint64
	beforeUnpublishAllCounter uint64
	UnpublishAllMock          mExecutionContextMockUnpublishAll

	funcUnpublishGlobalAlias          func(key interface{}) (b1 bool)
	inspectFuncUnpublishGlobalAlias   func(key interface{})
	afterUnpublishGlobalAliasCounter  uint64
	beforeUnpublishGlobalAliasCounter uint64
	UnpublishGlobalAliasMock          mExecutionContextMockUnpublishGlobalAlias

	funcUnshare          func(s1 SharedDataLink) (b1 bool)
	inspectFuncUnshare   func(s1 SharedDataLink)
	afterUnshareCounter  uint64
	beforeUnshareCounter uint64
	UnshareMock          mExecutionContextMockUnshare

	funcUpdateDefaultStepLogger          func(s1 StepLoggerUpdateFunc)
	inspectFuncUpdateDefaultStepLogger   func(s1 StepLoggerUpdateFunc)
	afterUpdateDefaultStepLoggerCounter  uint64
	beforeUpdateDefaultStepLoggerCounter uint64
	UpdateDefaultStepLoggerMock          mExecutionContextMockUpdateDefaultStepLogger

	funcUseShared          func(s1 SharedDataAccessor) (s2 SharedAccessReport)
	inspectFuncUseShared   func(s1 SharedDataAccessor)
	afterUseSharedCounter  uint64
	beforeUseSharedCounter uint64
	UseSharedMock          mExecutionContextMockUseShared

	funcWaitAny          func() (c1 ConditionalBuilder)
	inspectFuncWaitAny   func()
	afterWaitAnyCounter  uint64
	beforeWaitAnyCounter uint64
	WaitAnyMock          mExecutionContextMockWaitAny

	funcWaitAnyUntil          func(t1 time.Time) (s1 StateConditionalBuilder)
	inspectFuncWaitAnyUntil   func(t1 time.Time)
	afterWaitAnyUntilCounter  uint64
	beforeWaitAnyUntilCounter uint64
	WaitAnyUntilMock          mExecutionContextMockWaitAnyUntil

	funcWaitShared          func(s1 SharedDataLink) (s2 StateConditionalBuilder)
	inspectFuncWaitShared   func(s1 SharedDataLink)
	afterWaitSharedCounter  uint64
	beforeWaitSharedCounter uint64
	WaitSharedMock          mExecutionContextMockWaitShared

	funcYield          func() (c1 ConditionalBuilder)
	inspectFuncYield   func()
	afterYieldCounter  uint64
	beforeYieldCounter uint64
	YieldMock          mExecutionContextMockYield
}

// NewExecutionContextMock returns a mock for ExecutionContext
func NewExecutionContextMock(t minimock.Tester) *ExecutionContextMock {
	m := &ExecutionContextMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AcquireMock = mExecutionContextMockAcquire{mock: m}
	m.AcquireMock.callArgs = []*ExecutionContextMockAcquireParams{}

	m.AcquireAndReleaseMock = mExecutionContextMockAcquireAndRelease{mock: m}
	m.AcquireAndReleaseMock.callArgs = []*ExecutionContextMockAcquireAndReleaseParams{}

	m.AcquireExtMock = mExecutionContextMockAcquireExt{mock: m}
	m.AcquireExtMock.callArgs = []*ExecutionContextMockAcquireExtParams{}

	m.AcquireForThisStepMock = mExecutionContextMockAcquireForThisStep{mock: m}
	m.AcquireForThisStepMock.callArgs = []*ExecutionContextMockAcquireForThisStepParams{}

	m.AcquireForThisStepAndReleaseMock = mExecutionContextMockAcquireForThisStepAndRelease{mock: m}
	m.AcquireForThisStepAndReleaseMock.callArgs = []*ExecutionContextMockAcquireForThisStepAndReleaseParams{}

	m.ApplyAdjustmentMock = mExecutionContextMockApplyAdjustment{mock: m}
	m.ApplyAdjustmentMock.callArgs = []*ExecutionContextMockApplyAdjustmentParams{}

	m.CallBargeInMock = mExecutionContextMockCallBargeIn{mock: m}
	m.CallBargeInMock.callArgs = []*ExecutionContextMockCallBargeInParams{}

	m.CallBargeInWithParamMock = mExecutionContextMockCallBargeInWithParam{mock: m}
	m.CallBargeInWithParamMock.callArgs = []*ExecutionContextMockCallBargeInWithParamParams{}

	m.CallSubroutineMock = mExecutionContextMockCallSubroutine{mock: m}
	m.CallSubroutineMock.callArgs = []*ExecutionContextMockCallSubroutineParams{}

	m.CheckMock = mExecutionContextMockCheck{mock: m}
	m.CheckMock.callArgs = []*ExecutionContextMockCheckParams{}

	m.ErrorMock = mExecutionContextMockError{mock: m}
	m.ErrorMock.callArgs = []*ExecutionContextMockErrorParams{}

	m.GetContextMock = mExecutionContextMockGetContext{mock: m}

	m.GetPendingCallCountMock = mExecutionContextMockGetPendingCallCount{mock: m}

	m.GetPublishedMock = mExecutionContextMockGetPublished{mock: m}
	m.GetPublishedMock.callArgs = []*ExecutionContextMockGetPublishedParams{}

	m.GetPublishedGlobalAliasMock = mExecutionContextMockGetPublishedGlobalAlias{mock: m}
	m.GetPublishedGlobalAliasMock.callArgs = []*ExecutionContextMockGetPublishedGlobalAliasParams{}

	m.GetPublishedGlobalAliasAndBargeInMock = mExecutionContextMockGetPublishedGlobalAliasAndBargeIn{mock: m}
	m.GetPublishedGlobalAliasAndBargeInMock.callArgs = []*ExecutionContextMockGetPublishedGlobalAliasAndBargeInParams{}

	m.GetPublishedLinkMock = mExecutionContextMockGetPublishedLink{mock: m}
	m.GetPublishedLinkMock.callArgs = []*ExecutionContextMockGetPublishedLinkParams{}

	m.GetTerminationResultMock = mExecutionContextMockGetTerminationResult{mock: m}

	m.InitChildMock = mExecutionContextMockInitChild{mock: m}
	m.InitChildMock.callArgs = []*ExecutionContextMockInitChildParams{}

	m.InitChildExtMock = mExecutionContextMockInitChildExt{mock: m}
	m.InitChildExtMock.callArgs = []*ExecutionContextMockInitChildExtParams{}

	m.InitChildWithPostInitMock = mExecutionContextMockInitChildWithPostInit{mock: m}
	m.InitChildWithPostInitMock.callArgs = []*ExecutionContextMockInitChildWithPostInitParams{}

	m.InitiateLongRunMock = mExecutionContextMockInitiateLongRun{mock: m}
	m.InitiateLongRunMock.callArgs = []*ExecutionContextMockInitiateLongRunParams{}

	m.JumpMock = mExecutionContextMockJump{mock: m}
	m.JumpMock.callArgs = []*ExecutionContextMockJumpParams{}

	m.JumpExtMock = mExecutionContextMockJumpExt{mock: m}
	m.JumpExtMock.callArgs = []*ExecutionContextMockJumpExtParams{}

	m.LogMock = mExecutionContextMockLog{mock: m}

	m.LogAsyncMock = mExecutionContextMockLogAsync{mock: m}

	m.NewBargeInMock = mExecutionContextMockNewBargeIn{mock: m}

	m.NewBargeInThisStepOnlyMock = mExecutionContextMockNewBargeInThisStepOnly{mock: m}

	m.NewBargeInWithParamMock = mExecutionContextMockNewBargeInWithParam{mock: m}
	m.NewBargeInWithParamMock.callArgs = []*ExecutionContextMockNewBargeInWithParamParams{}

	m.NewChildMock = mExecutionContextMockNewChild{mock: m}
	m.NewChildMock.callArgs = []*ExecutionContextMockNewChildParams{}

	m.NewChildExtMock = mExecutionContextMockNewChildExt{mock: m}
	m.NewChildExtMock.callArgs = []*ExecutionContextMockNewChildExtParams{}

	m.OverrideDynamicBoostMock = mExecutionContextMockOverrideDynamicBoost{mock: m}
	m.OverrideDynamicBoostMock.callArgs = []*ExecutionContextMockOverrideDynamicBoostParams{}

	m.ParentLinkMock = mExecutionContextMockParentLink{mock: m}

	m.PollMock = mExecutionContextMockPoll{mock: m}

	m.PublishMock = mExecutionContextMockPublish{mock: m}
	m.PublishMock.callArgs = []*ExecutionContextMockPublishParams{}

	m.PublishGlobalAliasMock = mExecutionContextMockPublishGlobalAlias{mock: m}
	m.PublishGlobalAliasMock.callArgs = []*ExecutionContextMockPublishGlobalAliasParams{}

	m.PublishGlobalAliasAndBargeInMock = mExecutionContextMockPublishGlobalAliasAndBargeIn{mock: m}
	m.PublishGlobalAliasAndBargeInMock.callArgs = []*ExecutionContextMockPublishGlobalAliasAndBargeInParams{}

	m.PublishReplacementMock = mExecutionContextMockPublishReplacement{mock: m}
	m.PublishReplacementMock.callArgs = []*ExecutionContextMockPublishReplacementParams{}

	m.ReleaseMock = mExecutionContextMockRelease{mock: m}
	m.ReleaseMock.callArgs = []*ExecutionContextMockReleaseParams{}

	m.ReleaseAllMock = mExecutionContextMockReleaseAll{mock: m}

	m.RepeatMock = mExecutionContextMockRepeat{mock: m}
	m.RepeatMock.callArgs = []*ExecutionContextMockRepeatParams{}

	m.ReplaceMock = mExecutionContextMockReplace{mock: m}
	m.ReplaceMock.callArgs = []*ExecutionContextMockReplaceParams{}

	m.ReplaceExtMock = mExecutionContextMockReplaceExt{mock: m}
	m.ReplaceExtMock.callArgs = []*ExecutionContextMockReplaceExtParams{}

	m.ReplaceWithMock = mExecutionContextMockReplaceWith{mock: m}
	m.ReplaceWithMock.callArgs = []*ExecutionContextMockReplaceWithParams{}

	m.RestoreStepMock = mExecutionContextMockRestoreStep{mock: m}
	m.RestoreStepMock.callArgs = []*ExecutionContextMockRestoreStepParams{}

	m.SetDefaultErrorHandlerMock = mExecutionContextMockSetDefaultErrorHandler{mock: m}
	m.SetDefaultErrorHandlerMock.callArgs = []*ExecutionContextMockSetDefaultErrorHandlerParams{}

	m.SetDefaultFlagsMock = mExecutionContextMockSetDefaultFlags{mock: m}
	m.SetDefaultFlagsMock.callArgs = []*ExecutionContextMockSetDefaultFlagsParams{}

	m.SetDefaultMigrationMock = mExecutionContextMockSetDefaultMigration{mock: m}
	m.SetDefaultMigrationMock.callArgs = []*ExecutionContextMockSetDefaultMigrationParams{}

	m.SetFinalizerMock = mExecutionContextMockSetFinalizer{mock: m}
	m.SetFinalizerMock.callArgs = []*ExecutionContextMockSetFinalizerParams{}

	m.SetLogTracingMock = mExecutionContextMockSetLogTracing{mock: m}
	m.SetLogTracingMock.callArgs = []*ExecutionContextMockSetLogTracingParams{}

	m.SetTerminationResultMock = mExecutionContextMockSetTerminationResult{mock: m}
	m.SetTerminationResultMock.callArgs = []*ExecutionContextMockSetTerminationResultParams{}

	m.ShareMock = mExecutionContextMockShare{mock: m}
	m.ShareMock.callArgs = []*ExecutionContextMockShareParams{}

	m.SleepMock = mExecutionContextMockSleep{mock: m}

	m.SlotLinkMock = mExecutionContextMockSlotLink{mock: m}

	m.StepLinkMock = mExecutionContextMockStepLink{mock: m}

	m.StopMock = mExecutionContextMockStop{mock: m}

	m.UnpublishMock = mExecutionContextMockUnpublish{mock: m}
	m.UnpublishMock.callArgs = []*ExecutionContextMockUnpublishParams{}

	m.UnpublishAllMock = mExecutionContextMockUnpublishAll{mock: m}

	m.UnpublishGlobalAliasMock = mExecutionContextMockUnpublishGlobalAlias{mock: m}
	m.UnpublishGlobalAliasMock.callArgs = []*ExecutionContextMockUnpublishGlobalAliasParams{}

	m.UnshareMock = mExecutionContextMockUnshare{mock: m}
	m.UnshareMock.callArgs = []*ExecutionContextMockUnshareParams{}

	m.UpdateDefaultStepLoggerMock = mExecutionContextMockUpdateDefaultStepLogger{mock: m}
	m.UpdateDefaultStepLoggerMock.callArgs = []*ExecutionContextMockUpdateDefaultStepLoggerParams{}

	m.UseSharedMock = mExecutionContextMockUseShared{mock: m}
	m.UseSharedMock.callArgs = []*ExecutionContextMockUseSharedParams{}

	m.WaitAnyMock = mExecutionContextMockWaitAny{mock: m}

	m.WaitAnyUntilMock = mExecutionContextMockWaitAnyUntil{mock: m}
	m.WaitAnyUntilMock.callArgs = []*ExecutionContextMockWaitAnyUntilParams{}

	m.WaitSharedMock = mExecutionContextMockWaitShared{mock: m}
	m.WaitSharedMock.callArgs = []*ExecutionContextMockWaitSharedParams{}

	m.YieldMock = mExecutionContextMockYield{mock: m}

	return m
}

type mExecutionContextMockAcquire struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockAcquireExpectation
	expectations       []*ExecutionContextMockAcquireExpectation

	callArgs []*ExecutionContextMockAcquireParams
	mutex    sync.RWMutex
}

// ExecutionContextMockAcquireExpectation specifies expectation struct of the ExecutionContext.Acquire
type ExecutionContextMockAcquireExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockAcquireParams
	results *ExecutionContextMockAcquireResults
	Counter uint64
}

// ExecutionContextMockAcquireParams contains parameters of the ExecutionContext.Acquire
type ExecutionContextMockAcquireParams struct {
	s1 SyncLink
}

// ExecutionContextMockAcquireResults contains results of the ExecutionContext.Acquire
type ExecutionContextMockAcquireResults struct {
	b1 BoolDecision
}

// Expect sets up expected params for ExecutionContext.Acquire
func (mmAcquire *mExecutionContextMockAcquire) Expect(s1 SyncLink) *mExecutionContextMockAcquire {
	if mmAcquire.mock.funcAcquire != nil {
		mmAcquire.mock.t.Fatalf("ExecutionContextMock.Acquire mock is already set by Set")
	}

	if mmAcquire.defaultExpectation == nil {
		mmAcquire.defaultExpectation = &ExecutionContextMockAcquireExpectation{}
	}

	mmAcquire.defaultExpectation.params = &ExecutionContextMockAcquireParams{s1}
	for _, e := range mmAcquire.expectations {
		if minimock.Equal(e.params, mmAcquire.defaultExpectation.params) {
			mmAcquire.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcquire.defaultExpectation.params)
		}
	}

	return mmAcquire
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Acquire
func (mmAcquire *mExecutionContextMockAcquire) Inspect(f func(s1 SyncLink)) *mExecutionContextMockAcquire {
	if mmAcquire.mock.inspectFuncAcquire != nil {
		mmAcquire.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Acquire")
	}

	mmAcquire.mock.inspectFuncAcquire = f

	return mmAcquire
}

// Return sets up results that will be returned by ExecutionContext.Acquire
func (mmAcquire *mExecutionContextMockAcquire) Return(b1 BoolDecision) *ExecutionContextMock {
	if mmAcquire.mock.funcAcquire != nil {
		mmAcquire.mock.t.Fatalf("ExecutionContextMock.Acquire mock is already set by Set")
	}

	if mmAcquire.defaultExpectation == nil {
		mmAcquire.defaultExpectation = &ExecutionContextMockAcquireExpectation{mock: mmAcquire.mock}
	}
	mmAcquire.defaultExpectation.results = &ExecutionContextMockAcquireResults{b1}
	return mmAcquire.mock
}

//Set uses given function f to mock the ExecutionContext.Acquire method
func (mmAcquire *mExecutionContextMockAcquire) Set(f func(s1 SyncLink) (b1 BoolDecision)) *ExecutionContextMock {
	if mmAcquire.defaultExpectation != nil {
		mmAcquire.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Acquire method")
	}

	if len(mmAcquire.expectations) > 0 {
		mmAcquire.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Acquire method")
	}

	mmAcquire.mock.funcAcquire = f
	return mmAcquire.mock
}

// When sets expectation for the ExecutionContext.Acquire which will trigger the result defined by the following
// Then helper
func (mmAcquire *mExecutionContextMockAcquire) When(s1 SyncLink) *ExecutionContextMockAcquireExpectation {
	if mmAcquire.mock.funcAcquire != nil {
		mmAcquire.mock.t.Fatalf("ExecutionContextMock.Acquire mock is already set by Set")
	}

	expectation := &ExecutionContextMockAcquireExpectation{
		mock:   mmAcquire.mock,
		params: &ExecutionContextMockAcquireParams{s1},
	}
	mmAcquire.expectations = append(mmAcquire.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.Acquire return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockAcquireExpectation) Then(b1 BoolDecision) *ExecutionContextMock {
	e.results = &ExecutionContextMockAcquireResults{b1}
	return e.mock
}

// Acquire implements ExecutionContext
func (mmAcquire *ExecutionContextMock) Acquire(s1 SyncLink) (b1 BoolDecision) {
	mm_atomic.AddUint64(&mmAcquire.beforeAcquireCounter, 1)
	defer mm_atomic.AddUint64(&mmAcquire.afterAcquireCounter, 1)

	if mmAcquire.inspectFuncAcquire != nil {
		mmAcquire.inspectFuncAcquire(s1)
	}

	mm_params := &ExecutionContextMockAcquireParams{s1}

	// Record call args
	mmAcquire.AcquireMock.mutex.Lock()
	mmAcquire.AcquireMock.callArgs = append(mmAcquire.AcquireMock.callArgs, mm_params)
	mmAcquire.AcquireMock.mutex.Unlock()

	for _, e := range mmAcquire.AcquireMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmAcquire.AcquireMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcquire.AcquireMock.defaultExpectation.Counter, 1)
		mm_want := mmAcquire.AcquireMock.defaultExpectation.params
		mm_got := ExecutionContextMockAcquireParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcquire.t.Errorf("ExecutionContextMock.Acquire got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcquire.AcquireMock.defaultExpectation.results
		if mm_results == nil {
			mmAcquire.t.Fatal("No results are set for the ExecutionContextMock.Acquire")
		}
		return (*mm_results).b1
	}
	if mmAcquire.funcAcquire != nil {
		return mmAcquire.funcAcquire(s1)
	}
	mmAcquire.t.Fatalf("Unexpected call to ExecutionContextMock.Acquire. %v", s1)
	return
}

// AcquireAfterCounter returns a count of finished ExecutionContextMock.Acquire invocations
func (mmAcquire *ExecutionContextMock) AcquireAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquire.afterAcquireCounter)
}

// AcquireBeforeCounter returns a count of ExecutionContextMock.Acquire invocations
func (mmAcquire *ExecutionContextMock) AcquireBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquire.beforeAcquireCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.Acquire.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcquire *mExecutionContextMockAcquire) Calls() []*ExecutionContextMockAcquireParams {
	mmAcquire.mutex.RLock()

	argCopy := make([]*ExecutionContextMockAcquireParams, len(mmAcquire.callArgs))
	copy(argCopy, mmAcquire.callArgs)

	mmAcquire.mutex.RUnlock()

	return argCopy
}

// MinimockAcquireDone returns true if the count of the Acquire invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockAcquireDone() bool {
	for _, e := range m.AcquireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquire != nil && mm_atomic.LoadUint64(&m.afterAcquireCounter) < 1 {
		return false
	}
	return true
}

// MinimockAcquireInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockAcquireInspect() {
	for _, e := range m.AcquireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.Acquire with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireCounter) < 1 {
		if m.AcquireMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.Acquire")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.Acquire with params: %#v", *m.AcquireMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquire != nil && mm_atomic.LoadUint64(&m.afterAcquireCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Acquire")
	}
}

type mExecutionContextMockAcquireAndRelease struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockAcquireAndReleaseExpectation
	expectations       []*ExecutionContextMockAcquireAndReleaseExpectation

	callArgs []*ExecutionContextMockAcquireAndReleaseParams
	mutex    sync.RWMutex
}

// ExecutionContextMockAcquireAndReleaseExpectation specifies expectation struct of the ExecutionContext.AcquireAndRelease
type ExecutionContextMockAcquireAndReleaseExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockAcquireAndReleaseParams
	results *ExecutionContextMockAcquireAndReleaseResults
	Counter uint64
}

// ExecutionContextMockAcquireAndReleaseParams contains parameters of the ExecutionContext.AcquireAndRelease
type ExecutionContextMockAcquireAndReleaseParams struct {
	s1 SyncLink
}

// ExecutionContextMockAcquireAndReleaseResults contains results of the ExecutionContext.AcquireAndRelease
type ExecutionContextMockAcquireAndReleaseResults struct {
	b1 BoolDecision
}

// Expect sets up expected params for ExecutionContext.AcquireAndRelease
func (mmAcquireAndRelease *mExecutionContextMockAcquireAndRelease) Expect(s1 SyncLink) *mExecutionContextMockAcquireAndRelease {
	if mmAcquireAndRelease.mock.funcAcquireAndRelease != nil {
		mmAcquireAndRelease.mock.t.Fatalf("ExecutionContextMock.AcquireAndRelease mock is already set by Set")
	}

	if mmAcquireAndRelease.defaultExpectation == nil {
		mmAcquireAndRelease.defaultExpectation = &ExecutionContextMockAcquireAndReleaseExpectation{}
	}

	mmAcquireAndRelease.defaultExpectation.params = &ExecutionContextMockAcquireAndReleaseParams{s1}
	for _, e := range mmAcquireAndRelease.expectations {
		if minimock.Equal(e.params, mmAcquireAndRelease.defaultExpectation.params) {
			mmAcquireAndRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcquireAndRelease.defaultExpectation.params)
		}
	}

	return mmAcquireAndRelease
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.AcquireAndRelease
func (mmAcquireAndRelease *mExecutionContextMockAcquireAndRelease) Inspect(f func(s1 SyncLink)) *mExecutionContextMockAcquireAndRelease {
	if mmAcquireAndRelease.mock.inspectFuncAcquireAndRelease != nil {
		mmAcquireAndRelease.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.AcquireAndRelease")
	}

	mmAcquireAndRelease.mock.inspectFuncAcquireAndRelease = f

	return mmAcquireAndRelease
}

// Return sets up results that will be returned by ExecutionContext.AcquireAndRelease
func (mmAcquireAndRelease *mExecutionContextMockAcquireAndRelease) Return(b1 BoolDecision) *ExecutionContextMock {
	if mmAcquireAndRelease.mock.funcAcquireAndRelease != nil {
		mmAcquireAndRelease.mock.t.Fatalf("ExecutionContextMock.AcquireAndRelease mock is already set by Set")
	}

	if mmAcquireAndRelease.defaultExpectation == nil {
		mmAcquireAndRelease.defaultExpectation = &ExecutionContextMockAcquireAndReleaseExpectation{mock: mmAcquireAndRelease.mock}
	}
	mmAcquireAndRelease.defaultExpectation.results = &ExecutionContextMockAcquireAndReleaseResults{b1}
	return mmAcquireAndRelease.mock
}

//Set uses given function f to mock the ExecutionContext.AcquireAndRelease method
func (mmAcquireAndRelease *mExecutionContextMockAcquireAndRelease) Set(f func(s1 SyncLink) (b1 BoolDecision)) *ExecutionContextMock {
	if mmAcquireAndRelease.defaultExpectation != nil {
		mmAcquireAndRelease.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.AcquireAndRelease method")
	}

	if len(mmAcquireAndRelease.expectations) > 0 {
		mmAcquireAndRelease.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.AcquireAndRelease method")
	}

	mmAcquireAndRelease.mock.funcAcquireAndRelease = f
	return mmAcquireAndRelease.mock
}

// When sets expectation for the ExecutionContext.AcquireAndRelease which will trigger the result defined by the following
// Then helper
func (mmAcquireAndRelease *mExecutionContextMockAcquireAndRelease) When(s1 SyncLink) *ExecutionContextMockAcquireAndReleaseExpectation {
	if mmAcquireAndRelease.mock.funcAcquireAndRelease != nil {
		mmAcquireAndRelease.mock.t.Fatalf("ExecutionContextMock.AcquireAndRelease mock is already set by Set")
	}

	expectation := &ExecutionContextMockAcquireAndReleaseExpectation{
		mock:   mmAcquireAndRelease.mock,
		params: &ExecutionContextMockAcquireAndReleaseParams{s1},
	}
	mmAcquireAndRelease.expectations = append(mmAcquireAndRelease.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.AcquireAndRelease return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockAcquireAndReleaseExpectation) Then(b1 BoolDecision) *ExecutionContextMock {
	e.results = &ExecutionContextMockAcquireAndReleaseResults{b1}
	return e.mock
}

// AcquireAndRelease implements ExecutionContext
func (mmAcquireAndRelease *ExecutionContextMock) AcquireAndRelease(s1 SyncLink) (b1 BoolDecision) {
	mm_atomic.AddUint64(&mmAcquireAndRelease.beforeAcquireAndReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmAcquireAndRelease.afterAcquireAndReleaseCounter, 1)

	if mmAcquireAndRelease.inspectFuncAcquireAndRelease != nil {
		mmAcquireAndRelease.inspectFuncAcquireAndRelease(s1)
	}

	mm_params := &ExecutionContextMockAcquireAndReleaseParams{s1}

	// Record call args
	mmAcquireAndRelease.AcquireAndReleaseMock.mutex.Lock()
	mmAcquireAndRelease.AcquireAndReleaseMock.callArgs = append(mmAcquireAndRelease.AcquireAndReleaseMock.callArgs, mm_params)
	mmAcquireAndRelease.AcquireAndReleaseMock.mutex.Unlock()

	for _, e := range mmAcquireAndRelease.AcquireAndReleaseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmAcquireAndRelease.AcquireAndReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcquireAndRelease.AcquireAndReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmAcquireAndRelease.AcquireAndReleaseMock.defaultExpectation.params
		mm_got := ExecutionContextMockAcquireAndReleaseParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcquireAndRelease.t.Errorf("ExecutionContextMock.AcquireAndRelease got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcquireAndRelease.AcquireAndReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmAcquireAndRelease.t.Fatal("No results are set for the ExecutionContextMock.AcquireAndRelease")
		}
		return (*mm_results).b1
	}
	if mmAcquireAndRelease.funcAcquireAndRelease != nil {
		return mmAcquireAndRelease.funcAcquireAndRelease(s1)
	}
	mmAcquireAndRelease.t.Fatalf("Unexpected call to ExecutionContextMock.AcquireAndRelease. %v", s1)
	return
}

// AcquireAndReleaseAfterCounter returns a count of finished ExecutionContextMock.AcquireAndRelease invocations
func (mmAcquireAndRelease *ExecutionContextMock) AcquireAndReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireAndRelease.afterAcquireAndReleaseCounter)
}

// AcquireAndReleaseBeforeCounter returns a count of ExecutionContextMock.AcquireAndRelease invocations
func (mmAcquireAndRelease *ExecutionContextMock) AcquireAndReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireAndRelease.beforeAcquireAndReleaseCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.AcquireAndRelease.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcquireAndRelease *mExecutionContextMockAcquireAndRelease) Calls() []*ExecutionContextMockAcquireAndReleaseParams {
	mmAcquireAndRelease.mutex.RLock()

	argCopy := make([]*ExecutionContextMockAcquireAndReleaseParams, len(mmAcquireAndRelease.callArgs))
	copy(argCopy, mmAcquireAndRelease.callArgs)

	mmAcquireAndRelease.mutex.RUnlock()

	return argCopy
}

// MinimockAcquireAndReleaseDone returns true if the count of the AcquireAndRelease invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockAcquireAndReleaseDone() bool {
	for _, e := range m.AcquireAndReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireAndReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireAndReleaseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireAndRelease != nil && mm_atomic.LoadUint64(&m.afterAcquireAndReleaseCounter) < 1 {
		return false
	}
	return true
}

// MinimockAcquireAndReleaseInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockAcquireAndReleaseInspect() {
	for _, e := range m.AcquireAndReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.AcquireAndRelease with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireAndReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireAndReleaseCounter) < 1 {
		if m.AcquireAndReleaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.AcquireAndRelease")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.AcquireAndRelease with params: %#v", *m.AcquireAndReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireAndRelease != nil && mm_atomic.LoadUint64(&m.afterAcquireAndReleaseCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.AcquireAndRelease")
	}
}

type mExecutionContextMockAcquireExt struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockAcquireExtExpectation
	expectations       []*ExecutionContextMockAcquireExtExpectation

	callArgs []*ExecutionContextMockAcquireExtParams
	mutex    sync.RWMutex
}

// ExecutionContextMockAcquireExtExpectation specifies expectation struct of the ExecutionContext.AcquireExt
type ExecutionContextMockAcquireExtExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockAcquireExtParams
	results *ExecutionContextMockAcquireExtResults
	Counter uint64
}

// ExecutionContextMockAcquireExtParams contains parameters of the ExecutionContext.AcquireExt
type ExecutionContextMockAcquireExtParams struct {
	s1 SyncLink
	a1 AcquireFlags
}

// ExecutionContextMockAcquireExtResults contains results of the ExecutionContext.AcquireExt
type ExecutionContextMockAcquireExtResults struct {
	b1 BoolDecision
}

// Expect sets up expected params for ExecutionContext.AcquireExt
func (mmAcquireExt *mExecutionContextMockAcquireExt) Expect(s1 SyncLink, a1 AcquireFlags) *mExecutionContextMockAcquireExt {
	if mmAcquireExt.mock.funcAcquireExt != nil {
		mmAcquireExt.mock.t.Fatalf("ExecutionContextMock.AcquireExt mock is already set by Set")
	}

	if mmAcquireExt.defaultExpectation == nil {
		mmAcquireExt.defaultExpectation = &ExecutionContextMockAcquireExtExpectation{}
	}

	mmAcquireExt.defaultExpectation.params = &ExecutionContextMockAcquireExtParams{s1, a1}
	for _, e := range mmAcquireExt.expectations {
		if minimock.Equal(e.params, mmAcquireExt.defaultExpectation.params) {
			mmAcquireExt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcquireExt.defaultExpectation.params)
		}
	}

	return mmAcquireExt
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.AcquireExt
func (mmAcquireExt *mExecutionContextMockAcquireExt) Inspect(f func(s1 SyncLink, a1 AcquireFlags)) *mExecutionContextMockAcquireExt {
	if mmAcquireExt.mock.inspectFuncAcquireExt != nil {
		mmAcquireExt.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.AcquireExt")
	}

	mmAcquireExt.mock.inspectFuncAcquireExt = f

	return mmAcquireExt
}

// Return sets up results that will be returned by ExecutionContext.AcquireExt
func (mmAcquireExt *mExecutionContextMockAcquireExt) Return(b1 BoolDecision) *ExecutionContextMock {
	if mmAcquireExt.mock.funcAcquireExt != nil {
		mmAcquireExt.mock.t.Fatalf("ExecutionContextMock.AcquireExt mock is already set by Set")
	}

	if mmAcquireExt.defaultExpectation == nil {
		mmAcquireExt.defaultExpectation = &ExecutionContextMockAcquireExtExpectation{mock: mmAcquireExt.mock}
	}
	mmAcquireExt.defaultExpectation.results = &ExecutionContextMockAcquireExtResults{b1}
	return mmAcquireExt.mock
}

//Set uses given function f to mock the ExecutionContext.AcquireExt method
func (mmAcquireExt *mExecutionContextMockAcquireExt) Set(f func(s1 SyncLink, a1 AcquireFlags) (b1 BoolDecision)) *ExecutionContextMock {
	if mmAcquireExt.defaultExpectation != nil {
		mmAcquireExt.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.AcquireExt method")
	}

	if len(mmAcquireExt.expectations) > 0 {
		mmAcquireExt.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.AcquireExt method")
	}

	mmAcquireExt.mock.funcAcquireExt = f
	return mmAcquireExt.mock
}

// When sets expectation for the ExecutionContext.AcquireExt which will trigger the result defined by the following
// Then helper
func (mmAcquireExt *mExecutionContextMockAcquireExt) When(s1 SyncLink, a1 AcquireFlags) *ExecutionContextMockAcquireExtExpectation {
	if mmAcquireExt.mock.funcAcquireExt != nil {
		mmAcquireExt.mock.t.Fatalf("ExecutionContextMock.AcquireExt mock is already set by Set")
	}

	expectation := &ExecutionContextMockAcquireExtExpectation{
		mock:   mmAcquireExt.mock,
		params: &ExecutionContextMockAcquireExtParams{s1, a1},
	}
	mmAcquireExt.expectations = append(mmAcquireExt.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.AcquireExt return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockAcquireExtExpectation) Then(b1 BoolDecision) *ExecutionContextMock {
	e.results = &ExecutionContextMockAcquireExtResults{b1}
	return e.mock
}

// AcquireExt implements ExecutionContext
func (mmAcquireExt *ExecutionContextMock) AcquireExt(s1 SyncLink, a1 AcquireFlags) (b1 BoolDecision) {
	mm_atomic.AddUint64(&mmAcquireExt.beforeAcquireExtCounter, 1)
	defer mm_atomic.AddUint64(&mmAcquireExt.afterAcquireExtCounter, 1)

	if mmAcquireExt.inspectFuncAcquireExt != nil {
		mmAcquireExt.inspectFuncAcquireExt(s1, a1)
	}

	mm_params := &ExecutionContextMockAcquireExtParams{s1, a1}

	// Record call args
	mmAcquireExt.AcquireExtMock.mutex.Lock()
	mmAcquireExt.AcquireExtMock.callArgs = append(mmAcquireExt.AcquireExtMock.callArgs, mm_params)
	mmAcquireExt.AcquireExtMock.mutex.Unlock()

	for _, e := range mmAcquireExt.AcquireExtMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmAcquireExt.AcquireExtMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcquireExt.AcquireExtMock.defaultExpectation.Counter, 1)
		mm_want := mmAcquireExt.AcquireExtMock.defaultExpectation.params
		mm_got := ExecutionContextMockAcquireExtParams{s1, a1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcquireExt.t.Errorf("ExecutionContextMock.AcquireExt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcquireExt.AcquireExtMock.defaultExpectation.results
		if mm_results == nil {
			mmAcquireExt.t.Fatal("No results are set for the ExecutionContextMock.AcquireExt")
		}
		return (*mm_results).b1
	}
	if mmAcquireExt.funcAcquireExt != nil {
		return mmAcquireExt.funcAcquireExt(s1, a1)
	}
	mmAcquireExt.t.Fatalf("Unexpected call to ExecutionContextMock.AcquireExt. %v %v", s1, a1)
	return
}

// AcquireExtAfterCounter returns a count of finished ExecutionContextMock.AcquireExt invocations
func (mmAcquireExt *ExecutionContextMock) AcquireExtAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireExt.afterAcquireExtCounter)
}

// AcquireExtBeforeCounter returns a count of ExecutionContextMock.AcquireExt invocations
func (mmAcquireExt *ExecutionContextMock) AcquireExtBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireExt.beforeAcquireExtCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.AcquireExt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcquireExt *mExecutionContextMockAcquireExt) Calls() []*ExecutionContextMockAcquireExtParams {
	mmAcquireExt.mutex.RLock()

	argCopy := make([]*ExecutionContextMockAcquireExtParams, len(mmAcquireExt.callArgs))
	copy(argCopy, mmAcquireExt.callArgs)

	mmAcquireExt.mutex.RUnlock()

	return argCopy
}

// MinimockAcquireExtDone returns true if the count of the AcquireExt invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockAcquireExtDone() bool {
	for _, e := range m.AcquireExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireExtCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireExt != nil && mm_atomic.LoadUint64(&m.afterAcquireExtCounter) < 1 {
		return false
	}
	return true
}

// MinimockAcquireExtInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockAcquireExtInspect() {
	for _, e := range m.AcquireExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.AcquireExt with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireExtCounter) < 1 {
		if m.AcquireExtMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.AcquireExt")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.AcquireExt with params: %#v", *m.AcquireExtMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireExt != nil && mm_atomic.LoadUint64(&m.afterAcquireExtCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.AcquireExt")
	}
}

type mExecutionContextMockAcquireForThisStep struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockAcquireForThisStepExpectation
	expectations       []*ExecutionContextMockAcquireForThisStepExpectation

	callArgs []*ExecutionContextMockAcquireForThisStepParams
	mutex    sync.RWMutex
}

// ExecutionContextMockAcquireForThisStepExpectation specifies expectation struct of the ExecutionContext.AcquireForThisStep
type ExecutionContextMockAcquireForThisStepExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockAcquireForThisStepParams
	results *ExecutionContextMockAcquireForThisStepResults
	Counter uint64
}

// ExecutionContextMockAcquireForThisStepParams contains parameters of the ExecutionContext.AcquireForThisStep
type ExecutionContextMockAcquireForThisStepParams struct {
	s1 SyncLink
}

// ExecutionContextMockAcquireForThisStepResults contains results of the ExecutionContext.AcquireForThisStep
type ExecutionContextMockAcquireForThisStepResults struct {
	b1 BoolDecision
}

// Expect sets up expected params for ExecutionContext.AcquireForThisStep
func (mmAcquireForThisStep *mExecutionContextMockAcquireForThisStep) Expect(s1 SyncLink) *mExecutionContextMockAcquireForThisStep {
	if mmAcquireForThisStep.mock.funcAcquireForThisStep != nil {
		mmAcquireForThisStep.mock.t.Fatalf("ExecutionContextMock.AcquireForThisStep mock is already set by Set")
	}

	if mmAcquireForThisStep.defaultExpectation == nil {
		mmAcquireForThisStep.defaultExpectation = &ExecutionContextMockAcquireForThisStepExpectation{}
	}

	mmAcquireForThisStep.defaultExpectation.params = &ExecutionContextMockAcquireForThisStepParams{s1}
	for _, e := range mmAcquireForThisStep.expectations {
		if minimock.Equal(e.params, mmAcquireForThisStep.defaultExpectation.params) {
			mmAcquireForThisStep.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcquireForThisStep.defaultExpectation.params)
		}
	}

	return mmAcquireForThisStep
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.AcquireForThisStep
func (mmAcquireForThisStep *mExecutionContextMockAcquireForThisStep) Inspect(f func(s1 SyncLink)) *mExecutionContextMockAcquireForThisStep {
	if mmAcquireForThisStep.mock.inspectFuncAcquireForThisStep != nil {
		mmAcquireForThisStep.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.AcquireForThisStep")
	}

	mmAcquireForThisStep.mock.inspectFuncAcquireForThisStep = f

	return mmAcquireForThisStep
}

// Return sets up results that will be returned by ExecutionContext.AcquireForThisStep
func (mmAcquireForThisStep *mExecutionContextMockAcquireForThisStep) Return(b1 BoolDecision) *ExecutionContextMock {
	if mmAcquireForThisStep.mock.funcAcquireForThisStep != nil {
		mmAcquireForThisStep.mock.t.Fatalf("ExecutionContextMock.AcquireForThisStep mock is already set by Set")
	}

	if mmAcquireForThisStep.defaultExpectation == nil {
		mmAcquireForThisStep.defaultExpectation = &ExecutionContextMockAcquireForThisStepExpectation{mock: mmAcquireForThisStep.mock}
	}
	mmAcquireForThisStep.defaultExpectation.results = &ExecutionContextMockAcquireForThisStepResults{b1}
	return mmAcquireForThisStep.mock
}

//Set uses given function f to mock the ExecutionContext.AcquireForThisStep method
func (mmAcquireForThisStep *mExecutionContextMockAcquireForThisStep) Set(f func(s1 SyncLink) (b1 BoolDecision)) *ExecutionContextMock {
	if mmAcquireForThisStep.defaultExpectation != nil {
		mmAcquireForThisStep.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.AcquireForThisStep method")
	}

	if len(mmAcquireForThisStep.expectations) > 0 {
		mmAcquireForThisStep.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.AcquireForThisStep method")
	}

	mmAcquireForThisStep.mock.funcAcquireForThisStep = f
	return mmAcquireForThisStep.mock
}

// When sets expectation for the ExecutionContext.AcquireForThisStep which will trigger the result defined by the following
// Then helper
func (mmAcquireForThisStep *mExecutionContextMockAcquireForThisStep) When(s1 SyncLink) *ExecutionContextMockAcquireForThisStepExpectation {
	if mmAcquireForThisStep.mock.funcAcquireForThisStep != nil {
		mmAcquireForThisStep.mock.t.Fatalf("ExecutionContextMock.AcquireForThisStep mock is already set by Set")
	}

	expectation := &ExecutionContextMockAcquireForThisStepExpectation{
		mock:   mmAcquireForThisStep.mock,
		params: &ExecutionContextMockAcquireForThisStepParams{s1},
	}
	mmAcquireForThisStep.expectations = append(mmAcquireForThisStep.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.AcquireForThisStep return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockAcquireForThisStepExpectation) Then(b1 BoolDecision) *ExecutionContextMock {
	e.results = &ExecutionContextMockAcquireForThisStepResults{b1}
	return e.mock
}

// AcquireForThisStep implements ExecutionContext
func (mmAcquireForThisStep *ExecutionContextMock) AcquireForThisStep(s1 SyncLink) (b1 BoolDecision) {
	mm_atomic.AddUint64(&mmAcquireForThisStep.beforeAcquireForThisStepCounter, 1)
	defer mm_atomic.AddUint64(&mmAcquireForThisStep.afterAcquireForThisStepCounter, 1)

	if mmAcquireForThisStep.inspectFuncAcquireForThisStep != nil {
		mmAcquireForThisStep.inspectFuncAcquireForThisStep(s1)
	}

	mm_params := &ExecutionContextMockAcquireForThisStepParams{s1}

	// Record call args
	mmAcquireForThisStep.AcquireForThisStepMock.mutex.Lock()
	mmAcquireForThisStep.AcquireForThisStepMock.callArgs = append(mmAcquireForThisStep.AcquireForThisStepMock.callArgs, mm_params)
	mmAcquireForThisStep.AcquireForThisStepMock.mutex.Unlock()

	for _, e := range mmAcquireForThisStep.AcquireForThisStepMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmAcquireForThisStep.AcquireForThisStepMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcquireForThisStep.AcquireForThisStepMock.defaultExpectation.Counter, 1)
		mm_want := mmAcquireForThisStep.AcquireForThisStepMock.defaultExpectation.params
		mm_got := ExecutionContextMockAcquireForThisStepParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcquireForThisStep.t.Errorf("ExecutionContextMock.AcquireForThisStep got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcquireForThisStep.AcquireForThisStepMock.defaultExpectation.results
		if mm_results == nil {
			mmAcquireForThisStep.t.Fatal("No results are set for the ExecutionContextMock.AcquireForThisStep")
		}
		return (*mm_results).b1
	}
	if mmAcquireForThisStep.funcAcquireForThisStep != nil {
		return mmAcquireForThisStep.funcAcquireForThisStep(s1)
	}
	mmAcquireForThisStep.t.Fatalf("Unexpected call to ExecutionContextMock.AcquireForThisStep. %v", s1)
	return
}

// AcquireForThisStepAfterCounter returns a count of finished ExecutionContextMock.AcquireForThisStep invocations
func (mmAcquireForThisStep *ExecutionContextMock) AcquireForThisStepAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireForThisStep.afterAcquireForThisStepCounter)
}

// AcquireForThisStepBeforeCounter returns a count of ExecutionContextMock.AcquireForThisStep invocations
func (mmAcquireForThisStep *ExecutionContextMock) AcquireForThisStepBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireForThisStep.beforeAcquireForThisStepCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.AcquireForThisStep.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcquireForThisStep *mExecutionContextMockAcquireForThisStep) Calls() []*ExecutionContextMockAcquireForThisStepParams {
	mmAcquireForThisStep.mutex.RLock()

	argCopy := make([]*ExecutionContextMockAcquireForThisStepParams, len(mmAcquireForThisStep.callArgs))
	copy(argCopy, mmAcquireForThisStep.callArgs)

	mmAcquireForThisStep.mutex.RUnlock()

	return argCopy
}

// MinimockAcquireForThisStepDone returns true if the count of the AcquireForThisStep invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockAcquireForThisStepDone() bool {
	for _, e := range m.AcquireForThisStepMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireForThisStepMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireForThisStep != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepCounter) < 1 {
		return false
	}
	return true
}

// MinimockAcquireForThisStepInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockAcquireForThisStepInspect() {
	for _, e := range m.AcquireForThisStepMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.AcquireForThisStep with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireForThisStepMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepCounter) < 1 {
		if m.AcquireForThisStepMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.AcquireForThisStep")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.AcquireForThisStep with params: %#v", *m.AcquireForThisStepMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireForThisStep != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.AcquireForThisStep")
	}
}

type mExecutionContextMockAcquireForThisStepAndRelease struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockAcquireForThisStepAndReleaseExpectation
	expectations       []*ExecutionContextMockAcquireForThisStepAndReleaseExpectation

	callArgs []*ExecutionContextMockAcquireForThisStepAndReleaseParams
	mutex    sync.RWMutex
}

// ExecutionContextMockAcquireForThisStepAndReleaseExpectation specifies expectation struct of the ExecutionContext.AcquireForThisStepAndRelease
type ExecutionContextMockAcquireForThisStepAndReleaseExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockAcquireForThisStepAndReleaseParams
	results *ExecutionContextMockAcquireForThisStepAndReleaseResults
	Counter uint64
}

// ExecutionContextMockAcquireForThisStepAndReleaseParams contains parameters of the ExecutionContext.AcquireForThisStepAndRelease
type ExecutionContextMockAcquireForThisStepAndReleaseParams struct {
	s1 SyncLink
}

// ExecutionContextMockAcquireForThisStepAndReleaseResults contains results of the ExecutionContext.AcquireForThisStepAndRelease
type ExecutionContextMockAcquireForThisStepAndReleaseResults struct {
	b1 BoolDecision
}

// Expect sets up expected params for ExecutionContext.AcquireForThisStepAndRelease
func (mmAcquireForThisStepAndRelease *mExecutionContextMockAcquireForThisStepAndRelease) Expect(s1 SyncLink) *mExecutionContextMockAcquireForThisStepAndRelease {
	if mmAcquireForThisStepAndRelease.mock.funcAcquireForThisStepAndRelease != nil {
		mmAcquireForThisStepAndRelease.mock.t.Fatalf("ExecutionContextMock.AcquireForThisStepAndRelease mock is already set by Set")
	}

	if mmAcquireForThisStepAndRelease.defaultExpectation == nil {
		mmAcquireForThisStepAndRelease.defaultExpectation = &ExecutionContextMockAcquireForThisStepAndReleaseExpectation{}
	}

	mmAcquireForThisStepAndRelease.defaultExpectation.params = &ExecutionContextMockAcquireForThisStepAndReleaseParams{s1}
	for _, e := range mmAcquireForThisStepAndRelease.expectations {
		if minimock.Equal(e.params, mmAcquireForThisStepAndRelease.defaultExpectation.params) {
			mmAcquireForThisStepAndRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcquireForThisStepAndRelease.defaultExpectation.params)
		}
	}

	return mmAcquireForThisStepAndRelease
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.AcquireForThisStepAndRelease
func (mmAcquireForThisStepAndRelease *mExecutionContextMockAcquireForThisStepAndRelease) Inspect(f func(s1 SyncLink)) *mExecutionContextMockAcquireForThisStepAndRelease {
	if mmAcquireForThisStepAndRelease.mock.inspectFuncAcquireForThisStepAndRelease != nil {
		mmAcquireForThisStepAndRelease.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.AcquireForThisStepAndRelease")
	}

	mmAcquireForThisStepAndRelease.mock.inspectFuncAcquireForThisStepAndRelease = f

	return mmAcquireForThisStepAndRelease
}

// Return sets up results that will be returned by ExecutionContext.AcquireForThisStepAndRelease
func (mmAcquireForThisStepAndRelease *mExecutionContextMockAcquireForThisStepAndRelease) Return(b1 BoolDecision) *ExecutionContextMock {
	if mmAcquireForThisStepAndRelease.mock.funcAcquireForThisStepAndRelease != nil {
		mmAcquireForThisStepAndRelease.mock.t.Fatalf("ExecutionContextMock.AcquireForThisStepAndRelease mock is already set by Set")
	}

	if mmAcquireForThisStepAndRelease.defaultExpectation == nil {
		mmAcquireForThisStepAndRelease.defaultExpectation = &ExecutionContextMockAcquireForThisStepAndReleaseExpectation{mock: mmAcquireForThisStepAndRelease.mock}
	}
	mmAcquireForThisStepAndRelease.defaultExpectation.results = &ExecutionContextMockAcquireForThisStepAndReleaseResults{b1}
	return mmAcquireForThisStepAndRelease.mock
}

//Set uses given function f to mock the ExecutionContext.AcquireForThisStepAndRelease method
func (mmAcquireForThisStepAndRelease *mExecutionContextMockAcquireForThisStepAndRelease) Set(f func(s1 SyncLink) (b1 BoolDecision)) *ExecutionContextMock {
	if mmAcquireForThisStepAndRelease.defaultExpectation != nil {
		mmAcquireForThisStepAndRelease.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.AcquireForThisStepAndRelease method")
	}

	if len(mmAcquireForThisStepAndRelease.expectations) > 0 {
		mmAcquireForThisStepAndRelease.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.AcquireForThisStepAndRelease method")
	}

	mmAcquireForThisStepAndRelease.mock.funcAcquireForThisStepAndRelease = f
	return mmAcquireForThisStepAndRelease.mock
}

// When sets expectation for the ExecutionContext.AcquireForThisStepAndRelease which will trigger the result defined by the following
// Then helper
func (mmAcquireForThisStepAndRelease *mExecutionContextMockAcquireForThisStepAndRelease) When(s1 SyncLink) *ExecutionContextMockAcquireForThisStepAndReleaseExpectation {
	if mmAcquireForThisStepAndRelease.mock.funcAcquireForThisStepAndRelease != nil {
		mmAcquireForThisStepAndRelease.mock.t.Fatalf("ExecutionContextMock.AcquireForThisStepAndRelease mock is already set by Set")
	}

	expectation := &ExecutionContextMockAcquireForThisStepAndReleaseExpectation{
		mock:   mmAcquireForThisStepAndRelease.mock,
		params: &ExecutionContextMockAcquireForThisStepAndReleaseParams{s1},
	}
	mmAcquireForThisStepAndRelease.expectations = append(mmAcquireForThisStepAndRelease.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.AcquireForThisStepAndRelease return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockAcquireForThisStepAndReleaseExpectation) Then(b1 BoolDecision) *ExecutionContextMock {
	e.results = &ExecutionContextMockAcquireForThisStepAndReleaseResults{b1}
	return e.mock
}

// AcquireForThisStepAndRelease implements ExecutionContext
func (mmAcquireForThisStepAndRelease *ExecutionContextMock) AcquireForThisStepAndRelease(s1 SyncLink) (b1 BoolDecision) {
	mm_atomic.AddUint64(&mmAcquireForThisStepAndRelease.beforeAcquireForThisStepAndReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmAcquireForThisStepAndRelease.afterAcquireForThisStepAndReleaseCounter, 1)

	if mmAcquireForThisStepAndRelease.inspectFuncAcquireForThisStepAndRelease != nil {
		mmAcquireForThisStepAndRelease.inspectFuncAcquireForThisStepAndRelease(s1)
	}

	mm_params := &ExecutionContextMockAcquireForThisStepAndReleaseParams{s1}

	// Record call args
	mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.mutex.Lock()
	mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.callArgs = append(mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.callArgs, mm_params)
	mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.mutex.Unlock()

	for _, e := range mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.defaultExpectation.params
		mm_got := ExecutionContextMockAcquireForThisStepAndReleaseParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcquireForThisStepAndRelease.t.Errorf("ExecutionContextMock.AcquireForThisStepAndRelease got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmAcquireForThisStepAndRelease.t.Fatal("No results are set for the ExecutionContextMock.AcquireForThisStepAndRelease")
		}
		return (*mm_results).b1
	}
	if mmAcquireForThisStepAndRelease.funcAcquireForThisStepAndRelease != nil {
		return mmAcquireForThisStepAndRelease.funcAcquireForThisStepAndRelease(s1)
	}
	mmAcquireForThisStepAndRelease.t.Fatalf("Unexpected call to ExecutionContextMock.AcquireForThisStepAndRelease. %v", s1)
	return
}

// AcquireForThisStepAndReleaseAfterCounter returns a count of finished ExecutionContextMock.AcquireForThisStepAndRelease invocations
func (mmAcquireForThisStepAndRelease *ExecutionContextMock) AcquireForThisStepAndReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireForThisStepAndRelease.afterAcquireForThisStepAndReleaseCounter)
}

// AcquireForThisStepAndReleaseBeforeCounter returns a count of ExecutionContextMock.AcquireForThisStepAndRelease invocations
func (mmAcquireForThisStepAndRelease *ExecutionContextMock) AcquireForThisStepAndReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireForThisStepAndRelease.beforeAcquireForThisStepAndReleaseCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.AcquireForThisStepAndRelease.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcquireForThisStepAndRelease *mExecutionContextMockAcquireForThisStepAndRelease) Calls() []*ExecutionContextMockAcquireForThisStepAndReleaseParams {
	mmAcquireForThisStepAndRelease.mutex.RLock()

	argCopy := make([]*ExecutionContextMockAcquireForThisStepAndReleaseParams, len(mmAcquireForThisStepAndRelease.callArgs))
	copy(argCopy, mmAcquireForThisStepAndRelease.callArgs)

	mmAcquireForThisStepAndRelease.mutex.RUnlock()

	return argCopy
}

// MinimockAcquireForThisStepAndReleaseDone returns true if the count of the AcquireForThisStepAndRelease invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockAcquireForThisStepAndReleaseDone() bool {
	for _, e := range m.AcquireForThisStepAndReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireForThisStepAndReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepAndReleaseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireForThisStepAndRelease != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepAndReleaseCounter) < 1 {
		return false
	}
	return true
}

// MinimockAcquireForThisStepAndReleaseInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockAcquireForThisStepAndReleaseInspect() {
	for _, e := range m.AcquireForThisStepAndReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.AcquireForThisStepAndRelease with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireForThisStepAndReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepAndReleaseCounter) < 1 {
		if m.AcquireForThisStepAndReleaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.AcquireForThisStepAndRelease")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.AcquireForThisStepAndRelease with params: %#v", *m.AcquireForThisStepAndReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireForThisStepAndRelease != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepAndReleaseCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.AcquireForThisStepAndRelease")
	}
}

type mExecutionContextMockApplyAdjustment struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockApplyAdjustmentExpectation
	expectations       []*ExecutionContextMockApplyAdjustmentExpectation

	callArgs []*ExecutionContextMockApplyAdjustmentParams
	mutex    sync.RWMutex
}

// ExecutionContextMockApplyAdjustmentExpectation specifies expectation struct of the ExecutionContext.ApplyAdjustment
type ExecutionContextMockApplyAdjustmentExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockApplyAdjustmentParams
	results *ExecutionContextMockApplyAdjustmentResults
	Counter uint64
}

// ExecutionContextMockApplyAdjustmentParams contains parameters of the ExecutionContext.ApplyAdjustment
type ExecutionContextMockApplyAdjustmentParams struct {
	s1 SyncAdjustment
}

// ExecutionContextMockApplyAdjustmentResults contains results of the ExecutionContext.ApplyAdjustment
type ExecutionContextMockApplyAdjustmentResults struct {
	b1 bool
}

// Expect sets up expected params for ExecutionContext.ApplyAdjustment
func (mmApplyAdjustment *mExecutionContextMockApplyAdjustment) Expect(s1 SyncAdjustment) *mExecutionContextMockApplyAdjustment {
	if mmApplyAdjustment.mock.funcApplyAdjustment != nil {
		mmApplyAdjustment.mock.t.Fatalf("ExecutionContextMock.ApplyAdjustment mock is already set by Set")
	}

	if mmApplyAdjustment.defaultExpectation == nil {
		mmApplyAdjustment.defaultExpectation = &ExecutionContextMockApplyAdjustmentExpectation{}
	}

	mmApplyAdjustment.defaultExpectation.params = &ExecutionContextMockApplyAdjustmentParams{s1}
	for _, e := range mmApplyAdjustment.expectations {
		if minimock.Equal(e.params, mmApplyAdjustment.defaultExpectation.params) {
			mmApplyAdjustment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmApplyAdjustment.defaultExpectation.params)
		}
	}

	return mmApplyAdjustment
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.ApplyAdjustment
func (mmApplyAdjustment *mExecutionContextMockApplyAdjustment) Inspect(f func(s1 SyncAdjustment)) *mExecutionContextMockApplyAdjustment {
	if mmApplyAdjustment.mock.inspectFuncApplyAdjustment != nil {
		mmApplyAdjustment.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.ApplyAdjustment")
	}

	mmApplyAdjustment.mock.inspectFuncApplyAdjustment = f

	return mmApplyAdjustment
}

// Return sets up results that will be returned by ExecutionContext.ApplyAdjustment
func (mmApplyAdjustment *mExecutionContextMockApplyAdjustment) Return(b1 bool) *ExecutionContextMock {
	if mmApplyAdjustment.mock.funcApplyAdjustment != nil {
		mmApplyAdjustment.mock.t.Fatalf("ExecutionContextMock.ApplyAdjustment mock is already set by Set")
	}

	if mmApplyAdjustment.defaultExpectation == nil {
		mmApplyAdjustment.defaultExpectation = &ExecutionContextMockApplyAdjustmentExpectation{mock: mmApplyAdjustment.mock}
	}
	mmApplyAdjustment.defaultExpectation.results = &ExecutionContextMockApplyAdjustmentResults{b1}
	return mmApplyAdjustment.mock
}

//Set uses given function f to mock the ExecutionContext.ApplyAdjustment method
func (mmApplyAdjustment *mExecutionContextMockApplyAdjustment) Set(f func(s1 SyncAdjustment) (b1 bool)) *ExecutionContextMock {
	if mmApplyAdjustment.defaultExpectation != nil {
		mmApplyAdjustment.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.ApplyAdjustment method")
	}

	if len(mmApplyAdjustment.expectations) > 0 {
		mmApplyAdjustment.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.ApplyAdjustment method")
	}

	mmApplyAdjustment.mock.funcApplyAdjustment = f
	return mmApplyAdjustment.mock
}

// When sets expectation for the ExecutionContext.ApplyAdjustment which will trigger the result defined by the following
// Then helper
func (mmApplyAdjustment *mExecutionContextMockApplyAdjustment) When(s1 SyncAdjustment) *ExecutionContextMockApplyAdjustmentExpectation {
	if mmApplyAdjustment.mock.funcApplyAdjustment != nil {
		mmApplyAdjustment.mock.t.Fatalf("ExecutionContextMock.ApplyAdjustment mock is already set by Set")
	}

	expectation := &ExecutionContextMockApplyAdjustmentExpectation{
		mock:   mmApplyAdjustment.mock,
		params: &ExecutionContextMockApplyAdjustmentParams{s1},
	}
	mmApplyAdjustment.expectations = append(mmApplyAdjustment.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.ApplyAdjustment return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockApplyAdjustmentExpectation) Then(b1 bool) *ExecutionContextMock {
	e.results = &ExecutionContextMockApplyAdjustmentResults{b1}
	return e.mock
}

// ApplyAdjustment implements ExecutionContext
func (mmApplyAdjustment *ExecutionContextMock) ApplyAdjustment(s1 SyncAdjustment) (b1 bool) {
	mm_atomic.AddUint64(&mmApplyAdjustment.beforeApplyAdjustmentCounter, 1)
	defer mm_atomic.AddUint64(&mmApplyAdjustment.afterApplyAdjustmentCounter, 1)

	if mmApplyAdjustment.inspectFuncApplyAdjustment != nil {
		mmApplyAdjustment.inspectFuncApplyAdjustment(s1)
	}

	mm_params := &ExecutionContextMockApplyAdjustmentParams{s1}

	// Record call args
	mmApplyAdjustment.ApplyAdjustmentMock.mutex.Lock()
	mmApplyAdjustment.ApplyAdjustmentMock.callArgs = append(mmApplyAdjustment.ApplyAdjustmentMock.callArgs, mm_params)
	mmApplyAdjustment.ApplyAdjustmentMock.mutex.Unlock()

	for _, e := range mmApplyAdjustment.ApplyAdjustmentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmApplyAdjustment.ApplyAdjustmentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmApplyAdjustment.ApplyAdjustmentMock.defaultExpectation.Counter, 1)
		mm_want := mmApplyAdjustment.ApplyAdjustmentMock.defaultExpectation.params
		mm_got := ExecutionContextMockApplyAdjustmentParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmApplyAdjustment.t.Errorf("ExecutionContextMock.ApplyAdjustment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmApplyAdjustment.ApplyAdjustmentMock.defaultExpectation.results
		if mm_results == nil {
			mmApplyAdjustment.t.Fatal("No results are set for the ExecutionContextMock.ApplyAdjustment")
		}
		return (*mm_results).b1
	}
	if mmApplyAdjustment.funcApplyAdjustment != nil {
		return mmApplyAdjustment.funcApplyAdjustment(s1)
	}
	mmApplyAdjustment.t.Fatalf("Unexpected call to ExecutionContextMock.ApplyAdjustment. %v", s1)
	return
}

// ApplyAdjustmentAfterCounter returns a count of finished ExecutionContextMock.ApplyAdjustment invocations
func (mmApplyAdjustment *ExecutionContextMock) ApplyAdjustmentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyAdjustment.afterApplyAdjustmentCounter)
}

// ApplyAdjustmentBeforeCounter returns a count of ExecutionContextMock.ApplyAdjustment invocations
func (mmApplyAdjustment *ExecutionContextMock) ApplyAdjustmentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyAdjustment.beforeApplyAdjustmentCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.ApplyAdjustment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmApplyAdjustment *mExecutionContextMockApplyAdjustment) Calls() []*ExecutionContextMockApplyAdjustmentParams {
	mmApplyAdjustment.mutex.RLock()

	argCopy := make([]*ExecutionContextMockApplyAdjustmentParams, len(mmApplyAdjustment.callArgs))
	copy(argCopy, mmApplyAdjustment.callArgs)

	mmApplyAdjustment.mutex.RUnlock()

	return argCopy
}

// MinimockApplyAdjustmentDone returns true if the count of the ApplyAdjustment invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockApplyAdjustmentDone() bool {
	for _, e := range m.ApplyAdjustmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyAdjustmentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterApplyAdjustmentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApplyAdjustment != nil && mm_atomic.LoadUint64(&m.afterApplyAdjustmentCounter) < 1 {
		return false
	}
	return true
}

// MinimockApplyAdjustmentInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockApplyAdjustmentInspect() {
	for _, e := range m.ApplyAdjustmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.ApplyAdjustment with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyAdjustmentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterApplyAdjustmentCounter) < 1 {
		if m.ApplyAdjustmentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.ApplyAdjustment")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.ApplyAdjustment with params: %#v", *m.ApplyAdjustmentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApplyAdjustment != nil && mm_atomic.LoadUint64(&m.afterApplyAdjustmentCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.ApplyAdjustment")
	}
}

type mExecutionContextMockCallBargeIn struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockCallBargeInExpectation
	expectations       []*ExecutionContextMockCallBargeInExpectation

	callArgs []*ExecutionContextMockCallBargeInParams
	mutex    sync.RWMutex
}

// ExecutionContextMockCallBargeInExpectation specifies expectation struct of the ExecutionContext.CallBargeIn
type ExecutionContextMockCallBargeInExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockCallBargeInParams
	results *ExecutionContextMockCallBargeInResults
	Counter uint64
}

// ExecutionContextMockCallBargeInParams contains parameters of the ExecutionContext.CallBargeIn
type ExecutionContextMockCallBargeInParams struct {
	b BargeIn
}

// ExecutionContextMockCallBargeInResults contains results of the ExecutionContext.CallBargeIn
type ExecutionContextMockCallBargeInResults struct {
	b1 bool
}

// Expect sets up expected params for ExecutionContext.CallBargeIn
func (mmCallBargeIn *mExecutionContextMockCallBargeIn) Expect(b BargeIn) *mExecutionContextMockCallBargeIn {
	if mmCallBargeIn.mock.funcCallBargeIn != nil {
		mmCallBargeIn.mock.t.Fatalf("ExecutionContextMock.CallBargeIn mock is already set by Set")
	}

	if mmCallBargeIn.defaultExpectation == nil {
		mmCallBargeIn.defaultExpectation = &ExecutionContextMockCallBargeInExpectation{}
	}

	mmCallBargeIn.defaultExpectation.params = &ExecutionContextMockCallBargeInParams{b}
	for _, e := range mmCallBargeIn.expectations {
		if minimock.Equal(e.params, mmCallBargeIn.defaultExpectation.params) {
			mmCallBargeIn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCallBargeIn.defaultExpectation.params)
		}
	}

	return mmCallBargeIn
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.CallBargeIn
func (mmCallBargeIn *mExecutionContextMockCallBargeIn) Inspect(f func(b BargeIn)) *mExecutionContextMockCallBargeIn {
	if mmCallBargeIn.mock.inspectFuncCallBargeIn != nil {
		mmCallBargeIn.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.CallBargeIn")
	}

	mmCallBargeIn.mock.inspectFuncCallBargeIn = f

	return mmCallBargeIn
}

// Return sets up results that will be returned by ExecutionContext.CallBargeIn
func (mmCallBargeIn *mExecutionContextMockCallBargeIn) Return(b1 bool) *ExecutionContextMock {
	if mmCallBargeIn.mock.funcCallBargeIn != nil {
		mmCallBargeIn.mock.t.Fatalf("ExecutionContextMock.CallBargeIn mock is already set by Set")
	}

	if mmCallBargeIn.defaultExpectation == nil {
		mmCallBargeIn.defaultExpectation = &ExecutionContextMockCallBargeInExpectation{mock: mmCallBargeIn.mock}
	}
	mmCallBargeIn.defaultExpectation.results = &ExecutionContextMockCallBargeInResults{b1}
	return mmCallBargeIn.mock
}

//Set uses given function f to mock the ExecutionContext.CallBargeIn method
func (mmCallBargeIn *mExecutionContextMockCallBargeIn) Set(f func(b BargeIn) (b1 bool)) *ExecutionContextMock {
	if mmCallBargeIn.defaultExpectation != nil {
		mmCallBargeIn.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.CallBargeIn method")
	}

	if len(mmCallBargeIn.expectations) > 0 {
		mmCallBargeIn.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.CallBargeIn method")
	}

	mmCallBargeIn.mock.funcCallBargeIn = f
	return mmCallBargeIn.mock
}

// When sets expectation for the ExecutionContext.CallBargeIn which will trigger the result defined by the following
// Then helper
func (mmCallBargeIn *mExecutionContextMockCallBargeIn) When(b BargeIn) *ExecutionContextMockCallBargeInExpectation {
	if mmCallBargeIn.mock.funcCallBargeIn != nil {
		mmCallBargeIn.mock.t.Fatalf("ExecutionContextMock.CallBargeIn mock is already set by Set")
	}

	expectation := &ExecutionContextMockCallBargeInExpectation{
		mock:   mmCallBargeIn.mock,
		params: &ExecutionContextMockCallBargeInParams{b},
	}
	mmCallBargeIn.expectations = append(mmCallBargeIn.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.CallBargeIn return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockCallBargeInExpectation) Then(b1 bool) *ExecutionContextMock {
	e.results = &ExecutionContextMockCallBargeInResults{b1}
	return e.mock
}

// CallBargeIn implements ExecutionContext
func (mmCallBargeIn *ExecutionContextMock) CallBargeIn(b BargeIn) (b1 bool) {
	mm_atomic.AddUint64(&mmCallBargeIn.beforeCallBargeInCounter, 1)
	defer mm_atomic.AddUint64(&mmCallBargeIn.afterCallBargeInCounter, 1)

	if mmCallBargeIn.inspectFuncCallBargeIn != nil {
		mmCallBargeIn.inspectFuncCallBargeIn(b)
	}

	mm_params := &ExecutionContextMockCallBargeInParams{b}

	// Record call args
	mmCallBargeIn.CallBargeInMock.mutex.Lock()
	mmCallBargeIn.CallBargeInMock.callArgs = append(mmCallBargeIn.CallBargeInMock.callArgs, mm_params)
	mmCallBargeIn.CallBargeInMock.mutex.Unlock()

	for _, e := range mmCallBargeIn.CallBargeInMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmCallBargeIn.CallBargeInMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCallBargeIn.CallBargeInMock.defaultExpectation.Counter, 1)
		mm_want := mmCallBargeIn.CallBargeInMock.defaultExpectation.params
		mm_got := ExecutionContextMockCallBargeInParams{b}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCallBargeIn.t.Errorf("ExecutionContextMock.CallBargeIn got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCallBargeIn.CallBargeInMock.defaultExpectation.results
		if mm_results == nil {
			mmCallBargeIn.t.Fatal("No results are set for the ExecutionContextMock.CallBargeIn")
		}
		return (*mm_results).b1
	}
	if mmCallBargeIn.funcCallBargeIn != nil {
		return mmCallBargeIn.funcCallBargeIn(b)
	}
	mmCallBargeIn.t.Fatalf("Unexpected call to ExecutionContextMock.CallBargeIn. %v", b)
	return
}

// CallBargeInAfterCounter returns a count of finished ExecutionContextMock.CallBargeIn invocations
func (mmCallBargeIn *ExecutionContextMock) CallBargeInAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallBargeIn.afterCallBargeInCounter)
}

// CallBargeInBeforeCounter returns a count of ExecutionContextMock.CallBargeIn invocations
func (mmCallBargeIn *ExecutionContextMock) CallBargeInBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallBargeIn.beforeCallBargeInCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.CallBargeIn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCallBargeIn *mExecutionContextMockCallBargeIn) Calls() []*ExecutionContextMockCallBargeInParams {
	mmCallBargeIn.mutex.RLock()

	argCopy := make([]*ExecutionContextMockCallBargeInParams, len(mmCallBargeIn.callArgs))
	copy(argCopy, mmCallBargeIn.callArgs)

	mmCallBargeIn.mutex.RUnlock()

	return argCopy
}

// MinimockCallBargeInDone returns true if the count of the CallBargeIn invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockCallBargeInDone() bool {
	for _, e := range m.CallBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallBargeInCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallBargeIn != nil && mm_atomic.LoadUint64(&m.afterCallBargeInCounter) < 1 {
		return false
	}
	return true
}

// MinimockCallBargeInInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockCallBargeInInspect() {
	for _, e := range m.CallBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.CallBargeIn with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallBargeInCounter) < 1 {
		if m.CallBargeInMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.CallBargeIn")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.CallBargeIn with params: %#v", *m.CallBargeInMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallBargeIn != nil && mm_atomic.LoadUint64(&m.afterCallBargeInCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.CallBargeIn")
	}
}

type mExecutionContextMockCallBargeInWithParam struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockCallBargeInWithParamExpectation
	expectations       []*ExecutionContextMockCallBargeInWithParamExpectation

	callArgs []*ExecutionContextMockCallBargeInWithParamParams
	mutex    sync.RWMutex
}

// ExecutionContextMockCallBargeInWithParamExpectation specifies expectation struct of the ExecutionContext.CallBargeInWithParam
type ExecutionContextMockCallBargeInWithParamExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockCallBargeInWithParamParams
	results *ExecutionContextMockCallBargeInWithParamResults
	Counter uint64
}

// ExecutionContextMockCallBargeInWithParamParams contains parameters of the ExecutionContext.CallBargeInWithParam
type ExecutionContextMockCallBargeInWithParamParams struct {
	b     BargeInWithParam
	param interface{}
}

// ExecutionContextMockCallBargeInWithParamResults contains results of the ExecutionContext.CallBargeInWithParam
type ExecutionContextMockCallBargeInWithParamResults struct {
	b1 bool
}

// Expect sets up expected params for ExecutionContext.CallBargeInWithParam
func (mmCallBargeInWithParam *mExecutionContextMockCallBargeInWithParam) Expect(b BargeInWithParam, param interface{}) *mExecutionContextMockCallBargeInWithParam {
	if mmCallBargeInWithParam.mock.funcCallBargeInWithParam != nil {
		mmCallBargeInWithParam.mock.t.Fatalf("ExecutionContextMock.CallBargeInWithParam mock is already set by Set")
	}

	if mmCallBargeInWithParam.defaultExpectation == nil {
		mmCallBargeInWithParam.defaultExpectation = &ExecutionContextMockCallBargeInWithParamExpectation{}
	}

	mmCallBargeInWithParam.defaultExpectation.params = &ExecutionContextMockCallBargeInWithParamParams{b, param}
	for _, e := range mmCallBargeInWithParam.expectations {
		if minimock.Equal(e.params, mmCallBargeInWithParam.defaultExpectation.params) {
			mmCallBargeInWithParam.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCallBargeInWithParam.defaultExpectation.params)
		}
	}

	return mmCallBargeInWithParam
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.CallBargeInWithParam
func (mmCallBargeInWithParam *mExecutionContextMockCallBargeInWithParam) Inspect(f func(b BargeInWithParam, param interface{})) *mExecutionContextMockCallBargeInWithParam {
	if mmCallBargeInWithParam.mock.inspectFuncCallBargeInWithParam != nil {
		mmCallBargeInWithParam.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.CallBargeInWithParam")
	}

	mmCallBargeInWithParam.mock.inspectFuncCallBargeInWithParam = f

	return mmCallBargeInWithParam
}

// Return sets up results that will be returned by ExecutionContext.CallBargeInWithParam
func (mmCallBargeInWithParam *mExecutionContextMockCallBargeInWithParam) Return(b1 bool) *ExecutionContextMock {
	if mmCallBargeInWithParam.mock.funcCallBargeInWithParam != nil {
		mmCallBargeInWithParam.mock.t.Fatalf("ExecutionContextMock.CallBargeInWithParam mock is already set by Set")
	}

	if mmCallBargeInWithParam.defaultExpectation == nil {
		mmCallBargeInWithParam.defaultExpectation = &ExecutionContextMockCallBargeInWithParamExpectation{mock: mmCallBargeInWithParam.mock}
	}
	mmCallBargeInWithParam.defaultExpectation.results = &ExecutionContextMockCallBargeInWithParamResults{b1}
	return mmCallBargeInWithParam.mock
}

//Set uses given function f to mock the ExecutionContext.CallBargeInWithParam method
func (mmCallBargeInWithParam *mExecutionContextMockCallBargeInWithParam) Set(f func(b BargeInWithParam, param interface{}) (b1 bool)) *ExecutionContextMock {
	if mmCallBargeInWithParam.defaultExpectation != nil {
		mmCallBargeInWithParam.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.CallBargeInWithParam method")
	}

	if len(mmCallBargeInWithParam.expectations) > 0 {
		mmCallBargeInWithParam.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.CallBargeInWithParam method")
	}

	mmCallBargeInWithParam.mock.funcCallBargeInWithParam = f
	return mmCallBargeInWithParam.mock
}

// When sets expectation for the ExecutionContext.CallBargeInWithParam which will trigger the result defined by the following
// Then helper
func (mmCallBargeInWithParam *mExecutionContextMockCallBargeInWithParam) When(b BargeInWithParam, param interface{}) *ExecutionContextMockCallBargeInWithParamExpectation {
	if mmCallBargeInWithParam.mock.funcCallBargeInWithParam != nil {
		mmCallBargeInWithParam.mock.t.Fatalf("ExecutionContextMock.CallBargeInWithParam mock is already set by Set")
	}

	expectation := &ExecutionContextMockCallBargeInWithParamExpectation{
		mock:   mmCallBargeInWithParam.mock,
		params: &ExecutionContextMockCallBargeInWithParamParams{b, param},
	}
	mmCallBargeInWithParam.expectations = append(mmCallBargeInWithParam.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.CallBargeInWithParam return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockCallBargeInWithParamExpectation) Then(b1 bool) *ExecutionContextMock {
	e.results = &ExecutionContextMockCallBargeInWithParamResults{b1}
	return e.mock
}

// CallBargeInWithParam implements ExecutionContext
func (mmCallBargeInWithParam *ExecutionContextMock) CallBargeInWithParam(b BargeInWithParam, param interface{}) (b1 bool) {
	mm_atomic.AddUint64(&mmCallBargeInWithParam.beforeCallBargeInWithParamCounter, 1)
	defer mm_atomic.AddUint64(&mmCallBargeInWithParam.afterCallBargeInWithParamCounter, 1)

	if mmCallBargeInWithParam.inspectFuncCallBargeInWithParam != nil {
		mmCallBargeInWithParam.inspectFuncCallBargeInWithParam(b, param)
	}

	mm_params := &ExecutionContextMockCallBargeInWithParamParams{b, param}

	// Record call args
	mmCallBargeInWithParam.CallBargeInWithParamMock.mutex.Lock()
	mmCallBargeInWithParam.CallBargeInWithParamMock.callArgs = append(mmCallBargeInWithParam.CallBargeInWithParamMock.callArgs, mm_params)
	mmCallBargeInWithParam.CallBargeInWithParamMock.mutex.Unlock()

	for _, e := range mmCallBargeInWithParam.CallBargeInWithParamMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmCallBargeInWithParam.CallBargeInWithParamMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCallBargeInWithParam.CallBargeInWithParamMock.defaultExpectation.Counter, 1)
		mm_want := mmCallBargeInWithParam.CallBargeInWithParamMock.defaultExpectation.params
		mm_got := ExecutionContextMockCallBargeInWithParamParams{b, param}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCallBargeInWithParam.t.Errorf("ExecutionContextMock.CallBargeInWithParam got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCallBargeInWithParam.CallBargeInWithParamMock.defaultExpectation.results
		if mm_results == nil {
			mmCallBargeInWithParam.t.Fatal("No results are set for the ExecutionContextMock.CallBargeInWithParam")
		}
		return (*mm_results).b1
	}
	if mmCallBargeInWithParam.funcCallBargeInWithParam != nil {
		return mmCallBargeInWithParam.funcCallBargeInWithParam(b, param)
	}
	mmCallBargeInWithParam.t.Fatalf("Unexpected call to ExecutionContextMock.CallBargeInWithParam. %v %v", b, param)
	return
}

// CallBargeInWithParamAfterCounter returns a count of finished ExecutionContextMock.CallBargeInWithParam invocations
func (mmCallBargeInWithParam *ExecutionContextMock) CallBargeInWithParamAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallBargeInWithParam.afterCallBargeInWithParamCounter)
}

// CallBargeInWithParamBeforeCounter returns a count of ExecutionContextMock.CallBargeInWithParam invocations
func (mmCallBargeInWithParam *ExecutionContextMock) CallBargeInWithParamBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallBargeInWithParam.beforeCallBargeInWithParamCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.CallBargeInWithParam.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCallBargeInWithParam *mExecutionContextMockCallBargeInWithParam) Calls() []*ExecutionContextMockCallBargeInWithParamParams {
	mmCallBargeInWithParam.mutex.RLock()

	argCopy := make([]*ExecutionContextMockCallBargeInWithParamParams, len(mmCallBargeInWithParam.callArgs))
	copy(argCopy, mmCallBargeInWithParam.callArgs)

	mmCallBargeInWithParam.mutex.RUnlock()

	return argCopy
}

// MinimockCallBargeInWithParamDone returns true if the count of the CallBargeInWithParam invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockCallBargeInWithParamDone() bool {
	for _, e := range m.CallBargeInWithParamMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallBargeInWithParamMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallBargeInWithParamCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallBargeInWithParam != nil && mm_atomic.LoadUint64(&m.afterCallBargeInWithParamCounter) < 1 {
		return false
	}
	return true
}

// MinimockCallBargeInWithParamInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockCallBargeInWithParamInspect() {
	for _, e := range m.CallBargeInWithParamMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.CallBargeInWithParam with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallBargeInWithParamMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallBargeInWithParamCounter) < 1 {
		if m.CallBargeInWithParamMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.CallBargeInWithParam")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.CallBargeInWithParam with params: %#v", *m.CallBargeInWithParamMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallBargeInWithParam != nil && mm_atomic.LoadUint64(&m.afterCallBargeInWithParamCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.CallBargeInWithParam")
	}
}

type mExecutionContextMockCallSubroutine struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockCallSubroutineExpectation
	expectations       []*ExecutionContextMockCallSubroutineExpectation

	callArgs []*ExecutionContextMockCallSubroutineParams
	mutex    sync.RWMutex
}

// ExecutionContextMockCallSubroutineExpectation specifies expectation struct of the ExecutionContext.CallSubroutine
type ExecutionContextMockCallSubroutineExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockCallSubroutineParams
	results *ExecutionContextMockCallSubroutineResults
	Counter uint64
}

// ExecutionContextMockCallSubroutineParams contains parameters of the ExecutionContext.CallSubroutine
type ExecutionContextMockCallSubroutineParams struct {
	s1 SubroutineStateMachine
	m1 MigrateFunc
	s2 SubroutineExitFunc
}

// ExecutionContextMockCallSubroutineResults contains results of the ExecutionContext.CallSubroutine
type ExecutionContextMockCallSubroutineResults struct {
	s3 StateUpdate
}

// Expect sets up expected params for ExecutionContext.CallSubroutine
func (mmCallSubroutine *mExecutionContextMockCallSubroutine) Expect(s1 SubroutineStateMachine, m1 MigrateFunc, s2 SubroutineExitFunc) *mExecutionContextMockCallSubroutine {
	if mmCallSubroutine.mock.funcCallSubroutine != nil {
		mmCallSubroutine.mock.t.Fatalf("ExecutionContextMock.CallSubroutine mock is already set by Set")
	}

	if mmCallSubroutine.defaultExpectation == nil {
		mmCallSubroutine.defaultExpectation = &ExecutionContextMockCallSubroutineExpectation{}
	}

	mmCallSubroutine.defaultExpectation.params = &ExecutionContextMockCallSubroutineParams{s1, m1, s2}
	for _, e := range mmCallSubroutine.expectations {
		if minimock.Equal(e.params, mmCallSubroutine.defaultExpectation.params) {
			mmCallSubroutine.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCallSubroutine.defaultExpectation.params)
		}
	}

	return mmCallSubroutine
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.CallSubroutine
func (mmCallSubroutine *mExecutionContextMockCallSubroutine) Inspect(f func(s1 SubroutineStateMachine, m1 MigrateFunc, s2 SubroutineExitFunc)) *mExecutionContextMockCallSubroutine {
	if mmCallSubroutine.mock.inspectFuncCallSubroutine != nil {
		mmCallSubroutine.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.CallSubroutine")
	}

	mmCallSubroutine.mock.inspectFuncCallSubroutine = f

	return mmCallSubroutine
}

// Return sets up results that will be returned by ExecutionContext.CallSubroutine
func (mmCallSubroutine *mExecutionContextMockCallSubroutine) Return(s3 StateUpdate) *ExecutionContextMock {
	if mmCallSubroutine.mock.funcCallSubroutine != nil {
		mmCallSubroutine.mock.t.Fatalf("ExecutionContextMock.CallSubroutine mock is already set by Set")
	}

	if mmCallSubroutine.defaultExpectation == nil {
		mmCallSubroutine.defaultExpectation = &ExecutionContextMockCallSubroutineExpectation{mock: mmCallSubroutine.mock}
	}
	mmCallSubroutine.defaultExpectation.results = &ExecutionContextMockCallSubroutineResults{s3}
	return mmCallSubroutine.mock
}

//Set uses given function f to mock the ExecutionContext.CallSubroutine method
func (mmCallSubroutine *mExecutionContextMockCallSubroutine) Set(f func(s1 SubroutineStateMachine, m1 MigrateFunc, s2 SubroutineExitFunc) (s3 StateUpdate)) *ExecutionContextMock {
	if mmCallSubroutine.defaultExpectation != nil {
		mmCallSubroutine.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.CallSubroutine method")
	}

	if len(mmCallSubroutine.expectations) > 0 {
		mmCallSubroutine.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.CallSubroutine method")
	}

	mmCallSubroutine.mock.funcCallSubroutine = f
	return mmCallSubroutine.mock
}

// When sets expectation for the ExecutionContext.CallSubroutine which will trigger the result defined by the following
// Then helper
func (mmCallSubroutine *mExecutionContextMockCallSubroutine) When(s1 SubroutineStateMachine, m1 MigrateFunc, s2 SubroutineExitFunc) *ExecutionContextMockCallSubroutineExpectation {
	if mmCallSubroutine.mock.funcCallSubroutine != nil {
		mmCallSubroutine.mock.t.Fatalf("ExecutionContextMock.CallSubroutine mock is already set by Set")
	}

	expectation := &ExecutionContextMockCallSubroutineExpectation{
		mock:   mmCallSubroutine.mock,
		params: &ExecutionContextMockCallSubroutineParams{s1, m1, s2},
	}
	mmCallSubroutine.expectations = append(mmCallSubroutine.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.CallSubroutine return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockCallSubroutineExpectation) Then(s3 StateUpdate) *ExecutionContextMock {
	e.results = &ExecutionContextMockCallSubroutineResults{s3}
	return e.mock
}

// CallSubroutine implements ExecutionContext
func (mmCallSubroutine *ExecutionContextMock) CallSubroutine(s1 SubroutineStateMachine, m1 MigrateFunc, s2 SubroutineExitFunc) (s3 StateUpdate) {
	mm_atomic.AddUint64(&mmCallSubroutine.beforeCallSubroutineCounter, 1)
	defer mm_atomic.AddUint64(&mmCallSubroutine.afterCallSubroutineCounter, 1)

	if mmCallSubroutine.inspectFuncCallSubroutine != nil {
		mmCallSubroutine.inspectFuncCallSubroutine(s1, m1, s2)
	}

	mm_params := &ExecutionContextMockCallSubroutineParams{s1, m1, s2}

	// Record call args
	mmCallSubroutine.CallSubroutineMock.mutex.Lock()
	mmCallSubroutine.CallSubroutineMock.callArgs = append(mmCallSubroutine.CallSubroutineMock.callArgs, mm_params)
	mmCallSubroutine.CallSubroutineMock.mutex.Unlock()

	for _, e := range mmCallSubroutine.CallSubroutineMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s3
		}
	}

	if mmCallSubroutine.CallSubroutineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCallSubroutine.CallSubroutineMock.defaultExpectation.Counter, 1)
		mm_want := mmCallSubroutine.CallSubroutineMock.defaultExpectation.params
		mm_got := ExecutionContextMockCallSubroutineParams{s1, m1, s2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCallSubroutine.t.Errorf("ExecutionContextMock.CallSubroutine got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCallSubroutine.CallSubroutineMock.defaultExpectation.results
		if mm_results == nil {
			mmCallSubroutine.t.Fatal("No results are set for the ExecutionContextMock.CallSubroutine")
		}
		return (*mm_results).s3
	}
	if mmCallSubroutine.funcCallSubroutine != nil {
		return mmCallSubroutine.funcCallSubroutine(s1, m1, s2)
	}
	mmCallSubroutine.t.Fatalf("Unexpected call to ExecutionContextMock.CallSubroutine. %v %v %v", s1, m1, s2)
	return
}

// CallSubroutineAfterCounter returns a count of finished ExecutionContextMock.CallSubroutine invocations
func (mmCallSubroutine *ExecutionContextMock) CallSubroutineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallSubroutine.afterCallSubroutineCounter)
}

// CallSubroutineBeforeCounter returns a count of ExecutionContextMock.CallSubroutine invocations
func (mmCallSubroutine *ExecutionContextMock) CallSubroutineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallSubroutine.beforeCallSubroutineCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.CallSubroutine.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCallSubroutine *mExecutionContextMockCallSubroutine) Calls() []*ExecutionContextMockCallSubroutineParams {
	mmCallSubroutine.mutex.RLock()

	argCopy := make([]*ExecutionContextMockCallSubroutineParams, len(mmCallSubroutine.callArgs))
	copy(argCopy, mmCallSubroutine.callArgs)

	mmCallSubroutine.mutex.RUnlock()

	return argCopy
}

// MinimockCallSubroutineDone returns true if the count of the CallSubroutine invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockCallSubroutineDone() bool {
	for _, e := range m.CallSubroutineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallSubroutineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallSubroutineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallSubroutine != nil && mm_atomic.LoadUint64(&m.afterCallSubroutineCounter) < 1 {
		return false
	}
	return true
}

// MinimockCallSubroutineInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockCallSubroutineInspect() {
	for _, e := range m.CallSubroutineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.CallSubroutine with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallSubroutineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallSubroutineCounter) < 1 {
		if m.CallSubroutineMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.CallSubroutine")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.CallSubroutine with params: %#v", *m.CallSubroutineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallSubroutine != nil && mm_atomic.LoadUint64(&m.afterCallSubroutineCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.CallSubroutine")
	}
}

type mExecutionContextMockCheck struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockCheckExpectation
	expectations       []*ExecutionContextMockCheckExpectation

	callArgs []*ExecutionContextMockCheckParams
	mutex    sync.RWMutex
}

// ExecutionContextMockCheckExpectation specifies expectation struct of the ExecutionContext.Check
type ExecutionContextMockCheckExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockCheckParams
	results *ExecutionContextMockCheckResults
	Counter uint64
}

// ExecutionContextMockCheckParams contains parameters of the ExecutionContext.Check
type ExecutionContextMockCheckParams struct {
	s1 SyncLink
}

// ExecutionContextMockCheckResults contains results of the ExecutionContext.Check
type ExecutionContextMockCheckResults struct {
	b1 BoolDecision
}

// Expect sets up expected params for ExecutionContext.Check
func (mmCheck *mExecutionContextMockCheck) Expect(s1 SyncLink) *mExecutionContextMockCheck {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("ExecutionContextMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &ExecutionContextMockCheckExpectation{}
	}

	mmCheck.defaultExpectation.params = &ExecutionContextMockCheckParams{s1}
	for _, e := range mmCheck.expectations {
		if minimock.Equal(e.params, mmCheck.defaultExpectation.params) {
			mmCheck.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheck.defaultExpectation.params)
		}
	}

	return mmCheck
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Check
func (mmCheck *mExecutionContextMockCheck) Inspect(f func(s1 SyncLink)) *mExecutionContextMockCheck {
	if mmCheck.mock.inspectFuncCheck != nil {
		mmCheck.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Check")
	}

	mmCheck.mock.inspectFuncCheck = f

	return mmCheck
}

// Return sets up results that will be returned by ExecutionContext.Check
func (mmCheck *mExecutionContextMockCheck) Return(b1 BoolDecision) *ExecutionContextMock {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("ExecutionContextMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &ExecutionContextMockCheckExpectation{mock: mmCheck.mock}
	}
	mmCheck.defaultExpectation.results = &ExecutionContextMockCheckResults{b1}
	return mmCheck.mock
}

//Set uses given function f to mock the ExecutionContext.Check method
func (mmCheck *mExecutionContextMockCheck) Set(f func(s1 SyncLink) (b1 BoolDecision)) *ExecutionContextMock {
	if mmCheck.defaultExpectation != nil {
		mmCheck.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Check method")
	}

	if len(mmCheck.expectations) > 0 {
		mmCheck.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Check method")
	}

	mmCheck.mock.funcCheck = f
	return mmCheck.mock
}

// When sets expectation for the ExecutionContext.Check which will trigger the result defined by the following
// Then helper
func (mmCheck *mExecutionContextMockCheck) When(s1 SyncLink) *ExecutionContextMockCheckExpectation {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("ExecutionContextMock.Check mock is already set by Set")
	}

	expectation := &ExecutionContextMockCheckExpectation{
		mock:   mmCheck.mock,
		params: &ExecutionContextMockCheckParams{s1},
	}
	mmCheck.expectations = append(mmCheck.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.Check return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockCheckExpectation) Then(b1 BoolDecision) *ExecutionContextMock {
	e.results = &ExecutionContextMockCheckResults{b1}
	return e.mock
}

// Check implements ExecutionContext
func (mmCheck *ExecutionContextMock) Check(s1 SyncLink) (b1 BoolDecision) {
	mm_atomic.AddUint64(&mmCheck.beforeCheckCounter, 1)
	defer mm_atomic.AddUint64(&mmCheck.afterCheckCounter, 1)

	if mmCheck.inspectFuncCheck != nil {
		mmCheck.inspectFuncCheck(s1)
	}

	mm_params := &ExecutionContextMockCheckParams{s1}

	// Record call args
	mmCheck.CheckMock.mutex.Lock()
	mmCheck.CheckMock.callArgs = append(mmCheck.CheckMock.callArgs, mm_params)
	mmCheck.CheckMock.mutex.Unlock()

	for _, e := range mmCheck.CheckMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmCheck.CheckMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheck.CheckMock.defaultExpectation.Counter, 1)
		mm_want := mmCheck.CheckMock.defaultExpectation.params
		mm_got := ExecutionContextMockCheckParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheck.t.Errorf("ExecutionContextMock.Check got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheck.CheckMock.defaultExpectation.results
		if mm_results == nil {
			mmCheck.t.Fatal("No results are set for the ExecutionContextMock.Check")
		}
		return (*mm_results).b1
	}
	if mmCheck.funcCheck != nil {
		return mmCheck.funcCheck(s1)
	}
	mmCheck.t.Fatalf("Unexpected call to ExecutionContextMock.Check. %v", s1)
	return
}

// CheckAfterCounter returns a count of finished ExecutionContextMock.Check invocations
func (mmCheck *ExecutionContextMock) CheckAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheck.afterCheckCounter)
}

// CheckBeforeCounter returns a count of ExecutionContextMock.Check invocations
func (mmCheck *ExecutionContextMock) CheckBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheck.beforeCheckCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.Check.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheck *mExecutionContextMockCheck) Calls() []*ExecutionContextMockCheckParams {
	mmCheck.mutex.RLock()

	argCopy := make([]*ExecutionContextMockCheckParams, len(mmCheck.callArgs))
	copy(argCopy, mmCheck.callArgs)

	mmCheck.mutex.RUnlock()

	return argCopy
}

// MinimockCheckDone returns true if the count of the Check invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockCheckDone() bool {
	for _, e := range m.CheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheck != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		return false
	}
	return true
}

// MinimockCheckInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockCheckInspect() {
	for _, e := range m.CheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.Check with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		if m.CheckMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.Check")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.Check with params: %#v", *m.CheckMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheck != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Check")
	}
}

type mExecutionContextMockError struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockErrorExpectation
	expectations       []*ExecutionContextMockErrorExpectation

	callArgs []*ExecutionContextMockErrorParams
	mutex    sync.RWMutex
}

// ExecutionContextMockErrorExpectation specifies expectation struct of the ExecutionContext.Error
type ExecutionContextMockErrorExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockErrorParams
	results *ExecutionContextMockErrorResults
	Counter uint64
}

// ExecutionContextMockErrorParams contains parameters of the ExecutionContext.Error
type ExecutionContextMockErrorParams struct {
	e1 error
}

// ExecutionContextMockErrorResults contains results of the ExecutionContext.Error
type ExecutionContextMockErrorResults struct {
	s1 StateUpdate
}

// Expect sets up expected params for ExecutionContext.Error
func (mmError *mExecutionContextMockError) Expect(e1 error) *mExecutionContextMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("ExecutionContextMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &ExecutionContextMockErrorExpectation{}
	}

	mmError.defaultExpectation.params = &ExecutionContextMockErrorParams{e1}
	for _, e := range mmError.expectations {
		if minimock.Equal(e.params, mmError.defaultExpectation.params) {
			mmError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmError.defaultExpectation.params)
		}
	}

	return mmError
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Error
func (mmError *mExecutionContextMockError) Inspect(f func(e1 error)) *mExecutionContextMockError {
	if mmError.mock.inspectFuncError != nil {
		mmError.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Error")
	}

	mmError.mock.inspectFuncError = f

	return mmError
}

// Return sets up results that will be returned by ExecutionContext.Error
func (mmError *mExecutionContextMockError) Return(s1 StateUpdate) *ExecutionContextMock {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("ExecutionContextMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &ExecutionContextMockErrorExpectation{mock: mmError.mock}
	}
	mmError.defaultExpectation.results = &ExecutionContextMockErrorResults{s1}
	return mmError.mock
}

//Set uses given function f to mock the ExecutionContext.Error method
func (mmError *mExecutionContextMockError) Set(f func(e1 error) (s1 StateUpdate)) *ExecutionContextMock {
	if mmError.defaultExpectation != nil {
		mmError.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Error method")
	}

	if len(mmError.expectations) > 0 {
		mmError.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Error method")
	}

	mmError.mock.funcError = f
	return mmError.mock
}

// When sets expectation for the ExecutionContext.Error which will trigger the result defined by the following
// Then helper
func (mmError *mExecutionContextMockError) When(e1 error) *ExecutionContextMockErrorExpectation {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("ExecutionContextMock.Error mock is already set by Set")
	}

	expectation := &ExecutionContextMockErrorExpectation{
		mock:   mmError.mock,
		params: &ExecutionContextMockErrorParams{e1},
	}
	mmError.expectations = append(mmError.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.Error return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockErrorExpectation) Then(s1 StateUpdate) *ExecutionContextMock {
	e.results = &ExecutionContextMockErrorResults{s1}
	return e.mock
}

// Error implements ExecutionContext
func (mmError *ExecutionContextMock) Error(e1 error) (s1 StateUpdate) {
	mm_atomic.AddUint64(&mmError.beforeErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmError.afterErrorCounter, 1)

	if mmError.inspectFuncError != nil {
		mmError.inspectFuncError(e1)
	}

	mm_params := &ExecutionContextMockErrorParams{e1}

	// Record call args
	mmError.ErrorMock.mutex.Lock()
	mmError.ErrorMock.callArgs = append(mmError.ErrorMock.callArgs, mm_params)
	mmError.ErrorMock.mutex.Unlock()

	for _, e := range mmError.ErrorMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmError.ErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmError.ErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmError.ErrorMock.defaultExpectation.params
		mm_got := ExecutionContextMockErrorParams{e1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmError.t.Errorf("ExecutionContextMock.Error got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmError.ErrorMock.defaultExpectation.results
		if mm_results == nil {
			mmError.t.Fatal("No results are set for the ExecutionContextMock.Error")
		}
		return (*mm_results).s1
	}
	if mmError.funcError != nil {
		return mmError.funcError(e1)
	}
	mmError.t.Fatalf("Unexpected call to ExecutionContextMock.Error. %v", e1)
	return
}

// ErrorAfterCounter returns a count of finished ExecutionContextMock.Error invocations
func (mmError *ExecutionContextMock) ErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.afterErrorCounter)
}

// ErrorBeforeCounter returns a count of ExecutionContextMock.Error invocations
func (mmError *ExecutionContextMock) ErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.beforeErrorCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.Error.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmError *mExecutionContextMockError) Calls() []*ExecutionContextMockErrorParams {
	mmError.mutex.RLock()

	argCopy := make([]*ExecutionContextMockErrorParams, len(mmError.callArgs))
	copy(argCopy, mmError.callArgs)

	mmError.mutex.RUnlock()

	return argCopy
}

// MinimockErrorDone returns true if the count of the Error invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockErrorDone() bool {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	return true
}

// MinimockErrorInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockErrorInspect() {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.Error with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		if m.ErrorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.Error")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.Error with params: %#v", *m.ErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Error")
	}
}

type mExecutionContextMockGetContext struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockGetContextExpectation
	expectations       []*ExecutionContextMockGetContextExpectation
}

// ExecutionContextMockGetContextExpectation specifies expectation struct of the ExecutionContext.GetContext
type ExecutionContextMockGetContextExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockGetContextResults
	Counter uint64
}

// ExecutionContextMockGetContextResults contains results of the ExecutionContext.GetContext
type ExecutionContextMockGetContextResults struct {
	c1 context.Context
}

// Expect sets up expected params for ExecutionContext.GetContext
func (mmGetContext *mExecutionContextMockGetContext) Expect() *mExecutionContextMockGetContext {
	if mmGetContext.mock.funcGetContext != nil {
		mmGetContext.mock.t.Fatalf("ExecutionContextMock.GetContext mock is already set by Set")
	}

	if mmGetContext.defaultExpectation == nil {
		mmGetContext.defaultExpectation = &ExecutionContextMockGetContextExpectation{}
	}

	return mmGetContext
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.GetContext
func (mmGetContext *mExecutionContextMockGetContext) Inspect(f func()) *mExecutionContextMockGetContext {
	if mmGetContext.mock.inspectFuncGetContext != nil {
		mmGetContext.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.GetContext")
	}

	mmGetContext.mock.inspectFuncGetContext = f

	return mmGetContext
}

// Return sets up results that will be returned by ExecutionContext.GetContext
func (mmGetContext *mExecutionContextMockGetContext) Return(c1 context.Context) *ExecutionContextMock {
	if mmGetContext.mock.funcGetContext != nil {
		mmGetContext.mock.t.Fatalf("ExecutionContextMock.GetContext mock is already set by Set")
	}

	if mmGetContext.defaultExpectation == nil {
		mmGetContext.defaultExpectation = &ExecutionContextMockGetContextExpectation{mock: mmGetContext.mock}
	}
	mmGetContext.defaultExpectation.results = &ExecutionContextMockGetContextResults{c1}
	return mmGetContext.mock
}

//Set uses given function f to mock the ExecutionContext.GetContext method
func (mmGetContext *mExecutionContextMockGetContext) Set(f func() (c1 context.Context)) *ExecutionContextMock {
	if mmGetContext.defaultExpectation != nil {
		mmGetContext.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.GetContext method")
	}

	if len(mmGetContext.expectations) > 0 {
		mmGetContext.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.GetContext method")
	}

	mmGetContext.mock.funcGetContext = f
	return mmGetContext.mock
}

// GetContext implements ExecutionContext
func (mmGetContext *ExecutionContextMock) GetContext() (c1 context.Context) {
	mm_atomic.AddUint64(&mmGetContext.beforeGetContextCounter, 1)
	defer mm_atomic.AddUint64(&mmGetContext.afterGetContextCounter, 1)

	if mmGetContext.inspectFuncGetContext != nil {
		mmGetContext.inspectFuncGetContext()
	}

	if mmGetContext.GetContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetContext.GetContextMock.defaultExpectation.Counter, 1)

		mm_results := mmGetContext.GetContextMock.defaultExpectation.results
		if mm_results == nil {
			mmGetContext.t.Fatal("No results are set for the ExecutionContextMock.GetContext")
		}
		return (*mm_results).c1
	}
	if mmGetContext.funcGetContext != nil {
		return mmGetContext.funcGetContext()
	}
	mmGetContext.t.Fatalf("Unexpected call to ExecutionContextMock.GetContext.")
	return
}

// GetContextAfterCounter returns a count of finished ExecutionContextMock.GetContext invocations
func (mmGetContext *ExecutionContextMock) GetContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContext.afterGetContextCounter)
}

// GetContextBeforeCounter returns a count of ExecutionContextMock.GetContext invocations
func (mmGetContext *ExecutionContextMock) GetContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContext.beforeGetContextCounter)
}

// MinimockGetContextDone returns true if the count of the GetContext invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockGetContextDone() bool {
	for _, e := range m.GetContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetContext != nil && mm_atomic.LoadUint64(&m.afterGetContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetContextInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockGetContextInspect() {
	for _, e := range m.GetContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.GetContext")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetContextCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.GetContext")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetContext != nil && mm_atomic.LoadUint64(&m.afterGetContextCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.GetContext")
	}
}

type mExecutionContextMockGetPendingCallCount struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockGetPendingCallCountExpectation
	expectations       []*ExecutionContextMockGetPendingCallCountExpectation
}

// ExecutionContextMockGetPendingCallCountExpectation specifies expectation struct of the ExecutionContext.GetPendingCallCount
type ExecutionContextMockGetPendingCallCountExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockGetPendingCallCountResults
	Counter uint64
}

// ExecutionContextMockGetPendingCallCountResults contains results of the ExecutionContext.GetPendingCallCount
type ExecutionContextMockGetPendingCallCountResults struct {
	i1 int
}

// Expect sets up expected params for ExecutionContext.GetPendingCallCount
func (mmGetPendingCallCount *mExecutionContextMockGetPendingCallCount) Expect() *mExecutionContextMockGetPendingCallCount {
	if mmGetPendingCallCount.mock.funcGetPendingCallCount != nil {
		mmGetPendingCallCount.mock.t.Fatalf("ExecutionContextMock.GetPendingCallCount mock is already set by Set")
	}

	if mmGetPendingCallCount.defaultExpectation == nil {
		mmGetPendingCallCount.defaultExpectation = &ExecutionContextMockGetPendingCallCountExpectation{}
	}

	return mmGetPendingCallCount
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.GetPendingCallCount
func (mmGetPendingCallCount *mExecutionContextMockGetPendingCallCount) Inspect(f func()) *mExecutionContextMockGetPendingCallCount {
	if mmGetPendingCallCount.mock.inspectFuncGetPendingCallCount != nil {
		mmGetPendingCallCount.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.GetPendingCallCount")
	}

	mmGetPendingCallCount.mock.inspectFuncGetPendingCallCount = f

	return mmGetPendingCallCount
}

// Return sets up results that will be returned by ExecutionContext.GetPendingCallCount
func (mmGetPendingCallCount *mExecutionContextMockGetPendingCallCount) Return(i1 int) *ExecutionContextMock {
	if mmGetPendingCallCount.mock.funcGetPendingCallCount != nil {
		mmGetPendingCallCount.mock.t.Fatalf("ExecutionContextMock.GetPendingCallCount mock is already set by Set")
	}

	if mmGetPendingCallCount.defaultExpectation == nil {
		mmGetPendingCallCount.defaultExpectation = &ExecutionContextMockGetPendingCallCountExpectation{mock: mmGetPendingCallCount.mock}
	}
	mmGetPendingCallCount.defaultExpectation.results = &ExecutionContextMockGetPendingCallCountResults{i1}
	return mmGetPendingCallCount.mock
}

//Set uses given function f to mock the ExecutionContext.GetPendingCallCount method
func (mmGetPendingCallCount *mExecutionContextMockGetPendingCallCount) Set(f func() (i1 int)) *ExecutionContextMock {
	if mmGetPendingCallCount.defaultExpectation != nil {
		mmGetPendingCallCount.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.GetPendingCallCount method")
	}

	if len(mmGetPendingCallCount.expectations) > 0 {
		mmGetPendingCallCount.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.GetPendingCallCount method")
	}

	mmGetPendingCallCount.mock.funcGetPendingCallCount = f
	return mmGetPendingCallCount.mock
}

// GetPendingCallCount implements ExecutionContext
func (mmGetPendingCallCount *ExecutionContextMock) GetPendingCallCount() (i1 int) {
	mm_atomic.AddUint64(&mmGetPendingCallCount.beforeGetPendingCallCountCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPendingCallCount.afterGetPendingCallCountCounter, 1)

	if mmGetPendingCallCount.inspectFuncGetPendingCallCount != nil {
		mmGetPendingCallCount.inspectFuncGetPendingCallCount()
	}

	if mmGetPendingCallCount.GetPendingCallCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPendingCallCount.GetPendingCallCountMock.defaultExpectation.Counter, 1)

		mm_results := mmGetPendingCallCount.GetPendingCallCountMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPendingCallCount.t.Fatal("No results are set for the ExecutionContextMock.GetPendingCallCount")
		}
		return (*mm_results).i1
	}
	if mmGetPendingCallCount.funcGetPendingCallCount != nil {
		return mmGetPendingCallCount.funcGetPendingCallCount()
	}
	mmGetPendingCallCount.t.Fatalf("Unexpected call to ExecutionContextMock.GetPendingCallCount.")
	return
}

// GetPendingCallCountAfterCounter returns a count of finished ExecutionContextMock.GetPendingCallCount invocations
func (mmGetPendingCallCount *ExecutionContextMock) GetPendingCallCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPendingCallCount.afterGetPendingCallCountCounter)
}

// GetPendingCallCountBeforeCounter returns a count of ExecutionContextMock.GetPendingCallCount invocations
func (mmGetPendingCallCount *ExecutionContextMock) GetPendingCallCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPendingCallCount.beforeGetPendingCallCountCounter)
}

// MinimockGetPendingCallCountDone returns true if the count of the GetPendingCallCount invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockGetPendingCallCountDone() bool {
	for _, e := range m.GetPendingCallCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPendingCallCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPendingCallCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPendingCallCount != nil && mm_atomic.LoadUint64(&m.afterGetPendingCallCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPendingCallCountInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockGetPendingCallCountInspect() {
	for _, e := range m.GetPendingCallCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.GetPendingCallCount")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPendingCallCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPendingCallCountCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.GetPendingCallCount")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPendingCallCount != nil && mm_atomic.LoadUint64(&m.afterGetPendingCallCountCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.GetPendingCallCount")
	}
}

type mExecutionContextMockGetPublished struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockGetPublishedExpectation
	expectations       []*ExecutionContextMockGetPublishedExpectation

	callArgs []*ExecutionContextMockGetPublishedParams
	mutex    sync.RWMutex
}

// ExecutionContextMockGetPublishedExpectation specifies expectation struct of the ExecutionContext.GetPublished
type ExecutionContextMockGetPublishedExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockGetPublishedParams
	results *ExecutionContextMockGetPublishedResults
	Counter uint64
}

// ExecutionContextMockGetPublishedParams contains parameters of the ExecutionContext.GetPublished
type ExecutionContextMockGetPublishedParams struct {
	key interface{}
}

// ExecutionContextMockGetPublishedResults contains results of the ExecutionContext.GetPublished
type ExecutionContextMockGetPublishedResults struct {
	p1 interface{}
}

// Expect sets up expected params for ExecutionContext.GetPublished
func (mmGetPublished *mExecutionContextMockGetPublished) Expect(key interface{}) *mExecutionContextMockGetPublished {
	if mmGetPublished.mock.funcGetPublished != nil {
		mmGetPublished.mock.t.Fatalf("ExecutionContextMock.GetPublished mock is already set by Set")
	}

	if mmGetPublished.defaultExpectation == nil {
		mmGetPublished.defaultExpectation = &ExecutionContextMockGetPublishedExpectation{}
	}

	mmGetPublished.defaultExpectation.params = &ExecutionContextMockGetPublishedParams{key}
	for _, e := range mmGetPublished.expectations {
		if minimock.Equal(e.params, mmGetPublished.defaultExpectation.params) {
			mmGetPublished.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPublished.defaultExpectation.params)
		}
	}

	return mmGetPublished
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.GetPublished
func (mmGetPublished *mExecutionContextMockGetPublished) Inspect(f func(key interface{})) *mExecutionContextMockGetPublished {
	if mmGetPublished.mock.inspectFuncGetPublished != nil {
		mmGetPublished.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.GetPublished")
	}

	mmGetPublished.mock.inspectFuncGetPublished = f

	return mmGetPublished
}

// Return sets up results that will be returned by ExecutionContext.GetPublished
func (mmGetPublished *mExecutionContextMockGetPublished) Return(p1 interface{}) *ExecutionContextMock {
	if mmGetPublished.mock.funcGetPublished != nil {
		mmGetPublished.mock.t.Fatalf("ExecutionContextMock.GetPublished mock is already set by Set")
	}

	if mmGetPublished.defaultExpectation == nil {
		mmGetPublished.defaultExpectation = &ExecutionContextMockGetPublishedExpectation{mock: mmGetPublished.mock}
	}
	mmGetPublished.defaultExpectation.results = &ExecutionContextMockGetPublishedResults{p1}
	return mmGetPublished.mock
}

//Set uses given function f to mock the ExecutionContext.GetPublished method
func (mmGetPublished *mExecutionContextMockGetPublished) Set(f func(key interface{}) (p1 interface{})) *ExecutionContextMock {
	if mmGetPublished.defaultExpectation != nil {
		mmGetPublished.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.GetPublished method")
	}

	if len(mmGetPublished.expectations) > 0 {
		mmGetPublished.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.GetPublished method")
	}

	mmGetPublished.mock.funcGetPublished = f
	return mmGetPublished.mock
}

// When sets expectation for the ExecutionContext.GetPublished which will trigger the result defined by the following
// Then helper
func (mmGetPublished *mExecutionContextMockGetPublished) When(key interface{}) *ExecutionContextMockGetPublishedExpectation {
	if mmGetPublished.mock.funcGetPublished != nil {
		mmGetPublished.mock.t.Fatalf("ExecutionContextMock.GetPublished mock is already set by Set")
	}

	expectation := &ExecutionContextMockGetPublishedExpectation{
		mock:   mmGetPublished.mock,
		params: &ExecutionContextMockGetPublishedParams{key},
	}
	mmGetPublished.expectations = append(mmGetPublished.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.GetPublished return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockGetPublishedExpectation) Then(p1 interface{}) *ExecutionContextMock {
	e.results = &ExecutionContextMockGetPublishedResults{p1}
	return e.mock
}

// GetPublished implements ExecutionContext
func (mmGetPublished *ExecutionContextMock) GetPublished(key interface{}) (p1 interface{}) {
	mm_atomic.AddUint64(&mmGetPublished.beforeGetPublishedCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPublished.afterGetPublishedCounter, 1)

	if mmGetPublished.inspectFuncGetPublished != nil {
		mmGetPublished.inspectFuncGetPublished(key)
	}

	mm_params := &ExecutionContextMockGetPublishedParams{key}

	// Record call args
	mmGetPublished.GetPublishedMock.mutex.Lock()
	mmGetPublished.GetPublishedMock.callArgs = append(mmGetPublished.GetPublishedMock.callArgs, mm_params)
	mmGetPublished.GetPublishedMock.mutex.Unlock()

	for _, e := range mmGetPublished.GetPublishedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1
		}
	}

	if mmGetPublished.GetPublishedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPublished.GetPublishedMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPublished.GetPublishedMock.defaultExpectation.params
		mm_got := ExecutionContextMockGetPublishedParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPublished.t.Errorf("ExecutionContextMock.GetPublished got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPublished.GetPublishedMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPublished.t.Fatal("No results are set for the ExecutionContextMock.GetPublished")
		}
		return (*mm_results).p1
	}
	if mmGetPublished.funcGetPublished != nil {
		return mmGetPublished.funcGetPublished(key)
	}
	mmGetPublished.t.Fatalf("Unexpected call to ExecutionContextMock.GetPublished. %v", key)
	return
}

// GetPublishedAfterCounter returns a count of finished ExecutionContextMock.GetPublished invocations
func (mmGetPublished *ExecutionContextMock) GetPublishedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublished.afterGetPublishedCounter)
}

// GetPublishedBeforeCounter returns a count of ExecutionContextMock.GetPublished invocations
func (mmGetPublished *ExecutionContextMock) GetPublishedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublished.beforeGetPublishedCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.GetPublished.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPublished *mExecutionContextMockGetPublished) Calls() []*ExecutionContextMockGetPublishedParams {
	mmGetPublished.mutex.RLock()

	argCopy := make([]*ExecutionContextMockGetPublishedParams, len(mmGetPublished.callArgs))
	copy(argCopy, mmGetPublished.callArgs)

	mmGetPublished.mutex.RUnlock()

	return argCopy
}

// MinimockGetPublishedDone returns true if the count of the GetPublished invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockGetPublishedDone() bool {
	for _, e := range m.GetPublishedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublished != nil && mm_atomic.LoadUint64(&m.afterGetPublishedCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPublishedInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockGetPublishedInspect() {
	for _, e := range m.GetPublishedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.GetPublished with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedCounter) < 1 {
		if m.GetPublishedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.GetPublished")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.GetPublished with params: %#v", *m.GetPublishedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublished != nil && mm_atomic.LoadUint64(&m.afterGetPublishedCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.GetPublished")
	}
}

type mExecutionContextMockGetPublishedGlobalAlias struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockGetPublishedGlobalAliasExpectation
	expectations       []*ExecutionContextMockGetPublishedGlobalAliasExpectation

	callArgs []*ExecutionContextMockGetPublishedGlobalAliasParams
	mutex    sync.RWMutex
}

// ExecutionContextMockGetPublishedGlobalAliasExpectation specifies expectation struct of the ExecutionContext.GetPublishedGlobalAlias
type ExecutionContextMockGetPublishedGlobalAliasExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockGetPublishedGlobalAliasParams
	results *ExecutionContextMockGetPublishedGlobalAliasResults
	Counter uint64
}

// ExecutionContextMockGetPublishedGlobalAliasParams contains parameters of the ExecutionContext.GetPublishedGlobalAlias
type ExecutionContextMockGetPublishedGlobalAliasParams struct {
	key interface{}
}

// ExecutionContextMockGetPublishedGlobalAliasResults contains results of the ExecutionContext.GetPublishedGlobalAlias
type ExecutionContextMockGetPublishedGlobalAliasResults struct {
	s1 SlotLink
}

// Expect sets up expected params for ExecutionContext.GetPublishedGlobalAlias
func (mmGetPublishedGlobalAlias *mExecutionContextMockGetPublishedGlobalAlias) Expect(key interface{}) *mExecutionContextMockGetPublishedGlobalAlias {
	if mmGetPublishedGlobalAlias.mock.funcGetPublishedGlobalAlias != nil {
		mmGetPublishedGlobalAlias.mock.t.Fatalf("ExecutionContextMock.GetPublishedGlobalAlias mock is already set by Set")
	}

	if mmGetPublishedGlobalAlias.defaultExpectation == nil {
		mmGetPublishedGlobalAlias.defaultExpectation = &ExecutionContextMockGetPublishedGlobalAliasExpectation{}
	}

	mmGetPublishedGlobalAlias.defaultExpectation.params = &ExecutionContextMockGetPublishedGlobalAliasParams{key}
	for _, e := range mmGetPublishedGlobalAlias.expectations {
		if minimock.Equal(e.params, mmGetPublishedGlobalAlias.defaultExpectation.params) {
			mmGetPublishedGlobalAlias.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPublishedGlobalAlias.defaultExpectation.params)
		}
	}

	return mmGetPublishedGlobalAlias
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.GetPublishedGlobalAlias
func (mmGetPublishedGlobalAlias *mExecutionContextMockGetPublishedGlobalAlias) Inspect(f func(key interface{})) *mExecutionContextMockGetPublishedGlobalAlias {
	if mmGetPublishedGlobalAlias.mock.inspectFuncGetPublishedGlobalAlias != nil {
		mmGetPublishedGlobalAlias.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.GetPublishedGlobalAlias")
	}

	mmGetPublishedGlobalAlias.mock.inspectFuncGetPublishedGlobalAlias = f

	return mmGetPublishedGlobalAlias
}

// Return sets up results that will be returned by ExecutionContext.GetPublishedGlobalAlias
func (mmGetPublishedGlobalAlias *mExecutionContextMockGetPublishedGlobalAlias) Return(s1 SlotLink) *ExecutionContextMock {
	if mmGetPublishedGlobalAlias.mock.funcGetPublishedGlobalAlias != nil {
		mmGetPublishedGlobalAlias.mock.t.Fatalf("ExecutionContextMock.GetPublishedGlobalAlias mock is already set by Set")
	}

	if mmGetPublishedGlobalAlias.defaultExpectation == nil {
		mmGetPublishedGlobalAlias.defaultExpectation = &ExecutionContextMockGetPublishedGlobalAliasExpectation{mock: mmGetPublishedGlobalAlias.mock}
	}
	mmGetPublishedGlobalAlias.defaultExpectation.results = &ExecutionContextMockGetPublishedGlobalAliasResults{s1}
	return mmGetPublishedGlobalAlias.mock
}

//Set uses given function f to mock the ExecutionContext.GetPublishedGlobalAlias method
func (mmGetPublishedGlobalAlias *mExecutionContextMockGetPublishedGlobalAlias) Set(f func(key interface{}) (s1 SlotLink)) *ExecutionContextMock {
	if mmGetPublishedGlobalAlias.defaultExpectation != nil {
		mmGetPublishedGlobalAlias.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.GetPublishedGlobalAlias method")
	}

	if len(mmGetPublishedGlobalAlias.expectations) > 0 {
		mmGetPublishedGlobalAlias.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.GetPublishedGlobalAlias method")
	}

	mmGetPublishedGlobalAlias.mock.funcGetPublishedGlobalAlias = f
	return mmGetPublishedGlobalAlias.mock
}

// When sets expectation for the ExecutionContext.GetPublishedGlobalAlias which will trigger the result defined by the following
// Then helper
func (mmGetPublishedGlobalAlias *mExecutionContextMockGetPublishedGlobalAlias) When(key interface{}) *ExecutionContextMockGetPublishedGlobalAliasExpectation {
	if mmGetPublishedGlobalAlias.mock.funcGetPublishedGlobalAlias != nil {
		mmGetPublishedGlobalAlias.mock.t.Fatalf("ExecutionContextMock.GetPublishedGlobalAlias mock is already set by Set")
	}

	expectation := &ExecutionContextMockGetPublishedGlobalAliasExpectation{
		mock:   mmGetPublishedGlobalAlias.mock,
		params: &ExecutionContextMockGetPublishedGlobalAliasParams{key},
	}
	mmGetPublishedGlobalAlias.expectations = append(mmGetPublishedGlobalAlias.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.GetPublishedGlobalAlias return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockGetPublishedGlobalAliasExpectation) Then(s1 SlotLink) *ExecutionContextMock {
	e.results = &ExecutionContextMockGetPublishedGlobalAliasResults{s1}
	return e.mock
}

// GetPublishedGlobalAlias implements ExecutionContext
func (mmGetPublishedGlobalAlias *ExecutionContextMock) GetPublishedGlobalAlias(key interface{}) (s1 SlotLink) {
	mm_atomic.AddUint64(&mmGetPublishedGlobalAlias.beforeGetPublishedGlobalAliasCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPublishedGlobalAlias.afterGetPublishedGlobalAliasCounter, 1)

	if mmGetPublishedGlobalAlias.inspectFuncGetPublishedGlobalAlias != nil {
		mmGetPublishedGlobalAlias.inspectFuncGetPublishedGlobalAlias(key)
	}

	mm_params := &ExecutionContextMockGetPublishedGlobalAliasParams{key}

	// Record call args
	mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.mutex.Lock()
	mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.callArgs = append(mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.callArgs, mm_params)
	mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.mutex.Unlock()

	for _, e := range mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.defaultExpectation.params
		mm_got := ExecutionContextMockGetPublishedGlobalAliasParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPublishedGlobalAlias.t.Errorf("ExecutionContextMock.GetPublishedGlobalAlias got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPublishedGlobalAlias.t.Fatal("No results are set for the ExecutionContextMock.GetPublishedGlobalAlias")
		}
		return (*mm_results).s1
	}
	if mmGetPublishedGlobalAlias.funcGetPublishedGlobalAlias != nil {
		return mmGetPublishedGlobalAlias.funcGetPublishedGlobalAlias(key)
	}
	mmGetPublishedGlobalAlias.t.Fatalf("Unexpected call to ExecutionContextMock.GetPublishedGlobalAlias. %v", key)
	return
}

// GetPublishedGlobalAliasAfterCounter returns a count of finished ExecutionContextMock.GetPublishedGlobalAlias invocations
func (mmGetPublishedGlobalAlias *ExecutionContextMock) GetPublishedGlobalAliasAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublishedGlobalAlias.afterGetPublishedGlobalAliasCounter)
}

// GetPublishedGlobalAliasBeforeCounter returns a count of ExecutionContextMock.GetPublishedGlobalAlias invocations
func (mmGetPublishedGlobalAlias *ExecutionContextMock) GetPublishedGlobalAliasBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublishedGlobalAlias.beforeGetPublishedGlobalAliasCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.GetPublishedGlobalAlias.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPublishedGlobalAlias *mExecutionContextMockGetPublishedGlobalAlias) Calls() []*ExecutionContextMockGetPublishedGlobalAliasParams {
	mmGetPublishedGlobalAlias.mutex.RLock()

	argCopy := make([]*ExecutionContextMockGetPublishedGlobalAliasParams, len(mmGetPublishedGlobalAlias.callArgs))
	copy(argCopy, mmGetPublishedGlobalAlias.callArgs)

	mmGetPublishedGlobalAlias.mutex.RUnlock()

	return argCopy
}

// MinimockGetPublishedGlobalAliasDone returns true if the count of the GetPublishedGlobalAlias invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockGetPublishedGlobalAliasDone() bool {
	for _, e := range m.GetPublishedGlobalAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedGlobalAliasMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublishedGlobalAlias != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPublishedGlobalAliasInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockGetPublishedGlobalAliasInspect() {
	for _, e := range m.GetPublishedGlobalAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.GetPublishedGlobalAlias with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedGlobalAliasMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasCounter) < 1 {
		if m.GetPublishedGlobalAliasMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.GetPublishedGlobalAlias")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.GetPublishedGlobalAlias with params: %#v", *m.GetPublishedGlobalAliasMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublishedGlobalAlias != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.GetPublishedGlobalAlias")
	}
}

type mExecutionContextMockGetPublishedGlobalAliasAndBargeIn struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockGetPublishedGlobalAliasAndBargeInExpectation
	expectations       []*ExecutionContextMockGetPublishedGlobalAliasAndBargeInExpectation

	callArgs []*ExecutionContextMockGetPublishedGlobalAliasAndBargeInParams
	mutex    sync.RWMutex
}

// ExecutionContextMockGetPublishedGlobalAliasAndBargeInExpectation specifies expectation struct of the ExecutionContext.GetPublishedGlobalAliasAndBargeIn
type ExecutionContextMockGetPublishedGlobalAliasAndBargeInExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockGetPublishedGlobalAliasAndBargeInParams
	results *ExecutionContextMockGetPublishedGlobalAliasAndBargeInResults
	Counter uint64
}

// ExecutionContextMockGetPublishedGlobalAliasAndBargeInParams contains parameters of the ExecutionContext.GetPublishedGlobalAliasAndBargeIn
type ExecutionContextMockGetPublishedGlobalAliasAndBargeInParams struct {
	key interface{}
}

// ExecutionContextMockGetPublishedGlobalAliasAndBargeInResults contains results of the ExecutionContext.GetPublishedGlobalAliasAndBargeIn
type ExecutionContextMockGetPublishedGlobalAliasAndBargeInResults struct {
	s1 SlotLink
	b1 BargeInHolder
}

// Expect sets up expected params for ExecutionContext.GetPublishedGlobalAliasAndBargeIn
func (mmGetPublishedGlobalAliasAndBargeIn *mExecutionContextMockGetPublishedGlobalAliasAndBargeIn) Expect(key interface{}) *mExecutionContextMockGetPublishedGlobalAliasAndBargeIn {
	if mmGetPublishedGlobalAliasAndBargeIn.mock.funcGetPublishedGlobalAliasAndBargeIn != nil {
		mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("ExecutionContextMock.GetPublishedGlobalAliasAndBargeIn mock is already set by Set")
	}

	if mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation == nil {
		mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation = &ExecutionContextMockGetPublishedGlobalAliasAndBargeInExpectation{}
	}

	mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation.params = &ExecutionContextMockGetPublishedGlobalAliasAndBargeInParams{key}
	for _, e := range mmGetPublishedGlobalAliasAndBargeIn.expectations {
		if minimock.Equal(e.params, mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation.params) {
			mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation.params)
		}
	}

	return mmGetPublishedGlobalAliasAndBargeIn
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.GetPublishedGlobalAliasAndBargeIn
func (mmGetPublishedGlobalAliasAndBargeIn *mExecutionContextMockGetPublishedGlobalAliasAndBargeIn) Inspect(f func(key interface{})) *mExecutionContextMockGetPublishedGlobalAliasAndBargeIn {
	if mmGetPublishedGlobalAliasAndBargeIn.mock.inspectFuncGetPublishedGlobalAliasAndBargeIn != nil {
		mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.GetPublishedGlobalAliasAndBargeIn")
	}

	mmGetPublishedGlobalAliasAndBargeIn.mock.inspectFuncGetPublishedGlobalAliasAndBargeIn = f

	return mmGetPublishedGlobalAliasAndBargeIn
}

// Return sets up results that will be returned by ExecutionContext.GetPublishedGlobalAliasAndBargeIn
func (mmGetPublishedGlobalAliasAndBargeIn *mExecutionContextMockGetPublishedGlobalAliasAndBargeIn) Return(s1 SlotLink, b1 BargeInHolder) *ExecutionContextMock {
	if mmGetPublishedGlobalAliasAndBargeIn.mock.funcGetPublishedGlobalAliasAndBargeIn != nil {
		mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("ExecutionContextMock.GetPublishedGlobalAliasAndBargeIn mock is already set by Set")
	}

	if mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation == nil {
		mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation = &ExecutionContextMockGetPublishedGlobalAliasAndBargeInExpectation{mock: mmGetPublishedGlobalAliasAndBargeIn.mock}
	}
	mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation.results = &ExecutionContextMockGetPublishedGlobalAliasAndBargeInResults{s1, b1}
	return mmGetPublishedGlobalAliasAndBargeIn.mock
}

//Set uses given function f to mock the ExecutionContext.GetPublishedGlobalAliasAndBargeIn method
func (mmGetPublishedGlobalAliasAndBargeIn *mExecutionContextMockGetPublishedGlobalAliasAndBargeIn) Set(f func(key interface{}) (s1 SlotLink, b1 BargeInHolder)) *ExecutionContextMock {
	if mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation != nil {
		mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.GetPublishedGlobalAliasAndBargeIn method")
	}

	if len(mmGetPublishedGlobalAliasAndBargeIn.expectations) > 0 {
		mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.GetPublishedGlobalAliasAndBargeIn method")
	}

	mmGetPublishedGlobalAliasAndBargeIn.mock.funcGetPublishedGlobalAliasAndBargeIn = f
	return mmGetPublishedGlobalAliasAndBargeIn.mock
}

// When sets expectation for the ExecutionContext.GetPublishedGlobalAliasAndBargeIn which will trigger the result defined by the following
// Then helper
func (mmGetPublishedGlobalAliasAndBargeIn *mExecutionContextMockGetPublishedGlobalAliasAndBargeIn) When(key interface{}) *ExecutionContextMockGetPublishedGlobalAliasAndBargeInExpectation {
	if mmGetPublishedGlobalAliasAndBargeIn.mock.funcGetPublishedGlobalAliasAndBargeIn != nil {
		mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("ExecutionContextMock.GetPublishedGlobalAliasAndBargeIn mock is already set by Set")
	}

	expectation := &ExecutionContextMockGetPublishedGlobalAliasAndBargeInExpectation{
		mock:   mmGetPublishedGlobalAliasAndBargeIn.mock,
		params: &ExecutionContextMockGetPublishedGlobalAliasAndBargeInParams{key},
	}
	mmGetPublishedGlobalAliasAndBargeIn.expectations = append(mmGetPublishedGlobalAliasAndBargeIn.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.GetPublishedGlobalAliasAndBargeIn return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockGetPublishedGlobalAliasAndBargeInExpectation) Then(s1 SlotLink, b1 BargeInHolder) *ExecutionContextMock {
	e.results = &ExecutionContextMockGetPublishedGlobalAliasAndBargeInResults{s1, b1}
	return e.mock
}

// GetPublishedGlobalAliasAndBargeIn implements ExecutionContext
func (mmGetPublishedGlobalAliasAndBargeIn *ExecutionContextMock) GetPublishedGlobalAliasAndBargeIn(key interface{}) (s1 SlotLink, b1 BargeInHolder) {
	mm_atomic.AddUint64(&mmGetPublishedGlobalAliasAndBargeIn.beforeGetPublishedGlobalAliasAndBargeInCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPublishedGlobalAliasAndBargeIn.afterGetPublishedGlobalAliasAndBargeInCounter, 1)

	if mmGetPublishedGlobalAliasAndBargeIn.inspectFuncGetPublishedGlobalAliasAndBargeIn != nil {
		mmGetPublishedGlobalAliasAndBargeIn.inspectFuncGetPublishedGlobalAliasAndBargeIn(key)
	}

	mm_params := &ExecutionContextMockGetPublishedGlobalAliasAndBargeInParams{key}

	// Record call args
	mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.mutex.Lock()
	mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.callArgs = append(mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.callArgs, mm_params)
	mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.mutex.Unlock()

	for _, e := range mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.b1
		}
	}

	if mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation.params
		mm_got := ExecutionContextMockGetPublishedGlobalAliasAndBargeInParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPublishedGlobalAliasAndBargeIn.t.Errorf("ExecutionContextMock.GetPublishedGlobalAliasAndBargeIn got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPublishedGlobalAliasAndBargeIn.t.Fatal("No results are set for the ExecutionContextMock.GetPublishedGlobalAliasAndBargeIn")
		}
		return (*mm_results).s1, (*mm_results).b1
	}
	if mmGetPublishedGlobalAliasAndBargeIn.funcGetPublishedGlobalAliasAndBargeIn != nil {
		return mmGetPublishedGlobalAliasAndBargeIn.funcGetPublishedGlobalAliasAndBargeIn(key)
	}
	mmGetPublishedGlobalAliasAndBargeIn.t.Fatalf("Unexpected call to ExecutionContextMock.GetPublishedGlobalAliasAndBargeIn. %v", key)
	return
}

// GetPublishedGlobalAliasAndBargeInAfterCounter returns a count of finished ExecutionContextMock.GetPublishedGlobalAliasAndBargeIn invocations
func (mmGetPublishedGlobalAliasAndBargeIn *ExecutionContextMock) GetPublishedGlobalAliasAndBargeInAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublishedGlobalAliasAndBargeIn.afterGetPublishedGlobalAliasAndBargeInCounter)
}

// GetPublishedGlobalAliasAndBargeInBeforeCounter returns a count of ExecutionContextMock.GetPublishedGlobalAliasAndBargeIn invocations
func (mmGetPublishedGlobalAliasAndBargeIn *ExecutionContextMock) GetPublishedGlobalAliasAndBargeInBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublishedGlobalAliasAndBargeIn.beforeGetPublishedGlobalAliasAndBargeInCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.GetPublishedGlobalAliasAndBargeIn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPublishedGlobalAliasAndBargeIn *mExecutionContextMockGetPublishedGlobalAliasAndBargeIn) Calls() []*ExecutionContextMockGetPublishedGlobalAliasAndBargeInParams {
	mmGetPublishedGlobalAliasAndBargeIn.mutex.RLock()

	argCopy := make([]*ExecutionContextMockGetPublishedGlobalAliasAndBargeInParams, len(mmGetPublishedGlobalAliasAndBargeIn.callArgs))
	copy(argCopy, mmGetPublishedGlobalAliasAndBargeIn.callArgs)

	mmGetPublishedGlobalAliasAndBargeIn.mutex.RUnlock()

	return argCopy
}

// MinimockGetPublishedGlobalAliasAndBargeInDone returns true if the count of the GetPublishedGlobalAliasAndBargeIn invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockGetPublishedGlobalAliasAndBargeInDone() bool {
	for _, e := range m.GetPublishedGlobalAliasAndBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasAndBargeInCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublishedGlobalAliasAndBargeIn != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasAndBargeInCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPublishedGlobalAliasAndBargeInInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockGetPublishedGlobalAliasAndBargeInInspect() {
	for _, e := range m.GetPublishedGlobalAliasAndBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.GetPublishedGlobalAliasAndBargeIn with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasAndBargeInCounter) < 1 {
		if m.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.GetPublishedGlobalAliasAndBargeIn")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.GetPublishedGlobalAliasAndBargeIn with params: %#v", *m.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublishedGlobalAliasAndBargeIn != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasAndBargeInCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.GetPublishedGlobalAliasAndBargeIn")
	}
}

type mExecutionContextMockGetPublishedLink struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockGetPublishedLinkExpectation
	expectations       []*ExecutionContextMockGetPublishedLinkExpectation

	callArgs []*ExecutionContextMockGetPublishedLinkParams
	mutex    sync.RWMutex
}

// ExecutionContextMockGetPublishedLinkExpectation specifies expectation struct of the ExecutionContext.GetPublishedLink
type ExecutionContextMockGetPublishedLinkExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockGetPublishedLinkParams
	results *ExecutionContextMockGetPublishedLinkResults
	Counter uint64
}

// ExecutionContextMockGetPublishedLinkParams contains parameters of the ExecutionContext.GetPublishedLink
type ExecutionContextMockGetPublishedLinkParams struct {
	key interface{}
}

// ExecutionContextMockGetPublishedLinkResults contains results of the ExecutionContext.GetPublishedLink
type ExecutionContextMockGetPublishedLinkResults struct {
	s1 SharedDataLink
}

// Expect sets up expected params for ExecutionContext.GetPublishedLink
func (mmGetPublishedLink *mExecutionContextMockGetPublishedLink) Expect(key interface{}) *mExecutionContextMockGetPublishedLink {
	if mmGetPublishedLink.mock.funcGetPublishedLink != nil {
		mmGetPublishedLink.mock.t.Fatalf("ExecutionContextMock.GetPublishedLink mock is already set by Set")
	}

	if mmGetPublishedLink.defaultExpectation == nil {
		mmGetPublishedLink.defaultExpectation = &ExecutionContextMockGetPublishedLinkExpectation{}
	}

	mmGetPublishedLink.defaultExpectation.params = &ExecutionContextMockGetPublishedLinkParams{key}
	for _, e := range mmGetPublishedLink.expectations {
		if minimock.Equal(e.params, mmGetPublishedLink.defaultExpectation.params) {
			mmGetPublishedLink.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPublishedLink.defaultExpectation.params)
		}
	}

	return mmGetPublishedLink
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.GetPublishedLink
func (mmGetPublishedLink *mExecutionContextMockGetPublishedLink) Inspect(f func(key interface{})) *mExecutionContextMockGetPublishedLink {
	if mmGetPublishedLink.mock.inspectFuncGetPublishedLink != nil {
		mmGetPublishedLink.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.GetPublishedLink")
	}

	mmGetPublishedLink.mock.inspectFuncGetPublishedLink = f

	return mmGetPublishedLink
}

// Return sets up results that will be returned by ExecutionContext.GetPublishedLink
func (mmGetPublishedLink *mExecutionContextMockGetPublishedLink) Return(s1 SharedDataLink) *ExecutionContextMock {
	if mmGetPublishedLink.mock.funcGetPublishedLink != nil {
		mmGetPublishedLink.mock.t.Fatalf("ExecutionContextMock.GetPublishedLink mock is already set by Set")
	}

	if mmGetPublishedLink.defaultExpectation == nil {
		mmGetPublishedLink.defaultExpectation = &ExecutionContextMockGetPublishedLinkExpectation{mock: mmGetPublishedLink.mock}
	}
	mmGetPublishedLink.defaultExpectation.results = &ExecutionContextMockGetPublishedLinkResults{s1}
	return mmGetPublishedLink.mock
}

//Set uses given function f to mock the ExecutionContext.GetPublishedLink method
func (mmGetPublishedLink *mExecutionContextMockGetPublishedLink) Set(f func(key interface{}) (s1 SharedDataLink)) *ExecutionContextMock {
	if mmGetPublishedLink.defaultExpectation != nil {
		mmGetPublishedLink.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.GetPublishedLink method")
	}

	if len(mmGetPublishedLink.expectations) > 0 {
		mmGetPublishedLink.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.GetPublishedLink method")
	}

	mmGetPublishedLink.mock.funcGetPublishedLink = f
	return mmGetPublishedLink.mock
}

// When sets expectation for the ExecutionContext.GetPublishedLink which will trigger the result defined by the following
// Then helper
func (mmGetPublishedLink *mExecutionContextMockGetPublishedLink) When(key interface{}) *ExecutionContextMockGetPublishedLinkExpectation {
	if mmGetPublishedLink.mock.funcGetPublishedLink != nil {
		mmGetPublishedLink.mock.t.Fatalf("ExecutionContextMock.GetPublishedLink mock is already set by Set")
	}

	expectation := &ExecutionContextMockGetPublishedLinkExpectation{
		mock:   mmGetPublishedLink.mock,
		params: &ExecutionContextMockGetPublishedLinkParams{key},
	}
	mmGetPublishedLink.expectations = append(mmGetPublishedLink.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.GetPublishedLink return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockGetPublishedLinkExpectation) Then(s1 SharedDataLink) *ExecutionContextMock {
	e.results = &ExecutionContextMockGetPublishedLinkResults{s1}
	return e.mock
}

// GetPublishedLink implements ExecutionContext
func (mmGetPublishedLink *ExecutionContextMock) GetPublishedLink(key interface{}) (s1 SharedDataLink) {
	mm_atomic.AddUint64(&mmGetPublishedLink.beforeGetPublishedLinkCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPublishedLink.afterGetPublishedLinkCounter, 1)

	if mmGetPublishedLink.inspectFuncGetPublishedLink != nil {
		mmGetPublishedLink.inspectFuncGetPublishedLink(key)
	}

	mm_params := &ExecutionContextMockGetPublishedLinkParams{key}

	// Record call args
	mmGetPublishedLink.GetPublishedLinkMock.mutex.Lock()
	mmGetPublishedLink.GetPublishedLinkMock.callArgs = append(mmGetPublishedLink.GetPublishedLinkMock.callArgs, mm_params)
	mmGetPublishedLink.GetPublishedLinkMock.mutex.Unlock()

	for _, e := range mmGetPublishedLink.GetPublishedLinkMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmGetPublishedLink.GetPublishedLinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPublishedLink.GetPublishedLinkMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPublishedLink.GetPublishedLinkMock.defaultExpectation.params
		mm_got := ExecutionContextMockGetPublishedLinkParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPublishedLink.t.Errorf("ExecutionContextMock.GetPublishedLink got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPublishedLink.GetPublishedLinkMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPublishedLink.t.Fatal("No results are set for the ExecutionContextMock.GetPublishedLink")
		}
		return (*mm_results).s1
	}
	if mmGetPublishedLink.funcGetPublishedLink != nil {
		return mmGetPublishedLink.funcGetPublishedLink(key)
	}
	mmGetPublishedLink.t.Fatalf("Unexpected call to ExecutionContextMock.GetPublishedLink. %v", key)
	return
}

// GetPublishedLinkAfterCounter returns a count of finished ExecutionContextMock.GetPublishedLink invocations
func (mmGetPublishedLink *ExecutionContextMock) GetPublishedLinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublishedLink.afterGetPublishedLinkCounter)
}

// GetPublishedLinkBeforeCounter returns a count of ExecutionContextMock.GetPublishedLink invocations
func (mmGetPublishedLink *ExecutionContextMock) GetPublishedLinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublishedLink.beforeGetPublishedLinkCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.GetPublishedLink.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPublishedLink *mExecutionContextMockGetPublishedLink) Calls() []*ExecutionContextMockGetPublishedLinkParams {
	mmGetPublishedLink.mutex.RLock()

	argCopy := make([]*ExecutionContextMockGetPublishedLinkParams, len(mmGetPublishedLink.callArgs))
	copy(argCopy, mmGetPublishedLink.callArgs)

	mmGetPublishedLink.mutex.RUnlock()

	return argCopy
}

// MinimockGetPublishedLinkDone returns true if the count of the GetPublishedLink invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockGetPublishedLinkDone() bool {
	for _, e := range m.GetPublishedLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedLinkCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublishedLink != nil && mm_atomic.LoadUint64(&m.afterGetPublishedLinkCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPublishedLinkInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockGetPublishedLinkInspect() {
	for _, e := range m.GetPublishedLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.GetPublishedLink with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedLinkCounter) < 1 {
		if m.GetPublishedLinkMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.GetPublishedLink")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.GetPublishedLink with params: %#v", *m.GetPublishedLinkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublishedLink != nil && mm_atomic.LoadUint64(&m.afterGetPublishedLinkCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.GetPublishedLink")
	}
}

type mExecutionContextMockGetTerminationResult struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockGetTerminationResultExpectation
	expectations       []*ExecutionContextMockGetTerminationResultExpectation
}

// ExecutionContextMockGetTerminationResultExpectation specifies expectation struct of the ExecutionContext.GetTerminationResult
type ExecutionContextMockGetTerminationResultExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockGetTerminationResultResults
	Counter uint64
}

// ExecutionContextMockGetTerminationResultResults contains results of the ExecutionContext.GetTerminationResult
type ExecutionContextMockGetTerminationResultResults struct {
	p1 interface{}
}

// Expect sets up expected params for ExecutionContext.GetTerminationResult
func (mmGetTerminationResult *mExecutionContextMockGetTerminationResult) Expect() *mExecutionContextMockGetTerminationResult {
	if mmGetTerminationResult.mock.funcGetTerminationResult != nil {
		mmGetTerminationResult.mock.t.Fatalf("ExecutionContextMock.GetTerminationResult mock is already set by Set")
	}

	if mmGetTerminationResult.defaultExpectation == nil {
		mmGetTerminationResult.defaultExpectation = &ExecutionContextMockGetTerminationResultExpectation{}
	}

	return mmGetTerminationResult
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.GetTerminationResult
func (mmGetTerminationResult *mExecutionContextMockGetTerminationResult) Inspect(f func()) *mExecutionContextMockGetTerminationResult {
	if mmGetTerminationResult.mock.inspectFuncGetTerminationResult != nil {
		mmGetTerminationResult.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.GetTerminationResult")
	}

	mmGetTerminationResult.mock.inspectFuncGetTerminationResult = f

	return mmGetTerminationResult
}

// Return sets up results that will be returned by ExecutionContext.GetTerminationResult
func (mmGetTerminationResult *mExecutionContextMockGetTerminationResult) Return(p1 interface{}) *ExecutionContextMock {
	if mmGetTerminationResult.mock.funcGetTerminationResult != nil {
		mmGetTerminationResult.mock.t.Fatalf("ExecutionContextMock.GetTerminationResult mock is already set by Set")
	}

	if mmGetTerminationResult.defaultExpectation == nil {
		mmGetTerminationResult.defaultExpectation = &ExecutionContextMockGetTerminationResultExpectation{mock: mmGetTerminationResult.mock}
	}
	mmGetTerminationResult.defaultExpectation.results = &ExecutionContextMockGetTerminationResultResults{p1}
	return mmGetTerminationResult.mock
}

//Set uses given function f to mock the ExecutionContext.GetTerminationResult method
func (mmGetTerminationResult *mExecutionContextMockGetTerminationResult) Set(f func() (p1 interface{})) *ExecutionContextMock {
	if mmGetTerminationResult.defaultExpectation != nil {
		mmGetTerminationResult.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.GetTerminationResult method")
	}

	if len(mmGetTerminationResult.expectations) > 0 {
		mmGetTerminationResult.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.GetTerminationResult method")
	}

	mmGetTerminationResult.mock.funcGetTerminationResult = f
	return mmGetTerminationResult.mock
}

// GetTerminationResult implements ExecutionContext
func (mmGetTerminationResult *ExecutionContextMock) GetTerminationResult() (p1 interface{}) {
	mm_atomic.AddUint64(&mmGetTerminationResult.beforeGetTerminationResultCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTerminationResult.afterGetTerminationResultCounter, 1)

	if mmGetTerminationResult.inspectFuncGetTerminationResult != nil {
		mmGetTerminationResult.inspectFuncGetTerminationResult()
	}

	if mmGetTerminationResult.GetTerminationResultMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTerminationResult.GetTerminationResultMock.defaultExpectation.Counter, 1)

		mm_results := mmGetTerminationResult.GetTerminationResultMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTerminationResult.t.Fatal("No results are set for the ExecutionContextMock.GetTerminationResult")
		}
		return (*mm_results).p1
	}
	if mmGetTerminationResult.funcGetTerminationResult != nil {
		return mmGetTerminationResult.funcGetTerminationResult()
	}
	mmGetTerminationResult.t.Fatalf("Unexpected call to ExecutionContextMock.GetTerminationResult.")
	return
}

// GetTerminationResultAfterCounter returns a count of finished ExecutionContextMock.GetTerminationResult invocations
func (mmGetTerminationResult *ExecutionContextMock) GetTerminationResultAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTerminationResult.afterGetTerminationResultCounter)
}

// GetTerminationResultBeforeCounter returns a count of ExecutionContextMock.GetTerminationResult invocations
func (mmGetTerminationResult *ExecutionContextMock) GetTerminationResultBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTerminationResult.beforeGetTerminationResultCounter)
}

// MinimockGetTerminationResultDone returns true if the count of the GetTerminationResult invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockGetTerminationResultDone() bool {
	for _, e := range m.GetTerminationResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTerminationResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTerminationResultCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTerminationResult != nil && mm_atomic.LoadUint64(&m.afterGetTerminationResultCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetTerminationResultInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockGetTerminationResultInspect() {
	for _, e := range m.GetTerminationResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.GetTerminationResult")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTerminationResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTerminationResultCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.GetTerminationResult")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTerminationResult != nil && mm_atomic.LoadUint64(&m.afterGetTerminationResultCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.GetTerminationResult")
	}
}

type mExecutionContextMockInitChild struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockInitChildExpectation
	expectations       []*ExecutionContextMockInitChildExpectation

	callArgs []*ExecutionContextMockInitChildParams
	mutex    sync.RWMutex
}

// ExecutionContextMockInitChildExpectation specifies expectation struct of the ExecutionContext.InitChild
type ExecutionContextMockInitChildExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockInitChildParams
	results *ExecutionContextMockInitChildResults
	Counter uint64
}

// ExecutionContextMockInitChildParams contains parameters of the ExecutionContext.InitChild
type ExecutionContextMockInitChildParams struct {
	c1 CreateFunc
}

// ExecutionContextMockInitChildResults contains results of the ExecutionContext.InitChild
type ExecutionContextMockInitChildResults struct {
	s1 SlotLink
}

// Expect sets up expected params for ExecutionContext.InitChild
func (mmInitChild *mExecutionContextMockInitChild) Expect(c1 CreateFunc) *mExecutionContextMockInitChild {
	if mmInitChild.mock.funcInitChild != nil {
		mmInitChild.mock.t.Fatalf("ExecutionContextMock.InitChild mock is already set by Set")
	}

	if mmInitChild.defaultExpectation == nil {
		mmInitChild.defaultExpectation = &ExecutionContextMockInitChildExpectation{}
	}

	mmInitChild.defaultExpectation.params = &ExecutionContextMockInitChildParams{c1}
	for _, e := range mmInitChild.expectations {
		if minimock.Equal(e.params, mmInitChild.defaultExpectation.params) {
			mmInitChild.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInitChild.defaultExpectation.params)
		}
	}

	return mmInitChild
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.InitChild
func (mmInitChild *mExecutionContextMockInitChild) Inspect(f func(c1 CreateFunc)) *mExecutionContextMockInitChild {
	if mmInitChild.mock.inspectFuncInitChild != nil {
		mmInitChild.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.InitChild")
	}

	mmInitChild.mock.inspectFuncInitChild = f

	return mmInitChild
}

// Return sets up results that will be returned by ExecutionContext.InitChild
func (mmInitChild *mExecutionContextMockInitChild) Return(s1 SlotLink) *ExecutionContextMock {
	if mmInitChild.mock.funcInitChild != nil {
		mmInitChild.mock.t.Fatalf("ExecutionContextMock.InitChild mock is already set by Set")
	}

	if mmInitChild.defaultExpectation == nil {
		mmInitChild.defaultExpectation = &ExecutionContextMockInitChildExpectation{mock: mmInitChild.mock}
	}
	mmInitChild.defaultExpectation.results = &ExecutionContextMockInitChildResults{s1}
	return mmInitChild.mock
}

//Set uses given function f to mock the ExecutionContext.InitChild method
func (mmInitChild *mExecutionContextMockInitChild) Set(f func(c1 CreateFunc) (s1 SlotLink)) *ExecutionContextMock {
	if mmInitChild.defaultExpectation != nil {
		mmInitChild.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.InitChild method")
	}

	if len(mmInitChild.expectations) > 0 {
		mmInitChild.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.InitChild method")
	}

	mmInitChild.mock.funcInitChild = f
	return mmInitChild.mock
}

// When sets expectation for the ExecutionContext.InitChild which will trigger the result defined by the following
// Then helper
func (mmInitChild *mExecutionContextMockInitChild) When(c1 CreateFunc) *ExecutionContextMockInitChildExpectation {
	if mmInitChild.mock.funcInitChild != nil {
		mmInitChild.mock.t.Fatalf("ExecutionContextMock.InitChild mock is already set by Set")
	}

	expectation := &ExecutionContextMockInitChildExpectation{
		mock:   mmInitChild.mock,
		params: &ExecutionContextMockInitChildParams{c1},
	}
	mmInitChild.expectations = append(mmInitChild.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.InitChild return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockInitChildExpectation) Then(s1 SlotLink) *ExecutionContextMock {
	e.results = &ExecutionContextMockInitChildResults{s1}
	return e.mock
}

// InitChild implements ExecutionContext
func (mmInitChild *ExecutionContextMock) InitChild(c1 CreateFunc) (s1 SlotLink) {
	mm_atomic.AddUint64(&mmInitChild.beforeInitChildCounter, 1)
	defer mm_atomic.AddUint64(&mmInitChild.afterInitChildCounter, 1)

	if mmInitChild.inspectFuncInitChild != nil {
		mmInitChild.inspectFuncInitChild(c1)
	}

	mm_params := &ExecutionContextMockInitChildParams{c1}

	// Record call args
	mmInitChild.InitChildMock.mutex.Lock()
	mmInitChild.InitChildMock.callArgs = append(mmInitChild.InitChildMock.callArgs, mm_params)
	mmInitChild.InitChildMock.mutex.Unlock()

	for _, e := range mmInitChild.InitChildMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmInitChild.InitChildMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInitChild.InitChildMock.defaultExpectation.Counter, 1)
		mm_want := mmInitChild.InitChildMock.defaultExpectation.params
		mm_got := ExecutionContextMockInitChildParams{c1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInitChild.t.Errorf("ExecutionContextMock.InitChild got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInitChild.InitChildMock.defaultExpectation.results
		if mm_results == nil {
			mmInitChild.t.Fatal("No results are set for the ExecutionContextMock.InitChild")
		}
		return (*mm_results).s1
	}
	if mmInitChild.funcInitChild != nil {
		return mmInitChild.funcInitChild(c1)
	}
	mmInitChild.t.Fatalf("Unexpected call to ExecutionContextMock.InitChild. %v", c1)
	return
}

// InitChildAfterCounter returns a count of finished ExecutionContextMock.InitChild invocations
func (mmInitChild *ExecutionContextMock) InitChildAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitChild.afterInitChildCounter)
}

// InitChildBeforeCounter returns a count of ExecutionContextMock.InitChild invocations
func (mmInitChild *ExecutionContextMock) InitChildBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitChild.beforeInitChildCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.InitChild.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInitChild *mExecutionContextMockInitChild) Calls() []*ExecutionContextMockInitChildParams {
	mmInitChild.mutex.RLock()

	argCopy := make([]*ExecutionContextMockInitChildParams, len(mmInitChild.callArgs))
	copy(argCopy, mmInitChild.callArgs)

	mmInitChild.mutex.RUnlock()

	return argCopy
}

// MinimockInitChildDone returns true if the count of the InitChild invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockInitChildDone() bool {
	for _, e := range m.InitChildMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitChildMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitChildCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInitChild != nil && mm_atomic.LoadUint64(&m.afterInitChildCounter) < 1 {
		return false
	}
	return true
}

// MinimockInitChildInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockInitChildInspect() {
	for _, e := range m.InitChildMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.InitChild with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitChildMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitChildCounter) < 1 {
		if m.InitChildMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.InitChild")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.InitChild with params: %#v", *m.InitChildMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInitChild != nil && mm_atomic.LoadUint64(&m.afterInitChildCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.InitChild")
	}
}

type mExecutionContextMockInitChildExt struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockInitChildExtExpectation
	expectations       []*ExecutionContextMockInitChildExtExpectation

	callArgs []*ExecutionContextMockInitChildExtParams
	mutex    sync.RWMutex
}

// ExecutionContextMockInitChildExtExpectation specifies expectation struct of the ExecutionContext.InitChildExt
type ExecutionContextMockInitChildExtExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockInitChildExtParams
	results *ExecutionContextMockInitChildExtResults
	Counter uint64
}

// ExecutionContextMockInitChildExtParams contains parameters of the ExecutionContext.InitChildExt
type ExecutionContextMockInitChildExtParams struct {
	c1 CreateFunc
	c2 CreateDefaultValues
	p1 PostInitFunc
}

// ExecutionContextMockInitChildExtResults contains results of the ExecutionContext.InitChildExt
type ExecutionContextMockInitChildExtResults struct {
	s1 SlotLink
}

// Expect sets up expected params for ExecutionContext.InitChildExt
func (mmInitChildExt *mExecutionContextMockInitChildExt) Expect(c1 CreateFunc, c2 CreateDefaultValues, p1 PostInitFunc) *mExecutionContextMockInitChildExt {
	if mmInitChildExt.mock.funcInitChildExt != nil {
		mmInitChildExt.mock.t.Fatalf("ExecutionContextMock.InitChildExt mock is already set by Set")
	}

	if mmInitChildExt.defaultExpectation == nil {
		mmInitChildExt.defaultExpectation = &ExecutionContextMockInitChildExtExpectation{}
	}

	mmInitChildExt.defaultExpectation.params = &ExecutionContextMockInitChildExtParams{c1, c2, p1}
	for _, e := range mmInitChildExt.expectations {
		if minimock.Equal(e.params, mmInitChildExt.defaultExpectation.params) {
			mmInitChildExt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInitChildExt.defaultExpectation.params)
		}
	}

	return mmInitChildExt
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.InitChildExt
func (mmInitChildExt *mExecutionContextMockInitChildExt) Inspect(f func(c1 CreateFunc, c2 CreateDefaultValues, p1 PostInitFunc)) *mExecutionContextMockInitChildExt {
	if mmInitChildExt.mock.inspectFuncInitChildExt != nil {
		mmInitChildExt.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.InitChildExt")
	}

	mmInitChildExt.mock.inspectFuncInitChildExt = f

	return mmInitChildExt
}

// Return sets up results that will be returned by ExecutionContext.InitChildExt
func (mmInitChildExt *mExecutionContextMockInitChildExt) Return(s1 SlotLink) *ExecutionContextMock {
	if mmInitChildExt.mock.funcInitChildExt != nil {
		mmInitChildExt.mock.t.Fatalf("ExecutionContextMock.InitChildExt mock is already set by Set")
	}

	if mmInitChildExt.defaultExpectation == nil {
		mmInitChildExt.defaultExpectation = &ExecutionContextMockInitChildExtExpectation{mock: mmInitChildExt.mock}
	}
	mmInitChildExt.defaultExpectation.results = &ExecutionContextMockInitChildExtResults{s1}
	return mmInitChildExt.mock
}

//Set uses given function f to mock the ExecutionContext.InitChildExt method
func (mmInitChildExt *mExecutionContextMockInitChildExt) Set(f func(c1 CreateFunc, c2 CreateDefaultValues, p1 PostInitFunc) (s1 SlotLink)) *ExecutionContextMock {
	if mmInitChildExt.defaultExpectation != nil {
		mmInitChildExt.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.InitChildExt method")
	}

	if len(mmInitChildExt.expectations) > 0 {
		mmInitChildExt.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.InitChildExt method")
	}

	mmInitChildExt.mock.funcInitChildExt = f
	return mmInitChildExt.mock
}

// When sets expectation for the ExecutionContext.InitChildExt which will trigger the result defined by the following
// Then helper
func (mmInitChildExt *mExecutionContextMockInitChildExt) When(c1 CreateFunc, c2 CreateDefaultValues, p1 PostInitFunc) *ExecutionContextMockInitChildExtExpectation {
	if mmInitChildExt.mock.funcInitChildExt != nil {
		mmInitChildExt.mock.t.Fatalf("ExecutionContextMock.InitChildExt mock is already set by Set")
	}

	expectation := &ExecutionContextMockInitChildExtExpectation{
		mock:   mmInitChildExt.mock,
		params: &ExecutionContextMockInitChildExtParams{c1, c2, p1},
	}
	mmInitChildExt.expectations = append(mmInitChildExt.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.InitChildExt return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockInitChildExtExpectation) Then(s1 SlotLink) *ExecutionContextMock {
	e.results = &ExecutionContextMockInitChildExtResults{s1}
	return e.mock
}

// InitChildExt implements ExecutionContext
func (mmInitChildExt *ExecutionContextMock) InitChildExt(c1 CreateFunc, c2 CreateDefaultValues, p1 PostInitFunc) (s1 SlotLink) {
	mm_atomic.AddUint64(&mmInitChildExt.beforeInitChildExtCounter, 1)
	defer mm_atomic.AddUint64(&mmInitChildExt.afterInitChildExtCounter, 1)

	if mmInitChildExt.inspectFuncInitChildExt != nil {
		mmInitChildExt.inspectFuncInitChildExt(c1, c2, p1)
	}

	mm_params := &ExecutionContextMockInitChildExtParams{c1, c2, p1}

	// Record call args
	mmInitChildExt.InitChildExtMock.mutex.Lock()
	mmInitChildExt.InitChildExtMock.callArgs = append(mmInitChildExt.InitChildExtMock.callArgs, mm_params)
	mmInitChildExt.InitChildExtMock.mutex.Unlock()

	for _, e := range mmInitChildExt.InitChildExtMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmInitChildExt.InitChildExtMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInitChildExt.InitChildExtMock.defaultExpectation.Counter, 1)
		mm_want := mmInitChildExt.InitChildExtMock.defaultExpectation.params
		mm_got := ExecutionContextMockInitChildExtParams{c1, c2, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInitChildExt.t.Errorf("ExecutionContextMock.InitChildExt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInitChildExt.InitChildExtMock.defaultExpectation.results
		if mm_results == nil {
			mmInitChildExt.t.Fatal("No results are set for the ExecutionContextMock.InitChildExt")
		}
		return (*mm_results).s1
	}
	if mmInitChildExt.funcInitChildExt != nil {
		return mmInitChildExt.funcInitChildExt(c1, c2, p1)
	}
	mmInitChildExt.t.Fatalf("Unexpected call to ExecutionContextMock.InitChildExt. %v %v %v", c1, c2, p1)
	return
}

// InitChildExtAfterCounter returns a count of finished ExecutionContextMock.InitChildExt invocations
func (mmInitChildExt *ExecutionContextMock) InitChildExtAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitChildExt.afterInitChildExtCounter)
}

// InitChildExtBeforeCounter returns a count of ExecutionContextMock.InitChildExt invocations
func (mmInitChildExt *ExecutionContextMock) InitChildExtBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitChildExt.beforeInitChildExtCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.InitChildExt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInitChildExt *mExecutionContextMockInitChildExt) Calls() []*ExecutionContextMockInitChildExtParams {
	mmInitChildExt.mutex.RLock()

	argCopy := make([]*ExecutionContextMockInitChildExtParams, len(mmInitChildExt.callArgs))
	copy(argCopy, mmInitChildExt.callArgs)

	mmInitChildExt.mutex.RUnlock()

	return argCopy
}

// MinimockInitChildExtDone returns true if the count of the InitChildExt invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockInitChildExtDone() bool {
	for _, e := range m.InitChildExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitChildExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitChildExtCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInitChildExt != nil && mm_atomic.LoadUint64(&m.afterInitChildExtCounter) < 1 {
		return false
	}
	return true
}

// MinimockInitChildExtInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockInitChildExtInspect() {
	for _, e := range m.InitChildExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.InitChildExt with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitChildExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitChildExtCounter) < 1 {
		if m.InitChildExtMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.InitChildExt")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.InitChildExt with params: %#v", *m.InitChildExtMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInitChildExt != nil && mm_atomic.LoadUint64(&m.afterInitChildExtCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.InitChildExt")
	}
}

type mExecutionContextMockInitChildWithPostInit struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockInitChildWithPostInitExpectation
	expectations       []*ExecutionContextMockInitChildWithPostInitExpectation

	callArgs []*ExecutionContextMockInitChildWithPostInitParams
	mutex    sync.RWMutex
}

// ExecutionContextMockInitChildWithPostInitExpectation specifies expectation struct of the ExecutionContext.InitChildWithPostInit
type ExecutionContextMockInitChildWithPostInitExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockInitChildWithPostInitParams
	results *ExecutionContextMockInitChildWithPostInitResults
	Counter uint64
}

// ExecutionContextMockInitChildWithPostInitParams contains parameters of the ExecutionContext.InitChildWithPostInit
type ExecutionContextMockInitChildWithPostInitParams struct {
	c1 CreateFunc
	p1 PostInitFunc
}

// ExecutionContextMockInitChildWithPostInitResults contains results of the ExecutionContext.InitChildWithPostInit
type ExecutionContextMockInitChildWithPostInitResults struct {
	s1 SlotLink
}

// Expect sets up expected params for ExecutionContext.InitChildWithPostInit
func (mmInitChildWithPostInit *mExecutionContextMockInitChildWithPostInit) Expect(c1 CreateFunc, p1 PostInitFunc) *mExecutionContextMockInitChildWithPostInit {
	if mmInitChildWithPostInit.mock.funcInitChildWithPostInit != nil {
		mmInitChildWithPostInit.mock.t.Fatalf("ExecutionContextMock.InitChildWithPostInit mock is already set by Set")
	}

	if mmInitChildWithPostInit.defaultExpectation == nil {
		mmInitChildWithPostInit.defaultExpectation = &ExecutionContextMockInitChildWithPostInitExpectation{}
	}

	mmInitChildWithPostInit.defaultExpectation.params = &ExecutionContextMockInitChildWithPostInitParams{c1, p1}
	for _, e := range mmInitChildWithPostInit.expectations {
		if minimock.Equal(e.params, mmInitChildWithPostInit.defaultExpectation.params) {
			mmInitChildWithPostInit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInitChildWithPostInit.defaultExpectation.params)
		}
	}

	return mmInitChildWithPostInit
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.InitChildWithPostInit
func (mmInitChildWithPostInit *mExecutionContextMockInitChildWithPostInit) Inspect(f func(c1 CreateFunc, p1 PostInitFunc)) *mExecutionContextMockInitChildWithPostInit {
	if mmInitChildWithPostInit.mock.inspectFuncInitChildWithPostInit != nil {
		mmInitChildWithPostInit.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.InitChildWithPostInit")
	}

	mmInitChildWithPostInit.mock.inspectFuncInitChildWithPostInit = f

	return mmInitChildWithPostInit
}

// Return sets up results that will be returned by ExecutionContext.InitChildWithPostInit
func (mmInitChildWithPostInit *mExecutionContextMockInitChildWithPostInit) Return(s1 SlotLink) *ExecutionContextMock {
	if mmInitChildWithPostInit.mock.funcInitChildWithPostInit != nil {
		mmInitChildWithPostInit.mock.t.Fatalf("ExecutionContextMock.InitChildWithPostInit mock is already set by Set")
	}

	if mmInitChildWithPostInit.defaultExpectation == nil {
		mmInitChildWithPostInit.defaultExpectation = &ExecutionContextMockInitChildWithPostInitExpectation{mock: mmInitChildWithPostInit.mock}
	}
	mmInitChildWithPostInit.defaultExpectation.results = &ExecutionContextMockInitChildWithPostInitResults{s1}
	return mmInitChildWithPostInit.mock
}

//Set uses given function f to mock the ExecutionContext.InitChildWithPostInit method
func (mmInitChildWithPostInit *mExecutionContextMockInitChildWithPostInit) Set(f func(c1 CreateFunc, p1 PostInitFunc) (s1 SlotLink)) *ExecutionContextMock {
	if mmInitChildWithPostInit.defaultExpectation != nil {
		mmInitChildWithPostInit.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.InitChildWithPostInit method")
	}

	if len(mmInitChildWithPostInit.expectations) > 0 {
		mmInitChildWithPostInit.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.InitChildWithPostInit method")
	}

	mmInitChildWithPostInit.mock.funcInitChildWithPostInit = f
	return mmInitChildWithPostInit.mock
}

// When sets expectation for the ExecutionContext.InitChildWithPostInit which will trigger the result defined by the following
// Then helper
func (mmInitChildWithPostInit *mExecutionContextMockInitChildWithPostInit) When(c1 CreateFunc, p1 PostInitFunc) *ExecutionContextMockInitChildWithPostInitExpectation {
	if mmInitChildWithPostInit.mock.funcInitChildWithPostInit != nil {
		mmInitChildWithPostInit.mock.t.Fatalf("ExecutionContextMock.InitChildWithPostInit mock is already set by Set")
	}

	expectation := &ExecutionContextMockInitChildWithPostInitExpectation{
		mock:   mmInitChildWithPostInit.mock,
		params: &ExecutionContextMockInitChildWithPostInitParams{c1, p1},
	}
	mmInitChildWithPostInit.expectations = append(mmInitChildWithPostInit.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.InitChildWithPostInit return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockInitChildWithPostInitExpectation) Then(s1 SlotLink) *ExecutionContextMock {
	e.results = &ExecutionContextMockInitChildWithPostInitResults{s1}
	return e.mock
}

// InitChildWithPostInit implements ExecutionContext
func (mmInitChildWithPostInit *ExecutionContextMock) InitChildWithPostInit(c1 CreateFunc, p1 PostInitFunc) (s1 SlotLink) {
	mm_atomic.AddUint64(&mmInitChildWithPostInit.beforeInitChildWithPostInitCounter, 1)
	defer mm_atomic.AddUint64(&mmInitChildWithPostInit.afterInitChildWithPostInitCounter, 1)

	if mmInitChildWithPostInit.inspectFuncInitChildWithPostInit != nil {
		mmInitChildWithPostInit.inspectFuncInitChildWithPostInit(c1, p1)
	}

	mm_params := &ExecutionContextMockInitChildWithPostInitParams{c1, p1}

	// Record call args
	mmInitChildWithPostInit.InitChildWithPostInitMock.mutex.Lock()
	mmInitChildWithPostInit.InitChildWithPostInitMock.callArgs = append(mmInitChildWithPostInit.InitChildWithPostInitMock.callArgs, mm_params)
	mmInitChildWithPostInit.InitChildWithPostInitMock.mutex.Unlock()

	for _, e := range mmInitChildWithPostInit.InitChildWithPostInitMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmInitChildWithPostInit.InitChildWithPostInitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInitChildWithPostInit.InitChildWithPostInitMock.defaultExpectation.Counter, 1)
		mm_want := mmInitChildWithPostInit.InitChildWithPostInitMock.defaultExpectation.params
		mm_got := ExecutionContextMockInitChildWithPostInitParams{c1, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInitChildWithPostInit.t.Errorf("ExecutionContextMock.InitChildWithPostInit got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInitChildWithPostInit.InitChildWithPostInitMock.defaultExpectation.results
		if mm_results == nil {
			mmInitChildWithPostInit.t.Fatal("No results are set for the ExecutionContextMock.InitChildWithPostInit")
		}
		return (*mm_results).s1
	}
	if mmInitChildWithPostInit.funcInitChildWithPostInit != nil {
		return mmInitChildWithPostInit.funcInitChildWithPostInit(c1, p1)
	}
	mmInitChildWithPostInit.t.Fatalf("Unexpected call to ExecutionContextMock.InitChildWithPostInit. %v %v", c1, p1)
	return
}

// InitChildWithPostInitAfterCounter returns a count of finished ExecutionContextMock.InitChildWithPostInit invocations
func (mmInitChildWithPostInit *ExecutionContextMock) InitChildWithPostInitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitChildWithPostInit.afterInitChildWithPostInitCounter)
}

// InitChildWithPostInitBeforeCounter returns a count of ExecutionContextMock.InitChildWithPostInit invocations
func (mmInitChildWithPostInit *ExecutionContextMock) InitChildWithPostInitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitChildWithPostInit.beforeInitChildWithPostInitCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.InitChildWithPostInit.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInitChildWithPostInit *mExecutionContextMockInitChildWithPostInit) Calls() []*ExecutionContextMockInitChildWithPostInitParams {
	mmInitChildWithPostInit.mutex.RLock()

	argCopy := make([]*ExecutionContextMockInitChildWithPostInitParams, len(mmInitChildWithPostInit.callArgs))
	copy(argCopy, mmInitChildWithPostInit.callArgs)

	mmInitChildWithPostInit.mutex.RUnlock()

	return argCopy
}

// MinimockInitChildWithPostInitDone returns true if the count of the InitChildWithPostInit invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockInitChildWithPostInitDone() bool {
	for _, e := range m.InitChildWithPostInitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitChildWithPostInitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitChildWithPostInitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInitChildWithPostInit != nil && mm_atomic.LoadUint64(&m.afterInitChildWithPostInitCounter) < 1 {
		return false
	}
	return true
}

// MinimockInitChildWithPostInitInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockInitChildWithPostInitInspect() {
	for _, e := range m.InitChildWithPostInitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.InitChildWithPostInit with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitChildWithPostInitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitChildWithPostInitCounter) < 1 {
		if m.InitChildWithPostInitMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.InitChildWithPostInit")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.InitChildWithPostInit with params: %#v", *m.InitChildWithPostInitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInitChildWithPostInit != nil && mm_atomic.LoadUint64(&m.afterInitChildWithPostInitCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.InitChildWithPostInit")
	}
}

type mExecutionContextMockInitiateLongRun struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockInitiateLongRunExpectation
	expectations       []*ExecutionContextMockInitiateLongRunExpectation

	callArgs []*ExecutionContextMockInitiateLongRunParams
	mutex    sync.RWMutex
}

// ExecutionContextMockInitiateLongRunExpectation specifies expectation struct of the ExecutionContext.InitiateLongRun
type ExecutionContextMockInitiateLongRunExpectation struct {
	mock   *ExecutionContextMock
	params *ExecutionContextMockInitiateLongRunParams

	Counter uint64
}

// ExecutionContextMockInitiateLongRunParams contains parameters of the ExecutionContext.InitiateLongRun
type ExecutionContextMockInitiateLongRunParams struct {
	l1 LongRunFlags
}

// Expect sets up expected params for ExecutionContext.InitiateLongRun
func (mmInitiateLongRun *mExecutionContextMockInitiateLongRun) Expect(l1 LongRunFlags) *mExecutionContextMockInitiateLongRun {
	if mmInitiateLongRun.mock.funcInitiateLongRun != nil {
		mmInitiateLongRun.mock.t.Fatalf("ExecutionContextMock.InitiateLongRun mock is already set by Set")
	}

	if mmInitiateLongRun.defaultExpectation == nil {
		mmInitiateLongRun.defaultExpectation = &ExecutionContextMockInitiateLongRunExpectation{}
	}

	mmInitiateLongRun.defaultExpectation.params = &ExecutionContextMockInitiateLongRunParams{l1}
	for _, e := range mmInitiateLongRun.expectations {
		if minimock.Equal(e.params, mmInitiateLongRun.defaultExpectation.params) {
			mmInitiateLongRun.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInitiateLongRun.defaultExpectation.params)
		}
	}

	return mmInitiateLongRun
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.InitiateLongRun
func (mmInitiateLongRun *mExecutionContextMockInitiateLongRun) Inspect(f func(l1 LongRunFlags)) *mExecutionContextMockInitiateLongRun {
	if mmInitiateLongRun.mock.inspectFuncInitiateLongRun != nil {
		mmInitiateLongRun.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.InitiateLongRun")
	}

	mmInitiateLongRun.mock.inspectFuncInitiateLongRun = f

	return mmInitiateLongRun
}

// Return sets up results that will be returned by ExecutionContext.InitiateLongRun
func (mmInitiateLongRun *mExecutionContextMockInitiateLongRun) Return() *ExecutionContextMock {
	if mmInitiateLongRun.mock.funcInitiateLongRun != nil {
		mmInitiateLongRun.mock.t.Fatalf("ExecutionContextMock.InitiateLongRun mock is already set by Set")
	}

	if mmInitiateLongRun.defaultExpectation == nil {
		mmInitiateLongRun.defaultExpectation = &ExecutionContextMockInitiateLongRunExpectation{mock: mmInitiateLongRun.mock}
	}

	return mmInitiateLongRun.mock
}

//Set uses given function f to mock the ExecutionContext.InitiateLongRun method
func (mmInitiateLongRun *mExecutionContextMockInitiateLongRun) Set(f func(l1 LongRunFlags)) *ExecutionContextMock {
	if mmInitiateLongRun.defaultExpectation != nil {
		mmInitiateLongRun.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.InitiateLongRun method")
	}

	if len(mmInitiateLongRun.expectations) > 0 {
		mmInitiateLongRun.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.InitiateLongRun method")
	}

	mmInitiateLongRun.mock.funcInitiateLongRun = f
	return mmInitiateLongRun.mock
}

// InitiateLongRun implements ExecutionContext
func (mmInitiateLongRun *ExecutionContextMock) InitiateLongRun(l1 LongRunFlags) {
	mm_atomic.AddUint64(&mmInitiateLongRun.beforeInitiateLongRunCounter, 1)
	defer mm_atomic.AddUint64(&mmInitiateLongRun.afterInitiateLongRunCounter, 1)

	if mmInitiateLongRun.inspectFuncInitiateLongRun != nil {
		mmInitiateLongRun.inspectFuncInitiateLongRun(l1)
	}

	mm_params := &ExecutionContextMockInitiateLongRunParams{l1}

	// Record call args
	mmInitiateLongRun.InitiateLongRunMock.mutex.Lock()
	mmInitiateLongRun.InitiateLongRunMock.callArgs = append(mmInitiateLongRun.InitiateLongRunMock.callArgs, mm_params)
	mmInitiateLongRun.InitiateLongRunMock.mutex.Unlock()

	for _, e := range mmInitiateLongRun.InitiateLongRunMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInitiateLongRun.InitiateLongRunMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInitiateLongRun.InitiateLongRunMock.defaultExpectation.Counter, 1)
		mm_want := mmInitiateLongRun.InitiateLongRunMock.defaultExpectation.params
		mm_got := ExecutionContextMockInitiateLongRunParams{l1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInitiateLongRun.t.Errorf("ExecutionContextMock.InitiateLongRun got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInitiateLongRun.funcInitiateLongRun != nil {
		mmInitiateLongRun.funcInitiateLongRun(l1)
		return
	}
	mmInitiateLongRun.t.Fatalf("Unexpected call to ExecutionContextMock.InitiateLongRun. %v", l1)

}

// InitiateLongRunAfterCounter returns a count of finished ExecutionContextMock.InitiateLongRun invocations
func (mmInitiateLongRun *ExecutionContextMock) InitiateLongRunAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitiateLongRun.afterInitiateLongRunCounter)
}

// InitiateLongRunBeforeCounter returns a count of ExecutionContextMock.InitiateLongRun invocations
func (mmInitiateLongRun *ExecutionContextMock) InitiateLongRunBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitiateLongRun.beforeInitiateLongRunCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.InitiateLongRun.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInitiateLongRun *mExecutionContextMockInitiateLongRun) Calls() []*ExecutionContextMockInitiateLongRunParams {
	mmInitiateLongRun.mutex.RLock()

	argCopy := make([]*ExecutionContextMockInitiateLongRunParams, len(mmInitiateLongRun.callArgs))
	copy(argCopy, mmInitiateLongRun.callArgs)

	mmInitiateLongRun.mutex.RUnlock()

	return argCopy
}

// MinimockInitiateLongRunDone returns true if the count of the InitiateLongRun invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockInitiateLongRunDone() bool {
	for _, e := range m.InitiateLongRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitiateLongRunMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitiateLongRunCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInitiateLongRun != nil && mm_atomic.LoadUint64(&m.afterInitiateLongRunCounter) < 1 {
		return false
	}
	return true
}

// MinimockInitiateLongRunInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockInitiateLongRunInspect() {
	for _, e := range m.InitiateLongRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.InitiateLongRun with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitiateLongRunMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitiateLongRunCounter) < 1 {
		if m.InitiateLongRunMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.InitiateLongRun")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.InitiateLongRun with params: %#v", *m.InitiateLongRunMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInitiateLongRun != nil && mm_atomic.LoadUint64(&m.afterInitiateLongRunCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.InitiateLongRun")
	}
}

type mExecutionContextMockJump struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockJumpExpectation
	expectations       []*ExecutionContextMockJumpExpectation

	callArgs []*ExecutionContextMockJumpParams
	mutex    sync.RWMutex
}

// ExecutionContextMockJumpExpectation specifies expectation struct of the ExecutionContext.Jump
type ExecutionContextMockJumpExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockJumpParams
	results *ExecutionContextMockJumpResults
	Counter uint64
}

// ExecutionContextMockJumpParams contains parameters of the ExecutionContext.Jump
type ExecutionContextMockJumpParams struct {
	s1 StateFunc
}

// ExecutionContextMockJumpResults contains results of the ExecutionContext.Jump
type ExecutionContextMockJumpResults struct {
	s2 StateUpdate
}

// Expect sets up expected params for ExecutionContext.Jump
func (mmJump *mExecutionContextMockJump) Expect(s1 StateFunc) *mExecutionContextMockJump {
	if mmJump.mock.funcJump != nil {
		mmJump.mock.t.Fatalf("ExecutionContextMock.Jump mock is already set by Set")
	}

	if mmJump.defaultExpectation == nil {
		mmJump.defaultExpectation = &ExecutionContextMockJumpExpectation{}
	}

	mmJump.defaultExpectation.params = &ExecutionContextMockJumpParams{s1}
	for _, e := range mmJump.expectations {
		if minimock.Equal(e.params, mmJump.defaultExpectation.params) {
			mmJump.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmJump.defaultExpectation.params)
		}
	}

	return mmJump
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Jump
func (mmJump *mExecutionContextMockJump) Inspect(f func(s1 StateFunc)) *mExecutionContextMockJump {
	if mmJump.mock.inspectFuncJump != nil {
		mmJump.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Jump")
	}

	mmJump.mock.inspectFuncJump = f

	return mmJump
}

// Return sets up results that will be returned by ExecutionContext.Jump
func (mmJump *mExecutionContextMockJump) Return(s2 StateUpdate) *ExecutionContextMock {
	if mmJump.mock.funcJump != nil {
		mmJump.mock.t.Fatalf("ExecutionContextMock.Jump mock is already set by Set")
	}

	if mmJump.defaultExpectation == nil {
		mmJump.defaultExpectation = &ExecutionContextMockJumpExpectation{mock: mmJump.mock}
	}
	mmJump.defaultExpectation.results = &ExecutionContextMockJumpResults{s2}
	return mmJump.mock
}

//Set uses given function f to mock the ExecutionContext.Jump method
func (mmJump *mExecutionContextMockJump) Set(f func(s1 StateFunc) (s2 StateUpdate)) *ExecutionContextMock {
	if mmJump.defaultExpectation != nil {
		mmJump.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Jump method")
	}

	if len(mmJump.expectations) > 0 {
		mmJump.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Jump method")
	}

	mmJump.mock.funcJump = f
	return mmJump.mock
}

// When sets expectation for the ExecutionContext.Jump which will trigger the result defined by the following
// Then helper
func (mmJump *mExecutionContextMockJump) When(s1 StateFunc) *ExecutionContextMockJumpExpectation {
	if mmJump.mock.funcJump != nil {
		mmJump.mock.t.Fatalf("ExecutionContextMock.Jump mock is already set by Set")
	}

	expectation := &ExecutionContextMockJumpExpectation{
		mock:   mmJump.mock,
		params: &ExecutionContextMockJumpParams{s1},
	}
	mmJump.expectations = append(mmJump.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.Jump return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockJumpExpectation) Then(s2 StateUpdate) *ExecutionContextMock {
	e.results = &ExecutionContextMockJumpResults{s2}
	return e.mock
}

// Jump implements ExecutionContext
func (mmJump *ExecutionContextMock) Jump(s1 StateFunc) (s2 StateUpdate) {
	mm_atomic.AddUint64(&mmJump.beforeJumpCounter, 1)
	defer mm_atomic.AddUint64(&mmJump.afterJumpCounter, 1)

	if mmJump.inspectFuncJump != nil {
		mmJump.inspectFuncJump(s1)
	}

	mm_params := &ExecutionContextMockJumpParams{s1}

	// Record call args
	mmJump.JumpMock.mutex.Lock()
	mmJump.JumpMock.callArgs = append(mmJump.JumpMock.callArgs, mm_params)
	mmJump.JumpMock.mutex.Unlock()

	for _, e := range mmJump.JumpMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2
		}
	}

	if mmJump.JumpMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmJump.JumpMock.defaultExpectation.Counter, 1)
		mm_want := mmJump.JumpMock.defaultExpectation.params
		mm_got := ExecutionContextMockJumpParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmJump.t.Errorf("ExecutionContextMock.Jump got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmJump.JumpMock.defaultExpectation.results
		if mm_results == nil {
			mmJump.t.Fatal("No results are set for the ExecutionContextMock.Jump")
		}
		return (*mm_results).s2
	}
	if mmJump.funcJump != nil {
		return mmJump.funcJump(s1)
	}
	mmJump.t.Fatalf("Unexpected call to ExecutionContextMock.Jump. %v", s1)
	return
}

// JumpAfterCounter returns a count of finished ExecutionContextMock.Jump invocations
func (mmJump *ExecutionContextMock) JumpAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJump.afterJumpCounter)
}

// JumpBeforeCounter returns a count of ExecutionContextMock.Jump invocations
func (mmJump *ExecutionContextMock) JumpBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJump.beforeJumpCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.Jump.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmJump *mExecutionContextMockJump) Calls() []*ExecutionContextMockJumpParams {
	mmJump.mutex.RLock()

	argCopy := make([]*ExecutionContextMockJumpParams, len(mmJump.callArgs))
	copy(argCopy, mmJump.callArgs)

	mmJump.mutex.RUnlock()

	return argCopy
}

// MinimockJumpDone returns true if the count of the Jump invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockJumpDone() bool {
	for _, e := range m.JumpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.JumpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterJumpCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJump != nil && mm_atomic.LoadUint64(&m.afterJumpCounter) < 1 {
		return false
	}
	return true
}

// MinimockJumpInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockJumpInspect() {
	for _, e := range m.JumpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.Jump with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.JumpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterJumpCounter) < 1 {
		if m.JumpMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.Jump")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.Jump with params: %#v", *m.JumpMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJump != nil && mm_atomic.LoadUint64(&m.afterJumpCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Jump")
	}
}

type mExecutionContextMockJumpExt struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockJumpExtExpectation
	expectations       []*ExecutionContextMockJumpExtExpectation

	callArgs []*ExecutionContextMockJumpExtParams
	mutex    sync.RWMutex
}

// ExecutionContextMockJumpExtExpectation specifies expectation struct of the ExecutionContext.JumpExt
type ExecutionContextMockJumpExtExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockJumpExtParams
	results *ExecutionContextMockJumpExtResults
	Counter uint64
}

// ExecutionContextMockJumpExtParams contains parameters of the ExecutionContext.JumpExt
type ExecutionContextMockJumpExtParams struct {
	s1 SlotStep
}

// ExecutionContextMockJumpExtResults contains results of the ExecutionContext.JumpExt
type ExecutionContextMockJumpExtResults struct {
	s2 StateUpdate
}

// Expect sets up expected params for ExecutionContext.JumpExt
func (mmJumpExt *mExecutionContextMockJumpExt) Expect(s1 SlotStep) *mExecutionContextMockJumpExt {
	if mmJumpExt.mock.funcJumpExt != nil {
		mmJumpExt.mock.t.Fatalf("ExecutionContextMock.JumpExt mock is already set by Set")
	}

	if mmJumpExt.defaultExpectation == nil {
		mmJumpExt.defaultExpectation = &ExecutionContextMockJumpExtExpectation{}
	}

	mmJumpExt.defaultExpectation.params = &ExecutionContextMockJumpExtParams{s1}
	for _, e := range mmJumpExt.expectations {
		if minimock.Equal(e.params, mmJumpExt.defaultExpectation.params) {
			mmJumpExt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmJumpExt.defaultExpectation.params)
		}
	}

	return mmJumpExt
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.JumpExt
func (mmJumpExt *mExecutionContextMockJumpExt) Inspect(f func(s1 SlotStep)) *mExecutionContextMockJumpExt {
	if mmJumpExt.mock.inspectFuncJumpExt != nil {
		mmJumpExt.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.JumpExt")
	}

	mmJumpExt.mock.inspectFuncJumpExt = f

	return mmJumpExt
}

// Return sets up results that will be returned by ExecutionContext.JumpExt
func (mmJumpExt *mExecutionContextMockJumpExt) Return(s2 StateUpdate) *ExecutionContextMock {
	if mmJumpExt.mock.funcJumpExt != nil {
		mmJumpExt.mock.t.Fatalf("ExecutionContextMock.JumpExt mock is already set by Set")
	}

	if mmJumpExt.defaultExpectation == nil {
		mmJumpExt.defaultExpectation = &ExecutionContextMockJumpExtExpectation{mock: mmJumpExt.mock}
	}
	mmJumpExt.defaultExpectation.results = &ExecutionContextMockJumpExtResults{s2}
	return mmJumpExt.mock
}

//Set uses given function f to mock the ExecutionContext.JumpExt method
func (mmJumpExt *mExecutionContextMockJumpExt) Set(f func(s1 SlotStep) (s2 StateUpdate)) *ExecutionContextMock {
	if mmJumpExt.defaultExpectation != nil {
		mmJumpExt.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.JumpExt method")
	}

	if len(mmJumpExt.expectations) > 0 {
		mmJumpExt.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.JumpExt method")
	}

	mmJumpExt.mock.funcJumpExt = f
	return mmJumpExt.mock
}

// When sets expectation for the ExecutionContext.JumpExt which will trigger the result defined by the following
// Then helper
func (mmJumpExt *mExecutionContextMockJumpExt) When(s1 SlotStep) *ExecutionContextMockJumpExtExpectation {
	if mmJumpExt.mock.funcJumpExt != nil {
		mmJumpExt.mock.t.Fatalf("ExecutionContextMock.JumpExt mock is already set by Set")
	}

	expectation := &ExecutionContextMockJumpExtExpectation{
		mock:   mmJumpExt.mock,
		params: &ExecutionContextMockJumpExtParams{s1},
	}
	mmJumpExt.expectations = append(mmJumpExt.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.JumpExt return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockJumpExtExpectation) Then(s2 StateUpdate) *ExecutionContextMock {
	e.results = &ExecutionContextMockJumpExtResults{s2}
	return e.mock
}

// JumpExt implements ExecutionContext
func (mmJumpExt *ExecutionContextMock) JumpExt(s1 SlotStep) (s2 StateUpdate) {
	mm_atomic.AddUint64(&mmJumpExt.beforeJumpExtCounter, 1)
	defer mm_atomic.AddUint64(&mmJumpExt.afterJumpExtCounter, 1)

	if mmJumpExt.inspectFuncJumpExt != nil {
		mmJumpExt.inspectFuncJumpExt(s1)
	}

	mm_params := &ExecutionContextMockJumpExtParams{s1}

	// Record call args
	mmJumpExt.JumpExtMock.mutex.Lock()
	mmJumpExt.JumpExtMock.callArgs = append(mmJumpExt.JumpExtMock.callArgs, mm_params)
	mmJumpExt.JumpExtMock.mutex.Unlock()

	for _, e := range mmJumpExt.JumpExtMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2
		}
	}

	if mmJumpExt.JumpExtMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmJumpExt.JumpExtMock.defaultExpectation.Counter, 1)
		mm_want := mmJumpExt.JumpExtMock.defaultExpectation.params
		mm_got := ExecutionContextMockJumpExtParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmJumpExt.t.Errorf("ExecutionContextMock.JumpExt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmJumpExt.JumpExtMock.defaultExpectation.results
		if mm_results == nil {
			mmJumpExt.t.Fatal("No results are set for the ExecutionContextMock.JumpExt")
		}
		return (*mm_results).s2
	}
	if mmJumpExt.funcJumpExt != nil {
		return mmJumpExt.funcJumpExt(s1)
	}
	mmJumpExt.t.Fatalf("Unexpected call to ExecutionContextMock.JumpExt. %v", s1)
	return
}

// JumpExtAfterCounter returns a count of finished ExecutionContextMock.JumpExt invocations
func (mmJumpExt *ExecutionContextMock) JumpExtAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJumpExt.afterJumpExtCounter)
}

// JumpExtBeforeCounter returns a count of ExecutionContextMock.JumpExt invocations
func (mmJumpExt *ExecutionContextMock) JumpExtBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJumpExt.beforeJumpExtCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.JumpExt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmJumpExt *mExecutionContextMockJumpExt) Calls() []*ExecutionContextMockJumpExtParams {
	mmJumpExt.mutex.RLock()

	argCopy := make([]*ExecutionContextMockJumpExtParams, len(mmJumpExt.callArgs))
	copy(argCopy, mmJumpExt.callArgs)

	mmJumpExt.mutex.RUnlock()

	return argCopy
}

// MinimockJumpExtDone returns true if the count of the JumpExt invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockJumpExtDone() bool {
	for _, e := range m.JumpExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.JumpExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterJumpExtCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJumpExt != nil && mm_atomic.LoadUint64(&m.afterJumpExtCounter) < 1 {
		return false
	}
	return true
}

// MinimockJumpExtInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockJumpExtInspect() {
	for _, e := range m.JumpExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.JumpExt with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.JumpExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterJumpExtCounter) < 1 {
		if m.JumpExtMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.JumpExt")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.JumpExt with params: %#v", *m.JumpExtMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJumpExt != nil && mm_atomic.LoadUint64(&m.afterJumpExtCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.JumpExt")
	}
}

type mExecutionContextMockLog struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockLogExpectation
	expectations       []*ExecutionContextMockLogExpectation
}

// ExecutionContextMockLogExpectation specifies expectation struct of the ExecutionContext.Log
type ExecutionContextMockLogExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockLogResults
	Counter uint64
}

// ExecutionContextMockLogResults contains results of the ExecutionContext.Log
type ExecutionContextMockLogResults struct {
	l1 Logger
}

// Expect sets up expected params for ExecutionContext.Log
func (mmLog *mExecutionContextMockLog) Expect() *mExecutionContextMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("ExecutionContextMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &ExecutionContextMockLogExpectation{}
	}

	return mmLog
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Log
func (mmLog *mExecutionContextMockLog) Inspect(f func()) *mExecutionContextMockLog {
	if mmLog.mock.inspectFuncLog != nil {
		mmLog.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Log")
	}

	mmLog.mock.inspectFuncLog = f

	return mmLog
}

// Return sets up results that will be returned by ExecutionContext.Log
func (mmLog *mExecutionContextMockLog) Return(l1 Logger) *ExecutionContextMock {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("ExecutionContextMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &ExecutionContextMockLogExpectation{mock: mmLog.mock}
	}
	mmLog.defaultExpectation.results = &ExecutionContextMockLogResults{l1}
	return mmLog.mock
}

//Set uses given function f to mock the ExecutionContext.Log method
func (mmLog *mExecutionContextMockLog) Set(f func() (l1 Logger)) *ExecutionContextMock {
	if mmLog.defaultExpectation != nil {
		mmLog.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Log method")
	}

	if len(mmLog.expectations) > 0 {
		mmLog.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Log method")
	}

	mmLog.mock.funcLog = f
	return mmLog.mock
}

// Log implements ExecutionContext
func (mmLog *ExecutionContextMock) Log() (l1 Logger) {
	mm_atomic.AddUint64(&mmLog.beforeLogCounter, 1)
	defer mm_atomic.AddUint64(&mmLog.afterLogCounter, 1)

	if mmLog.inspectFuncLog != nil {
		mmLog.inspectFuncLog()
	}

	if mmLog.LogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLog.LogMock.defaultExpectation.Counter, 1)

		mm_results := mmLog.LogMock.defaultExpectation.results
		if mm_results == nil {
			mmLog.t.Fatal("No results are set for the ExecutionContextMock.Log")
		}
		return (*mm_results).l1
	}
	if mmLog.funcLog != nil {
		return mmLog.funcLog()
	}
	mmLog.t.Fatalf("Unexpected call to ExecutionContextMock.Log.")
	return
}

// LogAfterCounter returns a count of finished ExecutionContextMock.Log invocations
func (mmLog *ExecutionContextMock) LogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLog.afterLogCounter)
}

// LogBeforeCounter returns a count of ExecutionContextMock.Log invocations
func (mmLog *ExecutionContextMock) LogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLog.beforeLogCounter)
}

// MinimockLogDone returns true if the count of the Log invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockLogDone() bool {
	for _, e := range m.LogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLogCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLog != nil && mm_atomic.LoadUint64(&m.afterLogCounter) < 1 {
		return false
	}
	return true
}

// MinimockLogInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockLogInspect() {
	for _, e := range m.LogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.Log")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLogCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Log")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLog != nil && mm_atomic.LoadUint64(&m.afterLogCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Log")
	}
}

type mExecutionContextMockLogAsync struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockLogAsyncExpectation
	expectations       []*ExecutionContextMockLogAsyncExpectation
}

// ExecutionContextMockLogAsyncExpectation specifies expectation struct of the ExecutionContext.LogAsync
type ExecutionContextMockLogAsyncExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockLogAsyncResults
	Counter uint64
}

// ExecutionContextMockLogAsyncResults contains results of the ExecutionContext.LogAsync
type ExecutionContextMockLogAsyncResults struct {
	l1 Logger
}

// Expect sets up expected params for ExecutionContext.LogAsync
func (mmLogAsync *mExecutionContextMockLogAsync) Expect() *mExecutionContextMockLogAsync {
	if mmLogAsync.mock.funcLogAsync != nil {
		mmLogAsync.mock.t.Fatalf("ExecutionContextMock.LogAsync mock is already set by Set")
	}

	if mmLogAsync.defaultExpectation == nil {
		mmLogAsync.defaultExpectation = &ExecutionContextMockLogAsyncExpectation{}
	}

	return mmLogAsync
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.LogAsync
func (mmLogAsync *mExecutionContextMockLogAsync) Inspect(f func()) *mExecutionContextMockLogAsync {
	if mmLogAsync.mock.inspectFuncLogAsync != nil {
		mmLogAsync.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.LogAsync")
	}

	mmLogAsync.mock.inspectFuncLogAsync = f

	return mmLogAsync
}

// Return sets up results that will be returned by ExecutionContext.LogAsync
func (mmLogAsync *mExecutionContextMockLogAsync) Return(l1 Logger) *ExecutionContextMock {
	if mmLogAsync.mock.funcLogAsync != nil {
		mmLogAsync.mock.t.Fatalf("ExecutionContextMock.LogAsync mock is already set by Set")
	}

	if mmLogAsync.defaultExpectation == nil {
		mmLogAsync.defaultExpectation = &ExecutionContextMockLogAsyncExpectation{mock: mmLogAsync.mock}
	}
	mmLogAsync.defaultExpectation.results = &ExecutionContextMockLogAsyncResults{l1}
	return mmLogAsync.mock
}

//Set uses given function f to mock the ExecutionContext.LogAsync method
func (mmLogAsync *mExecutionContextMockLogAsync) Set(f func() (l1 Logger)) *ExecutionContextMock {
	if mmLogAsync.defaultExpectation != nil {
		mmLogAsync.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.LogAsync method")
	}

	if len(mmLogAsync.expectations) > 0 {
		mmLogAsync.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.LogAsync method")
	}

	mmLogAsync.mock.funcLogAsync = f
	return mmLogAsync.mock
}

// LogAsync implements ExecutionContext
func (mmLogAsync *ExecutionContextMock) LogAsync() (l1 Logger) {
	mm_atomic.AddUint64(&mmLogAsync.beforeLogAsyncCounter, 1)
	defer mm_atomic.AddUint64(&mmLogAsync.afterLogAsyncCounter, 1)

	if mmLogAsync.inspectFuncLogAsync != nil {
		mmLogAsync.inspectFuncLogAsync()
	}

	if mmLogAsync.LogAsyncMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogAsync.LogAsyncMock.defaultExpectation.Counter, 1)

		mm_results := mmLogAsync.LogAsyncMock.defaultExpectation.results
		if mm_results == nil {
			mmLogAsync.t.Fatal("No results are set for the ExecutionContextMock.LogAsync")
		}
		return (*mm_results).l1
	}
	if mmLogAsync.funcLogAsync != nil {
		return mmLogAsync.funcLogAsync()
	}
	mmLogAsync.t.Fatalf("Unexpected call to ExecutionContextMock.LogAsync.")
	return
}

// LogAsyncAfterCounter returns a count of finished ExecutionContextMock.LogAsync invocations
func (mmLogAsync *ExecutionContextMock) LogAsyncAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogAsync.afterLogAsyncCounter)
}

// LogAsyncBeforeCounter returns a count of ExecutionContextMock.LogAsync invocations
func (mmLogAsync *ExecutionContextMock) LogAsyncBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogAsync.beforeLogAsyncCounter)
}

// MinimockLogAsyncDone returns true if the count of the LogAsync invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockLogAsyncDone() bool {
	for _, e := range m.LogAsyncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LogAsyncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLogAsyncCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogAsync != nil && mm_atomic.LoadUint64(&m.afterLogAsyncCounter) < 1 {
		return false
	}
	return true
}

// MinimockLogAsyncInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockLogAsyncInspect() {
	for _, e := range m.LogAsyncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.LogAsync")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LogAsyncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLogAsyncCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.LogAsync")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogAsync != nil && mm_atomic.LoadUint64(&m.afterLogAsyncCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.LogAsync")
	}
}

type mExecutionContextMockNewBargeIn struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockNewBargeInExpectation
	expectations       []*ExecutionContextMockNewBargeInExpectation
}

// ExecutionContextMockNewBargeInExpectation specifies expectation struct of the ExecutionContext.NewBargeIn
type ExecutionContextMockNewBargeInExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockNewBargeInResults
	Counter uint64
}

// ExecutionContextMockNewBargeInResults contains results of the ExecutionContext.NewBargeIn
type ExecutionContextMockNewBargeInResults struct {
	b1 BargeInBuilder
}

// Expect sets up expected params for ExecutionContext.NewBargeIn
func (mmNewBargeIn *mExecutionContextMockNewBargeIn) Expect() *mExecutionContextMockNewBargeIn {
	if mmNewBargeIn.mock.funcNewBargeIn != nil {
		mmNewBargeIn.mock.t.Fatalf("ExecutionContextMock.NewBargeIn mock is already set by Set")
	}

	if mmNewBargeIn.defaultExpectation == nil {
		mmNewBargeIn.defaultExpectation = &ExecutionContextMockNewBargeInExpectation{}
	}

	return mmNewBargeIn
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.NewBargeIn
func (mmNewBargeIn *mExecutionContextMockNewBargeIn) Inspect(f func()) *mExecutionContextMockNewBargeIn {
	if mmNewBargeIn.mock.inspectFuncNewBargeIn != nil {
		mmNewBargeIn.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.NewBargeIn")
	}

	mmNewBargeIn.mock.inspectFuncNewBargeIn = f

	return mmNewBargeIn
}

// Return sets up results that will be returned by ExecutionContext.NewBargeIn
func (mmNewBargeIn *mExecutionContextMockNewBargeIn) Return(b1 BargeInBuilder) *ExecutionContextMock {
	if mmNewBargeIn.mock.funcNewBargeIn != nil {
		mmNewBargeIn.mock.t.Fatalf("ExecutionContextMock.NewBargeIn mock is already set by Set")
	}

	if mmNewBargeIn.defaultExpectation == nil {
		mmNewBargeIn.defaultExpectation = &ExecutionContextMockNewBargeInExpectation{mock: mmNewBargeIn.mock}
	}
	mmNewBargeIn.defaultExpectation.results = &ExecutionContextMockNewBargeInResults{b1}
	return mmNewBargeIn.mock
}

//Set uses given function f to mock the ExecutionContext.NewBargeIn method
func (mmNewBargeIn *mExecutionContextMockNewBargeIn) Set(f func() (b1 BargeInBuilder)) *ExecutionContextMock {
	if mmNewBargeIn.defaultExpectation != nil {
		mmNewBargeIn.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.NewBargeIn method")
	}

	if len(mmNewBargeIn.expectations) > 0 {
		mmNewBargeIn.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.NewBargeIn method")
	}

	mmNewBargeIn.mock.funcNewBargeIn = f
	return mmNewBargeIn.mock
}

// NewBargeIn implements ExecutionContext
func (mmNewBargeIn *ExecutionContextMock) NewBargeIn() (b1 BargeInBuilder) {
	mm_atomic.AddUint64(&mmNewBargeIn.beforeNewBargeInCounter, 1)
	defer mm_atomic.AddUint64(&mmNewBargeIn.afterNewBargeInCounter, 1)

	if mmNewBargeIn.inspectFuncNewBargeIn != nil {
		mmNewBargeIn.inspectFuncNewBargeIn()
	}

	if mmNewBargeIn.NewBargeInMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewBargeIn.NewBargeInMock.defaultExpectation.Counter, 1)

		mm_results := mmNewBargeIn.NewBargeInMock.defaultExpectation.results
		if mm_results == nil {
			mmNewBargeIn.t.Fatal("No results are set for the ExecutionContextMock.NewBargeIn")
		}
		return (*mm_results).b1
	}
	if mmNewBargeIn.funcNewBargeIn != nil {
		return mmNewBargeIn.funcNewBargeIn()
	}
	mmNewBargeIn.t.Fatalf("Unexpected call to ExecutionContextMock.NewBargeIn.")
	return
}

// NewBargeInAfterCounter returns a count of finished ExecutionContextMock.NewBargeIn invocations
func (mmNewBargeIn *ExecutionContextMock) NewBargeInAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewBargeIn.afterNewBargeInCounter)
}

// NewBargeInBeforeCounter returns a count of ExecutionContextMock.NewBargeIn invocations
func (mmNewBargeIn *ExecutionContextMock) NewBargeInBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewBargeIn.beforeNewBargeInCounter)
}

// MinimockNewBargeInDone returns true if the count of the NewBargeIn invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockNewBargeInDone() bool {
	for _, e := range m.NewBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewBargeInCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewBargeIn != nil && mm_atomic.LoadUint64(&m.afterNewBargeInCounter) < 1 {
		return false
	}
	return true
}

// MinimockNewBargeInInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockNewBargeInInspect() {
	for _, e := range m.NewBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.NewBargeIn")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewBargeInCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.NewBargeIn")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewBargeIn != nil && mm_atomic.LoadUint64(&m.afterNewBargeInCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.NewBargeIn")
	}
}

type mExecutionContextMockNewBargeInThisStepOnly struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockNewBargeInThisStepOnlyExpectation
	expectations       []*ExecutionContextMockNewBargeInThisStepOnlyExpectation
}

// ExecutionContextMockNewBargeInThisStepOnlyExpectation specifies expectation struct of the ExecutionContext.NewBargeInThisStepOnly
type ExecutionContextMockNewBargeInThisStepOnlyExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockNewBargeInThisStepOnlyResults
	Counter uint64
}

// ExecutionContextMockNewBargeInThisStepOnlyResults contains results of the ExecutionContext.NewBargeInThisStepOnly
type ExecutionContextMockNewBargeInThisStepOnlyResults struct {
	b1 BargeInBuilder
}

// Expect sets up expected params for ExecutionContext.NewBargeInThisStepOnly
func (mmNewBargeInThisStepOnly *mExecutionContextMockNewBargeInThisStepOnly) Expect() *mExecutionContextMockNewBargeInThisStepOnly {
	if mmNewBargeInThisStepOnly.mock.funcNewBargeInThisStepOnly != nil {
		mmNewBargeInThisStepOnly.mock.t.Fatalf("ExecutionContextMock.NewBargeInThisStepOnly mock is already set by Set")
	}

	if mmNewBargeInThisStepOnly.defaultExpectation == nil {
		mmNewBargeInThisStepOnly.defaultExpectation = &ExecutionContextMockNewBargeInThisStepOnlyExpectation{}
	}

	return mmNewBargeInThisStepOnly
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.NewBargeInThisStepOnly
func (mmNewBargeInThisStepOnly *mExecutionContextMockNewBargeInThisStepOnly) Inspect(f func()) *mExecutionContextMockNewBargeInThisStepOnly {
	if mmNewBargeInThisStepOnly.mock.inspectFuncNewBargeInThisStepOnly != nil {
		mmNewBargeInThisStepOnly.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.NewBargeInThisStepOnly")
	}

	mmNewBargeInThisStepOnly.mock.inspectFuncNewBargeInThisStepOnly = f

	return mmNewBargeInThisStepOnly
}

// Return sets up results that will be returned by ExecutionContext.NewBargeInThisStepOnly
func (mmNewBargeInThisStepOnly *mExecutionContextMockNewBargeInThisStepOnly) Return(b1 BargeInBuilder) *ExecutionContextMock {
	if mmNewBargeInThisStepOnly.mock.funcNewBargeInThisStepOnly != nil {
		mmNewBargeInThisStepOnly.mock.t.Fatalf("ExecutionContextMock.NewBargeInThisStepOnly mock is already set by Set")
	}

	if mmNewBargeInThisStepOnly.defaultExpectation == nil {
		mmNewBargeInThisStepOnly.defaultExpectation = &ExecutionContextMockNewBargeInThisStepOnlyExpectation{mock: mmNewBargeInThisStepOnly.mock}
	}
	mmNewBargeInThisStepOnly.defaultExpectation.results = &ExecutionContextMockNewBargeInThisStepOnlyResults{b1}
	return mmNewBargeInThisStepOnly.mock
}

//Set uses given function f to mock the ExecutionContext.NewBargeInThisStepOnly method
func (mmNewBargeInThisStepOnly *mExecutionContextMockNewBargeInThisStepOnly) Set(f func() (b1 BargeInBuilder)) *ExecutionContextMock {
	if mmNewBargeInThisStepOnly.defaultExpectation != nil {
		mmNewBargeInThisStepOnly.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.NewBargeInThisStepOnly method")
	}

	if len(mmNewBargeInThisStepOnly.expectations) > 0 {
		mmNewBargeInThisStepOnly.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.NewBargeInThisStepOnly method")
	}

	mmNewBargeInThisStepOnly.mock.funcNewBargeInThisStepOnly = f
	return mmNewBargeInThisStepOnly.mock
}

// NewBargeInThisStepOnly implements ExecutionContext
func (mmNewBargeInThisStepOnly *ExecutionContextMock) NewBargeInThisStepOnly() (b1 BargeInBuilder) {
	mm_atomic.AddUint64(&mmNewBargeInThisStepOnly.beforeNewBargeInThisStepOnlyCounter, 1)
	defer mm_atomic.AddUint64(&mmNewBargeInThisStepOnly.afterNewBargeInThisStepOnlyCounter, 1)

	if mmNewBargeInThisStepOnly.inspectFuncNewBargeInThisStepOnly != nil {
		mmNewBargeInThisStepOnly.inspectFuncNewBargeInThisStepOnly()
	}

	if mmNewBargeInThisStepOnly.NewBargeInThisStepOnlyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewBargeInThisStepOnly.NewBargeInThisStepOnlyMock.defaultExpectation.Counter, 1)

		mm_results := mmNewBargeInThisStepOnly.NewBargeInThisStepOnlyMock.defaultExpectation.results
		if mm_results == nil {
			mmNewBargeInThisStepOnly.t.Fatal("No results are set for the ExecutionContextMock.NewBargeInThisStepOnly")
		}
		return (*mm_results).b1
	}
	if mmNewBargeInThisStepOnly.funcNewBargeInThisStepOnly != nil {
		return mmNewBargeInThisStepOnly.funcNewBargeInThisStepOnly()
	}
	mmNewBargeInThisStepOnly.t.Fatalf("Unexpected call to ExecutionContextMock.NewBargeInThisStepOnly.")
	return
}

// NewBargeInThisStepOnlyAfterCounter returns a count of finished ExecutionContextMock.NewBargeInThisStepOnly invocations
func (mmNewBargeInThisStepOnly *ExecutionContextMock) NewBargeInThisStepOnlyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewBargeInThisStepOnly.afterNewBargeInThisStepOnlyCounter)
}

// NewBargeInThisStepOnlyBeforeCounter returns a count of ExecutionContextMock.NewBargeInThisStepOnly invocations
func (mmNewBargeInThisStepOnly *ExecutionContextMock) NewBargeInThisStepOnlyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewBargeInThisStepOnly.beforeNewBargeInThisStepOnlyCounter)
}

// MinimockNewBargeInThisStepOnlyDone returns true if the count of the NewBargeInThisStepOnly invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockNewBargeInThisStepOnlyDone() bool {
	for _, e := range m.NewBargeInThisStepOnlyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewBargeInThisStepOnlyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewBargeInThisStepOnlyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewBargeInThisStepOnly != nil && mm_atomic.LoadUint64(&m.afterNewBargeInThisStepOnlyCounter) < 1 {
		return false
	}
	return true
}

// MinimockNewBargeInThisStepOnlyInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockNewBargeInThisStepOnlyInspect() {
	for _, e := range m.NewBargeInThisStepOnlyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.NewBargeInThisStepOnly")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewBargeInThisStepOnlyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewBargeInThisStepOnlyCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.NewBargeInThisStepOnly")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewBargeInThisStepOnly != nil && mm_atomic.LoadUint64(&m.afterNewBargeInThisStepOnlyCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.NewBargeInThisStepOnly")
	}
}

type mExecutionContextMockNewBargeInWithParam struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockNewBargeInWithParamExpectation
	expectations       []*ExecutionContextMockNewBargeInWithParamExpectation

	callArgs []*ExecutionContextMockNewBargeInWithParamParams
	mutex    sync.RWMutex
}

// ExecutionContextMockNewBargeInWithParamExpectation specifies expectation struct of the ExecutionContext.NewBargeInWithParam
type ExecutionContextMockNewBargeInWithParamExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockNewBargeInWithParamParams
	results *ExecutionContextMockNewBargeInWithParamResults
	Counter uint64
}

// ExecutionContextMockNewBargeInWithParamParams contains parameters of the ExecutionContext.NewBargeInWithParam
type ExecutionContextMockNewBargeInWithParamParams struct {
	b1 BargeInApplyFunc
}

// ExecutionContextMockNewBargeInWithParamResults contains results of the ExecutionContext.NewBargeInWithParam
type ExecutionContextMockNewBargeInWithParamResults struct {
	b2 BargeInWithParam
}

// Expect sets up expected params for ExecutionContext.NewBargeInWithParam
func (mmNewBargeInWithParam *mExecutionContextMockNewBargeInWithParam) Expect(b1 BargeInApplyFunc) *mExecutionContextMockNewBargeInWithParam {
	if mmNewBargeInWithParam.mock.funcNewBargeInWithParam != nil {
		mmNewBargeInWithParam.mock.t.Fatalf("ExecutionContextMock.NewBargeInWithParam mock is already set by Set")
	}

	if mmNewBargeInWithParam.defaultExpectation == nil {
		mmNewBargeInWithParam.defaultExpectation = &ExecutionContextMockNewBargeInWithParamExpectation{}
	}

	mmNewBargeInWithParam.defaultExpectation.params = &ExecutionContextMockNewBargeInWithParamParams{b1}
	for _, e := range mmNewBargeInWithParam.expectations {
		if minimock.Equal(e.params, mmNewBargeInWithParam.defaultExpectation.params) {
			mmNewBargeInWithParam.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNewBargeInWithParam.defaultExpectation.params)
		}
	}

	return mmNewBargeInWithParam
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.NewBargeInWithParam
func (mmNewBargeInWithParam *mExecutionContextMockNewBargeInWithParam) Inspect(f func(b1 BargeInApplyFunc)) *mExecutionContextMockNewBargeInWithParam {
	if mmNewBargeInWithParam.mock.inspectFuncNewBargeInWithParam != nil {
		mmNewBargeInWithParam.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.NewBargeInWithParam")
	}

	mmNewBargeInWithParam.mock.inspectFuncNewBargeInWithParam = f

	return mmNewBargeInWithParam
}

// Return sets up results that will be returned by ExecutionContext.NewBargeInWithParam
func (mmNewBargeInWithParam *mExecutionContextMockNewBargeInWithParam) Return(b2 BargeInWithParam) *ExecutionContextMock {
	if mmNewBargeInWithParam.mock.funcNewBargeInWithParam != nil {
		mmNewBargeInWithParam.mock.t.Fatalf("ExecutionContextMock.NewBargeInWithParam mock is already set by Set")
	}

	if mmNewBargeInWithParam.defaultExpectation == nil {
		mmNewBargeInWithParam.defaultExpectation = &ExecutionContextMockNewBargeInWithParamExpectation{mock: mmNewBargeInWithParam.mock}
	}
	mmNewBargeInWithParam.defaultExpectation.results = &ExecutionContextMockNewBargeInWithParamResults{b2}
	return mmNewBargeInWithParam.mock
}

//Set uses given function f to mock the ExecutionContext.NewBargeInWithParam method
func (mmNewBargeInWithParam *mExecutionContextMockNewBargeInWithParam) Set(f func(b1 BargeInApplyFunc) (b2 BargeInWithParam)) *ExecutionContextMock {
	if mmNewBargeInWithParam.defaultExpectation != nil {
		mmNewBargeInWithParam.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.NewBargeInWithParam method")
	}

	if len(mmNewBargeInWithParam.expectations) > 0 {
		mmNewBargeInWithParam.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.NewBargeInWithParam method")
	}

	mmNewBargeInWithParam.mock.funcNewBargeInWithParam = f
	return mmNewBargeInWithParam.mock
}

// When sets expectation for the ExecutionContext.NewBargeInWithParam which will trigger the result defined by the following
// Then helper
func (mmNewBargeInWithParam *mExecutionContextMockNewBargeInWithParam) When(b1 BargeInApplyFunc) *ExecutionContextMockNewBargeInWithParamExpectation {
	if mmNewBargeInWithParam.mock.funcNewBargeInWithParam != nil {
		mmNewBargeInWithParam.mock.t.Fatalf("ExecutionContextMock.NewBargeInWithParam mock is already set by Set")
	}

	expectation := &ExecutionContextMockNewBargeInWithParamExpectation{
		mock:   mmNewBargeInWithParam.mock,
		params: &ExecutionContextMockNewBargeInWithParamParams{b1},
	}
	mmNewBargeInWithParam.expectations = append(mmNewBargeInWithParam.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.NewBargeInWithParam return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockNewBargeInWithParamExpectation) Then(b2 BargeInWithParam) *ExecutionContextMock {
	e.results = &ExecutionContextMockNewBargeInWithParamResults{b2}
	return e.mock
}

// NewBargeInWithParam implements ExecutionContext
func (mmNewBargeInWithParam *ExecutionContextMock) NewBargeInWithParam(b1 BargeInApplyFunc) (b2 BargeInWithParam) {
	mm_atomic.AddUint64(&mmNewBargeInWithParam.beforeNewBargeInWithParamCounter, 1)
	defer mm_atomic.AddUint64(&mmNewBargeInWithParam.afterNewBargeInWithParamCounter, 1)

	if mmNewBargeInWithParam.inspectFuncNewBargeInWithParam != nil {
		mmNewBargeInWithParam.inspectFuncNewBargeInWithParam(b1)
	}

	mm_params := &ExecutionContextMockNewBargeInWithParamParams{b1}

	// Record call args
	mmNewBargeInWithParam.NewBargeInWithParamMock.mutex.Lock()
	mmNewBargeInWithParam.NewBargeInWithParamMock.callArgs = append(mmNewBargeInWithParam.NewBargeInWithParamMock.callArgs, mm_params)
	mmNewBargeInWithParam.NewBargeInWithParamMock.mutex.Unlock()

	for _, e := range mmNewBargeInWithParam.NewBargeInWithParamMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b2
		}
	}

	if mmNewBargeInWithParam.NewBargeInWithParamMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewBargeInWithParam.NewBargeInWithParamMock.defaultExpectation.Counter, 1)
		mm_want := mmNewBargeInWithParam.NewBargeInWithParamMock.defaultExpectation.params
		mm_got := ExecutionContextMockNewBargeInWithParamParams{b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNewBargeInWithParam.t.Errorf("ExecutionContextMock.NewBargeInWithParam got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNewBargeInWithParam.NewBargeInWithParamMock.defaultExpectation.results
		if mm_results == nil {
			mmNewBargeInWithParam.t.Fatal("No results are set for the ExecutionContextMock.NewBargeInWithParam")
		}
		return (*mm_results).b2
	}
	if mmNewBargeInWithParam.funcNewBargeInWithParam != nil {
		return mmNewBargeInWithParam.funcNewBargeInWithParam(b1)
	}
	mmNewBargeInWithParam.t.Fatalf("Unexpected call to ExecutionContextMock.NewBargeInWithParam. %v", b1)
	return
}

// NewBargeInWithParamAfterCounter returns a count of finished ExecutionContextMock.NewBargeInWithParam invocations
func (mmNewBargeInWithParam *ExecutionContextMock) NewBargeInWithParamAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewBargeInWithParam.afterNewBargeInWithParamCounter)
}

// NewBargeInWithParamBeforeCounter returns a count of ExecutionContextMock.NewBargeInWithParam invocations
func (mmNewBargeInWithParam *ExecutionContextMock) NewBargeInWithParamBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewBargeInWithParam.beforeNewBargeInWithParamCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.NewBargeInWithParam.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNewBargeInWithParam *mExecutionContextMockNewBargeInWithParam) Calls() []*ExecutionContextMockNewBargeInWithParamParams {
	mmNewBargeInWithParam.mutex.RLock()

	argCopy := make([]*ExecutionContextMockNewBargeInWithParamParams, len(mmNewBargeInWithParam.callArgs))
	copy(argCopy, mmNewBargeInWithParam.callArgs)

	mmNewBargeInWithParam.mutex.RUnlock()

	return argCopy
}

// MinimockNewBargeInWithParamDone returns true if the count of the NewBargeInWithParam invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockNewBargeInWithParamDone() bool {
	for _, e := range m.NewBargeInWithParamMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewBargeInWithParamMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewBargeInWithParamCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewBargeInWithParam != nil && mm_atomic.LoadUint64(&m.afterNewBargeInWithParamCounter) < 1 {
		return false
	}
	return true
}

// MinimockNewBargeInWithParamInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockNewBargeInWithParamInspect() {
	for _, e := range m.NewBargeInWithParamMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.NewBargeInWithParam with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewBargeInWithParamMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewBargeInWithParamCounter) < 1 {
		if m.NewBargeInWithParamMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.NewBargeInWithParam")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.NewBargeInWithParam with params: %#v", *m.NewBargeInWithParamMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewBargeInWithParam != nil && mm_atomic.LoadUint64(&m.afterNewBargeInWithParamCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.NewBargeInWithParam")
	}
}

type mExecutionContextMockNewChild struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockNewChildExpectation
	expectations       []*ExecutionContextMockNewChildExpectation

	callArgs []*ExecutionContextMockNewChildParams
	mutex    sync.RWMutex
}

// ExecutionContextMockNewChildExpectation specifies expectation struct of the ExecutionContext.NewChild
type ExecutionContextMockNewChildExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockNewChildParams
	results *ExecutionContextMockNewChildResults
	Counter uint64
}

// ExecutionContextMockNewChildParams contains parameters of the ExecutionContext.NewChild
type ExecutionContextMockNewChildParams struct {
	c1 CreateFunc
}

// ExecutionContextMockNewChildResults contains results of the ExecutionContext.NewChild
type ExecutionContextMockNewChildResults struct {
	s1 SlotLink
}

// Expect sets up expected params for ExecutionContext.NewChild
func (mmNewChild *mExecutionContextMockNewChild) Expect(c1 CreateFunc) *mExecutionContextMockNewChild {
	if mmNewChild.mock.funcNewChild != nil {
		mmNewChild.mock.t.Fatalf("ExecutionContextMock.NewChild mock is already set by Set")
	}

	if mmNewChild.defaultExpectation == nil {
		mmNewChild.defaultExpectation = &ExecutionContextMockNewChildExpectation{}
	}

	mmNewChild.defaultExpectation.params = &ExecutionContextMockNewChildParams{c1}
	for _, e := range mmNewChild.expectations {
		if minimock.Equal(e.params, mmNewChild.defaultExpectation.params) {
			mmNewChild.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNewChild.defaultExpectation.params)
		}
	}

	return mmNewChild
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.NewChild
func (mmNewChild *mExecutionContextMockNewChild) Inspect(f func(c1 CreateFunc)) *mExecutionContextMockNewChild {
	if mmNewChild.mock.inspectFuncNewChild != nil {
		mmNewChild.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.NewChild")
	}

	mmNewChild.mock.inspectFuncNewChild = f

	return mmNewChild
}

// Return sets up results that will be returned by ExecutionContext.NewChild
func (mmNewChild *mExecutionContextMockNewChild) Return(s1 SlotLink) *ExecutionContextMock {
	if mmNewChild.mock.funcNewChild != nil {
		mmNewChild.mock.t.Fatalf("ExecutionContextMock.NewChild mock is already set by Set")
	}

	if mmNewChild.defaultExpectation == nil {
		mmNewChild.defaultExpectation = &ExecutionContextMockNewChildExpectation{mock: mmNewChild.mock}
	}
	mmNewChild.defaultExpectation.results = &ExecutionContextMockNewChildResults{s1}
	return mmNewChild.mock
}

//Set uses given function f to mock the ExecutionContext.NewChild method
func (mmNewChild *mExecutionContextMockNewChild) Set(f func(c1 CreateFunc) (s1 SlotLink)) *ExecutionContextMock {
	if mmNewChild.defaultExpectation != nil {
		mmNewChild.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.NewChild method")
	}

	if len(mmNewChild.expectations) > 0 {
		mmNewChild.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.NewChild method")
	}

	mmNewChild.mock.funcNewChild = f
	return mmNewChild.mock
}

// When sets expectation for the ExecutionContext.NewChild which will trigger the result defined by the following
// Then helper
func (mmNewChild *mExecutionContextMockNewChild) When(c1 CreateFunc) *ExecutionContextMockNewChildExpectation {
	if mmNewChild.mock.funcNewChild != nil {
		mmNewChild.mock.t.Fatalf("ExecutionContextMock.NewChild mock is already set by Set")
	}

	expectation := &ExecutionContextMockNewChildExpectation{
		mock:   mmNewChild.mock,
		params: &ExecutionContextMockNewChildParams{c1},
	}
	mmNewChild.expectations = append(mmNewChild.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.NewChild return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockNewChildExpectation) Then(s1 SlotLink) *ExecutionContextMock {
	e.results = &ExecutionContextMockNewChildResults{s1}
	return e.mock
}

// NewChild implements ExecutionContext
func (mmNewChild *ExecutionContextMock) NewChild(c1 CreateFunc) (s1 SlotLink) {
	mm_atomic.AddUint64(&mmNewChild.beforeNewChildCounter, 1)
	defer mm_atomic.AddUint64(&mmNewChild.afterNewChildCounter, 1)

	if mmNewChild.inspectFuncNewChild != nil {
		mmNewChild.inspectFuncNewChild(c1)
	}

	mm_params := &ExecutionContextMockNewChildParams{c1}

	// Record call args
	mmNewChild.NewChildMock.mutex.Lock()
	mmNewChild.NewChildMock.callArgs = append(mmNewChild.NewChildMock.callArgs, mm_params)
	mmNewChild.NewChildMock.mutex.Unlock()

	for _, e := range mmNewChild.NewChildMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmNewChild.NewChildMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewChild.NewChildMock.defaultExpectation.Counter, 1)
		mm_want := mmNewChild.NewChildMock.defaultExpectation.params
		mm_got := ExecutionContextMockNewChildParams{c1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNewChild.t.Errorf("ExecutionContextMock.NewChild got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNewChild.NewChildMock.defaultExpectation.results
		if mm_results == nil {
			mmNewChild.t.Fatal("No results are set for the ExecutionContextMock.NewChild")
		}
		return (*mm_results).s1
	}
	if mmNewChild.funcNewChild != nil {
		return mmNewChild.funcNewChild(c1)
	}
	mmNewChild.t.Fatalf("Unexpected call to ExecutionContextMock.NewChild. %v", c1)
	return
}

// NewChildAfterCounter returns a count of finished ExecutionContextMock.NewChild invocations
func (mmNewChild *ExecutionContextMock) NewChildAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewChild.afterNewChildCounter)
}

// NewChildBeforeCounter returns a count of ExecutionContextMock.NewChild invocations
func (mmNewChild *ExecutionContextMock) NewChildBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewChild.beforeNewChildCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.NewChild.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNewChild *mExecutionContextMockNewChild) Calls() []*ExecutionContextMockNewChildParams {
	mmNewChild.mutex.RLock()

	argCopy := make([]*ExecutionContextMockNewChildParams, len(mmNewChild.callArgs))
	copy(argCopy, mmNewChild.callArgs)

	mmNewChild.mutex.RUnlock()

	return argCopy
}

// MinimockNewChildDone returns true if the count of the NewChild invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockNewChildDone() bool {
	for _, e := range m.NewChildMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewChildMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewChildCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewChild != nil && mm_atomic.LoadUint64(&m.afterNewChildCounter) < 1 {
		return false
	}
	return true
}

// MinimockNewChildInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockNewChildInspect() {
	for _, e := range m.NewChildMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.NewChild with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewChildMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewChildCounter) < 1 {
		if m.NewChildMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.NewChild")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.NewChild with params: %#v", *m.NewChildMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewChild != nil && mm_atomic.LoadUint64(&m.afterNewChildCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.NewChild")
	}
}

type mExecutionContextMockNewChildExt struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockNewChildExtExpectation
	expectations       []*ExecutionContextMockNewChildExtExpectation

	callArgs []*ExecutionContextMockNewChildExtParams
	mutex    sync.RWMutex
}

// ExecutionContextMockNewChildExtExpectation specifies expectation struct of the ExecutionContext.NewChildExt
type ExecutionContextMockNewChildExtExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockNewChildExtParams
	results *ExecutionContextMockNewChildExtResults
	Counter uint64
}

// ExecutionContextMockNewChildExtParams contains parameters of the ExecutionContext.NewChildExt
type ExecutionContextMockNewChildExtParams struct {
	c1 CreateFunc
	c2 CreateDefaultValues
}

// ExecutionContextMockNewChildExtResults contains results of the ExecutionContext.NewChildExt
type ExecutionContextMockNewChildExtResults struct {
	s1 SlotLink
}

// Expect sets up expected params for ExecutionContext.NewChildExt
func (mmNewChildExt *mExecutionContextMockNewChildExt) Expect(c1 CreateFunc, c2 CreateDefaultValues) *mExecutionContextMockNewChildExt {
	if mmNewChildExt.mock.funcNewChildExt != nil {
		mmNewChildExt.mock.t.Fatalf("ExecutionContextMock.NewChildExt mock is already set by Set")
	}

	if mmNewChildExt.defaultExpectation == nil {
		mmNewChildExt.defaultExpectation = &ExecutionContextMockNewChildExtExpectation{}
	}

	mmNewChildExt.defaultExpectation.params = &ExecutionContextMockNewChildExtParams{c1, c2}
	for _, e := range mmNewChildExt.expectations {
		if minimock.Equal(e.params, mmNewChildExt.defaultExpectation.params) {
			mmNewChildExt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNewChildExt.defaultExpectation.params)
		}
	}

	return mmNewChildExt
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.NewChildExt
func (mmNewChildExt *mExecutionContextMockNewChildExt) Inspect(f func(c1 CreateFunc, c2 CreateDefaultValues)) *mExecutionContextMockNewChildExt {
	if mmNewChildExt.mock.inspectFuncNewChildExt != nil {
		mmNewChildExt.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.NewChildExt")
	}

	mmNewChildExt.mock.inspectFuncNewChildExt = f

	return mmNewChildExt
}

// Return sets up results that will be returned by ExecutionContext.NewChildExt
func (mmNewChildExt *mExecutionContextMockNewChildExt) Return(s1 SlotLink) *ExecutionContextMock {
	if mmNewChildExt.mock.funcNewChildExt != nil {
		mmNewChildExt.mock.t.Fatalf("ExecutionContextMock.NewChildExt mock is already set by Set")
	}

	if mmNewChildExt.defaultExpectation == nil {
		mmNewChildExt.defaultExpectation = &ExecutionContextMockNewChildExtExpectation{mock: mmNewChildExt.mock}
	}
	mmNewChildExt.defaultExpectation.results = &ExecutionContextMockNewChildExtResults{s1}
	return mmNewChildExt.mock
}

//Set uses given function f to mock the ExecutionContext.NewChildExt method
func (mmNewChildExt *mExecutionContextMockNewChildExt) Set(f func(c1 CreateFunc, c2 CreateDefaultValues) (s1 SlotLink)) *ExecutionContextMock {
	if mmNewChildExt.defaultExpectation != nil {
		mmNewChildExt.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.NewChildExt method")
	}

	if len(mmNewChildExt.expectations) > 0 {
		mmNewChildExt.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.NewChildExt method")
	}

	mmNewChildExt.mock.funcNewChildExt = f
	return mmNewChildExt.mock
}

// When sets expectation for the ExecutionContext.NewChildExt which will trigger the result defined by the following
// Then helper
func (mmNewChildExt *mExecutionContextMockNewChildExt) When(c1 CreateFunc, c2 CreateDefaultValues) *ExecutionContextMockNewChildExtExpectation {
	if mmNewChildExt.mock.funcNewChildExt != nil {
		mmNewChildExt.mock.t.Fatalf("ExecutionContextMock.NewChildExt mock is already set by Set")
	}

	expectation := &ExecutionContextMockNewChildExtExpectation{
		mock:   mmNewChildExt.mock,
		params: &ExecutionContextMockNewChildExtParams{c1, c2},
	}
	mmNewChildExt.expectations = append(mmNewChildExt.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.NewChildExt return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockNewChildExtExpectation) Then(s1 SlotLink) *ExecutionContextMock {
	e.results = &ExecutionContextMockNewChildExtResults{s1}
	return e.mock
}

// NewChildExt implements ExecutionContext
func (mmNewChildExt *ExecutionContextMock) NewChildExt(c1 CreateFunc, c2 CreateDefaultValues) (s1 SlotLink) {
	mm_atomic.AddUint64(&mmNewChildExt.beforeNewChildExtCounter, 1)
	defer mm_atomic.AddUint64(&mmNewChildExt.afterNewChildExtCounter, 1)

	if mmNewChildExt.inspectFuncNewChildExt != nil {
		mmNewChildExt.inspectFuncNewChildExt(c1, c2)
	}

	mm_params := &ExecutionContextMockNewChildExtParams{c1, c2}

	// Record call args
	mmNewChildExt.NewChildExtMock.mutex.Lock()
	mmNewChildExt.NewChildExtMock.callArgs = append(mmNewChildExt.NewChildExtMock.callArgs, mm_params)
	mmNewChildExt.NewChildExtMock.mutex.Unlock()

	for _, e := range mmNewChildExt.NewChildExtMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmNewChildExt.NewChildExtMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewChildExt.NewChildExtMock.defaultExpectation.Counter, 1)
		mm_want := mmNewChildExt.NewChildExtMock.defaultExpectation.params
		mm_got := ExecutionContextMockNewChildExtParams{c1, c2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNewChildExt.t.Errorf("ExecutionContextMock.NewChildExt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNewChildExt.NewChildExtMock.defaultExpectation.results
		if mm_results == nil {
			mmNewChildExt.t.Fatal("No results are set for the ExecutionContextMock.NewChildExt")
		}
		return (*mm_results).s1
	}
	if mmNewChildExt.funcNewChildExt != nil {
		return mmNewChildExt.funcNewChildExt(c1, c2)
	}
	mmNewChildExt.t.Fatalf("Unexpected call to ExecutionContextMock.NewChildExt. %v %v", c1, c2)
	return
}

// NewChildExtAfterCounter returns a count of finished ExecutionContextMock.NewChildExt invocations
func (mmNewChildExt *ExecutionContextMock) NewChildExtAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewChildExt.afterNewChildExtCounter)
}

// NewChildExtBeforeCounter returns a count of ExecutionContextMock.NewChildExt invocations
func (mmNewChildExt *ExecutionContextMock) NewChildExtBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewChildExt.beforeNewChildExtCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.NewChildExt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNewChildExt *mExecutionContextMockNewChildExt) Calls() []*ExecutionContextMockNewChildExtParams {
	mmNewChildExt.mutex.RLock()

	argCopy := make([]*ExecutionContextMockNewChildExtParams, len(mmNewChildExt.callArgs))
	copy(argCopy, mmNewChildExt.callArgs)

	mmNewChildExt.mutex.RUnlock()

	return argCopy
}

// MinimockNewChildExtDone returns true if the count of the NewChildExt invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockNewChildExtDone() bool {
	for _, e := range m.NewChildExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewChildExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewChildExtCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewChildExt != nil && mm_atomic.LoadUint64(&m.afterNewChildExtCounter) < 1 {
		return false
	}
	return true
}

// MinimockNewChildExtInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockNewChildExtInspect() {
	for _, e := range m.NewChildExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.NewChildExt with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewChildExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewChildExtCounter) < 1 {
		if m.NewChildExtMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.NewChildExt")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.NewChildExt with params: %#v", *m.NewChildExtMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewChildExt != nil && mm_atomic.LoadUint64(&m.afterNewChildExtCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.NewChildExt")
	}
}

type mExecutionContextMockOverrideDynamicBoost struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockOverrideDynamicBoostExpectation
	expectations       []*ExecutionContextMockOverrideDynamicBoostExpectation

	callArgs []*ExecutionContextMockOverrideDynamicBoostParams
	mutex    sync.RWMutex
}

// ExecutionContextMockOverrideDynamicBoostExpectation specifies expectation struct of the ExecutionContext.OverrideDynamicBoost
type ExecutionContextMockOverrideDynamicBoostExpectation struct {
	mock   *ExecutionContextMock
	params *ExecutionContextMockOverrideDynamicBoostParams

	Counter uint64
}

// ExecutionContextMockOverrideDynamicBoostParams contains parameters of the ExecutionContext.OverrideDynamicBoost
type ExecutionContextMockOverrideDynamicBoostParams struct {
	b1 bool
}

// Expect sets up expected params for ExecutionContext.OverrideDynamicBoost
func (mmOverrideDynamicBoost *mExecutionContextMockOverrideDynamicBoost) Expect(b1 bool) *mExecutionContextMockOverrideDynamicBoost {
	if mmOverrideDynamicBoost.mock.funcOverrideDynamicBoost != nil {
		mmOverrideDynamicBoost.mock.t.Fatalf("ExecutionContextMock.OverrideDynamicBoost mock is already set by Set")
	}

	if mmOverrideDynamicBoost.defaultExpectation == nil {
		mmOverrideDynamicBoost.defaultExpectation = &ExecutionContextMockOverrideDynamicBoostExpectation{}
	}

	mmOverrideDynamicBoost.defaultExpectation.params = &ExecutionContextMockOverrideDynamicBoostParams{b1}
	for _, e := range mmOverrideDynamicBoost.expectations {
		if minimock.Equal(e.params, mmOverrideDynamicBoost.defaultExpectation.params) {
			mmOverrideDynamicBoost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOverrideDynamicBoost.defaultExpectation.params)
		}
	}

	return mmOverrideDynamicBoost
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.OverrideDynamicBoost
func (mmOverrideDynamicBoost *mExecutionContextMockOverrideDynamicBoost) Inspect(f func(b1 bool)) *mExecutionContextMockOverrideDynamicBoost {
	if mmOverrideDynamicBoost.mock.inspectFuncOverrideDynamicBoost != nil {
		mmOverrideDynamicBoost.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.OverrideDynamicBoost")
	}

	mmOverrideDynamicBoost.mock.inspectFuncOverrideDynamicBoost = f

	return mmOverrideDynamicBoost
}

// Return sets up results that will be returned by ExecutionContext.OverrideDynamicBoost
func (mmOverrideDynamicBoost *mExecutionContextMockOverrideDynamicBoost) Return() *ExecutionContextMock {
	if mmOverrideDynamicBoost.mock.funcOverrideDynamicBoost != nil {
		mmOverrideDynamicBoost.mock.t.Fatalf("ExecutionContextMock.OverrideDynamicBoost mock is already set by Set")
	}

	if mmOverrideDynamicBoost.defaultExpectation == nil {
		mmOverrideDynamicBoost.defaultExpectation = &ExecutionContextMockOverrideDynamicBoostExpectation{mock: mmOverrideDynamicBoost.mock}
	}

	return mmOverrideDynamicBoost.mock
}

//Set uses given function f to mock the ExecutionContext.OverrideDynamicBoost method
func (mmOverrideDynamicBoost *mExecutionContextMockOverrideDynamicBoost) Set(f func(b1 bool)) *ExecutionContextMock {
	if mmOverrideDynamicBoost.defaultExpectation != nil {
		mmOverrideDynamicBoost.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.OverrideDynamicBoost method")
	}

	if len(mmOverrideDynamicBoost.expectations) > 0 {
		mmOverrideDynamicBoost.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.OverrideDynamicBoost method")
	}

	mmOverrideDynamicBoost.mock.funcOverrideDynamicBoost = f
	return mmOverrideDynamicBoost.mock
}

// OverrideDynamicBoost implements ExecutionContext
func (mmOverrideDynamicBoost *ExecutionContextMock) OverrideDynamicBoost(b1 bool) {
	mm_atomic.AddUint64(&mmOverrideDynamicBoost.beforeOverrideDynamicBoostCounter, 1)
	defer mm_atomic.AddUint64(&mmOverrideDynamicBoost.afterOverrideDynamicBoostCounter, 1)

	if mmOverrideDynamicBoost.inspectFuncOverrideDynamicBoost != nil {
		mmOverrideDynamicBoost.inspectFuncOverrideDynamicBoost(b1)
	}

	mm_params := &ExecutionContextMockOverrideDynamicBoostParams{b1}

	// Record call args
	mmOverrideDynamicBoost.OverrideDynamicBoostMock.mutex.Lock()
	mmOverrideDynamicBoost.OverrideDynamicBoostMock.callArgs = append(mmOverrideDynamicBoost.OverrideDynamicBoostMock.callArgs, mm_params)
	mmOverrideDynamicBoost.OverrideDynamicBoostMock.mutex.Unlock()

	for _, e := range mmOverrideDynamicBoost.OverrideDynamicBoostMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmOverrideDynamicBoost.OverrideDynamicBoostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOverrideDynamicBoost.OverrideDynamicBoostMock.defaultExpectation.Counter, 1)
		mm_want := mmOverrideDynamicBoost.OverrideDynamicBoostMock.defaultExpectation.params
		mm_got := ExecutionContextMockOverrideDynamicBoostParams{b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOverrideDynamicBoost.t.Errorf("ExecutionContextMock.OverrideDynamicBoost got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmOverrideDynamicBoost.funcOverrideDynamicBoost != nil {
		mmOverrideDynamicBoost.funcOverrideDynamicBoost(b1)
		return
	}
	mmOverrideDynamicBoost.t.Fatalf("Unexpected call to ExecutionContextMock.OverrideDynamicBoost. %v", b1)

}

// OverrideDynamicBoostAfterCounter returns a count of finished ExecutionContextMock.OverrideDynamicBoost invocations
func (mmOverrideDynamicBoost *ExecutionContextMock) OverrideDynamicBoostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOverrideDynamicBoost.afterOverrideDynamicBoostCounter)
}

// OverrideDynamicBoostBeforeCounter returns a count of ExecutionContextMock.OverrideDynamicBoost invocations
func (mmOverrideDynamicBoost *ExecutionContextMock) OverrideDynamicBoostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOverrideDynamicBoost.beforeOverrideDynamicBoostCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.OverrideDynamicBoost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOverrideDynamicBoost *mExecutionContextMockOverrideDynamicBoost) Calls() []*ExecutionContextMockOverrideDynamicBoostParams {
	mmOverrideDynamicBoost.mutex.RLock()

	argCopy := make([]*ExecutionContextMockOverrideDynamicBoostParams, len(mmOverrideDynamicBoost.callArgs))
	copy(argCopy, mmOverrideDynamicBoost.callArgs)

	mmOverrideDynamicBoost.mutex.RUnlock()

	return argCopy
}

// MinimockOverrideDynamicBoostDone returns true if the count of the OverrideDynamicBoost invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockOverrideDynamicBoostDone() bool {
	for _, e := range m.OverrideDynamicBoostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OverrideDynamicBoostMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOverrideDynamicBoostCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOverrideDynamicBoost != nil && mm_atomic.LoadUint64(&m.afterOverrideDynamicBoostCounter) < 1 {
		return false
	}
	return true
}

// MinimockOverrideDynamicBoostInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockOverrideDynamicBoostInspect() {
	for _, e := range m.OverrideDynamicBoostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.OverrideDynamicBoost with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OverrideDynamicBoostMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOverrideDynamicBoostCounter) < 1 {
		if m.OverrideDynamicBoostMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.OverrideDynamicBoost")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.OverrideDynamicBoost with params: %#v", *m.OverrideDynamicBoostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOverrideDynamicBoost != nil && mm_atomic.LoadUint64(&m.afterOverrideDynamicBoostCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.OverrideDynamicBoost")
	}
}

type mExecutionContextMockParentLink struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockParentLinkExpectation
	expectations       []*ExecutionContextMockParentLinkExpectation
}

// ExecutionContextMockParentLinkExpectation specifies expectation struct of the ExecutionContext.ParentLink
type ExecutionContextMockParentLinkExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockParentLinkResults
	Counter uint64
}

// ExecutionContextMockParentLinkResults contains results of the ExecutionContext.ParentLink
type ExecutionContextMockParentLinkResults struct {
	s1 SlotLink
}

// Expect sets up expected params for ExecutionContext.ParentLink
func (mmParentLink *mExecutionContextMockParentLink) Expect() *mExecutionContextMockParentLink {
	if mmParentLink.mock.funcParentLink != nil {
		mmParentLink.mock.t.Fatalf("ExecutionContextMock.ParentLink mock is already set by Set")
	}

	if mmParentLink.defaultExpectation == nil {
		mmParentLink.defaultExpectation = &ExecutionContextMockParentLinkExpectation{}
	}

	return mmParentLink
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.ParentLink
func (mmParentLink *mExecutionContextMockParentLink) Inspect(f func()) *mExecutionContextMockParentLink {
	if mmParentLink.mock.inspectFuncParentLink != nil {
		mmParentLink.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.ParentLink")
	}

	mmParentLink.mock.inspectFuncParentLink = f

	return mmParentLink
}

// Return sets up results that will be returned by ExecutionContext.ParentLink
func (mmParentLink *mExecutionContextMockParentLink) Return(s1 SlotLink) *ExecutionContextMock {
	if mmParentLink.mock.funcParentLink != nil {
		mmParentLink.mock.t.Fatalf("ExecutionContextMock.ParentLink mock is already set by Set")
	}

	if mmParentLink.defaultExpectation == nil {
		mmParentLink.defaultExpectation = &ExecutionContextMockParentLinkExpectation{mock: mmParentLink.mock}
	}
	mmParentLink.defaultExpectation.results = &ExecutionContextMockParentLinkResults{s1}
	return mmParentLink.mock
}

//Set uses given function f to mock the ExecutionContext.ParentLink method
func (mmParentLink *mExecutionContextMockParentLink) Set(f func() (s1 SlotLink)) *ExecutionContextMock {
	if mmParentLink.defaultExpectation != nil {
		mmParentLink.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.ParentLink method")
	}

	if len(mmParentLink.expectations) > 0 {
		mmParentLink.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.ParentLink method")
	}

	mmParentLink.mock.funcParentLink = f
	return mmParentLink.mock
}

// ParentLink implements ExecutionContext
func (mmParentLink *ExecutionContextMock) ParentLink() (s1 SlotLink) {
	mm_atomic.AddUint64(&mmParentLink.beforeParentLinkCounter, 1)
	defer mm_atomic.AddUint64(&mmParentLink.afterParentLinkCounter, 1)

	if mmParentLink.inspectFuncParentLink != nil {
		mmParentLink.inspectFuncParentLink()
	}

	if mmParentLink.ParentLinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmParentLink.ParentLinkMock.defaultExpectation.Counter, 1)

		mm_results := mmParentLink.ParentLinkMock.defaultExpectation.results
		if mm_results == nil {
			mmParentLink.t.Fatal("No results are set for the ExecutionContextMock.ParentLink")
		}
		return (*mm_results).s1
	}
	if mmParentLink.funcParentLink != nil {
		return mmParentLink.funcParentLink()
	}
	mmParentLink.t.Fatalf("Unexpected call to ExecutionContextMock.ParentLink.")
	return
}

// ParentLinkAfterCounter returns a count of finished ExecutionContextMock.ParentLink invocations
func (mmParentLink *ExecutionContextMock) ParentLinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParentLink.afterParentLinkCounter)
}

// ParentLinkBeforeCounter returns a count of ExecutionContextMock.ParentLink invocations
func (mmParentLink *ExecutionContextMock) ParentLinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParentLink.beforeParentLinkCounter)
}

// MinimockParentLinkDone returns true if the count of the ParentLink invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockParentLinkDone() bool {
	for _, e := range m.ParentLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParentLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParentLinkCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParentLink != nil && mm_atomic.LoadUint64(&m.afterParentLinkCounter) < 1 {
		return false
	}
	return true
}

// MinimockParentLinkInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockParentLinkInspect() {
	for _, e := range m.ParentLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.ParentLink")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParentLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParentLinkCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.ParentLink")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParentLink != nil && mm_atomic.LoadUint64(&m.afterParentLinkCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.ParentLink")
	}
}

type mExecutionContextMockPoll struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockPollExpectation
	expectations       []*ExecutionContextMockPollExpectation
}

// ExecutionContextMockPollExpectation specifies expectation struct of the ExecutionContext.Poll
type ExecutionContextMockPollExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockPollResults
	Counter uint64
}

// ExecutionContextMockPollResults contains results of the ExecutionContext.Poll
type ExecutionContextMockPollResults struct {
	c1 ConditionalBuilder
}

// Expect sets up expected params for ExecutionContext.Poll
func (mmPoll *mExecutionContextMockPoll) Expect() *mExecutionContextMockPoll {
	if mmPoll.mock.funcPoll != nil {
		mmPoll.mock.t.Fatalf("ExecutionContextMock.Poll mock is already set by Set")
	}

	if mmPoll.defaultExpectation == nil {
		mmPoll.defaultExpectation = &ExecutionContextMockPollExpectation{}
	}

	return mmPoll
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Poll
func (mmPoll *mExecutionContextMockPoll) Inspect(f func()) *mExecutionContextMockPoll {
	if mmPoll.mock.inspectFuncPoll != nil {
		mmPoll.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Poll")
	}

	mmPoll.mock.inspectFuncPoll = f

	return mmPoll
}

// Return sets up results that will be returned by ExecutionContext.Poll
func (mmPoll *mExecutionContextMockPoll) Return(c1 ConditionalBuilder) *ExecutionContextMock {
	if mmPoll.mock.funcPoll != nil {
		mmPoll.mock.t.Fatalf("ExecutionContextMock.Poll mock is already set by Set")
	}

	if mmPoll.defaultExpectation == nil {
		mmPoll.defaultExpectation = &ExecutionContextMockPollExpectation{mock: mmPoll.mock}
	}
	mmPoll.defaultExpectation.results = &ExecutionContextMockPollResults{c1}
	return mmPoll.mock
}

//Set uses given function f to mock the ExecutionContext.Poll method
func (mmPoll *mExecutionContextMockPoll) Set(f func() (c1 ConditionalBuilder)) *ExecutionContextMock {
	if mmPoll.defaultExpectation != nil {
		mmPoll.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Poll method")
	}

	if len(mmPoll.expectations) > 0 {
		mmPoll.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Poll method")
	}

	mmPoll.mock.funcPoll = f
	return mmPoll.mock
}

// Poll implements ExecutionContext
func (mmPoll *ExecutionContextMock) Poll() (c1 ConditionalBuilder) {
	mm_atomic.AddUint64(&mmPoll.beforePollCounter, 1)
	defer mm_atomic.AddUint64(&mmPoll.afterPollCounter, 1)

	if mmPoll.inspectFuncPoll != nil {
		mmPoll.inspectFuncPoll()
	}

	if mmPoll.PollMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPoll.PollMock.defaultExpectation.Counter, 1)

		mm_results := mmPoll.PollMock.defaultExpectation.results
		if mm_results == nil {
			mmPoll.t.Fatal("No results are set for the ExecutionContextMock.Poll")
		}
		return (*mm_results).c1
	}
	if mmPoll.funcPoll != nil {
		return mmPoll.funcPoll()
	}
	mmPoll.t.Fatalf("Unexpected call to ExecutionContextMock.Poll.")
	return
}

// PollAfterCounter returns a count of finished ExecutionContextMock.Poll invocations
func (mmPoll *ExecutionContextMock) PollAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPoll.afterPollCounter)
}

// PollBeforeCounter returns a count of ExecutionContextMock.Poll invocations
func (mmPoll *ExecutionContextMock) PollBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPoll.beforePollCounter)
}

// MinimockPollDone returns true if the count of the Poll invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockPollDone() bool {
	for _, e := range m.PollMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PollMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPollCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPoll != nil && mm_atomic.LoadUint64(&m.afterPollCounter) < 1 {
		return false
	}
	return true
}

// MinimockPollInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockPollInspect() {
	for _, e := range m.PollMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.Poll")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PollMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPollCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Poll")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPoll != nil && mm_atomic.LoadUint64(&m.afterPollCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Poll")
	}
}

type mExecutionContextMockPublish struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockPublishExpectation
	expectations       []*ExecutionContextMockPublishExpectation

	callArgs []*ExecutionContextMockPublishParams
	mutex    sync.RWMutex
}

// ExecutionContextMockPublishExpectation specifies expectation struct of the ExecutionContext.Publish
type ExecutionContextMockPublishExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockPublishParams
	results *ExecutionContextMockPublishResults
	Counter uint64
}

// ExecutionContextMockPublishParams contains parameters of the ExecutionContext.Publish
type ExecutionContextMockPublishParams struct {
	key  interface{}
	data interface{}
}

// ExecutionContextMockPublishResults contains results of the ExecutionContext.Publish
type ExecutionContextMockPublishResults struct {
	b1 bool
}

// Expect sets up expected params for ExecutionContext.Publish
func (mmPublish *mExecutionContextMockPublish) Expect(key interface{}, data interface{}) *mExecutionContextMockPublish {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("ExecutionContextMock.Publish mock is already set by Set")
	}

	if mmPublish.defaultExpectation == nil {
		mmPublish.defaultExpectation = &ExecutionContextMockPublishExpectation{}
	}

	mmPublish.defaultExpectation.params = &ExecutionContextMockPublishParams{key, data}
	for _, e := range mmPublish.expectations {
		if minimock.Equal(e.params, mmPublish.defaultExpectation.params) {
			mmPublish.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPublish.defaultExpectation.params)
		}
	}

	return mmPublish
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Publish
func (mmPublish *mExecutionContextMockPublish) Inspect(f func(key interface{}, data interface{})) *mExecutionContextMockPublish {
	if mmPublish.mock.inspectFuncPublish != nil {
		mmPublish.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Publish")
	}

	mmPublish.mock.inspectFuncPublish = f

	return mmPublish
}

// Return sets up results that will be returned by ExecutionContext.Publish
func (mmPublish *mExecutionContextMockPublish) Return(b1 bool) *ExecutionContextMock {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("ExecutionContextMock.Publish mock is already set by Set")
	}

	if mmPublish.defaultExpectation == nil {
		mmPublish.defaultExpectation = &ExecutionContextMockPublishExpectation{mock: mmPublish.mock}
	}
	mmPublish.defaultExpectation.results = &ExecutionContextMockPublishResults{b1}
	return mmPublish.mock
}

//Set uses given function f to mock the ExecutionContext.Publish method
func (mmPublish *mExecutionContextMockPublish) Set(f func(key interface{}, data interface{}) (b1 bool)) *ExecutionContextMock {
	if mmPublish.defaultExpectation != nil {
		mmPublish.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Publish method")
	}

	if len(mmPublish.expectations) > 0 {
		mmPublish.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Publish method")
	}

	mmPublish.mock.funcPublish = f
	return mmPublish.mock
}

// When sets expectation for the ExecutionContext.Publish which will trigger the result defined by the following
// Then helper
func (mmPublish *mExecutionContextMockPublish) When(key interface{}, data interface{}) *ExecutionContextMockPublishExpectation {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("ExecutionContextMock.Publish mock is already set by Set")
	}

	expectation := &ExecutionContextMockPublishExpectation{
		mock:   mmPublish.mock,
		params: &ExecutionContextMockPublishParams{key, data},
	}
	mmPublish.expectations = append(mmPublish.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.Publish return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockPublishExpectation) Then(b1 bool) *ExecutionContextMock {
	e.results = &ExecutionContextMockPublishResults{b1}
	return e.mock
}

// Publish implements ExecutionContext
func (mmPublish *ExecutionContextMock) Publish(key interface{}, data interface{}) (b1 bool) {
	mm_atomic.AddUint64(&mmPublish.beforePublishCounter, 1)
	defer mm_atomic.AddUint64(&mmPublish.afterPublishCounter, 1)

	if mmPublish.inspectFuncPublish != nil {
		mmPublish.inspectFuncPublish(key, data)
	}

	mm_params := &ExecutionContextMockPublishParams{key, data}

	// Record call args
	mmPublish.PublishMock.mutex.Lock()
	mmPublish.PublishMock.callArgs = append(mmPublish.PublishMock.callArgs, mm_params)
	mmPublish.PublishMock.mutex.Unlock()

	for _, e := range mmPublish.PublishMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmPublish.PublishMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublish.PublishMock.defaultExpectation.Counter, 1)
		mm_want := mmPublish.PublishMock.defaultExpectation.params
		mm_got := ExecutionContextMockPublishParams{key, data}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPublish.t.Errorf("ExecutionContextMock.Publish got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPublish.PublishMock.defaultExpectation.results
		if mm_results == nil {
			mmPublish.t.Fatal("No results are set for the ExecutionContextMock.Publish")
		}
		return (*mm_results).b1
	}
	if mmPublish.funcPublish != nil {
		return mmPublish.funcPublish(key, data)
	}
	mmPublish.t.Fatalf("Unexpected call to ExecutionContextMock.Publish. %v %v", key, data)
	return
}

// PublishAfterCounter returns a count of finished ExecutionContextMock.Publish invocations
func (mmPublish *ExecutionContextMock) PublishAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublish.afterPublishCounter)
}

// PublishBeforeCounter returns a count of ExecutionContextMock.Publish invocations
func (mmPublish *ExecutionContextMock) PublishBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublish.beforePublishCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.Publish.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPublish *mExecutionContextMockPublish) Calls() []*ExecutionContextMockPublishParams {
	mmPublish.mutex.RLock()

	argCopy := make([]*ExecutionContextMockPublishParams, len(mmPublish.callArgs))
	copy(argCopy, mmPublish.callArgs)

	mmPublish.mutex.RUnlock()

	return argCopy
}

// MinimockPublishDone returns true if the count of the Publish invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockPublishDone() bool {
	for _, e := range m.PublishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublish != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		return false
	}
	return true
}

// MinimockPublishInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockPublishInspect() {
	for _, e := range m.PublishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.Publish with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		if m.PublishMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.Publish")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.Publish with params: %#v", *m.PublishMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublish != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Publish")
	}
}

type mExecutionContextMockPublishGlobalAlias struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockPublishGlobalAliasExpectation
	expectations       []*ExecutionContextMockPublishGlobalAliasExpectation

	callArgs []*ExecutionContextMockPublishGlobalAliasParams
	mutex    sync.RWMutex
}

// ExecutionContextMockPublishGlobalAliasExpectation specifies expectation struct of the ExecutionContext.PublishGlobalAlias
type ExecutionContextMockPublishGlobalAliasExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockPublishGlobalAliasParams
	results *ExecutionContextMockPublishGlobalAliasResults
	Counter uint64
}

// ExecutionContextMockPublishGlobalAliasParams contains parameters of the ExecutionContext.PublishGlobalAlias
type ExecutionContextMockPublishGlobalAliasParams struct {
	key interface{}
}

// ExecutionContextMockPublishGlobalAliasResults contains results of the ExecutionContext.PublishGlobalAlias
type ExecutionContextMockPublishGlobalAliasResults struct {
	b1 bool
}

// Expect sets up expected params for ExecutionContext.PublishGlobalAlias
func (mmPublishGlobalAlias *mExecutionContextMockPublishGlobalAlias) Expect(key interface{}) *mExecutionContextMockPublishGlobalAlias {
	if mmPublishGlobalAlias.mock.funcPublishGlobalAlias != nil {
		mmPublishGlobalAlias.mock.t.Fatalf("ExecutionContextMock.PublishGlobalAlias mock is already set by Set")
	}

	if mmPublishGlobalAlias.defaultExpectation == nil {
		mmPublishGlobalAlias.defaultExpectation = &ExecutionContextMockPublishGlobalAliasExpectation{}
	}

	mmPublishGlobalAlias.defaultExpectation.params = &ExecutionContextMockPublishGlobalAliasParams{key}
	for _, e := range mmPublishGlobalAlias.expectations {
		if minimock.Equal(e.params, mmPublishGlobalAlias.defaultExpectation.params) {
			mmPublishGlobalAlias.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPublishGlobalAlias.defaultExpectation.params)
		}
	}

	return mmPublishGlobalAlias
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.PublishGlobalAlias
func (mmPublishGlobalAlias *mExecutionContextMockPublishGlobalAlias) Inspect(f func(key interface{})) *mExecutionContextMockPublishGlobalAlias {
	if mmPublishGlobalAlias.mock.inspectFuncPublishGlobalAlias != nil {
		mmPublishGlobalAlias.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.PublishGlobalAlias")
	}

	mmPublishGlobalAlias.mock.inspectFuncPublishGlobalAlias = f

	return mmPublishGlobalAlias
}

// Return sets up results that will be returned by ExecutionContext.PublishGlobalAlias
func (mmPublishGlobalAlias *mExecutionContextMockPublishGlobalAlias) Return(b1 bool) *ExecutionContextMock {
	if mmPublishGlobalAlias.mock.funcPublishGlobalAlias != nil {
		mmPublishGlobalAlias.mock.t.Fatalf("ExecutionContextMock.PublishGlobalAlias mock is already set by Set")
	}

	if mmPublishGlobalAlias.defaultExpectation == nil {
		mmPublishGlobalAlias.defaultExpectation = &ExecutionContextMockPublishGlobalAliasExpectation{mock: mmPublishGlobalAlias.mock}
	}
	mmPublishGlobalAlias.defaultExpectation.results = &ExecutionContextMockPublishGlobalAliasResults{b1}
	return mmPublishGlobalAlias.mock
}

//Set uses given function f to mock the ExecutionContext.PublishGlobalAlias method
func (mmPublishGlobalAlias *mExecutionContextMockPublishGlobalAlias) Set(f func(key interface{}) (b1 bool)) *ExecutionContextMock {
	if mmPublishGlobalAlias.defaultExpectation != nil {
		mmPublishGlobalAlias.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.PublishGlobalAlias method")
	}

	if len(mmPublishGlobalAlias.expectations) > 0 {
		mmPublishGlobalAlias.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.PublishGlobalAlias method")
	}

	mmPublishGlobalAlias.mock.funcPublishGlobalAlias = f
	return mmPublishGlobalAlias.mock
}

// When sets expectation for the ExecutionContext.PublishGlobalAlias which will trigger the result defined by the following
// Then helper
func (mmPublishGlobalAlias *mExecutionContextMockPublishGlobalAlias) When(key interface{}) *ExecutionContextMockPublishGlobalAliasExpectation {
	if mmPublishGlobalAlias.mock.funcPublishGlobalAlias != nil {
		mmPublishGlobalAlias.mock.t.Fatalf("ExecutionContextMock.PublishGlobalAlias mock is already set by Set")
	}

	expectation := &ExecutionContextMockPublishGlobalAliasExpectation{
		mock:   mmPublishGlobalAlias.mock,
		params: &ExecutionContextMockPublishGlobalAliasParams{key},
	}
	mmPublishGlobalAlias.expectations = append(mmPublishGlobalAlias.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.PublishGlobalAlias return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockPublishGlobalAliasExpectation) Then(b1 bool) *ExecutionContextMock {
	e.results = &ExecutionContextMockPublishGlobalAliasResults{b1}
	return e.mock
}

// PublishGlobalAlias implements ExecutionContext
func (mmPublishGlobalAlias *ExecutionContextMock) PublishGlobalAlias(key interface{}) (b1 bool) {
	mm_atomic.AddUint64(&mmPublishGlobalAlias.beforePublishGlobalAliasCounter, 1)
	defer mm_atomic.AddUint64(&mmPublishGlobalAlias.afterPublishGlobalAliasCounter, 1)

	if mmPublishGlobalAlias.inspectFuncPublishGlobalAlias != nil {
		mmPublishGlobalAlias.inspectFuncPublishGlobalAlias(key)
	}

	mm_params := &ExecutionContextMockPublishGlobalAliasParams{key}

	// Record call args
	mmPublishGlobalAlias.PublishGlobalAliasMock.mutex.Lock()
	mmPublishGlobalAlias.PublishGlobalAliasMock.callArgs = append(mmPublishGlobalAlias.PublishGlobalAliasMock.callArgs, mm_params)
	mmPublishGlobalAlias.PublishGlobalAliasMock.mutex.Unlock()

	for _, e := range mmPublishGlobalAlias.PublishGlobalAliasMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmPublishGlobalAlias.PublishGlobalAliasMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublishGlobalAlias.PublishGlobalAliasMock.defaultExpectation.Counter, 1)
		mm_want := mmPublishGlobalAlias.PublishGlobalAliasMock.defaultExpectation.params
		mm_got := ExecutionContextMockPublishGlobalAliasParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPublishGlobalAlias.t.Errorf("ExecutionContextMock.PublishGlobalAlias got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPublishGlobalAlias.PublishGlobalAliasMock.defaultExpectation.results
		if mm_results == nil {
			mmPublishGlobalAlias.t.Fatal("No results are set for the ExecutionContextMock.PublishGlobalAlias")
		}
		return (*mm_results).b1
	}
	if mmPublishGlobalAlias.funcPublishGlobalAlias != nil {
		return mmPublishGlobalAlias.funcPublishGlobalAlias(key)
	}
	mmPublishGlobalAlias.t.Fatalf("Unexpected call to ExecutionContextMock.PublishGlobalAlias. %v", key)
	return
}

// PublishGlobalAliasAfterCounter returns a count of finished ExecutionContextMock.PublishGlobalAlias invocations
func (mmPublishGlobalAlias *ExecutionContextMock) PublishGlobalAliasAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishGlobalAlias.afterPublishGlobalAliasCounter)
}

// PublishGlobalAliasBeforeCounter returns a count of ExecutionContextMock.PublishGlobalAlias invocations
func (mmPublishGlobalAlias *ExecutionContextMock) PublishGlobalAliasBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishGlobalAlias.beforePublishGlobalAliasCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.PublishGlobalAlias.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPublishGlobalAlias *mExecutionContextMockPublishGlobalAlias) Calls() []*ExecutionContextMockPublishGlobalAliasParams {
	mmPublishGlobalAlias.mutex.RLock()

	argCopy := make([]*ExecutionContextMockPublishGlobalAliasParams, len(mmPublishGlobalAlias.callArgs))
	copy(argCopy, mmPublishGlobalAlias.callArgs)

	mmPublishGlobalAlias.mutex.RUnlock()

	return argCopy
}

// MinimockPublishGlobalAliasDone returns true if the count of the PublishGlobalAlias invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockPublishGlobalAliasDone() bool {
	for _, e := range m.PublishGlobalAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishGlobalAliasMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublishGlobalAlias != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasCounter) < 1 {
		return false
	}
	return true
}

// MinimockPublishGlobalAliasInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockPublishGlobalAliasInspect() {
	for _, e := range m.PublishGlobalAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.PublishGlobalAlias with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishGlobalAliasMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasCounter) < 1 {
		if m.PublishGlobalAliasMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.PublishGlobalAlias")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.PublishGlobalAlias with params: %#v", *m.PublishGlobalAliasMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublishGlobalAlias != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.PublishGlobalAlias")
	}
}

type mExecutionContextMockPublishGlobalAliasAndBargeIn struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockPublishGlobalAliasAndBargeInExpectation
	expectations       []*ExecutionContextMockPublishGlobalAliasAndBargeInExpectation

	callArgs []*ExecutionContextMockPublishGlobalAliasAndBargeInParams
	mutex    sync.RWMutex
}

// ExecutionContextMockPublishGlobalAliasAndBargeInExpectation specifies expectation struct of the ExecutionContext.PublishGlobalAliasAndBargeIn
type ExecutionContextMockPublishGlobalAliasAndBargeInExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockPublishGlobalAliasAndBargeInParams
	results *ExecutionContextMockPublishGlobalAliasAndBargeInResults
	Counter uint64
}

// ExecutionContextMockPublishGlobalAliasAndBargeInParams contains parameters of the ExecutionContext.PublishGlobalAliasAndBargeIn
type ExecutionContextMockPublishGlobalAliasAndBargeInParams struct {
	key     interface{}
	handler BargeInHolder
}

// ExecutionContextMockPublishGlobalAliasAndBargeInResults contains results of the ExecutionContext.PublishGlobalAliasAndBargeIn
type ExecutionContextMockPublishGlobalAliasAndBargeInResults struct {
	b1 bool
}

// Expect sets up expected params for ExecutionContext.PublishGlobalAliasAndBargeIn
func (mmPublishGlobalAliasAndBargeIn *mExecutionContextMockPublishGlobalAliasAndBargeIn) Expect(key interface{}, handler BargeInHolder) *mExecutionContextMockPublishGlobalAliasAndBargeIn {
	if mmPublishGlobalAliasAndBargeIn.mock.funcPublishGlobalAliasAndBargeIn != nil {
		mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("ExecutionContextMock.PublishGlobalAliasAndBargeIn mock is already set by Set")
	}

	if mmPublishGlobalAliasAndBargeIn.defaultExpectation == nil {
		mmPublishGlobalAliasAndBargeIn.defaultExpectation = &ExecutionContextMockPublishGlobalAliasAndBargeInExpectation{}
	}

	mmPublishGlobalAliasAndBargeIn.defaultExpectation.params = &ExecutionContextMockPublishGlobalAliasAndBargeInParams{key, handler}
	for _, e := range mmPublishGlobalAliasAndBargeIn.expectations {
		if minimock.Equal(e.params, mmPublishGlobalAliasAndBargeIn.defaultExpectation.params) {
			mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPublishGlobalAliasAndBargeIn.defaultExpectation.params)
		}
	}

	return mmPublishGlobalAliasAndBargeIn
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.PublishGlobalAliasAndBargeIn
func (mmPublishGlobalAliasAndBargeIn *mExecutionContextMockPublishGlobalAliasAndBargeIn) Inspect(f func(key interface{}, handler BargeInHolder)) *mExecutionContextMockPublishGlobalAliasAndBargeIn {
	if mmPublishGlobalAliasAndBargeIn.mock.inspectFuncPublishGlobalAliasAndBargeIn != nil {
		mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.PublishGlobalAliasAndBargeIn")
	}

	mmPublishGlobalAliasAndBargeIn.mock.inspectFuncPublishGlobalAliasAndBargeIn = f

	return mmPublishGlobalAliasAndBargeIn
}

// Return sets up results that will be returned by ExecutionContext.PublishGlobalAliasAndBargeIn
func (mmPublishGlobalAliasAndBargeIn *mExecutionContextMockPublishGlobalAliasAndBargeIn) Return(b1 bool) *ExecutionContextMock {
	if mmPublishGlobalAliasAndBargeIn.mock.funcPublishGlobalAliasAndBargeIn != nil {
		mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("ExecutionContextMock.PublishGlobalAliasAndBargeIn mock is already set by Set")
	}

	if mmPublishGlobalAliasAndBargeIn.defaultExpectation == nil {
		mmPublishGlobalAliasAndBargeIn.defaultExpectation = &ExecutionContextMockPublishGlobalAliasAndBargeInExpectation{mock: mmPublishGlobalAliasAndBargeIn.mock}
	}
	mmPublishGlobalAliasAndBargeIn.defaultExpectation.results = &ExecutionContextMockPublishGlobalAliasAndBargeInResults{b1}
	return mmPublishGlobalAliasAndBargeIn.mock
}

//Set uses given function f to mock the ExecutionContext.PublishGlobalAliasAndBargeIn method
func (mmPublishGlobalAliasAndBargeIn *mExecutionContextMockPublishGlobalAliasAndBargeIn) Set(f func(key interface{}, handler BargeInHolder) (b1 bool)) *ExecutionContextMock {
	if mmPublishGlobalAliasAndBargeIn.defaultExpectation != nil {
		mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.PublishGlobalAliasAndBargeIn method")
	}

	if len(mmPublishGlobalAliasAndBargeIn.expectations) > 0 {
		mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.PublishGlobalAliasAndBargeIn method")
	}

	mmPublishGlobalAliasAndBargeIn.mock.funcPublishGlobalAliasAndBargeIn = f
	return mmPublishGlobalAliasAndBargeIn.mock
}

// When sets expectation for the ExecutionContext.PublishGlobalAliasAndBargeIn which will trigger the result defined by the following
// Then helper
func (mmPublishGlobalAliasAndBargeIn *mExecutionContextMockPublishGlobalAliasAndBargeIn) When(key interface{}, handler BargeInHolder) *ExecutionContextMockPublishGlobalAliasAndBargeInExpectation {
	if mmPublishGlobalAliasAndBargeIn.mock.funcPublishGlobalAliasAndBargeIn != nil {
		mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("ExecutionContextMock.PublishGlobalAliasAndBargeIn mock is already set by Set")
	}

	expectation := &ExecutionContextMockPublishGlobalAliasAndBargeInExpectation{
		mock:   mmPublishGlobalAliasAndBargeIn.mock,
		params: &ExecutionContextMockPublishGlobalAliasAndBargeInParams{key, handler},
	}
	mmPublishGlobalAliasAndBargeIn.expectations = append(mmPublishGlobalAliasAndBargeIn.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.PublishGlobalAliasAndBargeIn return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockPublishGlobalAliasAndBargeInExpectation) Then(b1 bool) *ExecutionContextMock {
	e.results = &ExecutionContextMockPublishGlobalAliasAndBargeInResults{b1}
	return e.mock
}

// PublishGlobalAliasAndBargeIn implements ExecutionContext
func (mmPublishGlobalAliasAndBargeIn *ExecutionContextMock) PublishGlobalAliasAndBargeIn(key interface{}, handler BargeInHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmPublishGlobalAliasAndBargeIn.beforePublishGlobalAliasAndBargeInCounter, 1)
	defer mm_atomic.AddUint64(&mmPublishGlobalAliasAndBargeIn.afterPublishGlobalAliasAndBargeInCounter, 1)

	if mmPublishGlobalAliasAndBargeIn.inspectFuncPublishGlobalAliasAndBargeIn != nil {
		mmPublishGlobalAliasAndBargeIn.inspectFuncPublishGlobalAliasAndBargeIn(key, handler)
	}

	mm_params := &ExecutionContextMockPublishGlobalAliasAndBargeInParams{key, handler}

	// Record call args
	mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.mutex.Lock()
	mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.callArgs = append(mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.callArgs, mm_params)
	mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.mutex.Unlock()

	for _, e := range mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.defaultExpectation.Counter, 1)
		mm_want := mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.defaultExpectation.params
		mm_got := ExecutionContextMockPublishGlobalAliasAndBargeInParams{key, handler}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPublishGlobalAliasAndBargeIn.t.Errorf("ExecutionContextMock.PublishGlobalAliasAndBargeIn got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.defaultExpectation.results
		if mm_results == nil {
			mmPublishGlobalAliasAndBargeIn.t.Fatal("No results are set for the ExecutionContextMock.PublishGlobalAliasAndBargeIn")
		}
		return (*mm_results).b1
	}
	if mmPublishGlobalAliasAndBargeIn.funcPublishGlobalAliasAndBargeIn != nil {
		return mmPublishGlobalAliasAndBargeIn.funcPublishGlobalAliasAndBargeIn(key, handler)
	}
	mmPublishGlobalAliasAndBargeIn.t.Fatalf("Unexpected call to ExecutionContextMock.PublishGlobalAliasAndBargeIn. %v %v", key, handler)
	return
}

// PublishGlobalAliasAndBargeInAfterCounter returns a count of finished ExecutionContextMock.PublishGlobalAliasAndBargeIn invocations
func (mmPublishGlobalAliasAndBargeIn *ExecutionContextMock) PublishGlobalAliasAndBargeInAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishGlobalAliasAndBargeIn.afterPublishGlobalAliasAndBargeInCounter)
}

// PublishGlobalAliasAndBargeInBeforeCounter returns a count of ExecutionContextMock.PublishGlobalAliasAndBargeIn invocations
func (mmPublishGlobalAliasAndBargeIn *ExecutionContextMock) PublishGlobalAliasAndBargeInBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishGlobalAliasAndBargeIn.beforePublishGlobalAliasAndBargeInCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.PublishGlobalAliasAndBargeIn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPublishGlobalAliasAndBargeIn *mExecutionContextMockPublishGlobalAliasAndBargeIn) Calls() []*ExecutionContextMockPublishGlobalAliasAndBargeInParams {
	mmPublishGlobalAliasAndBargeIn.mutex.RLock()

	argCopy := make([]*ExecutionContextMockPublishGlobalAliasAndBargeInParams, len(mmPublishGlobalAliasAndBargeIn.callArgs))
	copy(argCopy, mmPublishGlobalAliasAndBargeIn.callArgs)

	mmPublishGlobalAliasAndBargeIn.mutex.RUnlock()

	return argCopy
}

// MinimockPublishGlobalAliasAndBargeInDone returns true if the count of the PublishGlobalAliasAndBargeIn invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockPublishGlobalAliasAndBargeInDone() bool {
	for _, e := range m.PublishGlobalAliasAndBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishGlobalAliasAndBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasAndBargeInCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublishGlobalAliasAndBargeIn != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasAndBargeInCounter) < 1 {
		return false
	}
	return true
}

// MinimockPublishGlobalAliasAndBargeInInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockPublishGlobalAliasAndBargeInInspect() {
	for _, e := range m.PublishGlobalAliasAndBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.PublishGlobalAliasAndBargeIn with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishGlobalAliasAndBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasAndBargeInCounter) < 1 {
		if m.PublishGlobalAliasAndBargeInMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.PublishGlobalAliasAndBargeIn")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.PublishGlobalAliasAndBargeIn with params: %#v", *m.PublishGlobalAliasAndBargeInMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublishGlobalAliasAndBargeIn != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasAndBargeInCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.PublishGlobalAliasAndBargeIn")
	}
}

type mExecutionContextMockPublishReplacement struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockPublishReplacementExpectation
	expectations       []*ExecutionContextMockPublishReplacementExpectation

	callArgs []*ExecutionContextMockPublishReplacementParams
	mutex    sync.RWMutex
}

// ExecutionContextMockPublishReplacementExpectation specifies expectation struct of the ExecutionContext.PublishReplacement
type ExecutionContextMockPublishReplacementExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockPublishReplacementParams
	results *ExecutionContextMockPublishReplacementResults
	Counter uint64
}

// ExecutionContextMockPublishReplacementParams contains parameters of the ExecutionContext.PublishReplacement
type ExecutionContextMockPublishReplacementParams struct {
	key  interface{}
	data interface{}
}

// ExecutionContextMockPublishReplacementResults contains results of the ExecutionContext.PublishReplacement
type ExecutionContextMockPublishReplacementResults struct {
	b1 bool
}

// Expect sets up expected params for ExecutionContext.PublishReplacement
func (mmPublishReplacement *mExecutionContextMockPublishReplacement) Expect(key interface{}, data interface{}) *mExecutionContextMockPublishReplacement {
	if mmPublishReplacement.mock.funcPublishReplacement != nil {
		mmPublishReplacement.mock.t.Fatalf("ExecutionContextMock.PublishReplacement mock is already set by Set")
	}

	if mmPublishReplacement.defaultExpectation == nil {
		mmPublishReplacement.defaultExpectation = &ExecutionContextMockPublishReplacementExpectation{}
	}

	mmPublishReplacement.defaultExpectation.params = &ExecutionContextMockPublishReplacementParams{key, data}
	for _, e := range mmPublishReplacement.expectations {
		if minimock.Equal(e.params, mmPublishReplacement.defaultExpectation.params) {
			mmPublishReplacement.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPublishReplacement.defaultExpectation.params)
		}
	}

	return mmPublishReplacement
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.PublishReplacement
func (mmPublishReplacement *mExecutionContextMockPublishReplacement) Inspect(f func(key interface{}, data interface{})) *mExecutionContextMockPublishReplacement {
	if mmPublishReplacement.mock.inspectFuncPublishReplacement != nil {
		mmPublishReplacement.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.PublishReplacement")
	}

	mmPublishReplacement.mock.inspectFuncPublishReplacement = f

	return mmPublishReplacement
}

// Return sets up results that will be returned by ExecutionContext.PublishReplacement
func (mmPublishReplacement *mExecutionContextMockPublishReplacement) Return(b1 bool) *ExecutionContextMock {
	if mmPublishReplacement.mock.funcPublishReplacement != nil {
		mmPublishReplacement.mock.t.Fatalf("ExecutionContextMock.PublishReplacement mock is already set by Set")
	}

	if mmPublishReplacement.defaultExpectation == nil {
		mmPublishReplacement.defaultExpectation = &ExecutionContextMockPublishReplacementExpectation{mock: mmPublishReplacement.mock}
	}
	mmPublishReplacement.defaultExpectation.results = &ExecutionContextMockPublishReplacementResults{b1}
	return mmPublishReplacement.mock
}

//Set uses given function f to mock the ExecutionContext.PublishReplacement method
func (mmPublishReplacement *mExecutionContextMockPublishReplacement) Set(f func(key interface{}, data interface{}) (b1 bool)) *ExecutionContextMock {
	if mmPublishReplacement.defaultExpectation != nil {
		mmPublishReplacement.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.PublishReplacement method")
	}

	if len(mmPublishReplacement.expectations) > 0 {
		mmPublishReplacement.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.PublishReplacement method")
	}

	mmPublishReplacement.mock.funcPublishReplacement = f
	return mmPublishReplacement.mock
}

// When sets expectation for the ExecutionContext.PublishReplacement which will trigger the result defined by the following
// Then helper
func (mmPublishReplacement *mExecutionContextMockPublishReplacement) When(key interface{}, data interface{}) *ExecutionContextMockPublishReplacementExpectation {
	if mmPublishReplacement.mock.funcPublishReplacement != nil {
		mmPublishReplacement.mock.t.Fatalf("ExecutionContextMock.PublishReplacement mock is already set by Set")
	}

	expectation := &ExecutionContextMockPublishReplacementExpectation{
		mock:   mmPublishReplacement.mock,
		params: &ExecutionContextMockPublishReplacementParams{key, data},
	}
	mmPublishReplacement.expectations = append(mmPublishReplacement.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.PublishReplacement return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockPublishReplacementExpectation) Then(b1 bool) *ExecutionContextMock {
	e.results = &ExecutionContextMockPublishReplacementResults{b1}
	return e.mock
}

// PublishReplacement implements ExecutionContext
func (mmPublishReplacement *ExecutionContextMock) PublishReplacement(key interface{}, data interface{}) (b1 bool) {
	mm_atomic.AddUint64(&mmPublishReplacement.beforePublishReplacementCounter, 1)
	defer mm_atomic.AddUint64(&mmPublishReplacement.afterPublishReplacementCounter, 1)

	if mmPublishReplacement.inspectFuncPublishReplacement != nil {
		mmPublishReplacement.inspectFuncPublishReplacement(key, data)
	}

	mm_params := &ExecutionContextMockPublishReplacementParams{key, data}

	// Record call args
	mmPublishReplacement.PublishReplacementMock.mutex.Lock()
	mmPublishReplacement.PublishReplacementMock.callArgs = append(mmPublishReplacement.PublishReplacementMock.callArgs, mm_params)
	mmPublishReplacement.PublishReplacementMock.mutex.Unlock()

	for _, e := range mmPublishReplacement.PublishReplacementMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmPublishReplacement.PublishReplacementMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublishReplacement.PublishReplacementMock.defaultExpectation.Counter, 1)
		mm_want := mmPublishReplacement.PublishReplacementMock.defaultExpectation.params
		mm_got := ExecutionContextMockPublishReplacementParams{key, data}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPublishReplacement.t.Errorf("ExecutionContextMock.PublishReplacement got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPublishReplacement.PublishReplacementMock.defaultExpectation.results
		if mm_results == nil {
			mmPublishReplacement.t.Fatal("No results are set for the ExecutionContextMock.PublishReplacement")
		}
		return (*mm_results).b1
	}
	if mmPublishReplacement.funcPublishReplacement != nil {
		return mmPublishReplacement.funcPublishReplacement(key, data)
	}
	mmPublishReplacement.t.Fatalf("Unexpected call to ExecutionContextMock.PublishReplacement. %v %v", key, data)
	return
}

// PublishReplacementAfterCounter returns a count of finished ExecutionContextMock.PublishReplacement invocations
func (mmPublishReplacement *ExecutionContextMock) PublishReplacementAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishReplacement.afterPublishReplacementCounter)
}

// PublishReplacementBeforeCounter returns a count of ExecutionContextMock.PublishReplacement invocations
func (mmPublishReplacement *ExecutionContextMock) PublishReplacementBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishReplacement.beforePublishReplacementCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.PublishReplacement.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPublishReplacement *mExecutionContextMockPublishReplacement) Calls() []*ExecutionContextMockPublishReplacementParams {
	mmPublishReplacement.mutex.RLock()

	argCopy := make([]*ExecutionContextMockPublishReplacementParams, len(mmPublishReplacement.callArgs))
	copy(argCopy, mmPublishReplacement.callArgs)

	mmPublishReplacement.mutex.RUnlock()

	return argCopy
}

// MinimockPublishReplacementDone returns true if the count of the PublishReplacement invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockPublishReplacementDone() bool {
	for _, e := range m.PublishReplacementMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishReplacementMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishReplacementCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublishReplacement != nil && mm_atomic.LoadUint64(&m.afterPublishReplacementCounter) < 1 {
		return false
	}
	return true
}

// MinimockPublishReplacementInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockPublishReplacementInspect() {
	for _, e := range m.PublishReplacementMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.PublishReplacement with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishReplacementMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishReplacementCounter) < 1 {
		if m.PublishReplacementMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.PublishReplacement")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.PublishReplacement with params: %#v", *m.PublishReplacementMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublishReplacement != nil && mm_atomic.LoadUint64(&m.afterPublishReplacementCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.PublishReplacement")
	}
}

type mExecutionContextMockRelease struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockReleaseExpectation
	expectations       []*ExecutionContextMockReleaseExpectation

	callArgs []*ExecutionContextMockReleaseParams
	mutex    sync.RWMutex
}

// ExecutionContextMockReleaseExpectation specifies expectation struct of the ExecutionContext.Release
type ExecutionContextMockReleaseExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockReleaseParams
	results *ExecutionContextMockReleaseResults
	Counter uint64
}

// ExecutionContextMockReleaseParams contains parameters of the ExecutionContext.Release
type ExecutionContextMockReleaseParams struct {
	s1 SyncLink
}

// ExecutionContextMockReleaseResults contains results of the ExecutionContext.Release
type ExecutionContextMockReleaseResults struct {
	b1 bool
}

// Expect sets up expected params for ExecutionContext.Release
func (mmRelease *mExecutionContextMockRelease) Expect(s1 SyncLink) *mExecutionContextMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("ExecutionContextMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &ExecutionContextMockReleaseExpectation{}
	}

	mmRelease.defaultExpectation.params = &ExecutionContextMockReleaseParams{s1}
	for _, e := range mmRelease.expectations {
		if minimock.Equal(e.params, mmRelease.defaultExpectation.params) {
			mmRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRelease.defaultExpectation.params)
		}
	}

	return mmRelease
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Release
func (mmRelease *mExecutionContextMockRelease) Inspect(f func(s1 SyncLink)) *mExecutionContextMockRelease {
	if mmRelease.mock.inspectFuncRelease != nil {
		mmRelease.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Release")
	}

	mmRelease.mock.inspectFuncRelease = f

	return mmRelease
}

// Return sets up results that will be returned by ExecutionContext.Release
func (mmRelease *mExecutionContextMockRelease) Return(b1 bool) *ExecutionContextMock {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("ExecutionContextMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &ExecutionContextMockReleaseExpectation{mock: mmRelease.mock}
	}
	mmRelease.defaultExpectation.results = &ExecutionContextMockReleaseResults{b1}
	return mmRelease.mock
}

//Set uses given function f to mock the ExecutionContext.Release method
func (mmRelease *mExecutionContextMockRelease) Set(f func(s1 SyncLink) (b1 bool)) *ExecutionContextMock {
	if mmRelease.defaultExpectation != nil {
		mmRelease.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Release method")
	}

	if len(mmRelease.expectations) > 0 {
		mmRelease.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Release method")
	}

	mmRelease.mock.funcRelease = f
	return mmRelease.mock
}

// When sets expectation for the ExecutionContext.Release which will trigger the result defined by the following
// Then helper
func (mmRelease *mExecutionContextMockRelease) When(s1 SyncLink) *ExecutionContextMockReleaseExpectation {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("ExecutionContextMock.Release mock is already set by Set")
	}

	expectation := &ExecutionContextMockReleaseExpectation{
		mock:   mmRelease.mock,
		params: &ExecutionContextMockReleaseParams{s1},
	}
	mmRelease.expectations = append(mmRelease.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.Release return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockReleaseExpectation) Then(b1 bool) *ExecutionContextMock {
	e.results = &ExecutionContextMockReleaseResults{b1}
	return e.mock
}

// Release implements ExecutionContext
func (mmRelease *ExecutionContextMock) Release(s1 SyncLink) (b1 bool) {
	mm_atomic.AddUint64(&mmRelease.beforeReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmRelease.afterReleaseCounter, 1)

	if mmRelease.inspectFuncRelease != nil {
		mmRelease.inspectFuncRelease(s1)
	}

	mm_params := &ExecutionContextMockReleaseParams{s1}

	// Record call args
	mmRelease.ReleaseMock.mutex.Lock()
	mmRelease.ReleaseMock.callArgs = append(mmRelease.ReleaseMock.callArgs, mm_params)
	mmRelease.ReleaseMock.mutex.Unlock()

	for _, e := range mmRelease.ReleaseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmRelease.ReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRelease.ReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmRelease.ReleaseMock.defaultExpectation.params
		mm_got := ExecutionContextMockReleaseParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRelease.t.Errorf("ExecutionContextMock.Release got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRelease.ReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmRelease.t.Fatal("No results are set for the ExecutionContextMock.Release")
		}
		return (*mm_results).b1
	}
	if mmRelease.funcRelease != nil {
		return mmRelease.funcRelease(s1)
	}
	mmRelease.t.Fatalf("Unexpected call to ExecutionContextMock.Release. %v", s1)
	return
}

// ReleaseAfterCounter returns a count of finished ExecutionContextMock.Release invocations
func (mmRelease *ExecutionContextMock) ReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.afterReleaseCounter)
}

// ReleaseBeforeCounter returns a count of ExecutionContextMock.Release invocations
func (mmRelease *ExecutionContextMock) ReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.beforeReleaseCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.Release.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRelease *mExecutionContextMockRelease) Calls() []*ExecutionContextMockReleaseParams {
	mmRelease.mutex.RLock()

	argCopy := make([]*ExecutionContextMockReleaseParams, len(mmRelease.callArgs))
	copy(argCopy, mmRelease.callArgs)

	mmRelease.mutex.RUnlock()

	return argCopy
}

// MinimockReleaseDone returns true if the count of the Release invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockReleaseDone() bool {
	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReleaseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRelease != nil && mm_atomic.LoadUint64(&m.afterReleaseCounter) < 1 {
		return false
	}
	return true
}

// MinimockReleaseInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockReleaseInspect() {
	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.Release with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReleaseCounter) < 1 {
		if m.ReleaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.Release")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.Release with params: %#v", *m.ReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRelease != nil && mm_atomic.LoadUint64(&m.afterReleaseCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Release")
	}
}

type mExecutionContextMockReleaseAll struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockReleaseAllExpectation
	expectations       []*ExecutionContextMockReleaseAllExpectation
}

// ExecutionContextMockReleaseAllExpectation specifies expectation struct of the ExecutionContext.ReleaseAll
type ExecutionContextMockReleaseAllExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockReleaseAllResults
	Counter uint64
}

// ExecutionContextMockReleaseAllResults contains results of the ExecutionContext.ReleaseAll
type ExecutionContextMockReleaseAllResults struct {
	b1 bool
}

// Expect sets up expected params for ExecutionContext.ReleaseAll
func (mmReleaseAll *mExecutionContextMockReleaseAll) Expect() *mExecutionContextMockReleaseAll {
	if mmReleaseAll.mock.funcReleaseAll != nil {
		mmReleaseAll.mock.t.Fatalf("ExecutionContextMock.ReleaseAll mock is already set by Set")
	}

	if mmReleaseAll.defaultExpectation == nil {
		mmReleaseAll.defaultExpectation = &ExecutionContextMockReleaseAllExpectation{}
	}

	return mmReleaseAll
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.ReleaseAll
func (mmReleaseAll *mExecutionContextMockReleaseAll) Inspect(f func()) *mExecutionContextMockReleaseAll {
	if mmReleaseAll.mock.inspectFuncReleaseAll != nil {
		mmReleaseAll.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.ReleaseAll")
	}

	mmReleaseAll.mock.inspectFuncReleaseAll = f

	return mmReleaseAll
}

// Return sets up results that will be returned by ExecutionContext.ReleaseAll
func (mmReleaseAll *mExecutionContextMockReleaseAll) Return(b1 bool) *ExecutionContextMock {
	if mmReleaseAll.mock.funcReleaseAll != nil {
		mmReleaseAll.mock.t.Fatalf("ExecutionContextMock.ReleaseAll mock is already set by Set")
	}

	if mmReleaseAll.defaultExpectation == nil {
		mmReleaseAll.defaultExpectation = &ExecutionContextMockReleaseAllExpectation{mock: mmReleaseAll.mock}
	}
	mmReleaseAll.defaultExpectation.results = &ExecutionContextMockReleaseAllResults{b1}
	return mmReleaseAll.mock
}

//Set uses given function f to mock the ExecutionContext.ReleaseAll method
func (mmReleaseAll *mExecutionContextMockReleaseAll) Set(f func() (b1 bool)) *ExecutionContextMock {
	if mmReleaseAll.defaultExpectation != nil {
		mmReleaseAll.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.ReleaseAll method")
	}

	if len(mmReleaseAll.expectations) > 0 {
		mmReleaseAll.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.ReleaseAll method")
	}

	mmReleaseAll.mock.funcReleaseAll = f
	return mmReleaseAll.mock
}

// ReleaseAll implements ExecutionContext
func (mmReleaseAll *ExecutionContextMock) ReleaseAll() (b1 bool) {
	mm_atomic.AddUint64(&mmReleaseAll.beforeReleaseAllCounter, 1)
	defer mm_atomic.AddUint64(&mmReleaseAll.afterReleaseAllCounter, 1)

	if mmReleaseAll.inspectFuncReleaseAll != nil {
		mmReleaseAll.inspectFuncReleaseAll()
	}

	if mmReleaseAll.ReleaseAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReleaseAll.ReleaseAllMock.defaultExpectation.Counter, 1)

		mm_results := mmReleaseAll.ReleaseAllMock.defaultExpectation.results
		if mm_results == nil {
			mmReleaseAll.t.Fatal("No results are set for the ExecutionContextMock.ReleaseAll")
		}
		return (*mm_results).b1
	}
	if mmReleaseAll.funcReleaseAll != nil {
		return mmReleaseAll.funcReleaseAll()
	}
	mmReleaseAll.t.Fatalf("Unexpected call to ExecutionContextMock.ReleaseAll.")
	return
}

// ReleaseAllAfterCounter returns a count of finished ExecutionContextMock.ReleaseAll invocations
func (mmReleaseAll *ExecutionContextMock) ReleaseAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReleaseAll.afterReleaseAllCounter)
}

// ReleaseAllBeforeCounter returns a count of ExecutionContextMock.ReleaseAll invocations
func (mmReleaseAll *ExecutionContextMock) ReleaseAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReleaseAll.beforeReleaseAllCounter)
}

// MinimockReleaseAllDone returns true if the count of the ReleaseAll invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockReleaseAllDone() bool {
	for _, e := range m.ReleaseAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReleaseAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReleaseAll != nil && mm_atomic.LoadUint64(&m.afterReleaseAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockReleaseAllInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockReleaseAllInspect() {
	for _, e := range m.ReleaseAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.ReleaseAll")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReleaseAllCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.ReleaseAll")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReleaseAll != nil && mm_atomic.LoadUint64(&m.afterReleaseAllCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.ReleaseAll")
	}
}

type mExecutionContextMockRepeat struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockRepeatExpectation
	expectations       []*ExecutionContextMockRepeatExpectation

	callArgs []*ExecutionContextMockRepeatParams
	mutex    sync.RWMutex
}

// ExecutionContextMockRepeatExpectation specifies expectation struct of the ExecutionContext.Repeat
type ExecutionContextMockRepeatExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockRepeatParams
	results *ExecutionContextMockRepeatResults
	Counter uint64
}

// ExecutionContextMockRepeatParams contains parameters of the ExecutionContext.Repeat
type ExecutionContextMockRepeatParams struct {
	limitPerCycle int
}

// ExecutionContextMockRepeatResults contains results of the ExecutionContext.Repeat
type ExecutionContextMockRepeatResults struct {
	s1 StateUpdate
}

// Expect sets up expected params for ExecutionContext.Repeat
func (mmRepeat *mExecutionContextMockRepeat) Expect(limitPerCycle int) *mExecutionContextMockRepeat {
	if mmRepeat.mock.funcRepeat != nil {
		mmRepeat.mock.t.Fatalf("ExecutionContextMock.Repeat mock is already set by Set")
	}

	if mmRepeat.defaultExpectation == nil {
		mmRepeat.defaultExpectation = &ExecutionContextMockRepeatExpectation{}
	}

	mmRepeat.defaultExpectation.params = &ExecutionContextMockRepeatParams{limitPerCycle}
	for _, e := range mmRepeat.expectations {
		if minimock.Equal(e.params, mmRepeat.defaultExpectation.params) {
			mmRepeat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRepeat.defaultExpectation.params)
		}
	}

	return mmRepeat
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Repeat
func (mmRepeat *mExecutionContextMockRepeat) Inspect(f func(limitPerCycle int)) *mExecutionContextMockRepeat {
	if mmRepeat.mock.inspectFuncRepeat != nil {
		mmRepeat.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Repeat")
	}

	mmRepeat.mock.inspectFuncRepeat = f

	return mmRepeat
}

// Return sets up results that will be returned by ExecutionContext.Repeat
func (mmRepeat *mExecutionContextMockRepeat) Return(s1 StateUpdate) *ExecutionContextMock {
	if mmRepeat.mock.funcRepeat != nil {
		mmRepeat.mock.t.Fatalf("ExecutionContextMock.Repeat mock is already set by Set")
	}

	if mmRepeat.defaultExpectation == nil {
		mmRepeat.defaultExpectation = &ExecutionContextMockRepeatExpectation{mock: mmRepeat.mock}
	}
	mmRepeat.defaultExpectation.results = &ExecutionContextMockRepeatResults{s1}
	return mmRepeat.mock
}

//Set uses given function f to mock the ExecutionContext.Repeat method
func (mmRepeat *mExecutionContextMockRepeat) Set(f func(limitPerCycle int) (s1 StateUpdate)) *ExecutionContextMock {
	if mmRepeat.defaultExpectation != nil {
		mmRepeat.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Repeat method")
	}

	if len(mmRepeat.expectations) > 0 {
		mmRepeat.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Repeat method")
	}

	mmRepeat.mock.funcRepeat = f
	return mmRepeat.mock
}

// When sets expectation for the ExecutionContext.Repeat which will trigger the result defined by the following
// Then helper
func (mmRepeat *mExecutionContextMockRepeat) When(limitPerCycle int) *ExecutionContextMockRepeatExpectation {
	if mmRepeat.mock.funcRepeat != nil {
		mmRepeat.mock.t.Fatalf("ExecutionContextMock.Repeat mock is already set by Set")
	}

	expectation := &ExecutionContextMockRepeatExpectation{
		mock:   mmRepeat.mock,
		params: &ExecutionContextMockRepeatParams{limitPerCycle},
	}
	mmRepeat.expectations = append(mmRepeat.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.Repeat return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockRepeatExpectation) Then(s1 StateUpdate) *ExecutionContextMock {
	e.results = &ExecutionContextMockRepeatResults{s1}
	return e.mock
}

// Repeat implements ExecutionContext
func (mmRepeat *ExecutionContextMock) Repeat(limitPerCycle int) (s1 StateUpdate) {
	mm_atomic.AddUint64(&mmRepeat.beforeRepeatCounter, 1)
	defer mm_atomic.AddUint64(&mmRepeat.afterRepeatCounter, 1)

	if mmRepeat.inspectFuncRepeat != nil {
		mmRepeat.inspectFuncRepeat(limitPerCycle)
	}

	mm_params := &ExecutionContextMockRepeatParams{limitPerCycle}

	// Record call args
	mmRepeat.RepeatMock.mutex.Lock()
	mmRepeat.RepeatMock.callArgs = append(mmRepeat.RepeatMock.callArgs, mm_params)
	mmRepeat.RepeatMock.mutex.Unlock()

	for _, e := range mmRepeat.RepeatMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmRepeat.RepeatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRepeat.RepeatMock.defaultExpectation.Counter, 1)
		mm_want := mmRepeat.RepeatMock.defaultExpectation.params
		mm_got := ExecutionContextMockRepeatParams{limitPerCycle}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRepeat.t.Errorf("ExecutionContextMock.Repeat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRepeat.RepeatMock.defaultExpectation.results
		if mm_results == nil {
			mmRepeat.t.Fatal("No results are set for the ExecutionContextMock.Repeat")
		}
		return (*mm_results).s1
	}
	if mmRepeat.funcRepeat != nil {
		return mmRepeat.funcRepeat(limitPerCycle)
	}
	mmRepeat.t.Fatalf("Unexpected call to ExecutionContextMock.Repeat. %v", limitPerCycle)
	return
}

// RepeatAfterCounter returns a count of finished ExecutionContextMock.Repeat invocations
func (mmRepeat *ExecutionContextMock) RepeatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepeat.afterRepeatCounter)
}

// RepeatBeforeCounter returns a count of ExecutionContextMock.Repeat invocations
func (mmRepeat *ExecutionContextMock) RepeatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepeat.beforeRepeatCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.Repeat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRepeat *mExecutionContextMockRepeat) Calls() []*ExecutionContextMockRepeatParams {
	mmRepeat.mutex.RLock()

	argCopy := make([]*ExecutionContextMockRepeatParams, len(mmRepeat.callArgs))
	copy(argCopy, mmRepeat.callArgs)

	mmRepeat.mutex.RUnlock()

	return argCopy
}

// MinimockRepeatDone returns true if the count of the Repeat invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockRepeatDone() bool {
	for _, e := range m.RepeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RepeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRepeatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRepeat != nil && mm_atomic.LoadUint64(&m.afterRepeatCounter) < 1 {
		return false
	}
	return true
}

// MinimockRepeatInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockRepeatInspect() {
	for _, e := range m.RepeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.Repeat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RepeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRepeatCounter) < 1 {
		if m.RepeatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.Repeat")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.Repeat with params: %#v", *m.RepeatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRepeat != nil && mm_atomic.LoadUint64(&m.afterRepeatCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Repeat")
	}
}

type mExecutionContextMockReplace struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockReplaceExpectation
	expectations       []*ExecutionContextMockReplaceExpectation

	callArgs []*ExecutionContextMockReplaceParams
	mutex    sync.RWMutex
}

// ExecutionContextMockReplaceExpectation specifies expectation struct of the ExecutionContext.Replace
type ExecutionContextMockReplaceExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockReplaceParams
	results *ExecutionContextMockReplaceResults
	Counter uint64
}

// ExecutionContextMockReplaceParams contains parameters of the ExecutionContext.Replace
type ExecutionContextMockReplaceParams struct {
	c1 CreateFunc
}

// ExecutionContextMockReplaceResults contains results of the ExecutionContext.Replace
type ExecutionContextMockReplaceResults struct {
	s1 StateUpdate
}

// Expect sets up expected params for ExecutionContext.Replace
func (mmReplace *mExecutionContextMockReplace) Expect(c1 CreateFunc) *mExecutionContextMockReplace {
	if mmReplace.mock.funcReplace != nil {
		mmReplace.mock.t.Fatalf("ExecutionContextMock.Replace mock is already set by Set")
	}

	if mmReplace.defaultExpectation == nil {
		mmReplace.defaultExpectation = &ExecutionContextMockReplaceExpectation{}
	}

	mmReplace.defaultExpectation.params = &ExecutionContextMockReplaceParams{c1}
	for _, e := range mmReplace.expectations {
		if minimock.Equal(e.params, mmReplace.defaultExpectation.params) {
			mmReplace.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReplace.defaultExpectation.params)
		}
	}

	return mmReplace
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Replace
func (mmReplace *mExecutionContextMockReplace) Inspect(f func(c1 CreateFunc)) *mExecutionContextMockReplace {
	if mmReplace.mock.inspectFuncReplace != nil {
		mmReplace.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Replace")
	}

	mmReplace.mock.inspectFuncReplace = f

	return mmReplace
}

// Return sets up results that will be returned by ExecutionContext.Replace
func (mmReplace *mExecutionContextMockReplace) Return(s1 StateUpdate) *ExecutionContextMock {
	if mmReplace.mock.funcReplace != nil {
		mmReplace.mock.t.Fatalf("ExecutionContextMock.Replace mock is already set by Set")
	}

	if mmReplace.defaultExpectation == nil {
		mmReplace.defaultExpectation = &ExecutionContextMockReplaceExpectation{mock: mmReplace.mock}
	}
	mmReplace.defaultExpectation.results = &ExecutionContextMockReplaceResults{s1}
	return mmReplace.mock
}

//Set uses given function f to mock the ExecutionContext.Replace method
func (mmReplace *mExecutionContextMockReplace) Set(f func(c1 CreateFunc) (s1 StateUpdate)) *ExecutionContextMock {
	if mmReplace.defaultExpectation != nil {
		mmReplace.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Replace method")
	}

	if len(mmReplace.expectations) > 0 {
		mmReplace.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Replace method")
	}

	mmReplace.mock.funcReplace = f
	return mmReplace.mock
}

// When sets expectation for the ExecutionContext.Replace which will trigger the result defined by the following
// Then helper
func (mmReplace *mExecutionContextMockReplace) When(c1 CreateFunc) *ExecutionContextMockReplaceExpectation {
	if mmReplace.mock.funcReplace != nil {
		mmReplace.mock.t.Fatalf("ExecutionContextMock.Replace mock is already set by Set")
	}

	expectation := &ExecutionContextMockReplaceExpectation{
		mock:   mmReplace.mock,
		params: &ExecutionContextMockReplaceParams{c1},
	}
	mmReplace.expectations = append(mmReplace.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.Replace return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockReplaceExpectation) Then(s1 StateUpdate) *ExecutionContextMock {
	e.results = &ExecutionContextMockReplaceResults{s1}
	return e.mock
}

// Replace implements ExecutionContext
func (mmReplace *ExecutionContextMock) Replace(c1 CreateFunc) (s1 StateUpdate) {
	mm_atomic.AddUint64(&mmReplace.beforeReplaceCounter, 1)
	defer mm_atomic.AddUint64(&mmReplace.afterReplaceCounter, 1)

	if mmReplace.inspectFuncReplace != nil {
		mmReplace.inspectFuncReplace(c1)
	}

	mm_params := &ExecutionContextMockReplaceParams{c1}

	// Record call args
	mmReplace.ReplaceMock.mutex.Lock()
	mmReplace.ReplaceMock.callArgs = append(mmReplace.ReplaceMock.callArgs, mm_params)
	mmReplace.ReplaceMock.mutex.Unlock()

	for _, e := range mmReplace.ReplaceMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmReplace.ReplaceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReplace.ReplaceMock.defaultExpectation.Counter, 1)
		mm_want := mmReplace.ReplaceMock.defaultExpectation.params
		mm_got := ExecutionContextMockReplaceParams{c1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReplace.t.Errorf("ExecutionContextMock.Replace got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReplace.ReplaceMock.defaultExpectation.results
		if mm_results == nil {
			mmReplace.t.Fatal("No results are set for the ExecutionContextMock.Replace")
		}
		return (*mm_results).s1
	}
	if mmReplace.funcReplace != nil {
		return mmReplace.funcReplace(c1)
	}
	mmReplace.t.Fatalf("Unexpected call to ExecutionContextMock.Replace. %v", c1)
	return
}

// ReplaceAfterCounter returns a count of finished ExecutionContextMock.Replace invocations
func (mmReplace *ExecutionContextMock) ReplaceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReplace.afterReplaceCounter)
}

// ReplaceBeforeCounter returns a count of ExecutionContextMock.Replace invocations
func (mmReplace *ExecutionContextMock) ReplaceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReplace.beforeReplaceCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.Replace.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReplace *mExecutionContextMockReplace) Calls() []*ExecutionContextMockReplaceParams {
	mmReplace.mutex.RLock()

	argCopy := make([]*ExecutionContextMockReplaceParams, len(mmReplace.callArgs))
	copy(argCopy, mmReplace.callArgs)

	mmReplace.mutex.RUnlock()

	return argCopy
}

// MinimockReplaceDone returns true if the count of the Replace invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockReplaceDone() bool {
	for _, e := range m.ReplaceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReplaceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReplaceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReplace != nil && mm_atomic.LoadUint64(&m.afterReplaceCounter) < 1 {
		return false
	}
	return true
}

// MinimockReplaceInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockReplaceInspect() {
	for _, e := range m.ReplaceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.Replace with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReplaceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReplaceCounter) < 1 {
		if m.ReplaceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.Replace")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.Replace with params: %#v", *m.ReplaceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReplace != nil && mm_atomic.LoadUint64(&m.afterReplaceCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Replace")
	}
}

type mExecutionContextMockReplaceExt struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockReplaceExtExpectation
	expectations       []*ExecutionContextMockReplaceExtExpectation

	callArgs []*ExecutionContextMockReplaceExtParams
	mutex    sync.RWMutex
}

// ExecutionContextMockReplaceExtExpectation specifies expectation struct of the ExecutionContext.ReplaceExt
type ExecutionContextMockReplaceExtExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockReplaceExtParams
	results *ExecutionContextMockReplaceExtResults
	Counter uint64
}

// ExecutionContextMockReplaceExtParams contains parameters of the ExecutionContext.ReplaceExt
type ExecutionContextMockReplaceExtParams struct {
	c1 CreateFunc
	c2 CreateDefaultValues
}

// ExecutionContextMockReplaceExtResults contains results of the ExecutionContext.ReplaceExt
type ExecutionContextMockReplaceExtResults struct {
	s1 StateUpdate
}

// Expect sets up expected params for ExecutionContext.ReplaceExt
func (mmReplaceExt *mExecutionContextMockReplaceExt) Expect(c1 CreateFunc, c2 CreateDefaultValues) *mExecutionContextMockReplaceExt {
	if mmReplaceExt.mock.funcReplaceExt != nil {
		mmReplaceExt.mock.t.Fatalf("ExecutionContextMock.ReplaceExt mock is already set by Set")
	}

	if mmReplaceExt.defaultExpectation == nil {
		mmReplaceExt.defaultExpectation = &ExecutionContextMockReplaceExtExpectation{}
	}

	mmReplaceExt.defaultExpectation.params = &ExecutionContextMockReplaceExtParams{c1, c2}
	for _, e := range mmReplaceExt.expectations {
		if minimock.Equal(e.params, mmReplaceExt.defaultExpectation.params) {
			mmReplaceExt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReplaceExt.defaultExpectation.params)
		}
	}

	return mmReplaceExt
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.ReplaceExt
func (mmReplaceExt *mExecutionContextMockReplaceExt) Inspect(f func(c1 CreateFunc, c2 CreateDefaultValues)) *mExecutionContextMockReplaceExt {
	if mmReplaceExt.mock.inspectFuncReplaceExt != nil {
		mmReplaceExt.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.ReplaceExt")
	}

	mmReplaceExt.mock.inspectFuncReplaceExt = f

	return mmReplaceExt
}

// Return sets up results that will be returned by ExecutionContext.ReplaceExt
func (mmReplaceExt *mExecutionContextMockReplaceExt) Return(s1 StateUpdate) *ExecutionContextMock {
	if mmReplaceExt.mock.funcReplaceExt != nil {
		mmReplaceExt.mock.t.Fatalf("ExecutionContextMock.ReplaceExt mock is already set by Set")
	}

	if mmReplaceExt.defaultExpectation == nil {
		mmReplaceExt.defaultExpectation = &ExecutionContextMockReplaceExtExpectation{mock: mmReplaceExt.mock}
	}
	mmReplaceExt.defaultExpectation.results = &ExecutionContextMockReplaceExtResults{s1}
	return mmReplaceExt.mock
}

//Set uses given function f to mock the ExecutionContext.ReplaceExt method
func (mmReplaceExt *mExecutionContextMockReplaceExt) Set(f func(c1 CreateFunc, c2 CreateDefaultValues) (s1 StateUpdate)) *ExecutionContextMock {
	if mmReplaceExt.defaultExpectation != nil {
		mmReplaceExt.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.ReplaceExt method")
	}

	if len(mmReplaceExt.expectations) > 0 {
		mmReplaceExt.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.ReplaceExt method")
	}

	mmReplaceExt.mock.funcReplaceExt = f
	return mmReplaceExt.mock
}

// When sets expectation for the ExecutionContext.ReplaceExt which will trigger the result defined by the following
// Then helper
func (mmReplaceExt *mExecutionContextMockReplaceExt) When(c1 CreateFunc, c2 CreateDefaultValues) *ExecutionContextMockReplaceExtExpectation {
	if mmReplaceExt.mock.funcReplaceExt != nil {
		mmReplaceExt.mock.t.Fatalf("ExecutionContextMock.ReplaceExt mock is already set by Set")
	}

	expectation := &ExecutionContextMockReplaceExtExpectation{
		mock:   mmReplaceExt.mock,
		params: &ExecutionContextMockReplaceExtParams{c1, c2},
	}
	mmReplaceExt.expectations = append(mmReplaceExt.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.ReplaceExt return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockReplaceExtExpectation) Then(s1 StateUpdate) *ExecutionContextMock {
	e.results = &ExecutionContextMockReplaceExtResults{s1}
	return e.mock
}

// ReplaceExt implements ExecutionContext
func (mmReplaceExt *ExecutionContextMock) ReplaceExt(c1 CreateFunc, c2 CreateDefaultValues) (s1 StateUpdate) {
	mm_atomic.AddUint64(&mmReplaceExt.beforeReplaceExtCounter, 1)
	defer mm_atomic.AddUint64(&mmReplaceExt.afterReplaceExtCounter, 1)

	if mmReplaceExt.inspectFuncReplaceExt != nil {
		mmReplaceExt.inspectFuncReplaceExt(c1, c2)
	}

	mm_params := &ExecutionContextMockReplaceExtParams{c1, c2}

	// Record call args
	mmReplaceExt.ReplaceExtMock.mutex.Lock()
	mmReplaceExt.ReplaceExtMock.callArgs = append(mmReplaceExt.ReplaceExtMock.callArgs, mm_params)
	mmReplaceExt.ReplaceExtMock.mutex.Unlock()

	for _, e := range mmReplaceExt.ReplaceExtMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmReplaceExt.ReplaceExtMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReplaceExt.ReplaceExtMock.defaultExpectation.Counter, 1)
		mm_want := mmReplaceExt.ReplaceExtMock.defaultExpectation.params
		mm_got := ExecutionContextMockReplaceExtParams{c1, c2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReplaceExt.t.Errorf("ExecutionContextMock.ReplaceExt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReplaceExt.ReplaceExtMock.defaultExpectation.results
		if mm_results == nil {
			mmReplaceExt.t.Fatal("No results are set for the ExecutionContextMock.ReplaceExt")
		}
		return (*mm_results).s1
	}
	if mmReplaceExt.funcReplaceExt != nil {
		return mmReplaceExt.funcReplaceExt(c1, c2)
	}
	mmReplaceExt.t.Fatalf("Unexpected call to ExecutionContextMock.ReplaceExt. %v %v", c1, c2)
	return
}

// ReplaceExtAfterCounter returns a count of finished ExecutionContextMock.ReplaceExt invocations
func (mmReplaceExt *ExecutionContextMock) ReplaceExtAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReplaceExt.afterReplaceExtCounter)
}

// ReplaceExtBeforeCounter returns a count of ExecutionContextMock.ReplaceExt invocations
func (mmReplaceExt *ExecutionContextMock) ReplaceExtBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReplaceExt.beforeReplaceExtCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.ReplaceExt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReplaceExt *mExecutionContextMockReplaceExt) Calls() []*ExecutionContextMockReplaceExtParams {
	mmReplaceExt.mutex.RLock()

	argCopy := make([]*ExecutionContextMockReplaceExtParams, len(mmReplaceExt.callArgs))
	copy(argCopy, mmReplaceExt.callArgs)

	mmReplaceExt.mutex.RUnlock()

	return argCopy
}

// MinimockReplaceExtDone returns true if the count of the ReplaceExt invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockReplaceExtDone() bool {
	for _, e := range m.ReplaceExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReplaceExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReplaceExtCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReplaceExt != nil && mm_atomic.LoadUint64(&m.afterReplaceExtCounter) < 1 {
		return false
	}
	return true
}

// MinimockReplaceExtInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockReplaceExtInspect() {
	for _, e := range m.ReplaceExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.ReplaceExt with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReplaceExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReplaceExtCounter) < 1 {
		if m.ReplaceExtMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.ReplaceExt")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.ReplaceExt with params: %#v", *m.ReplaceExtMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReplaceExt != nil && mm_atomic.LoadUint64(&m.afterReplaceExtCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.ReplaceExt")
	}
}

type mExecutionContextMockReplaceWith struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockReplaceWithExpectation
	expectations       []*ExecutionContextMockReplaceWithExpectation

	callArgs []*ExecutionContextMockReplaceWithParams
	mutex    sync.RWMutex
}

// ExecutionContextMockReplaceWithExpectation specifies expectation struct of the ExecutionContext.ReplaceWith
type ExecutionContextMockReplaceWithExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockReplaceWithParams
	results *ExecutionContextMockReplaceWithResults
	Counter uint64
}

// ExecutionContextMockReplaceWithParams contains parameters of the ExecutionContext.ReplaceWith
type ExecutionContextMockReplaceWithParams struct {
	s1 StateMachine
}

// ExecutionContextMockReplaceWithResults contains results of the ExecutionContext.ReplaceWith
type ExecutionContextMockReplaceWithResults struct {
	s2 StateUpdate
}

// Expect sets up expected params for ExecutionContext.ReplaceWith
func (mmReplaceWith *mExecutionContextMockReplaceWith) Expect(s1 StateMachine) *mExecutionContextMockReplaceWith {
	if mmReplaceWith.mock.funcReplaceWith != nil {
		mmReplaceWith.mock.t.Fatalf("ExecutionContextMock.ReplaceWith mock is already set by Set")
	}

	if mmReplaceWith.defaultExpectation == nil {
		mmReplaceWith.defaultExpectation = &ExecutionContextMockReplaceWithExpectation{}
	}

	mmReplaceWith.defaultExpectation.params = &ExecutionContextMockReplaceWithParams{s1}
	for _, e := range mmReplaceWith.expectations {
		if minimock.Equal(e.params, mmReplaceWith.defaultExpectation.params) {
			mmReplaceWith.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReplaceWith.defaultExpectation.params)
		}
	}

	return mmReplaceWith
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.ReplaceWith
func (mmReplaceWith *mExecutionContextMockReplaceWith) Inspect(f func(s1 StateMachine)) *mExecutionContextMockReplaceWith {
	if mmReplaceWith.mock.inspectFuncReplaceWith != nil {
		mmReplaceWith.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.ReplaceWith")
	}

	mmReplaceWith.mock.inspectFuncReplaceWith = f

	return mmReplaceWith
}

// Return sets up results that will be returned by ExecutionContext.ReplaceWith
func (mmReplaceWith *mExecutionContextMockReplaceWith) Return(s2 StateUpdate) *ExecutionContextMock {
	if mmReplaceWith.mock.funcReplaceWith != nil {
		mmReplaceWith.mock.t.Fatalf("ExecutionContextMock.ReplaceWith mock is already set by Set")
	}

	if mmReplaceWith.defaultExpectation == nil {
		mmReplaceWith.defaultExpectation = &ExecutionContextMockReplaceWithExpectation{mock: mmReplaceWith.mock}
	}
	mmReplaceWith.defaultExpectation.results = &ExecutionContextMockReplaceWithResults{s2}
	return mmReplaceWith.mock
}

//Set uses given function f to mock the ExecutionContext.ReplaceWith method
func (mmReplaceWith *mExecutionContextMockReplaceWith) Set(f func(s1 StateMachine) (s2 StateUpdate)) *ExecutionContextMock {
	if mmReplaceWith.defaultExpectation != nil {
		mmReplaceWith.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.ReplaceWith method")
	}

	if len(mmReplaceWith.expectations) > 0 {
		mmReplaceWith.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.ReplaceWith method")
	}

	mmReplaceWith.mock.funcReplaceWith = f
	return mmReplaceWith.mock
}

// When sets expectation for the ExecutionContext.ReplaceWith which will trigger the result defined by the following
// Then helper
func (mmReplaceWith *mExecutionContextMockReplaceWith) When(s1 StateMachine) *ExecutionContextMockReplaceWithExpectation {
	if mmReplaceWith.mock.funcReplaceWith != nil {
		mmReplaceWith.mock.t.Fatalf("ExecutionContextMock.ReplaceWith mock is already set by Set")
	}

	expectation := &ExecutionContextMockReplaceWithExpectation{
		mock:   mmReplaceWith.mock,
		params: &ExecutionContextMockReplaceWithParams{s1},
	}
	mmReplaceWith.expectations = append(mmReplaceWith.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.ReplaceWith return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockReplaceWithExpectation) Then(s2 StateUpdate) *ExecutionContextMock {
	e.results = &ExecutionContextMockReplaceWithResults{s2}
	return e.mock
}

// ReplaceWith implements ExecutionContext
func (mmReplaceWith *ExecutionContextMock) ReplaceWith(s1 StateMachine) (s2 StateUpdate) {
	mm_atomic.AddUint64(&mmReplaceWith.beforeReplaceWithCounter, 1)
	defer mm_atomic.AddUint64(&mmReplaceWith.afterReplaceWithCounter, 1)

	if mmReplaceWith.inspectFuncReplaceWith != nil {
		mmReplaceWith.inspectFuncReplaceWith(s1)
	}

	mm_params := &ExecutionContextMockReplaceWithParams{s1}

	// Record call args
	mmReplaceWith.ReplaceWithMock.mutex.Lock()
	mmReplaceWith.ReplaceWithMock.callArgs = append(mmReplaceWith.ReplaceWithMock.callArgs, mm_params)
	mmReplaceWith.ReplaceWithMock.mutex.Unlock()

	for _, e := range mmReplaceWith.ReplaceWithMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2
		}
	}

	if mmReplaceWith.ReplaceWithMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReplaceWith.ReplaceWithMock.defaultExpectation.Counter, 1)
		mm_want := mmReplaceWith.ReplaceWithMock.defaultExpectation.params
		mm_got := ExecutionContextMockReplaceWithParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReplaceWith.t.Errorf("ExecutionContextMock.ReplaceWith got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReplaceWith.ReplaceWithMock.defaultExpectation.results
		if mm_results == nil {
			mmReplaceWith.t.Fatal("No results are set for the ExecutionContextMock.ReplaceWith")
		}
		return (*mm_results).s2
	}
	if mmReplaceWith.funcReplaceWith != nil {
		return mmReplaceWith.funcReplaceWith(s1)
	}
	mmReplaceWith.t.Fatalf("Unexpected call to ExecutionContextMock.ReplaceWith. %v", s1)
	return
}

// ReplaceWithAfterCounter returns a count of finished ExecutionContextMock.ReplaceWith invocations
func (mmReplaceWith *ExecutionContextMock) ReplaceWithAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReplaceWith.afterReplaceWithCounter)
}

// ReplaceWithBeforeCounter returns a count of ExecutionContextMock.ReplaceWith invocations
func (mmReplaceWith *ExecutionContextMock) ReplaceWithBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReplaceWith.beforeReplaceWithCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.ReplaceWith.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReplaceWith *mExecutionContextMockReplaceWith) Calls() []*ExecutionContextMockReplaceWithParams {
	mmReplaceWith.mutex.RLock()

	argCopy := make([]*ExecutionContextMockReplaceWithParams, len(mmReplaceWith.callArgs))
	copy(argCopy, mmReplaceWith.callArgs)

	mmReplaceWith.mutex.RUnlock()

	return argCopy
}

// MinimockReplaceWithDone returns true if the count of the ReplaceWith invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockReplaceWithDone() bool {
	for _, e := range m.ReplaceWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReplaceWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReplaceWithCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReplaceWith != nil && mm_atomic.LoadUint64(&m.afterReplaceWithCounter) < 1 {
		return false
	}
	return true
}

// MinimockReplaceWithInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockReplaceWithInspect() {
	for _, e := range m.ReplaceWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.ReplaceWith with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReplaceWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReplaceWithCounter) < 1 {
		if m.ReplaceWithMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.ReplaceWith")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.ReplaceWith with params: %#v", *m.ReplaceWithMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReplaceWith != nil && mm_atomic.LoadUint64(&m.afterReplaceWithCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.ReplaceWith")
	}
}

type mExecutionContextMockRestoreStep struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockRestoreStepExpectation
	expectations       []*ExecutionContextMockRestoreStepExpectation

	callArgs []*ExecutionContextMockRestoreStepParams
	mutex    sync.RWMutex
}

// ExecutionContextMockRestoreStepExpectation specifies expectation struct of the ExecutionContext.RestoreStep
type ExecutionContextMockRestoreStepExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockRestoreStepParams
	results *ExecutionContextMockRestoreStepResults
	Counter uint64
}

// ExecutionContextMockRestoreStepParams contains parameters of the ExecutionContext.RestoreStep
type ExecutionContextMockRestoreStepParams struct {
	s1 SlotStep
}

// ExecutionContextMockRestoreStepResults contains results of the ExecutionContext.RestoreStep
type ExecutionContextMockRestoreStepResults struct {
	s2 StateUpdate
}

// Expect sets up expected params for ExecutionContext.RestoreStep
func (mmRestoreStep *mExecutionContextMockRestoreStep) Expect(s1 SlotStep) *mExecutionContextMockRestoreStep {
	if mmRestoreStep.mock.funcRestoreStep != nil {
		mmRestoreStep.mock.t.Fatalf("ExecutionContextMock.RestoreStep mock is already set by Set")
	}

	if mmRestoreStep.defaultExpectation == nil {
		mmRestoreStep.defaultExpectation = &ExecutionContextMockRestoreStepExpectation{}
	}

	mmRestoreStep.defaultExpectation.params = &ExecutionContextMockRestoreStepParams{s1}
	for _, e := range mmRestoreStep.expectations {
		if minimock.Equal(e.params, mmRestoreStep.defaultExpectation.params) {
			mmRestoreStep.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRestoreStep.defaultExpectation.params)
		}
	}

	return mmRestoreStep
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.RestoreStep
func (mmRestoreStep *mExecutionContextMockRestoreStep) Inspect(f func(s1 SlotStep)) *mExecutionContextMockRestoreStep {
	if mmRestoreStep.mock.inspectFuncRestoreStep != nil {
		mmRestoreStep.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.RestoreStep")
	}

	mmRestoreStep.mock.inspectFuncRestoreStep = f

	return mmRestoreStep
}

// Return sets up results that will be returned by ExecutionContext.RestoreStep
func (mmRestoreStep *mExecutionContextMockRestoreStep) Return(s2 StateUpdate) *ExecutionContextMock {
	if mmRestoreStep.mock.funcRestoreStep != nil {
		mmRestoreStep.mock.t.Fatalf("ExecutionContextMock.RestoreStep mock is already set by Set")
	}

	if mmRestoreStep.defaultExpectation == nil {
		mmRestoreStep.defaultExpectation = &ExecutionContextMockRestoreStepExpectation{mock: mmRestoreStep.mock}
	}
	mmRestoreStep.defaultExpectation.results = &ExecutionContextMockRestoreStepResults{s2}
	return mmRestoreStep.mock
}

//Set uses given function f to mock the ExecutionContext.RestoreStep method
func (mmRestoreStep *mExecutionContextMockRestoreStep) Set(f func(s1 SlotStep) (s2 StateUpdate)) *ExecutionContextMock {
	if mmRestoreStep.defaultExpectation != nil {
		mmRestoreStep.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.RestoreStep method")
	}

	if len(mmRestoreStep.expectations) > 0 {
		mmRestoreStep.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.RestoreStep method")
	}

	mmRestoreStep.mock.funcRestoreStep = f
	return mmRestoreStep.mock
}

// When sets expectation for the ExecutionContext.RestoreStep which will trigger the result defined by the following
// Then helper
func (mmRestoreStep *mExecutionContextMockRestoreStep) When(s1 SlotStep) *ExecutionContextMockRestoreStepExpectation {
	if mmRestoreStep.mock.funcRestoreStep != nil {
		mmRestoreStep.mock.t.Fatalf("ExecutionContextMock.RestoreStep mock is already set by Set")
	}

	expectation := &ExecutionContextMockRestoreStepExpectation{
		mock:   mmRestoreStep.mock,
		params: &ExecutionContextMockRestoreStepParams{s1},
	}
	mmRestoreStep.expectations = append(mmRestoreStep.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.RestoreStep return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockRestoreStepExpectation) Then(s2 StateUpdate) *ExecutionContextMock {
	e.results = &ExecutionContextMockRestoreStepResults{s2}
	return e.mock
}

// RestoreStep implements ExecutionContext
func (mmRestoreStep *ExecutionContextMock) RestoreStep(s1 SlotStep) (s2 StateUpdate) {
	mm_atomic.AddUint64(&mmRestoreStep.beforeRestoreStepCounter, 1)
	defer mm_atomic.AddUint64(&mmRestoreStep.afterRestoreStepCounter, 1)

	if mmRestoreStep.inspectFuncRestoreStep != nil {
		mmRestoreStep.inspectFuncRestoreStep(s1)
	}

	mm_params := &ExecutionContextMockRestoreStepParams{s1}

	// Record call args
	mmRestoreStep.RestoreStepMock.mutex.Lock()
	mmRestoreStep.RestoreStepMock.callArgs = append(mmRestoreStep.RestoreStepMock.callArgs, mm_params)
	mmRestoreStep.RestoreStepMock.mutex.Unlock()

	for _, e := range mmRestoreStep.RestoreStepMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2
		}
	}

	if mmRestoreStep.RestoreStepMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRestoreStep.RestoreStepMock.defaultExpectation.Counter, 1)
		mm_want := mmRestoreStep.RestoreStepMock.defaultExpectation.params
		mm_got := ExecutionContextMockRestoreStepParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRestoreStep.t.Errorf("ExecutionContextMock.RestoreStep got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRestoreStep.RestoreStepMock.defaultExpectation.results
		if mm_results == nil {
			mmRestoreStep.t.Fatal("No results are set for the ExecutionContextMock.RestoreStep")
		}
		return (*mm_results).s2
	}
	if mmRestoreStep.funcRestoreStep != nil {
		return mmRestoreStep.funcRestoreStep(s1)
	}
	mmRestoreStep.t.Fatalf("Unexpected call to ExecutionContextMock.RestoreStep. %v", s1)
	return
}

// RestoreStepAfterCounter returns a count of finished ExecutionContextMock.RestoreStep invocations
func (mmRestoreStep *ExecutionContextMock) RestoreStepAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRestoreStep.afterRestoreStepCounter)
}

// RestoreStepBeforeCounter returns a count of ExecutionContextMock.RestoreStep invocations
func (mmRestoreStep *ExecutionContextMock) RestoreStepBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRestoreStep.beforeRestoreStepCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.RestoreStep.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRestoreStep *mExecutionContextMockRestoreStep) Calls() []*ExecutionContextMockRestoreStepParams {
	mmRestoreStep.mutex.RLock()

	argCopy := make([]*ExecutionContextMockRestoreStepParams, len(mmRestoreStep.callArgs))
	copy(argCopy, mmRestoreStep.callArgs)

	mmRestoreStep.mutex.RUnlock()

	return argCopy
}

// MinimockRestoreStepDone returns true if the count of the RestoreStep invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockRestoreStepDone() bool {
	for _, e := range m.RestoreStepMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RestoreStepMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRestoreStepCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRestoreStep != nil && mm_atomic.LoadUint64(&m.afterRestoreStepCounter) < 1 {
		return false
	}
	return true
}

// MinimockRestoreStepInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockRestoreStepInspect() {
	for _, e := range m.RestoreStepMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.RestoreStep with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RestoreStepMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRestoreStepCounter) < 1 {
		if m.RestoreStepMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.RestoreStep")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.RestoreStep with params: %#v", *m.RestoreStepMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRestoreStep != nil && mm_atomic.LoadUint64(&m.afterRestoreStepCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.RestoreStep")
	}
}

type mExecutionContextMockSetDefaultErrorHandler struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockSetDefaultErrorHandlerExpectation
	expectations       []*ExecutionContextMockSetDefaultErrorHandlerExpectation

	callArgs []*ExecutionContextMockSetDefaultErrorHandlerParams
	mutex    sync.RWMutex
}

// ExecutionContextMockSetDefaultErrorHandlerExpectation specifies expectation struct of the ExecutionContext.SetDefaultErrorHandler
type ExecutionContextMockSetDefaultErrorHandlerExpectation struct {
	mock   *ExecutionContextMock
	params *ExecutionContextMockSetDefaultErrorHandlerParams

	Counter uint64
}

// ExecutionContextMockSetDefaultErrorHandlerParams contains parameters of the ExecutionContext.SetDefaultErrorHandler
type ExecutionContextMockSetDefaultErrorHandlerParams struct {
	e1 ErrorHandlerFunc
}

// Expect sets up expected params for ExecutionContext.SetDefaultErrorHandler
func (mmSetDefaultErrorHandler *mExecutionContextMockSetDefaultErrorHandler) Expect(e1 ErrorHandlerFunc) *mExecutionContextMockSetDefaultErrorHandler {
	if mmSetDefaultErrorHandler.mock.funcSetDefaultErrorHandler != nil {
		mmSetDefaultErrorHandler.mock.t.Fatalf("ExecutionContextMock.SetDefaultErrorHandler mock is already set by Set")
	}

	if mmSetDefaultErrorHandler.defaultExpectation == nil {
		mmSetDefaultErrorHandler.defaultExpectation = &ExecutionContextMockSetDefaultErrorHandlerExpectation{}
	}

	mmSetDefaultErrorHandler.defaultExpectation.params = &ExecutionContextMockSetDefaultErrorHandlerParams{e1}
	for _, e := range mmSetDefaultErrorHandler.expectations {
		if minimock.Equal(e.params, mmSetDefaultErrorHandler.defaultExpectation.params) {
			mmSetDefaultErrorHandler.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetDefaultErrorHandler.defaultExpectation.params)
		}
	}

	return mmSetDefaultErrorHandler
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.SetDefaultErrorHandler
func (mmSetDefaultErrorHandler *mExecutionContextMockSetDefaultErrorHandler) Inspect(f func(e1 ErrorHandlerFunc)) *mExecutionContextMockSetDefaultErrorHandler {
	if mmSetDefaultErrorHandler.mock.inspectFuncSetDefaultErrorHandler != nil {
		mmSetDefaultErrorHandler.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.SetDefaultErrorHandler")
	}

	mmSetDefaultErrorHandler.mock.inspectFuncSetDefaultErrorHandler = f

	return mmSetDefaultErrorHandler
}

// Return sets up results that will be returned by ExecutionContext.SetDefaultErrorHandler
func (mmSetDefaultErrorHandler *mExecutionContextMockSetDefaultErrorHandler) Return() *ExecutionContextMock {
	if mmSetDefaultErrorHandler.mock.funcSetDefaultErrorHandler != nil {
		mmSetDefaultErrorHandler.mock.t.Fatalf("ExecutionContextMock.SetDefaultErrorHandler mock is already set by Set")
	}

	if mmSetDefaultErrorHandler.defaultExpectation == nil {
		mmSetDefaultErrorHandler.defaultExpectation = &ExecutionContextMockSetDefaultErrorHandlerExpectation{mock: mmSetDefaultErrorHandler.mock}
	}

	return mmSetDefaultErrorHandler.mock
}

//Set uses given function f to mock the ExecutionContext.SetDefaultErrorHandler method
func (mmSetDefaultErrorHandler *mExecutionContextMockSetDefaultErrorHandler) Set(f func(e1 ErrorHandlerFunc)) *ExecutionContextMock {
	if mmSetDefaultErrorHandler.defaultExpectation != nil {
		mmSetDefaultErrorHandler.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.SetDefaultErrorHandler method")
	}

	if len(mmSetDefaultErrorHandler.expectations) > 0 {
		mmSetDefaultErrorHandler.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.SetDefaultErrorHandler method")
	}

	mmSetDefaultErrorHandler.mock.funcSetDefaultErrorHandler = f
	return mmSetDefaultErrorHandler.mock
}

// SetDefaultErrorHandler implements ExecutionContext
func (mmSetDefaultErrorHandler *ExecutionContextMock) SetDefaultErrorHandler(e1 ErrorHandlerFunc) {
	mm_atomic.AddUint64(&mmSetDefaultErrorHandler.beforeSetDefaultErrorHandlerCounter, 1)
	defer mm_atomic.AddUint64(&mmSetDefaultErrorHandler.afterSetDefaultErrorHandlerCounter, 1)

	if mmSetDefaultErrorHandler.inspectFuncSetDefaultErrorHandler != nil {
		mmSetDefaultErrorHandler.inspectFuncSetDefaultErrorHandler(e1)
	}

	mm_params := &ExecutionContextMockSetDefaultErrorHandlerParams{e1}

	// Record call args
	mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.mutex.Lock()
	mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.callArgs = append(mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.callArgs, mm_params)
	mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.mutex.Unlock()

	for _, e := range mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.defaultExpectation.Counter, 1)
		mm_want := mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.defaultExpectation.params
		mm_got := ExecutionContextMockSetDefaultErrorHandlerParams{e1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetDefaultErrorHandler.t.Errorf("ExecutionContextMock.SetDefaultErrorHandler got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetDefaultErrorHandler.funcSetDefaultErrorHandler != nil {
		mmSetDefaultErrorHandler.funcSetDefaultErrorHandler(e1)
		return
	}
	mmSetDefaultErrorHandler.t.Fatalf("Unexpected call to ExecutionContextMock.SetDefaultErrorHandler. %v", e1)

}

// SetDefaultErrorHandlerAfterCounter returns a count of finished ExecutionContextMock.SetDefaultErrorHandler invocations
func (mmSetDefaultErrorHandler *ExecutionContextMock) SetDefaultErrorHandlerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultErrorHandler.afterSetDefaultErrorHandlerCounter)
}

// SetDefaultErrorHandlerBeforeCounter returns a count of ExecutionContextMock.SetDefaultErrorHandler invocations
func (mmSetDefaultErrorHandler *ExecutionContextMock) SetDefaultErrorHandlerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultErrorHandler.beforeSetDefaultErrorHandlerCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.SetDefaultErrorHandler.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetDefaultErrorHandler *mExecutionContextMockSetDefaultErrorHandler) Calls() []*ExecutionContextMockSetDefaultErrorHandlerParams {
	mmSetDefaultErrorHandler.mutex.RLock()

	argCopy := make([]*ExecutionContextMockSetDefaultErrorHandlerParams, len(mmSetDefaultErrorHandler.callArgs))
	copy(argCopy, mmSetDefaultErrorHandler.callArgs)

	mmSetDefaultErrorHandler.mutex.RUnlock()

	return argCopy
}

// MinimockSetDefaultErrorHandlerDone returns true if the count of the SetDefaultErrorHandler invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockSetDefaultErrorHandlerDone() bool {
	for _, e := range m.SetDefaultErrorHandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultErrorHandlerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultErrorHandlerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultErrorHandler != nil && mm_atomic.LoadUint64(&m.afterSetDefaultErrorHandlerCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetDefaultErrorHandlerInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockSetDefaultErrorHandlerInspect() {
	for _, e := range m.SetDefaultErrorHandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.SetDefaultErrorHandler with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultErrorHandlerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultErrorHandlerCounter) < 1 {
		if m.SetDefaultErrorHandlerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.SetDefaultErrorHandler")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.SetDefaultErrorHandler with params: %#v", *m.SetDefaultErrorHandlerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultErrorHandler != nil && mm_atomic.LoadUint64(&m.afterSetDefaultErrorHandlerCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.SetDefaultErrorHandler")
	}
}

type mExecutionContextMockSetDefaultFlags struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockSetDefaultFlagsExpectation
	expectations       []*ExecutionContextMockSetDefaultFlagsExpectation

	callArgs []*ExecutionContextMockSetDefaultFlagsParams
	mutex    sync.RWMutex
}

// ExecutionContextMockSetDefaultFlagsExpectation specifies expectation struct of the ExecutionContext.SetDefaultFlags
type ExecutionContextMockSetDefaultFlagsExpectation struct {
	mock   *ExecutionContextMock
	params *ExecutionContextMockSetDefaultFlagsParams

	Counter uint64
}

// ExecutionContextMockSetDefaultFlagsParams contains parameters of the ExecutionContext.SetDefaultFlags
type ExecutionContextMockSetDefaultFlagsParams struct {
	s1 StepFlags
}

// Expect sets up expected params for ExecutionContext.SetDefaultFlags
func (mmSetDefaultFlags *mExecutionContextMockSetDefaultFlags) Expect(s1 StepFlags) *mExecutionContextMockSetDefaultFlags {
	if mmSetDefaultFlags.mock.funcSetDefaultFlags != nil {
		mmSetDefaultFlags.mock.t.Fatalf("ExecutionContextMock.SetDefaultFlags mock is already set by Set")
	}

	if mmSetDefaultFlags.defaultExpectation == nil {
		mmSetDefaultFlags.defaultExpectation = &ExecutionContextMockSetDefaultFlagsExpectation{}
	}

	mmSetDefaultFlags.defaultExpectation.params = &ExecutionContextMockSetDefaultFlagsParams{s1}
	for _, e := range mmSetDefaultFlags.expectations {
		if minimock.Equal(e.params, mmSetDefaultFlags.defaultExpectation.params) {
			mmSetDefaultFlags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetDefaultFlags.defaultExpectation.params)
		}
	}

	return mmSetDefaultFlags
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.SetDefaultFlags
func (mmSetDefaultFlags *mExecutionContextMockSetDefaultFlags) Inspect(f func(s1 StepFlags)) *mExecutionContextMockSetDefaultFlags {
	if mmSetDefaultFlags.mock.inspectFuncSetDefaultFlags != nil {
		mmSetDefaultFlags.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.SetDefaultFlags")
	}

	mmSetDefaultFlags.mock.inspectFuncSetDefaultFlags = f

	return mmSetDefaultFlags
}

// Return sets up results that will be returned by ExecutionContext.SetDefaultFlags
func (mmSetDefaultFlags *mExecutionContextMockSetDefaultFlags) Return() *ExecutionContextMock {
	if mmSetDefaultFlags.mock.funcSetDefaultFlags != nil {
		mmSetDefaultFlags.mock.t.Fatalf("ExecutionContextMock.SetDefaultFlags mock is already set by Set")
	}

	if mmSetDefaultFlags.defaultExpectation == nil {
		mmSetDefaultFlags.defaultExpectation = &ExecutionContextMockSetDefaultFlagsExpectation{mock: mmSetDefaultFlags.mock}
	}

	return mmSetDefaultFlags.mock
}

//Set uses given function f to mock the ExecutionContext.SetDefaultFlags method
func (mmSetDefaultFlags *mExecutionContextMockSetDefaultFlags) Set(f func(s1 StepFlags)) *ExecutionContextMock {
	if mmSetDefaultFlags.defaultExpectation != nil {
		mmSetDefaultFlags.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.SetDefaultFlags method")
	}

	if len(mmSetDefaultFlags.expectations) > 0 {
		mmSetDefaultFlags.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.SetDefaultFlags method")
	}

	mmSetDefaultFlags.mock.funcSetDefaultFlags = f
	return mmSetDefaultFlags.mock
}

// SetDefaultFlags implements ExecutionContext
func (mmSetDefaultFlags *ExecutionContextMock) SetDefaultFlags(s1 StepFlags) {
	mm_atomic.AddUint64(&mmSetDefaultFlags.beforeSetDefaultFlagsCounter, 1)
	defer mm_atomic.AddUint64(&mmSetDefaultFlags.afterSetDefaultFlagsCounter, 1)

	if mmSetDefaultFlags.inspectFuncSetDefaultFlags != nil {
		mmSetDefaultFlags.inspectFuncSetDefaultFlags(s1)
	}

	mm_params := &ExecutionContextMockSetDefaultFlagsParams{s1}

	// Record call args
	mmSetDefaultFlags.SetDefaultFlagsMock.mutex.Lock()
	mmSetDefaultFlags.SetDefaultFlagsMock.callArgs = append(mmSetDefaultFlags.SetDefaultFlagsMock.callArgs, mm_params)
	mmSetDefaultFlags.SetDefaultFlagsMock.mutex.Unlock()

	for _, e := range mmSetDefaultFlags.SetDefaultFlagsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetDefaultFlags.SetDefaultFlagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetDefaultFlags.SetDefaultFlagsMock.defaultExpectation.Counter, 1)
		mm_want := mmSetDefaultFlags.SetDefaultFlagsMock.defaultExpectation.params
		mm_got := ExecutionContextMockSetDefaultFlagsParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetDefaultFlags.t.Errorf("ExecutionContextMock.SetDefaultFlags got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetDefaultFlags.funcSetDefaultFlags != nil {
		mmSetDefaultFlags.funcSetDefaultFlags(s1)
		return
	}
	mmSetDefaultFlags.t.Fatalf("Unexpected call to ExecutionContextMock.SetDefaultFlags. %v", s1)

}

// SetDefaultFlagsAfterCounter returns a count of finished ExecutionContextMock.SetDefaultFlags invocations
func (mmSetDefaultFlags *ExecutionContextMock) SetDefaultFlagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultFlags.afterSetDefaultFlagsCounter)
}

// SetDefaultFlagsBeforeCounter returns a count of ExecutionContextMock.SetDefaultFlags invocations
func (mmSetDefaultFlags *ExecutionContextMock) SetDefaultFlagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultFlags.beforeSetDefaultFlagsCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.SetDefaultFlags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetDefaultFlags *mExecutionContextMockSetDefaultFlags) Calls() []*ExecutionContextMockSetDefaultFlagsParams {
	mmSetDefaultFlags.mutex.RLock()

	argCopy := make([]*ExecutionContextMockSetDefaultFlagsParams, len(mmSetDefaultFlags.callArgs))
	copy(argCopy, mmSetDefaultFlags.callArgs)

	mmSetDefaultFlags.mutex.RUnlock()

	return argCopy
}

// MinimockSetDefaultFlagsDone returns true if the count of the SetDefaultFlags invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockSetDefaultFlagsDone() bool {
	for _, e := range m.SetDefaultFlagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultFlagsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultFlagsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultFlags != nil && mm_atomic.LoadUint64(&m.afterSetDefaultFlagsCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetDefaultFlagsInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockSetDefaultFlagsInspect() {
	for _, e := range m.SetDefaultFlagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.SetDefaultFlags with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultFlagsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultFlagsCounter) < 1 {
		if m.SetDefaultFlagsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.SetDefaultFlags")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.SetDefaultFlags with params: %#v", *m.SetDefaultFlagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultFlags != nil && mm_atomic.LoadUint64(&m.afterSetDefaultFlagsCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.SetDefaultFlags")
	}
}

type mExecutionContextMockSetDefaultMigration struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockSetDefaultMigrationExpectation
	expectations       []*ExecutionContextMockSetDefaultMigrationExpectation

	callArgs []*ExecutionContextMockSetDefaultMigrationParams
	mutex    sync.RWMutex
}

// ExecutionContextMockSetDefaultMigrationExpectation specifies expectation struct of the ExecutionContext.SetDefaultMigration
type ExecutionContextMockSetDefaultMigrationExpectation struct {
	mock   *ExecutionContextMock
	params *ExecutionContextMockSetDefaultMigrationParams

	Counter uint64
}

// ExecutionContextMockSetDefaultMigrationParams contains parameters of the ExecutionContext.SetDefaultMigration
type ExecutionContextMockSetDefaultMigrationParams struct {
	m1 MigrateFunc
}

// Expect sets up expected params for ExecutionContext.SetDefaultMigration
func (mmSetDefaultMigration *mExecutionContextMockSetDefaultMigration) Expect(m1 MigrateFunc) *mExecutionContextMockSetDefaultMigration {
	if mmSetDefaultMigration.mock.funcSetDefaultMigration != nil {
		mmSetDefaultMigration.mock.t.Fatalf("ExecutionContextMock.SetDefaultMigration mock is already set by Set")
	}

	if mmSetDefaultMigration.defaultExpectation == nil {
		mmSetDefaultMigration.defaultExpectation = &ExecutionContextMockSetDefaultMigrationExpectation{}
	}

	mmSetDefaultMigration.defaultExpectation.params = &ExecutionContextMockSetDefaultMigrationParams{m1}
	for _, e := range mmSetDefaultMigration.expectations {
		if minimock.Equal(e.params, mmSetDefaultMigration.defaultExpectation.params) {
			mmSetDefaultMigration.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetDefaultMigration.defaultExpectation.params)
		}
	}

	return mmSetDefaultMigration
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.SetDefaultMigration
func (mmSetDefaultMigration *mExecutionContextMockSetDefaultMigration) Inspect(f func(m1 MigrateFunc)) *mExecutionContextMockSetDefaultMigration {
	if mmSetDefaultMigration.mock.inspectFuncSetDefaultMigration != nil {
		mmSetDefaultMigration.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.SetDefaultMigration")
	}

	mmSetDefaultMigration.mock.inspectFuncSetDefaultMigration = f

	return mmSetDefaultMigration
}

// Return sets up results that will be returned by ExecutionContext.SetDefaultMigration
func (mmSetDefaultMigration *mExecutionContextMockSetDefaultMigration) Return() *ExecutionContextMock {
	if mmSetDefaultMigration.mock.funcSetDefaultMigration != nil {
		mmSetDefaultMigration.mock.t.Fatalf("ExecutionContextMock.SetDefaultMigration mock is already set by Set")
	}

	if mmSetDefaultMigration.defaultExpectation == nil {
		mmSetDefaultMigration.defaultExpectation = &ExecutionContextMockSetDefaultMigrationExpectation{mock: mmSetDefaultMigration.mock}
	}

	return mmSetDefaultMigration.mock
}

//Set uses given function f to mock the ExecutionContext.SetDefaultMigration method
func (mmSetDefaultMigration *mExecutionContextMockSetDefaultMigration) Set(f func(m1 MigrateFunc)) *ExecutionContextMock {
	if mmSetDefaultMigration.defaultExpectation != nil {
		mmSetDefaultMigration.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.SetDefaultMigration method")
	}

	if len(mmSetDefaultMigration.expectations) > 0 {
		mmSetDefaultMigration.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.SetDefaultMigration method")
	}

	mmSetDefaultMigration.mock.funcSetDefaultMigration = f
	return mmSetDefaultMigration.mock
}

// SetDefaultMigration implements ExecutionContext
func (mmSetDefaultMigration *ExecutionContextMock) SetDefaultMigration(m1 MigrateFunc) {
	mm_atomic.AddUint64(&mmSetDefaultMigration.beforeSetDefaultMigrationCounter, 1)
	defer mm_atomic.AddUint64(&mmSetDefaultMigration.afterSetDefaultMigrationCounter, 1)

	if mmSetDefaultMigration.inspectFuncSetDefaultMigration != nil {
		mmSetDefaultMigration.inspectFuncSetDefaultMigration(m1)
	}

	mm_params := &ExecutionContextMockSetDefaultMigrationParams{m1}

	// Record call args
	mmSetDefaultMigration.SetDefaultMigrationMock.mutex.Lock()
	mmSetDefaultMigration.SetDefaultMigrationMock.callArgs = append(mmSetDefaultMigration.SetDefaultMigrationMock.callArgs, mm_params)
	mmSetDefaultMigration.SetDefaultMigrationMock.mutex.Unlock()

	for _, e := range mmSetDefaultMigration.SetDefaultMigrationMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetDefaultMigration.SetDefaultMigrationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetDefaultMigration.SetDefaultMigrationMock.defaultExpectation.Counter, 1)
		mm_want := mmSetDefaultMigration.SetDefaultMigrationMock.defaultExpectation.params
		mm_got := ExecutionContextMockSetDefaultMigrationParams{m1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetDefaultMigration.t.Errorf("ExecutionContextMock.SetDefaultMigration got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetDefaultMigration.funcSetDefaultMigration != nil {
		mmSetDefaultMigration.funcSetDefaultMigration(m1)
		return
	}
	mmSetDefaultMigration.t.Fatalf("Unexpected call to ExecutionContextMock.SetDefaultMigration. %v", m1)

}

// SetDefaultMigrationAfterCounter returns a count of finished ExecutionContextMock.SetDefaultMigration invocations
func (mmSetDefaultMigration *ExecutionContextMock) SetDefaultMigrationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultMigration.afterSetDefaultMigrationCounter)
}

// SetDefaultMigrationBeforeCounter returns a count of ExecutionContextMock.SetDefaultMigration invocations
func (mmSetDefaultMigration *ExecutionContextMock) SetDefaultMigrationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultMigration.beforeSetDefaultMigrationCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.SetDefaultMigration.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetDefaultMigration *mExecutionContextMockSetDefaultMigration) Calls() []*ExecutionContextMockSetDefaultMigrationParams {
	mmSetDefaultMigration.mutex.RLock()

	argCopy := make([]*ExecutionContextMockSetDefaultMigrationParams, len(mmSetDefaultMigration.callArgs))
	copy(argCopy, mmSetDefaultMigration.callArgs)

	mmSetDefaultMigration.mutex.RUnlock()

	return argCopy
}

// MinimockSetDefaultMigrationDone returns true if the count of the SetDefaultMigration invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockSetDefaultMigrationDone() bool {
	for _, e := range m.SetDefaultMigrationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultMigrationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultMigrationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultMigration != nil && mm_atomic.LoadUint64(&m.afterSetDefaultMigrationCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetDefaultMigrationInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockSetDefaultMigrationInspect() {
	for _, e := range m.SetDefaultMigrationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.SetDefaultMigration with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultMigrationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultMigrationCounter) < 1 {
		if m.SetDefaultMigrationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.SetDefaultMigration")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.SetDefaultMigration with params: %#v", *m.SetDefaultMigrationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultMigration != nil && mm_atomic.LoadUint64(&m.afterSetDefaultMigrationCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.SetDefaultMigration")
	}
}

type mExecutionContextMockSetFinalizer struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockSetFinalizerExpectation
	expectations       []*ExecutionContextMockSetFinalizerExpectation

	callArgs []*ExecutionContextMockSetFinalizerParams
	mutex    sync.RWMutex
}

// ExecutionContextMockSetFinalizerExpectation specifies expectation struct of the ExecutionContext.SetFinalizer
type ExecutionContextMockSetFinalizerExpectation struct {
	mock   *ExecutionContextMock
	params *ExecutionContextMockSetFinalizerParams

	Counter uint64
}

// ExecutionContextMockSetFinalizerParams contains parameters of the ExecutionContext.SetFinalizer
type ExecutionContextMockSetFinalizerParams struct {
	f1 FinalizeFunc
}

// Expect sets up expected params for ExecutionContext.SetFinalizer
func (mmSetFinalizer *mExecutionContextMockSetFinalizer) Expect(f1 FinalizeFunc) *mExecutionContextMockSetFinalizer {
	if mmSetFinalizer.mock.funcSetFinalizer != nil {
		mmSetFinalizer.mock.t.Fatalf("ExecutionContextMock.SetFinalizer mock is already set by Set")
	}

	if mmSetFinalizer.defaultExpectation == nil {
		mmSetFinalizer.defaultExpectation = &ExecutionContextMockSetFinalizerExpectation{}
	}

	mmSetFinalizer.defaultExpectation.params = &ExecutionContextMockSetFinalizerParams{f1}
	for _, e := range mmSetFinalizer.expectations {
		if minimock.Equal(e.params, mmSetFinalizer.defaultExpectation.params) {
			mmSetFinalizer.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetFinalizer.defaultExpectation.params)
		}
	}

	return mmSetFinalizer
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.SetFinalizer
func (mmSetFinalizer *mExecutionContextMockSetFinalizer) Inspect(f func(f1 FinalizeFunc)) *mExecutionContextMockSetFinalizer {
	if mmSetFinalizer.mock.inspectFuncSetFinalizer != nil {
		mmSetFinalizer.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.SetFinalizer")
	}

	mmSetFinalizer.mock.inspectFuncSetFinalizer = f

	return mmSetFinalizer
}

// Return sets up results that will be returned by ExecutionContext.SetFinalizer
func (mmSetFinalizer *mExecutionContextMockSetFinalizer) Return() *ExecutionContextMock {
	if mmSetFinalizer.mock.funcSetFinalizer != nil {
		mmSetFinalizer.mock.t.Fatalf("ExecutionContextMock.SetFinalizer mock is already set by Set")
	}

	if mmSetFinalizer.defaultExpectation == nil {
		mmSetFinalizer.defaultExpectation = &ExecutionContextMockSetFinalizerExpectation{mock: mmSetFinalizer.mock}
	}

	return mmSetFinalizer.mock
}

//Set uses given function f to mock the ExecutionContext.SetFinalizer method
func (mmSetFinalizer *mExecutionContextMockSetFinalizer) Set(f func(f1 FinalizeFunc)) *ExecutionContextMock {
	if mmSetFinalizer.defaultExpectation != nil {
		mmSetFinalizer.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.SetFinalizer method")
	}

	if len(mmSetFinalizer.expectations) > 0 {
		mmSetFinalizer.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.SetFinalizer method")
	}

	mmSetFinalizer.mock.funcSetFinalizer = f
	return mmSetFinalizer.mock
}

// SetFinalizer implements ExecutionContext
func (mmSetFinalizer *ExecutionContextMock) SetFinalizer(f1 FinalizeFunc) {
	mm_atomic.AddUint64(&mmSetFinalizer.beforeSetFinalizerCounter, 1)
	defer mm_atomic.AddUint64(&mmSetFinalizer.afterSetFinalizerCounter, 1)

	if mmSetFinalizer.inspectFuncSetFinalizer != nil {
		mmSetFinalizer.inspectFuncSetFinalizer(f1)
	}

	mm_params := &ExecutionContextMockSetFinalizerParams{f1}

	// Record call args
	mmSetFinalizer.SetFinalizerMock.mutex.Lock()
	mmSetFinalizer.SetFinalizerMock.callArgs = append(mmSetFinalizer.SetFinalizerMock.callArgs, mm_params)
	mmSetFinalizer.SetFinalizerMock.mutex.Unlock()

	for _, e := range mmSetFinalizer.SetFinalizerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetFinalizer.SetFinalizerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetFinalizer.SetFinalizerMock.defaultExpectation.Counter, 1)
		mm_want := mmSetFinalizer.SetFinalizerMock.defaultExpectation.params
		mm_got := ExecutionContextMockSetFinalizerParams{f1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetFinalizer.t.Errorf("ExecutionContextMock.SetFinalizer got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetFinalizer.funcSetFinalizer != nil {
		mmSetFinalizer.funcSetFinalizer(f1)
		return
	}
	mmSetFinalizer.t.Fatalf("Unexpected call to ExecutionContextMock.SetFinalizer. %v", f1)

}

// SetFinalizerAfterCounter returns a count of finished ExecutionContextMock.SetFinalizer invocations
func (mmSetFinalizer *ExecutionContextMock) SetFinalizerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetFinalizer.afterSetFinalizerCounter)
}

// SetFinalizerBeforeCounter returns a count of ExecutionContextMock.SetFinalizer invocations
func (mmSetFinalizer *ExecutionContextMock) SetFinalizerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetFinalizer.beforeSetFinalizerCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.SetFinalizer.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetFinalizer *mExecutionContextMockSetFinalizer) Calls() []*ExecutionContextMockSetFinalizerParams {
	mmSetFinalizer.mutex.RLock()

	argCopy := make([]*ExecutionContextMockSetFinalizerParams, len(mmSetFinalizer.callArgs))
	copy(argCopy, mmSetFinalizer.callArgs)

	mmSetFinalizer.mutex.RUnlock()

	return argCopy
}

// MinimockSetFinalizerDone returns true if the count of the SetFinalizer invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockSetFinalizerDone() bool {
	for _, e := range m.SetFinalizerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetFinalizerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetFinalizerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetFinalizer != nil && mm_atomic.LoadUint64(&m.afterSetFinalizerCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetFinalizerInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockSetFinalizerInspect() {
	for _, e := range m.SetFinalizerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.SetFinalizer with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetFinalizerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetFinalizerCounter) < 1 {
		if m.SetFinalizerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.SetFinalizer")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.SetFinalizer with params: %#v", *m.SetFinalizerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetFinalizer != nil && mm_atomic.LoadUint64(&m.afterSetFinalizerCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.SetFinalizer")
	}
}

type mExecutionContextMockSetLogTracing struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockSetLogTracingExpectation
	expectations       []*ExecutionContextMockSetLogTracingExpectation

	callArgs []*ExecutionContextMockSetLogTracingParams
	mutex    sync.RWMutex
}

// ExecutionContextMockSetLogTracingExpectation specifies expectation struct of the ExecutionContext.SetLogTracing
type ExecutionContextMockSetLogTracingExpectation struct {
	mock   *ExecutionContextMock
	params *ExecutionContextMockSetLogTracingParams

	Counter uint64
}

// ExecutionContextMockSetLogTracingParams contains parameters of the ExecutionContext.SetLogTracing
type ExecutionContextMockSetLogTracingParams struct {
	b1 bool
}

// Expect sets up expected params for ExecutionContext.SetLogTracing
func (mmSetLogTracing *mExecutionContextMockSetLogTracing) Expect(b1 bool) *mExecutionContextMockSetLogTracing {
	if mmSetLogTracing.mock.funcSetLogTracing != nil {
		mmSetLogTracing.mock.t.Fatalf("ExecutionContextMock.SetLogTracing mock is already set by Set")
	}

	if mmSetLogTracing.defaultExpectation == nil {
		mmSetLogTracing.defaultExpectation = &ExecutionContextMockSetLogTracingExpectation{}
	}

	mmSetLogTracing.defaultExpectation.params = &ExecutionContextMockSetLogTracingParams{b1}
	for _, e := range mmSetLogTracing.expectations {
		if minimock.Equal(e.params, mmSetLogTracing.defaultExpectation.params) {
			mmSetLogTracing.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetLogTracing.defaultExpectation.params)
		}
	}

	return mmSetLogTracing
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.SetLogTracing
func (mmSetLogTracing *mExecutionContextMockSetLogTracing) Inspect(f func(b1 bool)) *mExecutionContextMockSetLogTracing {
	if mmSetLogTracing.mock.inspectFuncSetLogTracing != nil {
		mmSetLogTracing.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.SetLogTracing")
	}

	mmSetLogTracing.mock.inspectFuncSetLogTracing = f

	return mmSetLogTracing
}

// Return sets up results that will be returned by ExecutionContext.SetLogTracing
func (mmSetLogTracing *mExecutionContextMockSetLogTracing) Return() *ExecutionContextMock {
	if mmSetLogTracing.mock.funcSetLogTracing != nil {
		mmSetLogTracing.mock.t.Fatalf("ExecutionContextMock.SetLogTracing mock is already set by Set")
	}

	if mmSetLogTracing.defaultExpectation == nil {
		mmSetLogTracing.defaultExpectation = &ExecutionContextMockSetLogTracingExpectation{mock: mmSetLogTracing.mock}
	}

	return mmSetLogTracing.mock
}

//Set uses given function f to mock the ExecutionContext.SetLogTracing method
func (mmSetLogTracing *mExecutionContextMockSetLogTracing) Set(f func(b1 bool)) *ExecutionContextMock {
	if mmSetLogTracing.defaultExpectation != nil {
		mmSetLogTracing.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.SetLogTracing method")
	}

	if len(mmSetLogTracing.expectations) > 0 {
		mmSetLogTracing.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.SetLogTracing method")
	}

	mmSetLogTracing.mock.funcSetLogTracing = f
	return mmSetLogTracing.mock
}

// SetLogTracing implements ExecutionContext
func (mmSetLogTracing *ExecutionContextMock) SetLogTracing(b1 bool) {
	mm_atomic.AddUint64(&mmSetLogTracing.beforeSetLogTracingCounter, 1)
	defer mm_atomic.AddUint64(&mmSetLogTracing.afterSetLogTracingCounter, 1)

	if mmSetLogTracing.inspectFuncSetLogTracing != nil {
		mmSetLogTracing.inspectFuncSetLogTracing(b1)
	}

	mm_params := &ExecutionContextMockSetLogTracingParams{b1}

	// Record call args
	mmSetLogTracing.SetLogTracingMock.mutex.Lock()
	mmSetLogTracing.SetLogTracingMock.callArgs = append(mmSetLogTracing.SetLogTracingMock.callArgs, mm_params)
	mmSetLogTracing.SetLogTracingMock.mutex.Unlock()

	for _, e := range mmSetLogTracing.SetLogTracingMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetLogTracing.SetLogTracingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetLogTracing.SetLogTracingMock.defaultExpectation.Counter, 1)
		mm_want := mmSetLogTracing.SetLogTracingMock.defaultExpectation.params
		mm_got := ExecutionContextMockSetLogTracingParams{b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetLogTracing.t.Errorf("ExecutionContextMock.SetLogTracing got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetLogTracing.funcSetLogTracing != nil {
		mmSetLogTracing.funcSetLogTracing(b1)
		return
	}
	mmSetLogTracing.t.Fatalf("Unexpected call to ExecutionContextMock.SetLogTracing. %v", b1)

}

// SetLogTracingAfterCounter returns a count of finished ExecutionContextMock.SetLogTracing invocations
func (mmSetLogTracing *ExecutionContextMock) SetLogTracingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetLogTracing.afterSetLogTracingCounter)
}

// SetLogTracingBeforeCounter returns a count of ExecutionContextMock.SetLogTracing invocations
func (mmSetLogTracing *ExecutionContextMock) SetLogTracingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetLogTracing.beforeSetLogTracingCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.SetLogTracing.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetLogTracing *mExecutionContextMockSetLogTracing) Calls() []*ExecutionContextMockSetLogTracingParams {
	mmSetLogTracing.mutex.RLock()

	argCopy := make([]*ExecutionContextMockSetLogTracingParams, len(mmSetLogTracing.callArgs))
	copy(argCopy, mmSetLogTracing.callArgs)

	mmSetLogTracing.mutex.RUnlock()

	return argCopy
}

// MinimockSetLogTracingDone returns true if the count of the SetLogTracing invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockSetLogTracingDone() bool {
	for _, e := range m.SetLogTracingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetLogTracingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetLogTracingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetLogTracing != nil && mm_atomic.LoadUint64(&m.afterSetLogTracingCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetLogTracingInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockSetLogTracingInspect() {
	for _, e := range m.SetLogTracingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.SetLogTracing with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetLogTracingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetLogTracingCounter) < 1 {
		if m.SetLogTracingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.SetLogTracing")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.SetLogTracing with params: %#v", *m.SetLogTracingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetLogTracing != nil && mm_atomic.LoadUint64(&m.afterSetLogTracingCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.SetLogTracing")
	}
}

type mExecutionContextMockSetTerminationResult struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockSetTerminationResultExpectation
	expectations       []*ExecutionContextMockSetTerminationResultExpectation

	callArgs []*ExecutionContextMockSetTerminationResultParams
	mutex    sync.RWMutex
}

// ExecutionContextMockSetTerminationResultExpectation specifies expectation struct of the ExecutionContext.SetTerminationResult
type ExecutionContextMockSetTerminationResultExpectation struct {
	mock   *ExecutionContextMock
	params *ExecutionContextMockSetTerminationResultParams

	Counter uint64
}

// ExecutionContextMockSetTerminationResultParams contains parameters of the ExecutionContext.SetTerminationResult
type ExecutionContextMockSetTerminationResultParams struct {
	p1 interface{}
}

// Expect sets up expected params for ExecutionContext.SetTerminationResult
func (mmSetTerminationResult *mExecutionContextMockSetTerminationResult) Expect(p1 interface{}) *mExecutionContextMockSetTerminationResult {
	if mmSetTerminationResult.mock.funcSetTerminationResult != nil {
		mmSetTerminationResult.mock.t.Fatalf("ExecutionContextMock.SetTerminationResult mock is already set by Set")
	}

	if mmSetTerminationResult.defaultExpectation == nil {
		mmSetTerminationResult.defaultExpectation = &ExecutionContextMockSetTerminationResultExpectation{}
	}

	mmSetTerminationResult.defaultExpectation.params = &ExecutionContextMockSetTerminationResultParams{p1}
	for _, e := range mmSetTerminationResult.expectations {
		if minimock.Equal(e.params, mmSetTerminationResult.defaultExpectation.params) {
			mmSetTerminationResult.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetTerminationResult.defaultExpectation.params)
		}
	}

	return mmSetTerminationResult
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.SetTerminationResult
func (mmSetTerminationResult *mExecutionContextMockSetTerminationResult) Inspect(f func(p1 interface{})) *mExecutionContextMockSetTerminationResult {
	if mmSetTerminationResult.mock.inspectFuncSetTerminationResult != nil {
		mmSetTerminationResult.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.SetTerminationResult")
	}

	mmSetTerminationResult.mock.inspectFuncSetTerminationResult = f

	return mmSetTerminationResult
}

// Return sets up results that will be returned by ExecutionContext.SetTerminationResult
func (mmSetTerminationResult *mExecutionContextMockSetTerminationResult) Return() *ExecutionContextMock {
	if mmSetTerminationResult.mock.funcSetTerminationResult != nil {
		mmSetTerminationResult.mock.t.Fatalf("ExecutionContextMock.SetTerminationResult mock is already set by Set")
	}

	if mmSetTerminationResult.defaultExpectation == nil {
		mmSetTerminationResult.defaultExpectation = &ExecutionContextMockSetTerminationResultExpectation{mock: mmSetTerminationResult.mock}
	}

	return mmSetTerminationResult.mock
}

//Set uses given function f to mock the ExecutionContext.SetTerminationResult method
func (mmSetTerminationResult *mExecutionContextMockSetTerminationResult) Set(f func(p1 interface{})) *ExecutionContextMock {
	if mmSetTerminationResult.defaultExpectation != nil {
		mmSetTerminationResult.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.SetTerminationResult method")
	}

	if len(mmSetTerminationResult.expectations) > 0 {
		mmSetTerminationResult.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.SetTerminationResult method")
	}

	mmSetTerminationResult.mock.funcSetTerminationResult = f
	return mmSetTerminationResult.mock
}

// SetTerminationResult implements ExecutionContext
func (mmSetTerminationResult *ExecutionContextMock) SetTerminationResult(p1 interface{}) {
	mm_atomic.AddUint64(&mmSetTerminationResult.beforeSetTerminationResultCounter, 1)
	defer mm_atomic.AddUint64(&mmSetTerminationResult.afterSetTerminationResultCounter, 1)

	if mmSetTerminationResult.inspectFuncSetTerminationResult != nil {
		mmSetTerminationResult.inspectFuncSetTerminationResult(p1)
	}

	mm_params := &ExecutionContextMockSetTerminationResultParams{p1}

	// Record call args
	mmSetTerminationResult.SetTerminationResultMock.mutex.Lock()
	mmSetTerminationResult.SetTerminationResultMock.callArgs = append(mmSetTerminationResult.SetTerminationResultMock.callArgs, mm_params)
	mmSetTerminationResult.SetTerminationResultMock.mutex.Unlock()

	for _, e := range mmSetTerminationResult.SetTerminationResultMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetTerminationResult.SetTerminationResultMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetTerminationResult.SetTerminationResultMock.defaultExpectation.Counter, 1)
		mm_want := mmSetTerminationResult.SetTerminationResultMock.defaultExpectation.params
		mm_got := ExecutionContextMockSetTerminationResultParams{p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetTerminationResult.t.Errorf("ExecutionContextMock.SetTerminationResult got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetTerminationResult.funcSetTerminationResult != nil {
		mmSetTerminationResult.funcSetTerminationResult(p1)
		return
	}
	mmSetTerminationResult.t.Fatalf("Unexpected call to ExecutionContextMock.SetTerminationResult. %v", p1)

}

// SetTerminationResultAfterCounter returns a count of finished ExecutionContextMock.SetTerminationResult invocations
func (mmSetTerminationResult *ExecutionContextMock) SetTerminationResultAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTerminationResult.afterSetTerminationResultCounter)
}

// SetTerminationResultBeforeCounter returns a count of ExecutionContextMock.SetTerminationResult invocations
func (mmSetTerminationResult *ExecutionContextMock) SetTerminationResultBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTerminationResult.beforeSetTerminationResultCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.SetTerminationResult.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetTerminationResult *mExecutionContextMockSetTerminationResult) Calls() []*ExecutionContextMockSetTerminationResultParams {
	mmSetTerminationResult.mutex.RLock()

	argCopy := make([]*ExecutionContextMockSetTerminationResultParams, len(mmSetTerminationResult.callArgs))
	copy(argCopy, mmSetTerminationResult.callArgs)

	mmSetTerminationResult.mutex.RUnlock()

	return argCopy
}

// MinimockSetTerminationResultDone returns true if the count of the SetTerminationResult invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockSetTerminationResultDone() bool {
	for _, e := range m.SetTerminationResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTerminationResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTerminationResultCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTerminationResult != nil && mm_atomic.LoadUint64(&m.afterSetTerminationResultCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetTerminationResultInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockSetTerminationResultInspect() {
	for _, e := range m.SetTerminationResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.SetTerminationResult with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTerminationResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTerminationResultCounter) < 1 {
		if m.SetTerminationResultMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.SetTerminationResult")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.SetTerminationResult with params: %#v", *m.SetTerminationResultMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTerminationResult != nil && mm_atomic.LoadUint64(&m.afterSetTerminationResultCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.SetTerminationResult")
	}
}

type mExecutionContextMockShare struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockShareExpectation
	expectations       []*ExecutionContextMockShareExpectation

	callArgs []*ExecutionContextMockShareParams
	mutex    sync.RWMutex
}

// ExecutionContextMockShareExpectation specifies expectation struct of the ExecutionContext.Share
type ExecutionContextMockShareExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockShareParams
	results *ExecutionContextMockShareResults
	Counter uint64
}

// ExecutionContextMockShareParams contains parameters of the ExecutionContext.Share
type ExecutionContextMockShareParams struct {
	data  interface{}
	flags ShareDataFlags
}

// ExecutionContextMockShareResults contains results of the ExecutionContext.Share
type ExecutionContextMockShareResults struct {
	s1 SharedDataLink
}

// Expect sets up expected params for ExecutionContext.Share
func (mmShare *mExecutionContextMockShare) Expect(data interface{}, flags ShareDataFlags) *mExecutionContextMockShare {
	if mmShare.mock.funcShare != nil {
		mmShare.mock.t.Fatalf("ExecutionContextMock.Share mock is already set by Set")
	}

	if mmShare.defaultExpectation == nil {
		mmShare.defaultExpectation = &ExecutionContextMockShareExpectation{}
	}

	mmShare.defaultExpectation.params = &ExecutionContextMockShareParams{data, flags}
	for _, e := range mmShare.expectations {
		if minimock.Equal(e.params, mmShare.defaultExpectation.params) {
			mmShare.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmShare.defaultExpectation.params)
		}
	}

	return mmShare
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Share
func (mmShare *mExecutionContextMockShare) Inspect(f func(data interface{}, flags ShareDataFlags)) *mExecutionContextMockShare {
	if mmShare.mock.inspectFuncShare != nil {
		mmShare.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Share")
	}

	mmShare.mock.inspectFuncShare = f

	return mmShare
}

// Return sets up results that will be returned by ExecutionContext.Share
func (mmShare *mExecutionContextMockShare) Return(s1 SharedDataLink) *ExecutionContextMock {
	if mmShare.mock.funcShare != nil {
		mmShare.mock.t.Fatalf("ExecutionContextMock.Share mock is already set by Set")
	}

	if mmShare.defaultExpectation == nil {
		mmShare.defaultExpectation = &ExecutionContextMockShareExpectation{mock: mmShare.mock}
	}
	mmShare.defaultExpectation.results = &ExecutionContextMockShareResults{s1}
	return mmShare.mock
}

//Set uses given function f to mock the ExecutionContext.Share method
func (mmShare *mExecutionContextMockShare) Set(f func(data interface{}, flags ShareDataFlags) (s1 SharedDataLink)) *ExecutionContextMock {
	if mmShare.defaultExpectation != nil {
		mmShare.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Share method")
	}

	if len(mmShare.expectations) > 0 {
		mmShare.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Share method")
	}

	mmShare.mock.funcShare = f
	return mmShare.mock
}

// When sets expectation for the ExecutionContext.Share which will trigger the result defined by the following
// Then helper
func (mmShare *mExecutionContextMockShare) When(data interface{}, flags ShareDataFlags) *ExecutionContextMockShareExpectation {
	if mmShare.mock.funcShare != nil {
		mmShare.mock.t.Fatalf("ExecutionContextMock.Share mock is already set by Set")
	}

	expectation := &ExecutionContextMockShareExpectation{
		mock:   mmShare.mock,
		params: &ExecutionContextMockShareParams{data, flags},
	}
	mmShare.expectations = append(mmShare.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.Share return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockShareExpectation) Then(s1 SharedDataLink) *ExecutionContextMock {
	e.results = &ExecutionContextMockShareResults{s1}
	return e.mock
}

// Share implements ExecutionContext
func (mmShare *ExecutionContextMock) Share(data interface{}, flags ShareDataFlags) (s1 SharedDataLink) {
	mm_atomic.AddUint64(&mmShare.beforeShareCounter, 1)
	defer mm_atomic.AddUint64(&mmShare.afterShareCounter, 1)

	if mmShare.inspectFuncShare != nil {
		mmShare.inspectFuncShare(data, flags)
	}

	mm_params := &ExecutionContextMockShareParams{data, flags}

	// Record call args
	mmShare.ShareMock.mutex.Lock()
	mmShare.ShareMock.callArgs = append(mmShare.ShareMock.callArgs, mm_params)
	mmShare.ShareMock.mutex.Unlock()

	for _, e := range mmShare.ShareMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmShare.ShareMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShare.ShareMock.defaultExpectation.Counter, 1)
		mm_want := mmShare.ShareMock.defaultExpectation.params
		mm_got := ExecutionContextMockShareParams{data, flags}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmShare.t.Errorf("ExecutionContextMock.Share got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmShare.ShareMock.defaultExpectation.results
		if mm_results == nil {
			mmShare.t.Fatal("No results are set for the ExecutionContextMock.Share")
		}
		return (*mm_results).s1
	}
	if mmShare.funcShare != nil {
		return mmShare.funcShare(data, flags)
	}
	mmShare.t.Fatalf("Unexpected call to ExecutionContextMock.Share. %v %v", data, flags)
	return
}

// ShareAfterCounter returns a count of finished ExecutionContextMock.Share invocations
func (mmShare *ExecutionContextMock) ShareAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShare.afterShareCounter)
}

// ShareBeforeCounter returns a count of ExecutionContextMock.Share invocations
func (mmShare *ExecutionContextMock) ShareBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShare.beforeShareCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.Share.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmShare *mExecutionContextMockShare) Calls() []*ExecutionContextMockShareParams {
	mmShare.mutex.RLock()

	argCopy := make([]*ExecutionContextMockShareParams, len(mmShare.callArgs))
	copy(argCopy, mmShare.callArgs)

	mmShare.mutex.RUnlock()

	return argCopy
}

// MinimockShareDone returns true if the count of the Share invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockShareDone() bool {
	for _, e := range m.ShareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShareCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShare != nil && mm_atomic.LoadUint64(&m.afterShareCounter) < 1 {
		return false
	}
	return true
}

// MinimockShareInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockShareInspect() {
	for _, e := range m.ShareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.Share with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShareCounter) < 1 {
		if m.ShareMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.Share")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.Share with params: %#v", *m.ShareMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShare != nil && mm_atomic.LoadUint64(&m.afterShareCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Share")
	}
}

type mExecutionContextMockSleep struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockSleepExpectation
	expectations       []*ExecutionContextMockSleepExpectation
}

// ExecutionContextMockSleepExpectation specifies expectation struct of the ExecutionContext.Sleep
type ExecutionContextMockSleepExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockSleepResults
	Counter uint64
}

// ExecutionContextMockSleepResults contains results of the ExecutionContext.Sleep
type ExecutionContextMockSleepResults struct {
	c1 ConditionalBuilder
}

// Expect sets up expected params for ExecutionContext.Sleep
func (mmSleep *mExecutionContextMockSleep) Expect() *mExecutionContextMockSleep {
	if mmSleep.mock.funcSleep != nil {
		mmSleep.mock.t.Fatalf("ExecutionContextMock.Sleep mock is already set by Set")
	}

	if mmSleep.defaultExpectation == nil {
		mmSleep.defaultExpectation = &ExecutionContextMockSleepExpectation{}
	}

	return mmSleep
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Sleep
func (mmSleep *mExecutionContextMockSleep) Inspect(f func()) *mExecutionContextMockSleep {
	if mmSleep.mock.inspectFuncSleep != nil {
		mmSleep.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Sleep")
	}

	mmSleep.mock.inspectFuncSleep = f

	return mmSleep
}

// Return sets up results that will be returned by ExecutionContext.Sleep
func (mmSleep *mExecutionContextMockSleep) Return(c1 ConditionalBuilder) *ExecutionContextMock {
	if mmSleep.mock.funcSleep != nil {
		mmSleep.mock.t.Fatalf("ExecutionContextMock.Sleep mock is already set by Set")
	}

	if mmSleep.defaultExpectation == nil {
		mmSleep.defaultExpectation = &ExecutionContextMockSleepExpectation{mock: mmSleep.mock}
	}
	mmSleep.defaultExpectation.results = &ExecutionContextMockSleepResults{c1}
	return mmSleep.mock
}

//Set uses given function f to mock the ExecutionContext.Sleep method
func (mmSleep *mExecutionContextMockSleep) Set(f func() (c1 ConditionalBuilder)) *ExecutionContextMock {
	if mmSleep.defaultExpectation != nil {
		mmSleep.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Sleep method")
	}

	if len(mmSleep.expectations) > 0 {
		mmSleep.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Sleep method")
	}

	mmSleep.mock.funcSleep = f
	return mmSleep.mock
}

// Sleep implements ExecutionContext
func (mmSleep *ExecutionContextMock) Sleep() (c1 ConditionalBuilder) {
	mm_atomic.AddUint64(&mmSleep.beforeSleepCounter, 1)
	defer mm_atomic.AddUint64(&mmSleep.afterSleepCounter, 1)

	if mmSleep.inspectFuncSleep != nil {
		mmSleep.inspectFuncSleep()
	}

	if mmSleep.SleepMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSleep.SleepMock.defaultExpectation.Counter, 1)

		mm_results := mmSleep.SleepMock.defaultExpectation.results
		if mm_results == nil {
			mmSleep.t.Fatal("No results are set for the ExecutionContextMock.Sleep")
		}
		return (*mm_results).c1
	}
	if mmSleep.funcSleep != nil {
		return mmSleep.funcSleep()
	}
	mmSleep.t.Fatalf("Unexpected call to ExecutionContextMock.Sleep.")
	return
}

// SleepAfterCounter returns a count of finished ExecutionContextMock.Sleep invocations
func (mmSleep *ExecutionContextMock) SleepAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSleep.afterSleepCounter)
}

// SleepBeforeCounter returns a count of ExecutionContextMock.Sleep invocations
func (mmSleep *ExecutionContextMock) SleepBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSleep.beforeSleepCounter)
}

// MinimockSleepDone returns true if the count of the Sleep invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockSleepDone() bool {
	for _, e := range m.SleepMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SleepMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSleepCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSleep != nil && mm_atomic.LoadUint64(&m.afterSleepCounter) < 1 {
		return false
	}
	return true
}

// MinimockSleepInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockSleepInspect() {
	for _, e := range m.SleepMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.Sleep")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SleepMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSleepCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Sleep")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSleep != nil && mm_atomic.LoadUint64(&m.afterSleepCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Sleep")
	}
}

type mExecutionContextMockSlotLink struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockSlotLinkExpectation
	expectations       []*ExecutionContextMockSlotLinkExpectation
}

// ExecutionContextMockSlotLinkExpectation specifies expectation struct of the ExecutionContext.SlotLink
type ExecutionContextMockSlotLinkExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockSlotLinkResults
	Counter uint64
}

// ExecutionContextMockSlotLinkResults contains results of the ExecutionContext.SlotLink
type ExecutionContextMockSlotLinkResults struct {
	s1 SlotLink
}

// Expect sets up expected params for ExecutionContext.SlotLink
func (mmSlotLink *mExecutionContextMockSlotLink) Expect() *mExecutionContextMockSlotLink {
	if mmSlotLink.mock.funcSlotLink != nil {
		mmSlotLink.mock.t.Fatalf("ExecutionContextMock.SlotLink mock is already set by Set")
	}

	if mmSlotLink.defaultExpectation == nil {
		mmSlotLink.defaultExpectation = &ExecutionContextMockSlotLinkExpectation{}
	}

	return mmSlotLink
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.SlotLink
func (mmSlotLink *mExecutionContextMockSlotLink) Inspect(f func()) *mExecutionContextMockSlotLink {
	if mmSlotLink.mock.inspectFuncSlotLink != nil {
		mmSlotLink.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.SlotLink")
	}

	mmSlotLink.mock.inspectFuncSlotLink = f

	return mmSlotLink
}

// Return sets up results that will be returned by ExecutionContext.SlotLink
func (mmSlotLink *mExecutionContextMockSlotLink) Return(s1 SlotLink) *ExecutionContextMock {
	if mmSlotLink.mock.funcSlotLink != nil {
		mmSlotLink.mock.t.Fatalf("ExecutionContextMock.SlotLink mock is already set by Set")
	}

	if mmSlotLink.defaultExpectation == nil {
		mmSlotLink.defaultExpectation = &ExecutionContextMockSlotLinkExpectation{mock: mmSlotLink.mock}
	}
	mmSlotLink.defaultExpectation.results = &ExecutionContextMockSlotLinkResults{s1}
	return mmSlotLink.mock
}

//Set uses given function f to mock the ExecutionContext.SlotLink method
func (mmSlotLink *mExecutionContextMockSlotLink) Set(f func() (s1 SlotLink)) *ExecutionContextMock {
	if mmSlotLink.defaultExpectation != nil {
		mmSlotLink.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.SlotLink method")
	}

	if len(mmSlotLink.expectations) > 0 {
		mmSlotLink.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.SlotLink method")
	}

	mmSlotLink.mock.funcSlotLink = f
	return mmSlotLink.mock
}

// SlotLink implements ExecutionContext
func (mmSlotLink *ExecutionContextMock) SlotLink() (s1 SlotLink) {
	mm_atomic.AddUint64(&mmSlotLink.beforeSlotLinkCounter, 1)
	defer mm_atomic.AddUint64(&mmSlotLink.afterSlotLinkCounter, 1)

	if mmSlotLink.inspectFuncSlotLink != nil {
		mmSlotLink.inspectFuncSlotLink()
	}

	if mmSlotLink.SlotLinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSlotLink.SlotLinkMock.defaultExpectation.Counter, 1)

		mm_results := mmSlotLink.SlotLinkMock.defaultExpectation.results
		if mm_results == nil {
			mmSlotLink.t.Fatal("No results are set for the ExecutionContextMock.SlotLink")
		}
		return (*mm_results).s1
	}
	if mmSlotLink.funcSlotLink != nil {
		return mmSlotLink.funcSlotLink()
	}
	mmSlotLink.t.Fatalf("Unexpected call to ExecutionContextMock.SlotLink.")
	return
}

// SlotLinkAfterCounter returns a count of finished ExecutionContextMock.SlotLink invocations
func (mmSlotLink *ExecutionContextMock) SlotLinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSlotLink.afterSlotLinkCounter)
}

// SlotLinkBeforeCounter returns a count of ExecutionContextMock.SlotLink invocations
func (mmSlotLink *ExecutionContextMock) SlotLinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSlotLink.beforeSlotLinkCounter)
}

// MinimockSlotLinkDone returns true if the count of the SlotLink invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockSlotLinkDone() bool {
	for _, e := range m.SlotLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SlotLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSlotLinkCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSlotLink != nil && mm_atomic.LoadUint64(&m.afterSlotLinkCounter) < 1 {
		return false
	}
	return true
}

// MinimockSlotLinkInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockSlotLinkInspect() {
	for _, e := range m.SlotLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.SlotLink")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SlotLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSlotLinkCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.SlotLink")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSlotLink != nil && mm_atomic.LoadUint64(&m.afterSlotLinkCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.SlotLink")
	}
}

type mExecutionContextMockStepLink struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockStepLinkExpectation
	expectations       []*ExecutionContextMockStepLinkExpectation
}

// ExecutionContextMockStepLinkExpectation specifies expectation struct of the ExecutionContext.StepLink
type ExecutionContextMockStepLinkExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockStepLinkResults
	Counter uint64
}

// ExecutionContextMockStepLinkResults contains results of the ExecutionContext.StepLink
type ExecutionContextMockStepLinkResults struct {
	s1 StepLink
}

// Expect sets up expected params for ExecutionContext.StepLink
func (mmStepLink *mExecutionContextMockStepLink) Expect() *mExecutionContextMockStepLink {
	if mmStepLink.mock.funcStepLink != nil {
		mmStepLink.mock.t.Fatalf("ExecutionContextMock.StepLink mock is already set by Set")
	}

	if mmStepLink.defaultExpectation == nil {
		mmStepLink.defaultExpectation = &ExecutionContextMockStepLinkExpectation{}
	}

	return mmStepLink
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.StepLink
func (mmStepLink *mExecutionContextMockStepLink) Inspect(f func()) *mExecutionContextMockStepLink {
	if mmStepLink.mock.inspectFuncStepLink != nil {
		mmStepLink.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.StepLink")
	}

	mmStepLink.mock.inspectFuncStepLink = f

	return mmStepLink
}

// Return sets up results that will be returned by ExecutionContext.StepLink
func (mmStepLink *mExecutionContextMockStepLink) Return(s1 StepLink) *ExecutionContextMock {
	if mmStepLink.mock.funcStepLink != nil {
		mmStepLink.mock.t.Fatalf("ExecutionContextMock.StepLink mock is already set by Set")
	}

	if mmStepLink.defaultExpectation == nil {
		mmStepLink.defaultExpectation = &ExecutionContextMockStepLinkExpectation{mock: mmStepLink.mock}
	}
	mmStepLink.defaultExpectation.results = &ExecutionContextMockStepLinkResults{s1}
	return mmStepLink.mock
}

//Set uses given function f to mock the ExecutionContext.StepLink method
func (mmStepLink *mExecutionContextMockStepLink) Set(f func() (s1 StepLink)) *ExecutionContextMock {
	if mmStepLink.defaultExpectation != nil {
		mmStepLink.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.StepLink method")
	}

	if len(mmStepLink.expectations) > 0 {
		mmStepLink.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.StepLink method")
	}

	mmStepLink.mock.funcStepLink = f
	return mmStepLink.mock
}

// StepLink implements ExecutionContext
func (mmStepLink *ExecutionContextMock) StepLink() (s1 StepLink) {
	mm_atomic.AddUint64(&mmStepLink.beforeStepLinkCounter, 1)
	defer mm_atomic.AddUint64(&mmStepLink.afterStepLinkCounter, 1)

	if mmStepLink.inspectFuncStepLink != nil {
		mmStepLink.inspectFuncStepLink()
	}

	if mmStepLink.StepLinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStepLink.StepLinkMock.defaultExpectation.Counter, 1)

		mm_results := mmStepLink.StepLinkMock.defaultExpectation.results
		if mm_results == nil {
			mmStepLink.t.Fatal("No results are set for the ExecutionContextMock.StepLink")
		}
		return (*mm_results).s1
	}
	if mmStepLink.funcStepLink != nil {
		return mmStepLink.funcStepLink()
	}
	mmStepLink.t.Fatalf("Unexpected call to ExecutionContextMock.StepLink.")
	return
}

// StepLinkAfterCounter returns a count of finished ExecutionContextMock.StepLink invocations
func (mmStepLink *ExecutionContextMock) StepLinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStepLink.afterStepLinkCounter)
}

// StepLinkBeforeCounter returns a count of ExecutionContextMock.StepLink invocations
func (mmStepLink *ExecutionContextMock) StepLinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStepLink.beforeStepLinkCounter)
}

// MinimockStepLinkDone returns true if the count of the StepLink invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockStepLinkDone() bool {
	for _, e := range m.StepLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StepLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStepLinkCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStepLink != nil && mm_atomic.LoadUint64(&m.afterStepLinkCounter) < 1 {
		return false
	}
	return true
}

// MinimockStepLinkInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockStepLinkInspect() {
	for _, e := range m.StepLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.StepLink")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StepLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStepLinkCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.StepLink")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStepLink != nil && mm_atomic.LoadUint64(&m.afterStepLinkCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.StepLink")
	}
}

type mExecutionContextMockStop struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockStopExpectation
	expectations       []*ExecutionContextMockStopExpectation
}

// ExecutionContextMockStopExpectation specifies expectation struct of the ExecutionContext.Stop
type ExecutionContextMockStopExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockStopResults
	Counter uint64
}

// ExecutionContextMockStopResults contains results of the ExecutionContext.Stop
type ExecutionContextMockStopResults struct {
	s1 StateUpdate
}

// Expect sets up expected params for ExecutionContext.Stop
func (mmStop *mExecutionContextMockStop) Expect() *mExecutionContextMockStop {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("ExecutionContextMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &ExecutionContextMockStopExpectation{}
	}

	return mmStop
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Stop
func (mmStop *mExecutionContextMockStop) Inspect(f func()) *mExecutionContextMockStop {
	if mmStop.mock.inspectFuncStop != nil {
		mmStop.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Stop")
	}

	mmStop.mock.inspectFuncStop = f

	return mmStop
}

// Return sets up results that will be returned by ExecutionContext.Stop
func (mmStop *mExecutionContextMockStop) Return(s1 StateUpdate) *ExecutionContextMock {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("ExecutionContextMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &ExecutionContextMockStopExpectation{mock: mmStop.mock}
	}
	mmStop.defaultExpectation.results = &ExecutionContextMockStopResults{s1}
	return mmStop.mock
}

//Set uses given function f to mock the ExecutionContext.Stop method
func (mmStop *mExecutionContextMockStop) Set(f func() (s1 StateUpdate)) *ExecutionContextMock {
	if mmStop.defaultExpectation != nil {
		mmStop.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Stop method")
	}

	if len(mmStop.expectations) > 0 {
		mmStop.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Stop method")
	}

	mmStop.mock.funcStop = f
	return mmStop.mock
}

// Stop implements ExecutionContext
func (mmStop *ExecutionContextMock) Stop() (s1 StateUpdate) {
	mm_atomic.AddUint64(&mmStop.beforeStopCounter, 1)
	defer mm_atomic.AddUint64(&mmStop.afterStopCounter, 1)

	if mmStop.inspectFuncStop != nil {
		mmStop.inspectFuncStop()
	}

	if mmStop.StopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStop.StopMock.defaultExpectation.Counter, 1)

		mm_results := mmStop.StopMock.defaultExpectation.results
		if mm_results == nil {
			mmStop.t.Fatal("No results are set for the ExecutionContextMock.Stop")
		}
		return (*mm_results).s1
	}
	if mmStop.funcStop != nil {
		return mmStop.funcStop()
	}
	mmStop.t.Fatalf("Unexpected call to ExecutionContextMock.Stop.")
	return
}

// StopAfterCounter returns a count of finished ExecutionContextMock.Stop invocations
func (mmStop *ExecutionContextMock) StopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.afterStopCounter)
}

// StopBeforeCounter returns a count of ExecutionContextMock.Stop invocations
func (mmStop *ExecutionContextMock) StopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.beforeStopCounter)
}

// MinimockStopDone returns true if the count of the Stop invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockStopDone() bool {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	return true
}

// MinimockStopInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockStopInspect() {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.Stop")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Stop")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Stop")
	}
}

type mExecutionContextMockUnpublish struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockUnpublishExpectation
	expectations       []*ExecutionContextMockUnpublishExpectation

	callArgs []*ExecutionContextMockUnpublishParams
	mutex    sync.RWMutex
}

// ExecutionContextMockUnpublishExpectation specifies expectation struct of the ExecutionContext.Unpublish
type ExecutionContextMockUnpublishExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockUnpublishParams
	results *ExecutionContextMockUnpublishResults
	Counter uint64
}

// ExecutionContextMockUnpublishParams contains parameters of the ExecutionContext.Unpublish
type ExecutionContextMockUnpublishParams struct {
	key interface{}
}

// ExecutionContextMockUnpublishResults contains results of the ExecutionContext.Unpublish
type ExecutionContextMockUnpublishResults struct {
	b1 bool
}

// Expect sets up expected params for ExecutionContext.Unpublish
func (mmUnpublish *mExecutionContextMockUnpublish) Expect(key interface{}) *mExecutionContextMockUnpublish {
	if mmUnpublish.mock.funcUnpublish != nil {
		mmUnpublish.mock.t.Fatalf("ExecutionContextMock.Unpublish mock is already set by Set")
	}

	if mmUnpublish.defaultExpectation == nil {
		mmUnpublish.defaultExpectation = &ExecutionContextMockUnpublishExpectation{}
	}

	mmUnpublish.defaultExpectation.params = &ExecutionContextMockUnpublishParams{key}
	for _, e := range mmUnpublish.expectations {
		if minimock.Equal(e.params, mmUnpublish.defaultExpectation.params) {
			mmUnpublish.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnpublish.defaultExpectation.params)
		}
	}

	return mmUnpublish
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Unpublish
func (mmUnpublish *mExecutionContextMockUnpublish) Inspect(f func(key interface{})) *mExecutionContextMockUnpublish {
	if mmUnpublish.mock.inspectFuncUnpublish != nil {
		mmUnpublish.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Unpublish")
	}

	mmUnpublish.mock.inspectFuncUnpublish = f

	return mmUnpublish
}

// Return sets up results that will be returned by ExecutionContext.Unpublish
func (mmUnpublish *mExecutionContextMockUnpublish) Return(b1 bool) *ExecutionContextMock {
	if mmUnpublish.mock.funcUnpublish != nil {
		mmUnpublish.mock.t.Fatalf("ExecutionContextMock.Unpublish mock is already set by Set")
	}

	if mmUnpublish.defaultExpectation == nil {
		mmUnpublish.defaultExpectation = &ExecutionContextMockUnpublishExpectation{mock: mmUnpublish.mock}
	}
	mmUnpublish.defaultExpectation.results = &ExecutionContextMockUnpublishResults{b1}
	return mmUnpublish.mock
}

//Set uses given function f to mock the ExecutionContext.Unpublish method
func (mmUnpublish *mExecutionContextMockUnpublish) Set(f func(key interface{}) (b1 bool)) *ExecutionContextMock {
	if mmUnpublish.defaultExpectation != nil {
		mmUnpublish.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Unpublish method")
	}

	if len(mmUnpublish.expectations) > 0 {
		mmUnpublish.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Unpublish method")
	}

	mmUnpublish.mock.funcUnpublish = f
	return mmUnpublish.mock
}

// When sets expectation for the ExecutionContext.Unpublish which will trigger the result defined by the following
// Then helper
func (mmUnpublish *mExecutionContextMockUnpublish) When(key interface{}) *ExecutionContextMockUnpublishExpectation {
	if mmUnpublish.mock.funcUnpublish != nil {
		mmUnpublish.mock.t.Fatalf("ExecutionContextMock.Unpublish mock is already set by Set")
	}

	expectation := &ExecutionContextMockUnpublishExpectation{
		mock:   mmUnpublish.mock,
		params: &ExecutionContextMockUnpublishParams{key},
	}
	mmUnpublish.expectations = append(mmUnpublish.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.Unpublish return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockUnpublishExpectation) Then(b1 bool) *ExecutionContextMock {
	e.results = &ExecutionContextMockUnpublishResults{b1}
	return e.mock
}

// Unpublish implements ExecutionContext
func (mmUnpublish *ExecutionContextMock) Unpublish(key interface{}) (b1 bool) {
	mm_atomic.AddUint64(&mmUnpublish.beforeUnpublishCounter, 1)
	defer mm_atomic.AddUint64(&mmUnpublish.afterUnpublishCounter, 1)

	if mmUnpublish.inspectFuncUnpublish != nil {
		mmUnpublish.inspectFuncUnpublish(key)
	}

	mm_params := &ExecutionContextMockUnpublishParams{key}

	// Record call args
	mmUnpublish.UnpublishMock.mutex.Lock()
	mmUnpublish.UnpublishMock.callArgs = append(mmUnpublish.UnpublishMock.callArgs, mm_params)
	mmUnpublish.UnpublishMock.mutex.Unlock()

	for _, e := range mmUnpublish.UnpublishMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmUnpublish.UnpublishMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnpublish.UnpublishMock.defaultExpectation.Counter, 1)
		mm_want := mmUnpublish.UnpublishMock.defaultExpectation.params
		mm_got := ExecutionContextMockUnpublishParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnpublish.t.Errorf("ExecutionContextMock.Unpublish got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnpublish.UnpublishMock.defaultExpectation.results
		if mm_results == nil {
			mmUnpublish.t.Fatal("No results are set for the ExecutionContextMock.Unpublish")
		}
		return (*mm_results).b1
	}
	if mmUnpublish.funcUnpublish != nil {
		return mmUnpublish.funcUnpublish(key)
	}
	mmUnpublish.t.Fatalf("Unexpected call to ExecutionContextMock.Unpublish. %v", key)
	return
}

// UnpublishAfterCounter returns a count of finished ExecutionContextMock.Unpublish invocations
func (mmUnpublish *ExecutionContextMock) UnpublishAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpublish.afterUnpublishCounter)
}

// UnpublishBeforeCounter returns a count of ExecutionContextMock.Unpublish invocations
func (mmUnpublish *ExecutionContextMock) UnpublishBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpublish.beforeUnpublishCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.Unpublish.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnpublish *mExecutionContextMockUnpublish) Calls() []*ExecutionContextMockUnpublishParams {
	mmUnpublish.mutex.RLock()

	argCopy := make([]*ExecutionContextMockUnpublishParams, len(mmUnpublish.callArgs))
	copy(argCopy, mmUnpublish.callArgs)

	mmUnpublish.mutex.RUnlock()

	return argCopy
}

// MinimockUnpublishDone returns true if the count of the Unpublish invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockUnpublishDone() bool {
	for _, e := range m.UnpublishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpublishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpublishCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpublish != nil && mm_atomic.LoadUint64(&m.afterUnpublishCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnpublishInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockUnpublishInspect() {
	for _, e := range m.UnpublishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.Unpublish with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpublishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpublishCounter) < 1 {
		if m.UnpublishMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.Unpublish")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.Unpublish with params: %#v", *m.UnpublishMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpublish != nil && mm_atomic.LoadUint64(&m.afterUnpublishCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Unpublish")
	}
}

type mExecutionContextMockUnpublishAll struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockUnpublishAllExpectation
	expectations       []*ExecutionContextMockUnpublishAllExpectation
}

// ExecutionContextMockUnpublishAllExpectation specifies expectation struct of the ExecutionContext.UnpublishAll
type ExecutionContextMockUnpublishAllExpectation struct {
	mock *ExecutionContextMock

	Counter uint64
}

// Expect sets up expected params for ExecutionContext.UnpublishAll
func (mmUnpublishAll *mExecutionContextMockUnpublishAll) Expect() *mExecutionContextMockUnpublishAll {
	if mmUnpublishAll.mock.funcUnpublishAll != nil {
		mmUnpublishAll.mock.t.Fatalf("ExecutionContextMock.UnpublishAll mock is already set by Set")
	}

	if mmUnpublishAll.defaultExpectation == nil {
		mmUnpublishAll.defaultExpectation = &ExecutionContextMockUnpublishAllExpectation{}
	}

	return mmUnpublishAll
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.UnpublishAll
func (mmUnpublishAll *mExecutionContextMockUnpublishAll) Inspect(f func()) *mExecutionContextMockUnpublishAll {
	if mmUnpublishAll.mock.inspectFuncUnpublishAll != nil {
		mmUnpublishAll.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.UnpublishAll")
	}

	mmUnpublishAll.mock.inspectFuncUnpublishAll = f

	return mmUnpublishAll
}

// Return sets up results that will be returned by ExecutionContext.UnpublishAll
func (mmUnpublishAll *mExecutionContextMockUnpublishAll) Return() *ExecutionContextMock {
	if mmUnpublishAll.mock.funcUnpublishAll != nil {
		mmUnpublishAll.mock.t.Fatalf("ExecutionContextMock.UnpublishAll mock is already set by Set")
	}

	if mmUnpublishAll.defaultExpectation == nil {
		mmUnpublishAll.defaultExpectation = &ExecutionContextMockUnpublishAllExpectation{mock: mmUnpublishAll.mock}
	}

	return mmUnpublishAll.mock
}

//Set uses given function f to mock the ExecutionContext.UnpublishAll method
func (mmUnpublishAll *mExecutionContextMockUnpublishAll) Set(f func()) *ExecutionContextMock {
	if mmUnpublishAll.defaultExpectation != nil {
		mmUnpublishAll.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.UnpublishAll method")
	}

	if len(mmUnpublishAll.expectations) > 0 {
		mmUnpublishAll.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.UnpublishAll method")
	}

	mmUnpublishAll.mock.funcUnpublishAll = f
	return mmUnpublishAll.mock
}

// UnpublishAll implements ExecutionContext
func (mmUnpublishAll *ExecutionContextMock) UnpublishAll() {
	mm_atomic.AddUint64(&mmUnpublishAll.beforeUnpublishAllCounter, 1)
	defer mm_atomic.AddUint64(&mmUnpublishAll.afterUnpublishAllCounter, 1)

	if mmUnpublishAll.inspectFuncUnpublishAll != nil {
		mmUnpublishAll.inspectFuncUnpublishAll()
	}

	if mmUnpublishAll.UnpublishAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnpublishAll.UnpublishAllMock.defaultExpectation.Counter, 1)

		return

	}
	if mmUnpublishAll.funcUnpublishAll != nil {
		mmUnpublishAll.funcUnpublishAll()
		return
	}
	mmUnpublishAll.t.Fatalf("Unexpected call to ExecutionContextMock.UnpublishAll.")

}

// UnpublishAllAfterCounter returns a count of finished ExecutionContextMock.UnpublishAll invocations
func (mmUnpublishAll *ExecutionContextMock) UnpublishAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpublishAll.afterUnpublishAllCounter)
}

// UnpublishAllBeforeCounter returns a count of ExecutionContextMock.UnpublishAll invocations
func (mmUnpublishAll *ExecutionContextMock) UnpublishAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpublishAll.beforeUnpublishAllCounter)
}

// MinimockUnpublishAllDone returns true if the count of the UnpublishAll invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockUnpublishAllDone() bool {
	for _, e := range m.UnpublishAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpublishAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpublishAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpublishAll != nil && mm_atomic.LoadUint64(&m.afterUnpublishAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnpublishAllInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockUnpublishAllInspect() {
	for _, e := range m.UnpublishAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.UnpublishAll")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpublishAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpublishAllCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.UnpublishAll")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpublishAll != nil && mm_atomic.LoadUint64(&m.afterUnpublishAllCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.UnpublishAll")
	}
}

type mExecutionContextMockUnpublishGlobalAlias struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockUnpublishGlobalAliasExpectation
	expectations       []*ExecutionContextMockUnpublishGlobalAliasExpectation

	callArgs []*ExecutionContextMockUnpublishGlobalAliasParams
	mutex    sync.RWMutex
}

// ExecutionContextMockUnpublishGlobalAliasExpectation specifies expectation struct of the ExecutionContext.UnpublishGlobalAlias
type ExecutionContextMockUnpublishGlobalAliasExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockUnpublishGlobalAliasParams
	results *ExecutionContextMockUnpublishGlobalAliasResults
	Counter uint64
}

// ExecutionContextMockUnpublishGlobalAliasParams contains parameters of the ExecutionContext.UnpublishGlobalAlias
type ExecutionContextMockUnpublishGlobalAliasParams struct {
	key interface{}
}

// ExecutionContextMockUnpublishGlobalAliasResults contains results of the ExecutionContext.UnpublishGlobalAlias
type ExecutionContextMockUnpublishGlobalAliasResults struct {
	b1 bool
}

// Expect sets up expected params for ExecutionContext.UnpublishGlobalAlias
func (mmUnpublishGlobalAlias *mExecutionContextMockUnpublishGlobalAlias) Expect(key interface{}) *mExecutionContextMockUnpublishGlobalAlias {
	if mmUnpublishGlobalAlias.mock.funcUnpublishGlobalAlias != nil {
		mmUnpublishGlobalAlias.mock.t.Fatalf("ExecutionContextMock.UnpublishGlobalAlias mock is already set by Set")
	}

	if mmUnpublishGlobalAlias.defaultExpectation == nil {
		mmUnpublishGlobalAlias.defaultExpectation = &ExecutionContextMockUnpublishGlobalAliasExpectation{}
	}

	mmUnpublishGlobalAlias.defaultExpectation.params = &ExecutionContextMockUnpublishGlobalAliasParams{key}
	for _, e := range mmUnpublishGlobalAlias.expectations {
		if minimock.Equal(e.params, mmUnpublishGlobalAlias.defaultExpectation.params) {
			mmUnpublishGlobalAlias.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnpublishGlobalAlias.defaultExpectation.params)
		}
	}

	return mmUnpublishGlobalAlias
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.UnpublishGlobalAlias
func (mmUnpublishGlobalAlias *mExecutionContextMockUnpublishGlobalAlias) Inspect(f func(key interface{})) *mExecutionContextMockUnpublishGlobalAlias {
	if mmUnpublishGlobalAlias.mock.inspectFuncUnpublishGlobalAlias != nil {
		mmUnpublishGlobalAlias.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.UnpublishGlobalAlias")
	}

	mmUnpublishGlobalAlias.mock.inspectFuncUnpublishGlobalAlias = f

	return mmUnpublishGlobalAlias
}

// Return sets up results that will be returned by ExecutionContext.UnpublishGlobalAlias
func (mmUnpublishGlobalAlias *mExecutionContextMockUnpublishGlobalAlias) Return(b1 bool) *ExecutionContextMock {
	if mmUnpublishGlobalAlias.mock.funcUnpublishGlobalAlias != nil {
		mmUnpublishGlobalAlias.mock.t.Fatalf("ExecutionContextMock.UnpublishGlobalAlias mock is already set by Set")
	}

	if mmUnpublishGlobalAlias.defaultExpectation == nil {
		mmUnpublishGlobalAlias.defaultExpectation = &ExecutionContextMockUnpublishGlobalAliasExpectation{mock: mmUnpublishGlobalAlias.mock}
	}
	mmUnpublishGlobalAlias.defaultExpectation.results = &ExecutionContextMockUnpublishGlobalAliasResults{b1}
	return mmUnpublishGlobalAlias.mock
}

//Set uses given function f to mock the ExecutionContext.UnpublishGlobalAlias method
func (mmUnpublishGlobalAlias *mExecutionContextMockUnpublishGlobalAlias) Set(f func(key interface{}) (b1 bool)) *ExecutionContextMock {
	if mmUnpublishGlobalAlias.defaultExpectation != nil {
		mmUnpublishGlobalAlias.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.UnpublishGlobalAlias method")
	}

	if len(mmUnpublishGlobalAlias.expectations) > 0 {
		mmUnpublishGlobalAlias.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.UnpublishGlobalAlias method")
	}

	mmUnpublishGlobalAlias.mock.funcUnpublishGlobalAlias = f
	return mmUnpublishGlobalAlias.mock
}

// When sets expectation for the ExecutionContext.UnpublishGlobalAlias which will trigger the result defined by the following
// Then helper
func (mmUnpublishGlobalAlias *mExecutionContextMockUnpublishGlobalAlias) When(key interface{}) *ExecutionContextMockUnpublishGlobalAliasExpectation {
	if mmUnpublishGlobalAlias.mock.funcUnpublishGlobalAlias != nil {
		mmUnpublishGlobalAlias.mock.t.Fatalf("ExecutionContextMock.UnpublishGlobalAlias mock is already set by Set")
	}

	expectation := &ExecutionContextMockUnpublishGlobalAliasExpectation{
		mock:   mmUnpublishGlobalAlias.mock,
		params: &ExecutionContextMockUnpublishGlobalAliasParams{key},
	}
	mmUnpublishGlobalAlias.expectations = append(mmUnpublishGlobalAlias.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.UnpublishGlobalAlias return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockUnpublishGlobalAliasExpectation) Then(b1 bool) *ExecutionContextMock {
	e.results = &ExecutionContextMockUnpublishGlobalAliasResults{b1}
	return e.mock
}

// UnpublishGlobalAlias implements ExecutionContext
func (mmUnpublishGlobalAlias *ExecutionContextMock) UnpublishGlobalAlias(key interface{}) (b1 bool) {
	mm_atomic.AddUint64(&mmUnpublishGlobalAlias.beforeUnpublishGlobalAliasCounter, 1)
	defer mm_atomic.AddUint64(&mmUnpublishGlobalAlias.afterUnpublishGlobalAliasCounter, 1)

	if mmUnpublishGlobalAlias.inspectFuncUnpublishGlobalAlias != nil {
		mmUnpublishGlobalAlias.inspectFuncUnpublishGlobalAlias(key)
	}

	mm_params := &ExecutionContextMockUnpublishGlobalAliasParams{key}

	// Record call args
	mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.mutex.Lock()
	mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.callArgs = append(mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.callArgs, mm_params)
	mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.mutex.Unlock()

	for _, e := range mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.defaultExpectation.Counter, 1)
		mm_want := mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.defaultExpectation.params
		mm_got := ExecutionContextMockUnpublishGlobalAliasParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnpublishGlobalAlias.t.Errorf("ExecutionContextMock.UnpublishGlobalAlias got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.defaultExpectation.results
		if mm_results == nil {
			mmUnpublishGlobalAlias.t.Fatal("No results are set for the ExecutionContextMock.UnpublishGlobalAlias")
		}
		return (*mm_results).b1
	}
	if mmUnpublishGlobalAlias.funcUnpublishGlobalAlias != nil {
		return mmUnpublishGlobalAlias.funcUnpublishGlobalAlias(key)
	}
	mmUnpublishGlobalAlias.t.Fatalf("Unexpected call to ExecutionContextMock.UnpublishGlobalAlias. %v", key)
	return
}

// UnpublishGlobalAliasAfterCounter returns a count of finished ExecutionContextMock.UnpublishGlobalAlias invocations
func (mmUnpublishGlobalAlias *ExecutionContextMock) UnpublishGlobalAliasAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpublishGlobalAlias.afterUnpublishGlobalAliasCounter)
}

// UnpublishGlobalAliasBeforeCounter returns a count of ExecutionContextMock.UnpublishGlobalAlias invocations
func (mmUnpublishGlobalAlias *ExecutionContextMock) UnpublishGlobalAliasBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpublishGlobalAlias.beforeUnpublishGlobalAliasCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.UnpublishGlobalAlias.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnpublishGlobalAlias *mExecutionContextMockUnpublishGlobalAlias) Calls() []*ExecutionContextMockUnpublishGlobalAliasParams {
	mmUnpublishGlobalAlias.mutex.RLock()

	argCopy := make([]*ExecutionContextMockUnpublishGlobalAliasParams, len(mmUnpublishGlobalAlias.callArgs))
	copy(argCopy, mmUnpublishGlobalAlias.callArgs)

	mmUnpublishGlobalAlias.mutex.RUnlock()

	return argCopy
}

// MinimockUnpublishGlobalAliasDone returns true if the count of the UnpublishGlobalAlias invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockUnpublishGlobalAliasDone() bool {
	for _, e := range m.UnpublishGlobalAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpublishGlobalAliasMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpublishGlobalAliasCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpublishGlobalAlias != nil && mm_atomic.LoadUint64(&m.afterUnpublishGlobalAliasCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnpublishGlobalAliasInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockUnpublishGlobalAliasInspect() {
	for _, e := range m.UnpublishGlobalAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.UnpublishGlobalAlias with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpublishGlobalAliasMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpublishGlobalAliasCounter) < 1 {
		if m.UnpublishGlobalAliasMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.UnpublishGlobalAlias")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.UnpublishGlobalAlias with params: %#v", *m.UnpublishGlobalAliasMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpublishGlobalAlias != nil && mm_atomic.LoadUint64(&m.afterUnpublishGlobalAliasCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.UnpublishGlobalAlias")
	}
}

type mExecutionContextMockUnshare struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockUnshareExpectation
	expectations       []*ExecutionContextMockUnshareExpectation

	callArgs []*ExecutionContextMockUnshareParams
	mutex    sync.RWMutex
}

// ExecutionContextMockUnshareExpectation specifies expectation struct of the ExecutionContext.Unshare
type ExecutionContextMockUnshareExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockUnshareParams
	results *ExecutionContextMockUnshareResults
	Counter uint64
}

// ExecutionContextMockUnshareParams contains parameters of the ExecutionContext.Unshare
type ExecutionContextMockUnshareParams struct {
	s1 SharedDataLink
}

// ExecutionContextMockUnshareResults contains results of the ExecutionContext.Unshare
type ExecutionContextMockUnshareResults struct {
	b1 bool
}

// Expect sets up expected params for ExecutionContext.Unshare
func (mmUnshare *mExecutionContextMockUnshare) Expect(s1 SharedDataLink) *mExecutionContextMockUnshare {
	if mmUnshare.mock.funcUnshare != nil {
		mmUnshare.mock.t.Fatalf("ExecutionContextMock.Unshare mock is already set by Set")
	}

	if mmUnshare.defaultExpectation == nil {
		mmUnshare.defaultExpectation = &ExecutionContextMockUnshareExpectation{}
	}

	mmUnshare.defaultExpectation.params = &ExecutionContextMockUnshareParams{s1}
	for _, e := range mmUnshare.expectations {
		if minimock.Equal(e.params, mmUnshare.defaultExpectation.params) {
			mmUnshare.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnshare.defaultExpectation.params)
		}
	}

	return mmUnshare
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Unshare
func (mmUnshare *mExecutionContextMockUnshare) Inspect(f func(s1 SharedDataLink)) *mExecutionContextMockUnshare {
	if mmUnshare.mock.inspectFuncUnshare != nil {
		mmUnshare.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Unshare")
	}

	mmUnshare.mock.inspectFuncUnshare = f

	return mmUnshare
}

// Return sets up results that will be returned by ExecutionContext.Unshare
func (mmUnshare *mExecutionContextMockUnshare) Return(b1 bool) *ExecutionContextMock {
	if mmUnshare.mock.funcUnshare != nil {
		mmUnshare.mock.t.Fatalf("ExecutionContextMock.Unshare mock is already set by Set")
	}

	if mmUnshare.defaultExpectation == nil {
		mmUnshare.defaultExpectation = &ExecutionContextMockUnshareExpectation{mock: mmUnshare.mock}
	}
	mmUnshare.defaultExpectation.results = &ExecutionContextMockUnshareResults{b1}
	return mmUnshare.mock
}

//Set uses given function f to mock the ExecutionContext.Unshare method
func (mmUnshare *mExecutionContextMockUnshare) Set(f func(s1 SharedDataLink) (b1 bool)) *ExecutionContextMock {
	if mmUnshare.defaultExpectation != nil {
		mmUnshare.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Unshare method")
	}

	if len(mmUnshare.expectations) > 0 {
		mmUnshare.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Unshare method")
	}

	mmUnshare.mock.funcUnshare = f
	return mmUnshare.mock
}

// When sets expectation for the ExecutionContext.Unshare which will trigger the result defined by the following
// Then helper
func (mmUnshare *mExecutionContextMockUnshare) When(s1 SharedDataLink) *ExecutionContextMockUnshareExpectation {
	if mmUnshare.mock.funcUnshare != nil {
		mmUnshare.mock.t.Fatalf("ExecutionContextMock.Unshare mock is already set by Set")
	}

	expectation := &ExecutionContextMockUnshareExpectation{
		mock:   mmUnshare.mock,
		params: &ExecutionContextMockUnshareParams{s1},
	}
	mmUnshare.expectations = append(mmUnshare.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.Unshare return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockUnshareExpectation) Then(b1 bool) *ExecutionContextMock {
	e.results = &ExecutionContextMockUnshareResults{b1}
	return e.mock
}

// Unshare implements ExecutionContext
func (mmUnshare *ExecutionContextMock) Unshare(s1 SharedDataLink) (b1 bool) {
	mm_atomic.AddUint64(&mmUnshare.beforeUnshareCounter, 1)
	defer mm_atomic.AddUint64(&mmUnshare.afterUnshareCounter, 1)

	if mmUnshare.inspectFuncUnshare != nil {
		mmUnshare.inspectFuncUnshare(s1)
	}

	mm_params := &ExecutionContextMockUnshareParams{s1}

	// Record call args
	mmUnshare.UnshareMock.mutex.Lock()
	mmUnshare.UnshareMock.callArgs = append(mmUnshare.UnshareMock.callArgs, mm_params)
	mmUnshare.UnshareMock.mutex.Unlock()

	for _, e := range mmUnshare.UnshareMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmUnshare.UnshareMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnshare.UnshareMock.defaultExpectation.Counter, 1)
		mm_want := mmUnshare.UnshareMock.defaultExpectation.params
		mm_got := ExecutionContextMockUnshareParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnshare.t.Errorf("ExecutionContextMock.Unshare got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnshare.UnshareMock.defaultExpectation.results
		if mm_results == nil {
			mmUnshare.t.Fatal("No results are set for the ExecutionContextMock.Unshare")
		}
		return (*mm_results).b1
	}
	if mmUnshare.funcUnshare != nil {
		return mmUnshare.funcUnshare(s1)
	}
	mmUnshare.t.Fatalf("Unexpected call to ExecutionContextMock.Unshare. %v", s1)
	return
}

// UnshareAfterCounter returns a count of finished ExecutionContextMock.Unshare invocations
func (mmUnshare *ExecutionContextMock) UnshareAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnshare.afterUnshareCounter)
}

// UnshareBeforeCounter returns a count of ExecutionContextMock.Unshare invocations
func (mmUnshare *ExecutionContextMock) UnshareBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnshare.beforeUnshareCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.Unshare.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnshare *mExecutionContextMockUnshare) Calls() []*ExecutionContextMockUnshareParams {
	mmUnshare.mutex.RLock()

	argCopy := make([]*ExecutionContextMockUnshareParams, len(mmUnshare.callArgs))
	copy(argCopy, mmUnshare.callArgs)

	mmUnshare.mutex.RUnlock()

	return argCopy
}

// MinimockUnshareDone returns true if the count of the Unshare invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockUnshareDone() bool {
	for _, e := range m.UnshareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnshareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnshareCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnshare != nil && mm_atomic.LoadUint64(&m.afterUnshareCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnshareInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockUnshareInspect() {
	for _, e := range m.UnshareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.Unshare with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnshareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnshareCounter) < 1 {
		if m.UnshareMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.Unshare")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.Unshare with params: %#v", *m.UnshareMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnshare != nil && mm_atomic.LoadUint64(&m.afterUnshareCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Unshare")
	}
}

type mExecutionContextMockUpdateDefaultStepLogger struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockUpdateDefaultStepLoggerExpectation
	expectations       []*ExecutionContextMockUpdateDefaultStepLoggerExpectation

	callArgs []*ExecutionContextMockUpdateDefaultStepLoggerParams
	mutex    sync.RWMutex
}

// ExecutionContextMockUpdateDefaultStepLoggerExpectation specifies expectation struct of the ExecutionContext.UpdateDefaultStepLogger
type ExecutionContextMockUpdateDefaultStepLoggerExpectation struct {
	mock   *ExecutionContextMock
	params *ExecutionContextMockUpdateDefaultStepLoggerParams

	Counter uint64
}

// ExecutionContextMockUpdateDefaultStepLoggerParams contains parameters of the ExecutionContext.UpdateDefaultStepLogger
type ExecutionContextMockUpdateDefaultStepLoggerParams struct {
	s1 StepLoggerUpdateFunc
}

// Expect sets up expected params for ExecutionContext.UpdateDefaultStepLogger
func (mmUpdateDefaultStepLogger *mExecutionContextMockUpdateDefaultStepLogger) Expect(s1 StepLoggerUpdateFunc) *mExecutionContextMockUpdateDefaultStepLogger {
	if mmUpdateDefaultStepLogger.mock.funcUpdateDefaultStepLogger != nil {
		mmUpdateDefaultStepLogger.mock.t.Fatalf("ExecutionContextMock.UpdateDefaultStepLogger mock is already set by Set")
	}

	if mmUpdateDefaultStepLogger.defaultExpectation == nil {
		mmUpdateDefaultStepLogger.defaultExpectation = &ExecutionContextMockUpdateDefaultStepLoggerExpectation{}
	}

	mmUpdateDefaultStepLogger.defaultExpectation.params = &ExecutionContextMockUpdateDefaultStepLoggerParams{s1}
	for _, e := range mmUpdateDefaultStepLogger.expectations {
		if minimock.Equal(e.params, mmUpdateDefaultStepLogger.defaultExpectation.params) {
			mmUpdateDefaultStepLogger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateDefaultStepLogger.defaultExpectation.params)
		}
	}

	return mmUpdateDefaultStepLogger
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.UpdateDefaultStepLogger
func (mmUpdateDefaultStepLogger *mExecutionContextMockUpdateDefaultStepLogger) Inspect(f func(s1 StepLoggerUpdateFunc)) *mExecutionContextMockUpdateDefaultStepLogger {
	if mmUpdateDefaultStepLogger.mock.inspectFuncUpdateDefaultStepLogger != nil {
		mmUpdateDefaultStepLogger.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.UpdateDefaultStepLogger")
	}

	mmUpdateDefaultStepLogger.mock.inspectFuncUpdateDefaultStepLogger = f

	return mmUpdateDefaultStepLogger
}

// Return sets up results that will be returned by ExecutionContext.UpdateDefaultStepLogger
func (mmUpdateDefaultStepLogger *mExecutionContextMockUpdateDefaultStepLogger) Return() *ExecutionContextMock {
	if mmUpdateDefaultStepLogger.mock.funcUpdateDefaultStepLogger != nil {
		mmUpdateDefaultStepLogger.mock.t.Fatalf("ExecutionContextMock.UpdateDefaultStepLogger mock is already set by Set")
	}

	if mmUpdateDefaultStepLogger.defaultExpectation == nil {
		mmUpdateDefaultStepLogger.defaultExpectation = &ExecutionContextMockUpdateDefaultStepLoggerExpectation{mock: mmUpdateDefaultStepLogger.mock}
	}

	return mmUpdateDefaultStepLogger.mock
}

//Set uses given function f to mock the ExecutionContext.UpdateDefaultStepLogger method
func (mmUpdateDefaultStepLogger *mExecutionContextMockUpdateDefaultStepLogger) Set(f func(s1 StepLoggerUpdateFunc)) *ExecutionContextMock {
	if mmUpdateDefaultStepLogger.defaultExpectation != nil {
		mmUpdateDefaultStepLogger.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.UpdateDefaultStepLogger method")
	}

	if len(mmUpdateDefaultStepLogger.expectations) > 0 {
		mmUpdateDefaultStepLogger.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.UpdateDefaultStepLogger method")
	}

	mmUpdateDefaultStepLogger.mock.funcUpdateDefaultStepLogger = f
	return mmUpdateDefaultStepLogger.mock
}

// UpdateDefaultStepLogger implements ExecutionContext
func (mmUpdateDefaultStepLogger *ExecutionContextMock) UpdateDefaultStepLogger(s1 StepLoggerUpdateFunc) {
	mm_atomic.AddUint64(&mmUpdateDefaultStepLogger.beforeUpdateDefaultStepLoggerCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateDefaultStepLogger.afterUpdateDefaultStepLoggerCounter, 1)

	if mmUpdateDefaultStepLogger.inspectFuncUpdateDefaultStepLogger != nil {
		mmUpdateDefaultStepLogger.inspectFuncUpdateDefaultStepLogger(s1)
	}

	mm_params := &ExecutionContextMockUpdateDefaultStepLoggerParams{s1}

	// Record call args
	mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.mutex.Lock()
	mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.callArgs = append(mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.callArgs, mm_params)
	mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.mutex.Unlock()

	for _, e := range mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.defaultExpectation.params
		mm_got := ExecutionContextMockUpdateDefaultStepLoggerParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateDefaultStepLogger.t.Errorf("ExecutionContextMock.UpdateDefaultStepLogger got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmUpdateDefaultStepLogger.funcUpdateDefaultStepLogger != nil {
		mmUpdateDefaultStepLogger.funcUpdateDefaultStepLogger(s1)
		return
	}
	mmUpdateDefaultStepLogger.t.Fatalf("Unexpected call to ExecutionContextMock.UpdateDefaultStepLogger. %v", s1)

}

// UpdateDefaultStepLoggerAfterCounter returns a count of finished ExecutionContextMock.UpdateDefaultStepLogger invocations
func (mmUpdateDefaultStepLogger *ExecutionContextMock) UpdateDefaultStepLoggerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateDefaultStepLogger.afterUpdateDefaultStepLoggerCounter)
}

// UpdateDefaultStepLoggerBeforeCounter returns a count of ExecutionContextMock.UpdateDefaultStepLogger invocations
func (mmUpdateDefaultStepLogger *ExecutionContextMock) UpdateDefaultStepLoggerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateDefaultStepLogger.beforeUpdateDefaultStepLoggerCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.UpdateDefaultStepLogger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateDefaultStepLogger *mExecutionContextMockUpdateDefaultStepLogger) Calls() []*ExecutionContextMockUpdateDefaultStepLoggerParams {
	mmUpdateDefaultStepLogger.mutex.RLock()

	argCopy := make([]*ExecutionContextMockUpdateDefaultStepLoggerParams, len(mmUpdateDefaultStepLogger.callArgs))
	copy(argCopy, mmUpdateDefaultStepLogger.callArgs)

	mmUpdateDefaultStepLogger.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDefaultStepLoggerDone returns true if the count of the UpdateDefaultStepLogger invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockUpdateDefaultStepLoggerDone() bool {
	for _, e := range m.UpdateDefaultStepLoggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateDefaultStepLoggerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateDefaultStepLoggerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateDefaultStepLogger != nil && mm_atomic.LoadUint64(&m.afterUpdateDefaultStepLoggerCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateDefaultStepLoggerInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockUpdateDefaultStepLoggerInspect() {
	for _, e := range m.UpdateDefaultStepLoggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.UpdateDefaultStepLogger with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateDefaultStepLoggerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateDefaultStepLoggerCounter) < 1 {
		if m.UpdateDefaultStepLoggerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.UpdateDefaultStepLogger")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.UpdateDefaultStepLogger with params: %#v", *m.UpdateDefaultStepLoggerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateDefaultStepLogger != nil && mm_atomic.LoadUint64(&m.afterUpdateDefaultStepLoggerCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.UpdateDefaultStepLogger")
	}
}

type mExecutionContextMockUseShared struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockUseSharedExpectation
	expectations       []*ExecutionContextMockUseSharedExpectation

	callArgs []*ExecutionContextMockUseSharedParams
	mutex    sync.RWMutex
}

// ExecutionContextMockUseSharedExpectation specifies expectation struct of the ExecutionContext.UseShared
type ExecutionContextMockUseSharedExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockUseSharedParams
	results *ExecutionContextMockUseSharedResults
	Counter uint64
}

// ExecutionContextMockUseSharedParams contains parameters of the ExecutionContext.UseShared
type ExecutionContextMockUseSharedParams struct {
	s1 SharedDataAccessor
}

// ExecutionContextMockUseSharedResults contains results of the ExecutionContext.UseShared
type ExecutionContextMockUseSharedResults struct {
	s2 SharedAccessReport
}

// Expect sets up expected params for ExecutionContext.UseShared
func (mmUseShared *mExecutionContextMockUseShared) Expect(s1 SharedDataAccessor) *mExecutionContextMockUseShared {
	if mmUseShared.mock.funcUseShared != nil {
		mmUseShared.mock.t.Fatalf("ExecutionContextMock.UseShared mock is already set by Set")
	}

	if mmUseShared.defaultExpectation == nil {
		mmUseShared.defaultExpectation = &ExecutionContextMockUseSharedExpectation{}
	}

	mmUseShared.defaultExpectation.params = &ExecutionContextMockUseSharedParams{s1}
	for _, e := range mmUseShared.expectations {
		if minimock.Equal(e.params, mmUseShared.defaultExpectation.params) {
			mmUseShared.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUseShared.defaultExpectation.params)
		}
	}

	return mmUseShared
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.UseShared
func (mmUseShared *mExecutionContextMockUseShared) Inspect(f func(s1 SharedDataAccessor)) *mExecutionContextMockUseShared {
	if mmUseShared.mock.inspectFuncUseShared != nil {
		mmUseShared.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.UseShared")
	}

	mmUseShared.mock.inspectFuncUseShared = f

	return mmUseShared
}

// Return sets up results that will be returned by ExecutionContext.UseShared
func (mmUseShared *mExecutionContextMockUseShared) Return(s2 SharedAccessReport) *ExecutionContextMock {
	if mmUseShared.mock.funcUseShared != nil {
		mmUseShared.mock.t.Fatalf("ExecutionContextMock.UseShared mock is already set by Set")
	}

	if mmUseShared.defaultExpectation == nil {
		mmUseShared.defaultExpectation = &ExecutionContextMockUseSharedExpectation{mock: mmUseShared.mock}
	}
	mmUseShared.defaultExpectation.results = &ExecutionContextMockUseSharedResults{s2}
	return mmUseShared.mock
}

//Set uses given function f to mock the ExecutionContext.UseShared method
func (mmUseShared *mExecutionContextMockUseShared) Set(f func(s1 SharedDataAccessor) (s2 SharedAccessReport)) *ExecutionContextMock {
	if mmUseShared.defaultExpectation != nil {
		mmUseShared.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.UseShared method")
	}

	if len(mmUseShared.expectations) > 0 {
		mmUseShared.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.UseShared method")
	}

	mmUseShared.mock.funcUseShared = f
	return mmUseShared.mock
}

// When sets expectation for the ExecutionContext.UseShared which will trigger the result defined by the following
// Then helper
func (mmUseShared *mExecutionContextMockUseShared) When(s1 SharedDataAccessor) *ExecutionContextMockUseSharedExpectation {
	if mmUseShared.mock.funcUseShared != nil {
		mmUseShared.mock.t.Fatalf("ExecutionContextMock.UseShared mock is already set by Set")
	}

	expectation := &ExecutionContextMockUseSharedExpectation{
		mock:   mmUseShared.mock,
		params: &ExecutionContextMockUseSharedParams{s1},
	}
	mmUseShared.expectations = append(mmUseShared.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.UseShared return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockUseSharedExpectation) Then(s2 SharedAccessReport) *ExecutionContextMock {
	e.results = &ExecutionContextMockUseSharedResults{s2}
	return e.mock
}

// UseShared implements ExecutionContext
func (mmUseShared *ExecutionContextMock) UseShared(s1 SharedDataAccessor) (s2 SharedAccessReport) {
	mm_atomic.AddUint64(&mmUseShared.beforeUseSharedCounter, 1)
	defer mm_atomic.AddUint64(&mmUseShared.afterUseSharedCounter, 1)

	if mmUseShared.inspectFuncUseShared != nil {
		mmUseShared.inspectFuncUseShared(s1)
	}

	mm_params := &ExecutionContextMockUseSharedParams{s1}

	// Record call args
	mmUseShared.UseSharedMock.mutex.Lock()
	mmUseShared.UseSharedMock.callArgs = append(mmUseShared.UseSharedMock.callArgs, mm_params)
	mmUseShared.UseSharedMock.mutex.Unlock()

	for _, e := range mmUseShared.UseSharedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2
		}
	}

	if mmUseShared.UseSharedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUseShared.UseSharedMock.defaultExpectation.Counter, 1)
		mm_want := mmUseShared.UseSharedMock.defaultExpectation.params
		mm_got := ExecutionContextMockUseSharedParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUseShared.t.Errorf("ExecutionContextMock.UseShared got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUseShared.UseSharedMock.defaultExpectation.results
		if mm_results == nil {
			mmUseShared.t.Fatal("No results are set for the ExecutionContextMock.UseShared")
		}
		return (*mm_results).s2
	}
	if mmUseShared.funcUseShared != nil {
		return mmUseShared.funcUseShared(s1)
	}
	mmUseShared.t.Fatalf("Unexpected call to ExecutionContextMock.UseShared. %v", s1)
	return
}

// UseSharedAfterCounter returns a count of finished ExecutionContextMock.UseShared invocations
func (mmUseShared *ExecutionContextMock) UseSharedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUseShared.afterUseSharedCounter)
}

// UseSharedBeforeCounter returns a count of ExecutionContextMock.UseShared invocations
func (mmUseShared *ExecutionContextMock) UseSharedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUseShared.beforeUseSharedCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.UseShared.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUseShared *mExecutionContextMockUseShared) Calls() []*ExecutionContextMockUseSharedParams {
	mmUseShared.mutex.RLock()

	argCopy := make([]*ExecutionContextMockUseSharedParams, len(mmUseShared.callArgs))
	copy(argCopy, mmUseShared.callArgs)

	mmUseShared.mutex.RUnlock()

	return argCopy
}

// MinimockUseSharedDone returns true if the count of the UseShared invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockUseSharedDone() bool {
	for _, e := range m.UseSharedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UseSharedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUseSharedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUseShared != nil && mm_atomic.LoadUint64(&m.afterUseSharedCounter) < 1 {
		return false
	}
	return true
}

// MinimockUseSharedInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockUseSharedInspect() {
	for _, e := range m.UseSharedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.UseShared with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UseSharedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUseSharedCounter) < 1 {
		if m.UseSharedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.UseShared")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.UseShared with params: %#v", *m.UseSharedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUseShared != nil && mm_atomic.LoadUint64(&m.afterUseSharedCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.UseShared")
	}
}

type mExecutionContextMockWaitAny struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockWaitAnyExpectation
	expectations       []*ExecutionContextMockWaitAnyExpectation
}

// ExecutionContextMockWaitAnyExpectation specifies expectation struct of the ExecutionContext.WaitAny
type ExecutionContextMockWaitAnyExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockWaitAnyResults
	Counter uint64
}

// ExecutionContextMockWaitAnyResults contains results of the ExecutionContext.WaitAny
type ExecutionContextMockWaitAnyResults struct {
	c1 ConditionalBuilder
}

// Expect sets up expected params for ExecutionContext.WaitAny
func (mmWaitAny *mExecutionContextMockWaitAny) Expect() *mExecutionContextMockWaitAny {
	if mmWaitAny.mock.funcWaitAny != nil {
		mmWaitAny.mock.t.Fatalf("ExecutionContextMock.WaitAny mock is already set by Set")
	}

	if mmWaitAny.defaultExpectation == nil {
		mmWaitAny.defaultExpectation = &ExecutionContextMockWaitAnyExpectation{}
	}

	return mmWaitAny
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.WaitAny
func (mmWaitAny *mExecutionContextMockWaitAny) Inspect(f func()) *mExecutionContextMockWaitAny {
	if mmWaitAny.mock.inspectFuncWaitAny != nil {
		mmWaitAny.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.WaitAny")
	}

	mmWaitAny.mock.inspectFuncWaitAny = f

	return mmWaitAny
}

// Return sets up results that will be returned by ExecutionContext.WaitAny
func (mmWaitAny *mExecutionContextMockWaitAny) Return(c1 ConditionalBuilder) *ExecutionContextMock {
	if mmWaitAny.mock.funcWaitAny != nil {
		mmWaitAny.mock.t.Fatalf("ExecutionContextMock.WaitAny mock is already set by Set")
	}

	if mmWaitAny.defaultExpectation == nil {
		mmWaitAny.defaultExpectation = &ExecutionContextMockWaitAnyExpectation{mock: mmWaitAny.mock}
	}
	mmWaitAny.defaultExpectation.results = &ExecutionContextMockWaitAnyResults{c1}
	return mmWaitAny.mock
}

//Set uses given function f to mock the ExecutionContext.WaitAny method
func (mmWaitAny *mExecutionContextMockWaitAny) Set(f func() (c1 ConditionalBuilder)) *ExecutionContextMock {
	if mmWaitAny.defaultExpectation != nil {
		mmWaitAny.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.WaitAny method")
	}

	if len(mmWaitAny.expectations) > 0 {
		mmWaitAny.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.WaitAny method")
	}

	mmWaitAny.mock.funcWaitAny = f
	return mmWaitAny.mock
}

// WaitAny implements ExecutionContext
func (mmWaitAny *ExecutionContextMock) WaitAny() (c1 ConditionalBuilder) {
	mm_atomic.AddUint64(&mmWaitAny.beforeWaitAnyCounter, 1)
	defer mm_atomic.AddUint64(&mmWaitAny.afterWaitAnyCounter, 1)

	if mmWaitAny.inspectFuncWaitAny != nil {
		mmWaitAny.inspectFuncWaitAny()
	}

	if mmWaitAny.WaitAnyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWaitAny.WaitAnyMock.defaultExpectation.Counter, 1)

		mm_results := mmWaitAny.WaitAnyMock.defaultExpectation.results
		if mm_results == nil {
			mmWaitAny.t.Fatal("No results are set for the ExecutionContextMock.WaitAny")
		}
		return (*mm_results).c1
	}
	if mmWaitAny.funcWaitAny != nil {
		return mmWaitAny.funcWaitAny()
	}
	mmWaitAny.t.Fatalf("Unexpected call to ExecutionContextMock.WaitAny.")
	return
}

// WaitAnyAfterCounter returns a count of finished ExecutionContextMock.WaitAny invocations
func (mmWaitAny *ExecutionContextMock) WaitAnyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitAny.afterWaitAnyCounter)
}

// WaitAnyBeforeCounter returns a count of ExecutionContextMock.WaitAny invocations
func (mmWaitAny *ExecutionContextMock) WaitAnyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitAny.beforeWaitAnyCounter)
}

// MinimockWaitAnyDone returns true if the count of the WaitAny invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockWaitAnyDone() bool {
	for _, e := range m.WaitAnyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WaitAnyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWaitAnyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitAny != nil && mm_atomic.LoadUint64(&m.afterWaitAnyCounter) < 1 {
		return false
	}
	return true
}

// MinimockWaitAnyInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockWaitAnyInspect() {
	for _, e := range m.WaitAnyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.WaitAny")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WaitAnyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWaitAnyCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.WaitAny")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitAny != nil && mm_atomic.LoadUint64(&m.afterWaitAnyCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.WaitAny")
	}
}

type mExecutionContextMockWaitAnyUntil struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockWaitAnyUntilExpectation
	expectations       []*ExecutionContextMockWaitAnyUntilExpectation

	callArgs []*ExecutionContextMockWaitAnyUntilParams
	mutex    sync.RWMutex
}

// ExecutionContextMockWaitAnyUntilExpectation specifies expectation struct of the ExecutionContext.WaitAnyUntil
type ExecutionContextMockWaitAnyUntilExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockWaitAnyUntilParams
	results *ExecutionContextMockWaitAnyUntilResults
	Counter uint64
}

// ExecutionContextMockWaitAnyUntilParams contains parameters of the ExecutionContext.WaitAnyUntil
type ExecutionContextMockWaitAnyUntilParams struct {
	t1 time.Time
}

// ExecutionContextMockWaitAnyUntilResults contains results of the ExecutionContext.WaitAnyUntil
type ExecutionContextMockWaitAnyUntilResults struct {
	s1 StateConditionalBuilder
}

// Expect sets up expected params for ExecutionContext.WaitAnyUntil
func (mmWaitAnyUntil *mExecutionContextMockWaitAnyUntil) Expect(t1 time.Time) *mExecutionContextMockWaitAnyUntil {
	if mmWaitAnyUntil.mock.funcWaitAnyUntil != nil {
		mmWaitAnyUntil.mock.t.Fatalf("ExecutionContextMock.WaitAnyUntil mock is already set by Set")
	}

	if mmWaitAnyUntil.defaultExpectation == nil {
		mmWaitAnyUntil.defaultExpectation = &ExecutionContextMockWaitAnyUntilExpectation{}
	}

	mmWaitAnyUntil.defaultExpectation.params = &ExecutionContextMockWaitAnyUntilParams{t1}
	for _, e := range mmWaitAnyUntil.expectations {
		if minimock.Equal(e.params, mmWaitAnyUntil.defaultExpectation.params) {
			mmWaitAnyUntil.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWaitAnyUntil.defaultExpectation.params)
		}
	}

	return mmWaitAnyUntil
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.WaitAnyUntil
func (mmWaitAnyUntil *mExecutionContextMockWaitAnyUntil) Inspect(f func(t1 time.Time)) *mExecutionContextMockWaitAnyUntil {
	if mmWaitAnyUntil.mock.inspectFuncWaitAnyUntil != nil {
		mmWaitAnyUntil.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.WaitAnyUntil")
	}

	mmWaitAnyUntil.mock.inspectFuncWaitAnyUntil = f

	return mmWaitAnyUntil
}

// Return sets up results that will be returned by ExecutionContext.WaitAnyUntil
func (mmWaitAnyUntil *mExecutionContextMockWaitAnyUntil) Return(s1 StateConditionalBuilder) *ExecutionContextMock {
	if mmWaitAnyUntil.mock.funcWaitAnyUntil != nil {
		mmWaitAnyUntil.mock.t.Fatalf("ExecutionContextMock.WaitAnyUntil mock is already set by Set")
	}

	if mmWaitAnyUntil.defaultExpectation == nil {
		mmWaitAnyUntil.defaultExpectation = &ExecutionContextMockWaitAnyUntilExpectation{mock: mmWaitAnyUntil.mock}
	}
	mmWaitAnyUntil.defaultExpectation.results = &ExecutionContextMockWaitAnyUntilResults{s1}
	return mmWaitAnyUntil.mock
}

//Set uses given function f to mock the ExecutionContext.WaitAnyUntil method
func (mmWaitAnyUntil *mExecutionContextMockWaitAnyUntil) Set(f func(t1 time.Time) (s1 StateConditionalBuilder)) *ExecutionContextMock {
	if mmWaitAnyUntil.defaultExpectation != nil {
		mmWaitAnyUntil.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.WaitAnyUntil method")
	}

	if len(mmWaitAnyUntil.expectations) > 0 {
		mmWaitAnyUntil.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.WaitAnyUntil method")
	}

	mmWaitAnyUntil.mock.funcWaitAnyUntil = f
	return mmWaitAnyUntil.mock
}

// When sets expectation for the ExecutionContext.WaitAnyUntil which will trigger the result defined by the following
// Then helper
func (mmWaitAnyUntil *mExecutionContextMockWaitAnyUntil) When(t1 time.Time) *ExecutionContextMockWaitAnyUntilExpectation {
	if mmWaitAnyUntil.mock.funcWaitAnyUntil != nil {
		mmWaitAnyUntil.mock.t.Fatalf("ExecutionContextMock.WaitAnyUntil mock is already set by Set")
	}

	expectation := &ExecutionContextMockWaitAnyUntilExpectation{
		mock:   mmWaitAnyUntil.mock,
		params: &ExecutionContextMockWaitAnyUntilParams{t1},
	}
	mmWaitAnyUntil.expectations = append(mmWaitAnyUntil.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.WaitAnyUntil return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockWaitAnyUntilExpectation) Then(s1 StateConditionalBuilder) *ExecutionContextMock {
	e.results = &ExecutionContextMockWaitAnyUntilResults{s1}
	return e.mock
}

// WaitAnyUntil implements ExecutionContext
func (mmWaitAnyUntil *ExecutionContextMock) WaitAnyUntil(t1 time.Time) (s1 StateConditionalBuilder) {
	mm_atomic.AddUint64(&mmWaitAnyUntil.beforeWaitAnyUntilCounter, 1)
	defer mm_atomic.AddUint64(&mmWaitAnyUntil.afterWaitAnyUntilCounter, 1)

	if mmWaitAnyUntil.inspectFuncWaitAnyUntil != nil {
		mmWaitAnyUntil.inspectFuncWaitAnyUntil(t1)
	}

	mm_params := &ExecutionContextMockWaitAnyUntilParams{t1}

	// Record call args
	mmWaitAnyUntil.WaitAnyUntilMock.mutex.Lock()
	mmWaitAnyUntil.WaitAnyUntilMock.callArgs = append(mmWaitAnyUntil.WaitAnyUntilMock.callArgs, mm_params)
	mmWaitAnyUntil.WaitAnyUntilMock.mutex.Unlock()

	for _, e := range mmWaitAnyUntil.WaitAnyUntilMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmWaitAnyUntil.WaitAnyUntilMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWaitAnyUntil.WaitAnyUntilMock.defaultExpectation.Counter, 1)
		mm_want := mmWaitAnyUntil.WaitAnyUntilMock.defaultExpectation.params
		mm_got := ExecutionContextMockWaitAnyUntilParams{t1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWaitAnyUntil.t.Errorf("ExecutionContextMock.WaitAnyUntil got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWaitAnyUntil.WaitAnyUntilMock.defaultExpectation.results
		if mm_results == nil {
			mmWaitAnyUntil.t.Fatal("No results are set for the ExecutionContextMock.WaitAnyUntil")
		}
		return (*mm_results).s1
	}
	if mmWaitAnyUntil.funcWaitAnyUntil != nil {
		return mmWaitAnyUntil.funcWaitAnyUntil(t1)
	}
	mmWaitAnyUntil.t.Fatalf("Unexpected call to ExecutionContextMock.WaitAnyUntil. %v", t1)
	return
}

// WaitAnyUntilAfterCounter returns a count of finished ExecutionContextMock.WaitAnyUntil invocations
func (mmWaitAnyUntil *ExecutionContextMock) WaitAnyUntilAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitAnyUntil.afterWaitAnyUntilCounter)
}

// WaitAnyUntilBeforeCounter returns a count of ExecutionContextMock.WaitAnyUntil invocations
func (mmWaitAnyUntil *ExecutionContextMock) WaitAnyUntilBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitAnyUntil.beforeWaitAnyUntilCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.WaitAnyUntil.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWaitAnyUntil *mExecutionContextMockWaitAnyUntil) Calls() []*ExecutionContextMockWaitAnyUntilParams {
	mmWaitAnyUntil.mutex.RLock()

	argCopy := make([]*ExecutionContextMockWaitAnyUntilParams, len(mmWaitAnyUntil.callArgs))
	copy(argCopy, mmWaitAnyUntil.callArgs)

	mmWaitAnyUntil.mutex.RUnlock()

	return argCopy
}

// MinimockWaitAnyUntilDone returns true if the count of the WaitAnyUntil invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockWaitAnyUntilDone() bool {
	for _, e := range m.WaitAnyUntilMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WaitAnyUntilMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWaitAnyUntilCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitAnyUntil != nil && mm_atomic.LoadUint64(&m.afterWaitAnyUntilCounter) < 1 {
		return false
	}
	return true
}

// MinimockWaitAnyUntilInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockWaitAnyUntilInspect() {
	for _, e := range m.WaitAnyUntilMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.WaitAnyUntil with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WaitAnyUntilMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWaitAnyUntilCounter) < 1 {
		if m.WaitAnyUntilMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.WaitAnyUntil")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.WaitAnyUntil with params: %#v", *m.WaitAnyUntilMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitAnyUntil != nil && mm_atomic.LoadUint64(&m.afterWaitAnyUntilCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.WaitAnyUntil")
	}
}

type mExecutionContextMockWaitShared struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockWaitSharedExpectation
	expectations       []*ExecutionContextMockWaitSharedExpectation

	callArgs []*ExecutionContextMockWaitSharedParams
	mutex    sync.RWMutex
}

// ExecutionContextMockWaitSharedExpectation specifies expectation struct of the ExecutionContext.WaitShared
type ExecutionContextMockWaitSharedExpectation struct {
	mock    *ExecutionContextMock
	params  *ExecutionContextMockWaitSharedParams
	results *ExecutionContextMockWaitSharedResults
	Counter uint64
}

// ExecutionContextMockWaitSharedParams contains parameters of the ExecutionContext.WaitShared
type ExecutionContextMockWaitSharedParams struct {
	s1 SharedDataLink
}

// ExecutionContextMockWaitSharedResults contains results of the ExecutionContext.WaitShared
type ExecutionContextMockWaitSharedResults struct {
	s2 StateConditionalBuilder
}

// Expect sets up expected params for ExecutionContext.WaitShared
func (mmWaitShared *mExecutionContextMockWaitShared) Expect(s1 SharedDataLink) *mExecutionContextMockWaitShared {
	if mmWaitShared.mock.funcWaitShared != nil {
		mmWaitShared.mock.t.Fatalf("ExecutionContextMock.WaitShared mock is already set by Set")
	}

	if mmWaitShared.defaultExpectation == nil {
		mmWaitShared.defaultExpectation = &ExecutionContextMockWaitSharedExpectation{}
	}

	mmWaitShared.defaultExpectation.params = &ExecutionContextMockWaitSharedParams{s1}
	for _, e := range mmWaitShared.expectations {
		if minimock.Equal(e.params, mmWaitShared.defaultExpectation.params) {
			mmWaitShared.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWaitShared.defaultExpectation.params)
		}
	}

	return mmWaitShared
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.WaitShared
func (mmWaitShared *mExecutionContextMockWaitShared) Inspect(f func(s1 SharedDataLink)) *mExecutionContextMockWaitShared {
	if mmWaitShared.mock.inspectFuncWaitShared != nil {
		mmWaitShared.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.WaitShared")
	}

	mmWaitShared.mock.inspectFuncWaitShared = f

	return mmWaitShared
}

// Return sets up results that will be returned by ExecutionContext.WaitShared
func (mmWaitShared *mExecutionContextMockWaitShared) Return(s2 StateConditionalBuilder) *ExecutionContextMock {
	if mmWaitShared.mock.funcWaitShared != nil {
		mmWaitShared.mock.t.Fatalf("ExecutionContextMock.WaitShared mock is already set by Set")
	}

	if mmWaitShared.defaultExpectation == nil {
		mmWaitShared.defaultExpectation = &ExecutionContextMockWaitSharedExpectation{mock: mmWaitShared.mock}
	}
	mmWaitShared.defaultExpectation.results = &ExecutionContextMockWaitSharedResults{s2}
	return mmWaitShared.mock
}

//Set uses given function f to mock the ExecutionContext.WaitShared method
func (mmWaitShared *mExecutionContextMockWaitShared) Set(f func(s1 SharedDataLink) (s2 StateConditionalBuilder)) *ExecutionContextMock {
	if mmWaitShared.defaultExpectation != nil {
		mmWaitShared.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.WaitShared method")
	}

	if len(mmWaitShared.expectations) > 0 {
		mmWaitShared.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.WaitShared method")
	}

	mmWaitShared.mock.funcWaitShared = f
	return mmWaitShared.mock
}

// When sets expectation for the ExecutionContext.WaitShared which will trigger the result defined by the following
// Then helper
func (mmWaitShared *mExecutionContextMockWaitShared) When(s1 SharedDataLink) *ExecutionContextMockWaitSharedExpectation {
	if mmWaitShared.mock.funcWaitShared != nil {
		mmWaitShared.mock.t.Fatalf("ExecutionContextMock.WaitShared mock is already set by Set")
	}

	expectation := &ExecutionContextMockWaitSharedExpectation{
		mock:   mmWaitShared.mock,
		params: &ExecutionContextMockWaitSharedParams{s1},
	}
	mmWaitShared.expectations = append(mmWaitShared.expectations, expectation)
	return expectation
}

// Then sets up ExecutionContext.WaitShared return parameters for the expectation previously defined by the When method
func (e *ExecutionContextMockWaitSharedExpectation) Then(s2 StateConditionalBuilder) *ExecutionContextMock {
	e.results = &ExecutionContextMockWaitSharedResults{s2}
	return e.mock
}

// WaitShared implements ExecutionContext
func (mmWaitShared *ExecutionContextMock) WaitShared(s1 SharedDataLink) (s2 StateConditionalBuilder) {
	mm_atomic.AddUint64(&mmWaitShared.beforeWaitSharedCounter, 1)
	defer mm_atomic.AddUint64(&mmWaitShared.afterWaitSharedCounter, 1)

	if mmWaitShared.inspectFuncWaitShared != nil {
		mmWaitShared.inspectFuncWaitShared(s1)
	}

	mm_params := &ExecutionContextMockWaitSharedParams{s1}

	// Record call args
	mmWaitShared.WaitSharedMock.mutex.Lock()
	mmWaitShared.WaitSharedMock.callArgs = append(mmWaitShared.WaitSharedMock.callArgs, mm_params)
	mmWaitShared.WaitSharedMock.mutex.Unlock()

	for _, e := range mmWaitShared.WaitSharedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2
		}
	}

	if mmWaitShared.WaitSharedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWaitShared.WaitSharedMock.defaultExpectation.Counter, 1)
		mm_want := mmWaitShared.WaitSharedMock.defaultExpectation.params
		mm_got := ExecutionContextMockWaitSharedParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWaitShared.t.Errorf("ExecutionContextMock.WaitShared got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWaitShared.WaitSharedMock.defaultExpectation.results
		if mm_results == nil {
			mmWaitShared.t.Fatal("No results are set for the ExecutionContextMock.WaitShared")
		}
		return (*mm_results).s2
	}
	if mmWaitShared.funcWaitShared != nil {
		return mmWaitShared.funcWaitShared(s1)
	}
	mmWaitShared.t.Fatalf("Unexpected call to ExecutionContextMock.WaitShared. %v", s1)
	return
}

// WaitSharedAfterCounter returns a count of finished ExecutionContextMock.WaitShared invocations
func (mmWaitShared *ExecutionContextMock) WaitSharedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitShared.afterWaitSharedCounter)
}

// WaitSharedBeforeCounter returns a count of ExecutionContextMock.WaitShared invocations
func (mmWaitShared *ExecutionContextMock) WaitSharedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitShared.beforeWaitSharedCounter)
}

// Calls returns a list of arguments used in each call to ExecutionContextMock.WaitShared.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWaitShared *mExecutionContextMockWaitShared) Calls() []*ExecutionContextMockWaitSharedParams {
	mmWaitShared.mutex.RLock()

	argCopy := make([]*ExecutionContextMockWaitSharedParams, len(mmWaitShared.callArgs))
	copy(argCopy, mmWaitShared.callArgs)

	mmWaitShared.mutex.RUnlock()

	return argCopy
}

// MinimockWaitSharedDone returns true if the count of the WaitShared invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockWaitSharedDone() bool {
	for _, e := range m.WaitSharedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WaitSharedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWaitSharedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitShared != nil && mm_atomic.LoadUint64(&m.afterWaitSharedCounter) < 1 {
		return false
	}
	return true
}

// MinimockWaitSharedInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockWaitSharedInspect() {
	for _, e := range m.WaitSharedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionContextMock.WaitShared with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WaitSharedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWaitSharedCounter) < 1 {
		if m.WaitSharedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionContextMock.WaitShared")
		} else {
			m.t.Errorf("Expected call to ExecutionContextMock.WaitShared with params: %#v", *m.WaitSharedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitShared != nil && mm_atomic.LoadUint64(&m.afterWaitSharedCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.WaitShared")
	}
}

type mExecutionContextMockYield struct {
	mock               *ExecutionContextMock
	defaultExpectation *ExecutionContextMockYieldExpectation
	expectations       []*ExecutionContextMockYieldExpectation
}

// ExecutionContextMockYieldExpectation specifies expectation struct of the ExecutionContext.Yield
type ExecutionContextMockYieldExpectation struct {
	mock *ExecutionContextMock

	results *ExecutionContextMockYieldResults
	Counter uint64
}

// ExecutionContextMockYieldResults contains results of the ExecutionContext.Yield
type ExecutionContextMockYieldResults struct {
	c1 ConditionalBuilder
}

// Expect sets up expected params for ExecutionContext.Yield
func (mmYield *mExecutionContextMockYield) Expect() *mExecutionContextMockYield {
	if mmYield.mock.funcYield != nil {
		mmYield.mock.t.Fatalf("ExecutionContextMock.Yield mock is already set by Set")
	}

	if mmYield.defaultExpectation == nil {
		mmYield.defaultExpectation = &ExecutionContextMockYieldExpectation{}
	}

	return mmYield
}

// Inspect accepts an inspector function that has same arguments as the ExecutionContext.Yield
func (mmYield *mExecutionContextMockYield) Inspect(f func()) *mExecutionContextMockYield {
	if mmYield.mock.inspectFuncYield != nil {
		mmYield.mock.t.Fatalf("Inspect function is already set for ExecutionContextMock.Yield")
	}

	mmYield.mock.inspectFuncYield = f

	return mmYield
}

// Return sets up results that will be returned by ExecutionContext.Yield
func (mmYield *mExecutionContextMockYield) Return(c1 ConditionalBuilder) *ExecutionContextMock {
	if mmYield.mock.funcYield != nil {
		mmYield.mock.t.Fatalf("ExecutionContextMock.Yield mock is already set by Set")
	}

	if mmYield.defaultExpectation == nil {
		mmYield.defaultExpectation = &ExecutionContextMockYieldExpectation{mock: mmYield.mock}
	}
	mmYield.defaultExpectation.results = &ExecutionContextMockYieldResults{c1}
	return mmYield.mock
}

//Set uses given function f to mock the ExecutionContext.Yield method
func (mmYield *mExecutionContextMockYield) Set(f func() (c1 ConditionalBuilder)) *ExecutionContextMock {
	if mmYield.defaultExpectation != nil {
		mmYield.mock.t.Fatalf("Default expectation is already set for the ExecutionContext.Yield method")
	}

	if len(mmYield.expectations) > 0 {
		mmYield.mock.t.Fatalf("Some expectations are already set for the ExecutionContext.Yield method")
	}

	mmYield.mock.funcYield = f
	return mmYield.mock
}

// Yield implements ExecutionContext
func (mmYield *ExecutionContextMock) Yield() (c1 ConditionalBuilder) {
	mm_atomic.AddUint64(&mmYield.beforeYieldCounter, 1)
	defer mm_atomic.AddUint64(&mmYield.afterYieldCounter, 1)

	if mmYield.inspectFuncYield != nil {
		mmYield.inspectFuncYield()
	}

	if mmYield.YieldMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmYield.YieldMock.defaultExpectation.Counter, 1)

		mm_results := mmYield.YieldMock.defaultExpectation.results
		if mm_results == nil {
			mmYield.t.Fatal("No results are set for the ExecutionContextMock.Yield")
		}
		return (*mm_results).c1
	}
	if mmYield.funcYield != nil {
		return mmYield.funcYield()
	}
	mmYield.t.Fatalf("Unexpected call to ExecutionContextMock.Yield.")
	return
}

// YieldAfterCounter returns a count of finished ExecutionContextMock.Yield invocations
func (mmYield *ExecutionContextMock) YieldAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmYield.afterYieldCounter)
}

// YieldBeforeCounter returns a count of ExecutionContextMock.Yield invocations
func (mmYield *ExecutionContextMock) YieldBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmYield.beforeYieldCounter)
}

// MinimockYieldDone returns true if the count of the Yield invocations corresponds
// the number of defined expectations
func (m *ExecutionContextMock) MinimockYieldDone() bool {
	for _, e := range m.YieldMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.YieldMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterYieldCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcYield != nil && mm_atomic.LoadUint64(&m.afterYieldCounter) < 1 {
		return false
	}
	return true
}

// MinimockYieldInspect logs each unmet expectation
func (m *ExecutionContextMock) MinimockYieldInspect() {
	for _, e := range m.YieldMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionContextMock.Yield")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.YieldMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterYieldCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Yield")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcYield != nil && mm_atomic.LoadUint64(&m.afterYieldCounter) < 1 {
		m.t.Error("Expected call to ExecutionContextMock.Yield")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ExecutionContextMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAcquireInspect()

		m.MinimockAcquireAndReleaseInspect()

		m.MinimockAcquireExtInspect()

		m.MinimockAcquireForThisStepInspect()

		m.MinimockAcquireForThisStepAndReleaseInspect()

		m.MinimockApplyAdjustmentInspect()

		m.MinimockCallBargeInInspect()

		m.MinimockCallBargeInWithParamInspect()

		m.MinimockCallSubroutineInspect()

		m.MinimockCheckInspect()

		m.MinimockErrorInspect()

		m.MinimockGetContextInspect()

		m.MinimockGetPendingCallCountInspect()

		m.MinimockGetPublishedInspect()

		m.MinimockGetPublishedGlobalAliasInspect()

		m.MinimockGetPublishedGlobalAliasAndBargeInInspect()

		m.MinimockGetPublishedLinkInspect()

		m.MinimockGetTerminationResultInspect()

		m.MinimockInitChildInspect()

		m.MinimockInitChildExtInspect()

		m.MinimockInitChildWithPostInitInspect()

		m.MinimockInitiateLongRunInspect()

		m.MinimockJumpInspect()

		m.MinimockJumpExtInspect()

		m.MinimockLogInspect()

		m.MinimockLogAsyncInspect()

		m.MinimockNewBargeInInspect()

		m.MinimockNewBargeInThisStepOnlyInspect()

		m.MinimockNewBargeInWithParamInspect()

		m.MinimockNewChildInspect()

		m.MinimockNewChildExtInspect()

		m.MinimockOverrideDynamicBoostInspect()

		m.MinimockParentLinkInspect()

		m.MinimockPollInspect()

		m.MinimockPublishInspect()

		m.MinimockPublishGlobalAliasInspect()

		m.MinimockPublishGlobalAliasAndBargeInInspect()

		m.MinimockPublishReplacementInspect()

		m.MinimockReleaseInspect()

		m.MinimockReleaseAllInspect()

		m.MinimockRepeatInspect()

		m.MinimockReplaceInspect()

		m.MinimockReplaceExtInspect()

		m.MinimockReplaceWithInspect()

		m.MinimockRestoreStepInspect()

		m.MinimockSetDefaultErrorHandlerInspect()

		m.MinimockSetDefaultFlagsInspect()

		m.MinimockSetDefaultMigrationInspect()

		m.MinimockSetFinalizerInspect()

		m.MinimockSetLogTracingInspect()

		m.MinimockSetTerminationResultInspect()

		m.MinimockShareInspect()

		m.MinimockSleepInspect()

		m.MinimockSlotLinkInspect()

		m.MinimockStepLinkInspect()

		m.MinimockStopInspect()

		m.MinimockUnpublishInspect()

		m.MinimockUnpublishAllInspect()

		m.MinimockUnpublishGlobalAliasInspect()

		m.MinimockUnshareInspect()

		m.MinimockUpdateDefaultStepLoggerInspect()

		m.MinimockUseSharedInspect()

		m.MinimockWaitAnyInspect()

		m.MinimockWaitAnyUntilInspect()

		m.MinimockWaitSharedInspect()

		m.MinimockYieldInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ExecutionContextMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ExecutionContextMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAcquireDone() &&
		m.MinimockAcquireAndReleaseDone() &&
		m.MinimockAcquireExtDone() &&
		m.MinimockAcquireForThisStepDone() &&
		m.MinimockAcquireForThisStepAndReleaseDone() &&
		m.MinimockApplyAdjustmentDone() &&
		m.MinimockCallBargeInDone() &&
		m.MinimockCallBargeInWithParamDone() &&
		m.MinimockCallSubroutineDone() &&
		m.MinimockCheckDone() &&
		m.MinimockErrorDone() &&
		m.MinimockGetContextDone() &&
		m.MinimockGetPendingCallCountDone() &&
		m.MinimockGetPublishedDone() &&
		m.MinimockGetPublishedGlobalAliasDone() &&
		m.MinimockGetPublishedGlobalAliasAndBargeInDone() &&
		m.MinimockGetPublishedLinkDone() &&
		m.MinimockGetTerminationResultDone() &&
		m.MinimockInitChildDone() &&
		m.MinimockInitChildExtDone() &&
		m.MinimockInitChildWithPostInitDone() &&
		m.MinimockInitiateLongRunDone() &&
		m.MinimockJumpDone() &&
		m.MinimockJumpExtDone() &&
		m.MinimockLogDone() &&
		m.MinimockLogAsyncDone() &&
		m.MinimockNewBargeInDone() &&
		m.MinimockNewBargeInThisStepOnlyDone() &&
		m.MinimockNewBargeInWithParamDone() &&
		m.MinimockNewChildDone() &&
		m.MinimockNewChildExtDone() &&
		m.MinimockOverrideDynamicBoostDone() &&
		m.MinimockParentLinkDone() &&
		m.MinimockPollDone() &&
		m.MinimockPublishDone() &&
		m.MinimockPublishGlobalAliasDone() &&
		m.MinimockPublishGlobalAliasAndBargeInDone() &&
		m.MinimockPublishReplacementDone() &&
		m.MinimockReleaseDone() &&
		m.MinimockReleaseAllDone() &&
		m.MinimockRepeatDone() &&
		m.MinimockReplaceDone() &&
		m.MinimockReplaceExtDone() &&
		m.MinimockReplaceWithDone() &&
		m.MinimockRestoreStepDone() &&
		m.MinimockSetDefaultErrorHandlerDone() &&
		m.MinimockSetDefaultFlagsDone() &&
		m.MinimockSetDefaultMigrationDone() &&
		m.MinimockSetFinalizerDone() &&
		m.MinimockSetLogTracingDone() &&
		m.MinimockSetTerminationResultDone() &&
		m.MinimockShareDone() &&
		m.MinimockSleepDone() &&
		m.MinimockSlotLinkDone() &&
		m.MinimockStepLinkDone() &&
		m.MinimockStopDone() &&
		m.MinimockUnpublishDone() &&
		m.MinimockUnpublishAllDone() &&
		m.MinimockUnpublishGlobalAliasDone() &&
		m.MinimockUnshareDone() &&
		m.MinimockUpdateDefaultStepLoggerDone() &&
		m.MinimockUseSharedDone() &&
		m.MinimockWaitAnyDone() &&
		m.MinimockWaitAnyUntilDone() &&
		m.MinimockWaitSharedDone() &&
		m.MinimockYieldDone()
}
