package smachine

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// AsyncCallRequesterMock implements AsyncCallRequester
type AsyncCallRequesterMock struct {
	t minimock.Tester

	funcDelayedStart          func() (c1 CallConditionalBuilder)
	inspectFuncDelayedStart   func()
	afterDelayedStartCounter  uint64
	beforeDelayedStartCounter uint64
	DelayedStartMock          mAsyncCallRequesterMockDelayedStart

	funcStart          func()
	inspectFuncStart   func()
	afterStartCounter  uint64
	beforeStartCounter uint64
	StartMock          mAsyncCallRequesterMockStart

	funcWithCancel          func(cp1 *context.CancelFunc) (a1 AsyncCallRequester)
	inspectFuncWithCancel   func(cp1 *context.CancelFunc)
	afterWithCancelCounter  uint64
	beforeWithCancelCounter uint64
	WithCancelMock          mAsyncCallRequesterMockWithCancel

	funcWithFlags          func(flags AsyncCallFlags) (a1 AsyncCallRequester)
	inspectFuncWithFlags   func(flags AsyncCallFlags)
	afterWithFlagsCounter  uint64
	beforeWithFlagsCounter uint64
	WithFlagsMock          mAsyncCallRequesterMockWithFlags

	funcWithLog          func(isLogging bool) (a1 AsyncCallRequester)
	inspectFuncWithLog   func(isLogging bool)
	afterWithLogCounter  uint64
	beforeWithLogCounter uint64
	WithLogMock          mAsyncCallRequesterMockWithLog

	funcWithNested          func(c1 CreateFactoryFunc) (a1 AsyncCallRequester)
	inspectFuncWithNested   func(c1 CreateFactoryFunc)
	afterWithNestedCounter  uint64
	beforeWithNestedCounter uint64
	WithNestedMock          mAsyncCallRequesterMockWithNested

	funcWithoutAutoWakeUp          func() (a1 AsyncCallRequester)
	inspectFuncWithoutAutoWakeUp   func()
	afterWithoutAutoWakeUpCounter  uint64
	beforeWithoutAutoWakeUpCounter uint64
	WithoutAutoWakeUpMock          mAsyncCallRequesterMockWithoutAutoWakeUp
}

// NewAsyncCallRequesterMock returns a mock for AsyncCallRequester
func NewAsyncCallRequesterMock(t minimock.Tester) *AsyncCallRequesterMock {
	m := &AsyncCallRequesterMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DelayedStartMock = mAsyncCallRequesterMockDelayedStart{mock: m}

	m.StartMock = mAsyncCallRequesterMockStart{mock: m}

	m.WithCancelMock = mAsyncCallRequesterMockWithCancel{mock: m}
	m.WithCancelMock.callArgs = []*AsyncCallRequesterMockWithCancelParams{}

	m.WithFlagsMock = mAsyncCallRequesterMockWithFlags{mock: m}
	m.WithFlagsMock.callArgs = []*AsyncCallRequesterMockWithFlagsParams{}

	m.WithLogMock = mAsyncCallRequesterMockWithLog{mock: m}
	m.WithLogMock.callArgs = []*AsyncCallRequesterMockWithLogParams{}

	m.WithNestedMock = mAsyncCallRequesterMockWithNested{mock: m}
	m.WithNestedMock.callArgs = []*AsyncCallRequesterMockWithNestedParams{}

	m.WithoutAutoWakeUpMock = mAsyncCallRequesterMockWithoutAutoWakeUp{mock: m}

	return m
}

type mAsyncCallRequesterMockDelayedStart struct {
	mock               *AsyncCallRequesterMock
	defaultExpectation *AsyncCallRequesterMockDelayedStartExpectation
	expectations       []*AsyncCallRequesterMockDelayedStartExpectation
}

// AsyncCallRequesterMockDelayedStartExpectation specifies expectation struct of the AsyncCallRequester.DelayedStart
type AsyncCallRequesterMockDelayedStartExpectation struct {
	mock *AsyncCallRequesterMock

	results *AsyncCallRequesterMockDelayedStartResults
	Counter uint64
}

// AsyncCallRequesterMockDelayedStartResults contains results of the AsyncCallRequester.DelayedStart
type AsyncCallRequesterMockDelayedStartResults struct {
	c1 CallConditionalBuilder
}

// Expect sets up expected params for AsyncCallRequester.DelayedStart
func (mmDelayedStart *mAsyncCallRequesterMockDelayedStart) Expect() *mAsyncCallRequesterMockDelayedStart {
	if mmDelayedStart.mock.funcDelayedStart != nil {
		mmDelayedStart.mock.t.Fatalf("AsyncCallRequesterMock.DelayedStart mock is already set by Set")
	}

	if mmDelayedStart.defaultExpectation == nil {
		mmDelayedStart.defaultExpectation = &AsyncCallRequesterMockDelayedStartExpectation{}
	}

	return mmDelayedStart
}

// Inspect accepts an inspector function that has same arguments as the AsyncCallRequester.DelayedStart
func (mmDelayedStart *mAsyncCallRequesterMockDelayedStart) Inspect(f func()) *mAsyncCallRequesterMockDelayedStart {
	if mmDelayedStart.mock.inspectFuncDelayedStart != nil {
		mmDelayedStart.mock.t.Fatalf("Inspect function is already set for AsyncCallRequesterMock.DelayedStart")
	}

	mmDelayedStart.mock.inspectFuncDelayedStart = f

	return mmDelayedStart
}

// Return sets up results that will be returned by AsyncCallRequester.DelayedStart
func (mmDelayedStart *mAsyncCallRequesterMockDelayedStart) Return(c1 CallConditionalBuilder) *AsyncCallRequesterMock {
	if mmDelayedStart.mock.funcDelayedStart != nil {
		mmDelayedStart.mock.t.Fatalf("AsyncCallRequesterMock.DelayedStart mock is already set by Set")
	}

	if mmDelayedStart.defaultExpectation == nil {
		mmDelayedStart.defaultExpectation = &AsyncCallRequesterMockDelayedStartExpectation{mock: mmDelayedStart.mock}
	}
	mmDelayedStart.defaultExpectation.results = &AsyncCallRequesterMockDelayedStartResults{c1}
	return mmDelayedStart.mock
}

//Set uses given function f to mock the AsyncCallRequester.DelayedStart method
func (mmDelayedStart *mAsyncCallRequesterMockDelayedStart) Set(f func() (c1 CallConditionalBuilder)) *AsyncCallRequesterMock {
	if mmDelayedStart.defaultExpectation != nil {
		mmDelayedStart.mock.t.Fatalf("Default expectation is already set for the AsyncCallRequester.DelayedStart method")
	}

	if len(mmDelayedStart.expectations) > 0 {
		mmDelayedStart.mock.t.Fatalf("Some expectations are already set for the AsyncCallRequester.DelayedStart method")
	}

	mmDelayedStart.mock.funcDelayedStart = f
	return mmDelayedStart.mock
}

// DelayedStart implements AsyncCallRequester
func (mmDelayedStart *AsyncCallRequesterMock) DelayedStart() (c1 CallConditionalBuilder) {
	mm_atomic.AddUint64(&mmDelayedStart.beforeDelayedStartCounter, 1)
	defer mm_atomic.AddUint64(&mmDelayedStart.afterDelayedStartCounter, 1)

	if mmDelayedStart.inspectFuncDelayedStart != nil {
		mmDelayedStart.inspectFuncDelayedStart()
	}

	if mmDelayedStart.DelayedStartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelayedStart.DelayedStartMock.defaultExpectation.Counter, 1)

		mm_results := mmDelayedStart.DelayedStartMock.defaultExpectation.results
		if mm_results == nil {
			mmDelayedStart.t.Fatal("No results are set for the AsyncCallRequesterMock.DelayedStart")
		}
		return (*mm_results).c1
	}
	if mmDelayedStart.funcDelayedStart != nil {
		return mmDelayedStart.funcDelayedStart()
	}
	mmDelayedStart.t.Fatalf("Unexpected call to AsyncCallRequesterMock.DelayedStart.")
	return
}

// DelayedStartAfterCounter returns a count of finished AsyncCallRequesterMock.DelayedStart invocations
func (mmDelayedStart *AsyncCallRequesterMock) DelayedStartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelayedStart.afterDelayedStartCounter)
}

// DelayedStartBeforeCounter returns a count of AsyncCallRequesterMock.DelayedStart invocations
func (mmDelayedStart *AsyncCallRequesterMock) DelayedStartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelayedStart.beforeDelayedStartCounter)
}

// MinimockDelayedStartDone returns true if the count of the DelayedStart invocations corresponds
// the number of defined expectations
func (m *AsyncCallRequesterMock) MinimockDelayedStartDone() bool {
	for _, e := range m.DelayedStartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DelayedStartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDelayedStartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelayedStart != nil && mm_atomic.LoadUint64(&m.afterDelayedStartCounter) < 1 {
		return false
	}
	return true
}

// MinimockDelayedStartInspect logs each unmet expectation
func (m *AsyncCallRequesterMock) MinimockDelayedStartInspect() {
	for _, e := range m.DelayedStartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncCallRequesterMock.DelayedStart")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DelayedStartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDelayedStartCounter) < 1 {
		m.t.Error("Expected call to AsyncCallRequesterMock.DelayedStart")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelayedStart != nil && mm_atomic.LoadUint64(&m.afterDelayedStartCounter) < 1 {
		m.t.Error("Expected call to AsyncCallRequesterMock.DelayedStart")
	}
}

type mAsyncCallRequesterMockStart struct {
	mock               *AsyncCallRequesterMock
	defaultExpectation *AsyncCallRequesterMockStartExpectation
	expectations       []*AsyncCallRequesterMockStartExpectation
}

// AsyncCallRequesterMockStartExpectation specifies expectation struct of the AsyncCallRequester.Start
type AsyncCallRequesterMockStartExpectation struct {
	mock *AsyncCallRequesterMock

	Counter uint64
}

// Expect sets up expected params for AsyncCallRequester.Start
func (mmStart *mAsyncCallRequesterMockStart) Expect() *mAsyncCallRequesterMockStart {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("AsyncCallRequesterMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &AsyncCallRequesterMockStartExpectation{}
	}

	return mmStart
}

// Inspect accepts an inspector function that has same arguments as the AsyncCallRequester.Start
func (mmStart *mAsyncCallRequesterMockStart) Inspect(f func()) *mAsyncCallRequesterMockStart {
	if mmStart.mock.inspectFuncStart != nil {
		mmStart.mock.t.Fatalf("Inspect function is already set for AsyncCallRequesterMock.Start")
	}

	mmStart.mock.inspectFuncStart = f

	return mmStart
}

// Return sets up results that will be returned by AsyncCallRequester.Start
func (mmStart *mAsyncCallRequesterMockStart) Return() *AsyncCallRequesterMock {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("AsyncCallRequesterMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &AsyncCallRequesterMockStartExpectation{mock: mmStart.mock}
	}

	return mmStart.mock
}

//Set uses given function f to mock the AsyncCallRequester.Start method
func (mmStart *mAsyncCallRequesterMockStart) Set(f func()) *AsyncCallRequesterMock {
	if mmStart.defaultExpectation != nil {
		mmStart.mock.t.Fatalf("Default expectation is already set for the AsyncCallRequester.Start method")
	}

	if len(mmStart.expectations) > 0 {
		mmStart.mock.t.Fatalf("Some expectations are already set for the AsyncCallRequester.Start method")
	}

	mmStart.mock.funcStart = f
	return mmStart.mock
}

// Start implements AsyncCallRequester
func (mmStart *AsyncCallRequesterMock) Start() {
	mm_atomic.AddUint64(&mmStart.beforeStartCounter, 1)
	defer mm_atomic.AddUint64(&mmStart.afterStartCounter, 1)

	if mmStart.inspectFuncStart != nil {
		mmStart.inspectFuncStart()
	}

	if mmStart.StartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStart.StartMock.defaultExpectation.Counter, 1)

		return

	}
	if mmStart.funcStart != nil {
		mmStart.funcStart()
		return
	}
	mmStart.t.Fatalf("Unexpected call to AsyncCallRequesterMock.Start.")

}

// StartAfterCounter returns a count of finished AsyncCallRequesterMock.Start invocations
func (mmStart *AsyncCallRequesterMock) StartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStart.afterStartCounter)
}

// StartBeforeCounter returns a count of AsyncCallRequesterMock.Start invocations
func (mmStart *AsyncCallRequesterMock) StartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStart.beforeStartCounter)
}

// MinimockStartDone returns true if the count of the Start invocations corresponds
// the number of defined expectations
func (m *AsyncCallRequesterMock) MinimockStartDone() bool {
	for _, e := range m.StartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStart != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		return false
	}
	return true
}

// MinimockStartInspect logs each unmet expectation
func (m *AsyncCallRequesterMock) MinimockStartInspect() {
	for _, e := range m.StartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncCallRequesterMock.Start")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		m.t.Error("Expected call to AsyncCallRequesterMock.Start")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStart != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		m.t.Error("Expected call to AsyncCallRequesterMock.Start")
	}
}

type mAsyncCallRequesterMockWithCancel struct {
	mock               *AsyncCallRequesterMock
	defaultExpectation *AsyncCallRequesterMockWithCancelExpectation
	expectations       []*AsyncCallRequesterMockWithCancelExpectation

	callArgs []*AsyncCallRequesterMockWithCancelParams
	mutex    sync.RWMutex
}

// AsyncCallRequesterMockWithCancelExpectation specifies expectation struct of the AsyncCallRequester.WithCancel
type AsyncCallRequesterMockWithCancelExpectation struct {
	mock    *AsyncCallRequesterMock
	params  *AsyncCallRequesterMockWithCancelParams
	results *AsyncCallRequesterMockWithCancelResults
	Counter uint64
}

// AsyncCallRequesterMockWithCancelParams contains parameters of the AsyncCallRequester.WithCancel
type AsyncCallRequesterMockWithCancelParams struct {
	cp1 *context.CancelFunc
}

// AsyncCallRequesterMockWithCancelResults contains results of the AsyncCallRequester.WithCancel
type AsyncCallRequesterMockWithCancelResults struct {
	a1 AsyncCallRequester
}

// Expect sets up expected params for AsyncCallRequester.WithCancel
func (mmWithCancel *mAsyncCallRequesterMockWithCancel) Expect(cp1 *context.CancelFunc) *mAsyncCallRequesterMockWithCancel {
	if mmWithCancel.mock.funcWithCancel != nil {
		mmWithCancel.mock.t.Fatalf("AsyncCallRequesterMock.WithCancel mock is already set by Set")
	}

	if mmWithCancel.defaultExpectation == nil {
		mmWithCancel.defaultExpectation = &AsyncCallRequesterMockWithCancelExpectation{}
	}

	mmWithCancel.defaultExpectation.params = &AsyncCallRequesterMockWithCancelParams{cp1}
	for _, e := range mmWithCancel.expectations {
		if minimock.Equal(e.params, mmWithCancel.defaultExpectation.params) {
			mmWithCancel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithCancel.defaultExpectation.params)
		}
	}

	return mmWithCancel
}

// Inspect accepts an inspector function that has same arguments as the AsyncCallRequester.WithCancel
func (mmWithCancel *mAsyncCallRequesterMockWithCancel) Inspect(f func(cp1 *context.CancelFunc)) *mAsyncCallRequesterMockWithCancel {
	if mmWithCancel.mock.inspectFuncWithCancel != nil {
		mmWithCancel.mock.t.Fatalf("Inspect function is already set for AsyncCallRequesterMock.WithCancel")
	}

	mmWithCancel.mock.inspectFuncWithCancel = f

	return mmWithCancel
}

// Return sets up results that will be returned by AsyncCallRequester.WithCancel
func (mmWithCancel *mAsyncCallRequesterMockWithCancel) Return(a1 AsyncCallRequester) *AsyncCallRequesterMock {
	if mmWithCancel.mock.funcWithCancel != nil {
		mmWithCancel.mock.t.Fatalf("AsyncCallRequesterMock.WithCancel mock is already set by Set")
	}

	if mmWithCancel.defaultExpectation == nil {
		mmWithCancel.defaultExpectation = &AsyncCallRequesterMockWithCancelExpectation{mock: mmWithCancel.mock}
	}
	mmWithCancel.defaultExpectation.results = &AsyncCallRequesterMockWithCancelResults{a1}
	return mmWithCancel.mock
}

//Set uses given function f to mock the AsyncCallRequester.WithCancel method
func (mmWithCancel *mAsyncCallRequesterMockWithCancel) Set(f func(cp1 *context.CancelFunc) (a1 AsyncCallRequester)) *AsyncCallRequesterMock {
	if mmWithCancel.defaultExpectation != nil {
		mmWithCancel.mock.t.Fatalf("Default expectation is already set for the AsyncCallRequester.WithCancel method")
	}

	if len(mmWithCancel.expectations) > 0 {
		mmWithCancel.mock.t.Fatalf("Some expectations are already set for the AsyncCallRequester.WithCancel method")
	}

	mmWithCancel.mock.funcWithCancel = f
	return mmWithCancel.mock
}

// When sets expectation for the AsyncCallRequester.WithCancel which will trigger the result defined by the following
// Then helper
func (mmWithCancel *mAsyncCallRequesterMockWithCancel) When(cp1 *context.CancelFunc) *AsyncCallRequesterMockWithCancelExpectation {
	if mmWithCancel.mock.funcWithCancel != nil {
		mmWithCancel.mock.t.Fatalf("AsyncCallRequesterMock.WithCancel mock is already set by Set")
	}

	expectation := &AsyncCallRequesterMockWithCancelExpectation{
		mock:   mmWithCancel.mock,
		params: &AsyncCallRequesterMockWithCancelParams{cp1},
	}
	mmWithCancel.expectations = append(mmWithCancel.expectations, expectation)
	return expectation
}

// Then sets up AsyncCallRequester.WithCancel return parameters for the expectation previously defined by the When method
func (e *AsyncCallRequesterMockWithCancelExpectation) Then(a1 AsyncCallRequester) *AsyncCallRequesterMock {
	e.results = &AsyncCallRequesterMockWithCancelResults{a1}
	return e.mock
}

// WithCancel implements AsyncCallRequester
func (mmWithCancel *AsyncCallRequesterMock) WithCancel(cp1 *context.CancelFunc) (a1 AsyncCallRequester) {
	mm_atomic.AddUint64(&mmWithCancel.beforeWithCancelCounter, 1)
	defer mm_atomic.AddUint64(&mmWithCancel.afterWithCancelCounter, 1)

	if mmWithCancel.inspectFuncWithCancel != nil {
		mmWithCancel.inspectFuncWithCancel(cp1)
	}

	mm_params := &AsyncCallRequesterMockWithCancelParams{cp1}

	// Record call args
	mmWithCancel.WithCancelMock.mutex.Lock()
	mmWithCancel.WithCancelMock.callArgs = append(mmWithCancel.WithCancelMock.callArgs, mm_params)
	mmWithCancel.WithCancelMock.mutex.Unlock()

	for _, e := range mmWithCancel.WithCancelMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.a1
		}
	}

	if mmWithCancel.WithCancelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithCancel.WithCancelMock.defaultExpectation.Counter, 1)
		mm_want := mmWithCancel.WithCancelMock.defaultExpectation.params
		mm_got := AsyncCallRequesterMockWithCancelParams{cp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithCancel.t.Errorf("AsyncCallRequesterMock.WithCancel got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithCancel.WithCancelMock.defaultExpectation.results
		if mm_results == nil {
			mmWithCancel.t.Fatal("No results are set for the AsyncCallRequesterMock.WithCancel")
		}
		return (*mm_results).a1
	}
	if mmWithCancel.funcWithCancel != nil {
		return mmWithCancel.funcWithCancel(cp1)
	}
	mmWithCancel.t.Fatalf("Unexpected call to AsyncCallRequesterMock.WithCancel. %v", cp1)
	return
}

// WithCancelAfterCounter returns a count of finished AsyncCallRequesterMock.WithCancel invocations
func (mmWithCancel *AsyncCallRequesterMock) WithCancelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithCancel.afterWithCancelCounter)
}

// WithCancelBeforeCounter returns a count of AsyncCallRequesterMock.WithCancel invocations
func (mmWithCancel *AsyncCallRequesterMock) WithCancelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithCancel.beforeWithCancelCounter)
}

// Calls returns a list of arguments used in each call to AsyncCallRequesterMock.WithCancel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithCancel *mAsyncCallRequesterMockWithCancel) Calls() []*AsyncCallRequesterMockWithCancelParams {
	mmWithCancel.mutex.RLock()

	argCopy := make([]*AsyncCallRequesterMockWithCancelParams, len(mmWithCancel.callArgs))
	copy(argCopy, mmWithCancel.callArgs)

	mmWithCancel.mutex.RUnlock()

	return argCopy
}

// MinimockWithCancelDone returns true if the count of the WithCancel invocations corresponds
// the number of defined expectations
func (m *AsyncCallRequesterMock) MinimockWithCancelDone() bool {
	for _, e := range m.WithCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithCancelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithCancelCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithCancel != nil && mm_atomic.LoadUint64(&m.afterWithCancelCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithCancelInspect logs each unmet expectation
func (m *AsyncCallRequesterMock) MinimockWithCancelInspect() {
	for _, e := range m.WithCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AsyncCallRequesterMock.WithCancel with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithCancelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithCancelCounter) < 1 {
		if m.WithCancelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AsyncCallRequesterMock.WithCancel")
		} else {
			m.t.Errorf("Expected call to AsyncCallRequesterMock.WithCancel with params: %#v", *m.WithCancelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithCancel != nil && mm_atomic.LoadUint64(&m.afterWithCancelCounter) < 1 {
		m.t.Error("Expected call to AsyncCallRequesterMock.WithCancel")
	}
}

type mAsyncCallRequesterMockWithFlags struct {
	mock               *AsyncCallRequesterMock
	defaultExpectation *AsyncCallRequesterMockWithFlagsExpectation
	expectations       []*AsyncCallRequesterMockWithFlagsExpectation

	callArgs []*AsyncCallRequesterMockWithFlagsParams
	mutex    sync.RWMutex
}

// AsyncCallRequesterMockWithFlagsExpectation specifies expectation struct of the AsyncCallRequester.WithFlags
type AsyncCallRequesterMockWithFlagsExpectation struct {
	mock    *AsyncCallRequesterMock
	params  *AsyncCallRequesterMockWithFlagsParams
	results *AsyncCallRequesterMockWithFlagsResults
	Counter uint64
}

// AsyncCallRequesterMockWithFlagsParams contains parameters of the AsyncCallRequester.WithFlags
type AsyncCallRequesterMockWithFlagsParams struct {
	flags AsyncCallFlags
}

// AsyncCallRequesterMockWithFlagsResults contains results of the AsyncCallRequester.WithFlags
type AsyncCallRequesterMockWithFlagsResults struct {
	a1 AsyncCallRequester
}

// Expect sets up expected params for AsyncCallRequester.WithFlags
func (mmWithFlags *mAsyncCallRequesterMockWithFlags) Expect(flags AsyncCallFlags) *mAsyncCallRequesterMockWithFlags {
	if mmWithFlags.mock.funcWithFlags != nil {
		mmWithFlags.mock.t.Fatalf("AsyncCallRequesterMock.WithFlags mock is already set by Set")
	}

	if mmWithFlags.defaultExpectation == nil {
		mmWithFlags.defaultExpectation = &AsyncCallRequesterMockWithFlagsExpectation{}
	}

	mmWithFlags.defaultExpectation.params = &AsyncCallRequesterMockWithFlagsParams{flags}
	for _, e := range mmWithFlags.expectations {
		if minimock.Equal(e.params, mmWithFlags.defaultExpectation.params) {
			mmWithFlags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithFlags.defaultExpectation.params)
		}
	}

	return mmWithFlags
}

// Inspect accepts an inspector function that has same arguments as the AsyncCallRequester.WithFlags
func (mmWithFlags *mAsyncCallRequesterMockWithFlags) Inspect(f func(flags AsyncCallFlags)) *mAsyncCallRequesterMockWithFlags {
	if mmWithFlags.mock.inspectFuncWithFlags != nil {
		mmWithFlags.mock.t.Fatalf("Inspect function is already set for AsyncCallRequesterMock.WithFlags")
	}

	mmWithFlags.mock.inspectFuncWithFlags = f

	return mmWithFlags
}

// Return sets up results that will be returned by AsyncCallRequester.WithFlags
func (mmWithFlags *mAsyncCallRequesterMockWithFlags) Return(a1 AsyncCallRequester) *AsyncCallRequesterMock {
	if mmWithFlags.mock.funcWithFlags != nil {
		mmWithFlags.mock.t.Fatalf("AsyncCallRequesterMock.WithFlags mock is already set by Set")
	}

	if mmWithFlags.defaultExpectation == nil {
		mmWithFlags.defaultExpectation = &AsyncCallRequesterMockWithFlagsExpectation{mock: mmWithFlags.mock}
	}
	mmWithFlags.defaultExpectation.results = &AsyncCallRequesterMockWithFlagsResults{a1}
	return mmWithFlags.mock
}

//Set uses given function f to mock the AsyncCallRequester.WithFlags method
func (mmWithFlags *mAsyncCallRequesterMockWithFlags) Set(f func(flags AsyncCallFlags) (a1 AsyncCallRequester)) *AsyncCallRequesterMock {
	if mmWithFlags.defaultExpectation != nil {
		mmWithFlags.mock.t.Fatalf("Default expectation is already set for the AsyncCallRequester.WithFlags method")
	}

	if len(mmWithFlags.expectations) > 0 {
		mmWithFlags.mock.t.Fatalf("Some expectations are already set for the AsyncCallRequester.WithFlags method")
	}

	mmWithFlags.mock.funcWithFlags = f
	return mmWithFlags.mock
}

// When sets expectation for the AsyncCallRequester.WithFlags which will trigger the result defined by the following
// Then helper
func (mmWithFlags *mAsyncCallRequesterMockWithFlags) When(flags AsyncCallFlags) *AsyncCallRequesterMockWithFlagsExpectation {
	if mmWithFlags.mock.funcWithFlags != nil {
		mmWithFlags.mock.t.Fatalf("AsyncCallRequesterMock.WithFlags mock is already set by Set")
	}

	expectation := &AsyncCallRequesterMockWithFlagsExpectation{
		mock:   mmWithFlags.mock,
		params: &AsyncCallRequesterMockWithFlagsParams{flags},
	}
	mmWithFlags.expectations = append(mmWithFlags.expectations, expectation)
	return expectation
}

// Then sets up AsyncCallRequester.WithFlags return parameters for the expectation previously defined by the When method
func (e *AsyncCallRequesterMockWithFlagsExpectation) Then(a1 AsyncCallRequester) *AsyncCallRequesterMock {
	e.results = &AsyncCallRequesterMockWithFlagsResults{a1}
	return e.mock
}

// WithFlags implements AsyncCallRequester
func (mmWithFlags *AsyncCallRequesterMock) WithFlags(flags AsyncCallFlags) (a1 AsyncCallRequester) {
	mm_atomic.AddUint64(&mmWithFlags.beforeWithFlagsCounter, 1)
	defer mm_atomic.AddUint64(&mmWithFlags.afterWithFlagsCounter, 1)

	if mmWithFlags.inspectFuncWithFlags != nil {
		mmWithFlags.inspectFuncWithFlags(flags)
	}

	mm_params := &AsyncCallRequesterMockWithFlagsParams{flags}

	// Record call args
	mmWithFlags.WithFlagsMock.mutex.Lock()
	mmWithFlags.WithFlagsMock.callArgs = append(mmWithFlags.WithFlagsMock.callArgs, mm_params)
	mmWithFlags.WithFlagsMock.mutex.Unlock()

	for _, e := range mmWithFlags.WithFlagsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.a1
		}
	}

	if mmWithFlags.WithFlagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithFlags.WithFlagsMock.defaultExpectation.Counter, 1)
		mm_want := mmWithFlags.WithFlagsMock.defaultExpectation.params
		mm_got := AsyncCallRequesterMockWithFlagsParams{flags}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithFlags.t.Errorf("AsyncCallRequesterMock.WithFlags got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithFlags.WithFlagsMock.defaultExpectation.results
		if mm_results == nil {
			mmWithFlags.t.Fatal("No results are set for the AsyncCallRequesterMock.WithFlags")
		}
		return (*mm_results).a1
	}
	if mmWithFlags.funcWithFlags != nil {
		return mmWithFlags.funcWithFlags(flags)
	}
	mmWithFlags.t.Fatalf("Unexpected call to AsyncCallRequesterMock.WithFlags. %v", flags)
	return
}

// WithFlagsAfterCounter returns a count of finished AsyncCallRequesterMock.WithFlags invocations
func (mmWithFlags *AsyncCallRequesterMock) WithFlagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithFlags.afterWithFlagsCounter)
}

// WithFlagsBeforeCounter returns a count of AsyncCallRequesterMock.WithFlags invocations
func (mmWithFlags *AsyncCallRequesterMock) WithFlagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithFlags.beforeWithFlagsCounter)
}

// Calls returns a list of arguments used in each call to AsyncCallRequesterMock.WithFlags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithFlags *mAsyncCallRequesterMockWithFlags) Calls() []*AsyncCallRequesterMockWithFlagsParams {
	mmWithFlags.mutex.RLock()

	argCopy := make([]*AsyncCallRequesterMockWithFlagsParams, len(mmWithFlags.callArgs))
	copy(argCopy, mmWithFlags.callArgs)

	mmWithFlags.mutex.RUnlock()

	return argCopy
}

// MinimockWithFlagsDone returns true if the count of the WithFlags invocations corresponds
// the number of defined expectations
func (m *AsyncCallRequesterMock) MinimockWithFlagsDone() bool {
	for _, e := range m.WithFlagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithFlagsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithFlagsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithFlags != nil && mm_atomic.LoadUint64(&m.afterWithFlagsCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithFlagsInspect logs each unmet expectation
func (m *AsyncCallRequesterMock) MinimockWithFlagsInspect() {
	for _, e := range m.WithFlagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AsyncCallRequesterMock.WithFlags with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithFlagsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithFlagsCounter) < 1 {
		if m.WithFlagsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AsyncCallRequesterMock.WithFlags")
		} else {
			m.t.Errorf("Expected call to AsyncCallRequesterMock.WithFlags with params: %#v", *m.WithFlagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithFlags != nil && mm_atomic.LoadUint64(&m.afterWithFlagsCounter) < 1 {
		m.t.Error("Expected call to AsyncCallRequesterMock.WithFlags")
	}
}

type mAsyncCallRequesterMockWithLog struct {
	mock               *AsyncCallRequesterMock
	defaultExpectation *AsyncCallRequesterMockWithLogExpectation
	expectations       []*AsyncCallRequesterMockWithLogExpectation

	callArgs []*AsyncCallRequesterMockWithLogParams
	mutex    sync.RWMutex
}

// AsyncCallRequesterMockWithLogExpectation specifies expectation struct of the AsyncCallRequester.WithLog
type AsyncCallRequesterMockWithLogExpectation struct {
	mock    *AsyncCallRequesterMock
	params  *AsyncCallRequesterMockWithLogParams
	results *AsyncCallRequesterMockWithLogResults
	Counter uint64
}

// AsyncCallRequesterMockWithLogParams contains parameters of the AsyncCallRequester.WithLog
type AsyncCallRequesterMockWithLogParams struct {
	isLogging bool
}

// AsyncCallRequesterMockWithLogResults contains results of the AsyncCallRequester.WithLog
type AsyncCallRequesterMockWithLogResults struct {
	a1 AsyncCallRequester
}

// Expect sets up expected params for AsyncCallRequester.WithLog
func (mmWithLog *mAsyncCallRequesterMockWithLog) Expect(isLogging bool) *mAsyncCallRequesterMockWithLog {
	if mmWithLog.mock.funcWithLog != nil {
		mmWithLog.mock.t.Fatalf("AsyncCallRequesterMock.WithLog mock is already set by Set")
	}

	if mmWithLog.defaultExpectation == nil {
		mmWithLog.defaultExpectation = &AsyncCallRequesterMockWithLogExpectation{}
	}

	mmWithLog.defaultExpectation.params = &AsyncCallRequesterMockWithLogParams{isLogging}
	for _, e := range mmWithLog.expectations {
		if minimock.Equal(e.params, mmWithLog.defaultExpectation.params) {
			mmWithLog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithLog.defaultExpectation.params)
		}
	}

	return mmWithLog
}

// Inspect accepts an inspector function that has same arguments as the AsyncCallRequester.WithLog
func (mmWithLog *mAsyncCallRequesterMockWithLog) Inspect(f func(isLogging bool)) *mAsyncCallRequesterMockWithLog {
	if mmWithLog.mock.inspectFuncWithLog != nil {
		mmWithLog.mock.t.Fatalf("Inspect function is already set for AsyncCallRequesterMock.WithLog")
	}

	mmWithLog.mock.inspectFuncWithLog = f

	return mmWithLog
}

// Return sets up results that will be returned by AsyncCallRequester.WithLog
func (mmWithLog *mAsyncCallRequesterMockWithLog) Return(a1 AsyncCallRequester) *AsyncCallRequesterMock {
	if mmWithLog.mock.funcWithLog != nil {
		mmWithLog.mock.t.Fatalf("AsyncCallRequesterMock.WithLog mock is already set by Set")
	}

	if mmWithLog.defaultExpectation == nil {
		mmWithLog.defaultExpectation = &AsyncCallRequesterMockWithLogExpectation{mock: mmWithLog.mock}
	}
	mmWithLog.defaultExpectation.results = &AsyncCallRequesterMockWithLogResults{a1}
	return mmWithLog.mock
}

//Set uses given function f to mock the AsyncCallRequester.WithLog method
func (mmWithLog *mAsyncCallRequesterMockWithLog) Set(f func(isLogging bool) (a1 AsyncCallRequester)) *AsyncCallRequesterMock {
	if mmWithLog.defaultExpectation != nil {
		mmWithLog.mock.t.Fatalf("Default expectation is already set for the AsyncCallRequester.WithLog method")
	}

	if len(mmWithLog.expectations) > 0 {
		mmWithLog.mock.t.Fatalf("Some expectations are already set for the AsyncCallRequester.WithLog method")
	}

	mmWithLog.mock.funcWithLog = f
	return mmWithLog.mock
}

// When sets expectation for the AsyncCallRequester.WithLog which will trigger the result defined by the following
// Then helper
func (mmWithLog *mAsyncCallRequesterMockWithLog) When(isLogging bool) *AsyncCallRequesterMockWithLogExpectation {
	if mmWithLog.mock.funcWithLog != nil {
		mmWithLog.mock.t.Fatalf("AsyncCallRequesterMock.WithLog mock is already set by Set")
	}

	expectation := &AsyncCallRequesterMockWithLogExpectation{
		mock:   mmWithLog.mock,
		params: &AsyncCallRequesterMockWithLogParams{isLogging},
	}
	mmWithLog.expectations = append(mmWithLog.expectations, expectation)
	return expectation
}

// Then sets up AsyncCallRequester.WithLog return parameters for the expectation previously defined by the When method
func (e *AsyncCallRequesterMockWithLogExpectation) Then(a1 AsyncCallRequester) *AsyncCallRequesterMock {
	e.results = &AsyncCallRequesterMockWithLogResults{a1}
	return e.mock
}

// WithLog implements AsyncCallRequester
func (mmWithLog *AsyncCallRequesterMock) WithLog(isLogging bool) (a1 AsyncCallRequester) {
	mm_atomic.AddUint64(&mmWithLog.beforeWithLogCounter, 1)
	defer mm_atomic.AddUint64(&mmWithLog.afterWithLogCounter, 1)

	if mmWithLog.inspectFuncWithLog != nil {
		mmWithLog.inspectFuncWithLog(isLogging)
	}

	mm_params := &AsyncCallRequesterMockWithLogParams{isLogging}

	// Record call args
	mmWithLog.WithLogMock.mutex.Lock()
	mmWithLog.WithLogMock.callArgs = append(mmWithLog.WithLogMock.callArgs, mm_params)
	mmWithLog.WithLogMock.mutex.Unlock()

	for _, e := range mmWithLog.WithLogMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.a1
		}
	}

	if mmWithLog.WithLogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithLog.WithLogMock.defaultExpectation.Counter, 1)
		mm_want := mmWithLog.WithLogMock.defaultExpectation.params
		mm_got := AsyncCallRequesterMockWithLogParams{isLogging}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithLog.t.Errorf("AsyncCallRequesterMock.WithLog got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithLog.WithLogMock.defaultExpectation.results
		if mm_results == nil {
			mmWithLog.t.Fatal("No results are set for the AsyncCallRequesterMock.WithLog")
		}
		return (*mm_results).a1
	}
	if mmWithLog.funcWithLog != nil {
		return mmWithLog.funcWithLog(isLogging)
	}
	mmWithLog.t.Fatalf("Unexpected call to AsyncCallRequesterMock.WithLog. %v", isLogging)
	return
}

// WithLogAfterCounter returns a count of finished AsyncCallRequesterMock.WithLog invocations
func (mmWithLog *AsyncCallRequesterMock) WithLogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithLog.afterWithLogCounter)
}

// WithLogBeforeCounter returns a count of AsyncCallRequesterMock.WithLog invocations
func (mmWithLog *AsyncCallRequesterMock) WithLogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithLog.beforeWithLogCounter)
}

// Calls returns a list of arguments used in each call to AsyncCallRequesterMock.WithLog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithLog *mAsyncCallRequesterMockWithLog) Calls() []*AsyncCallRequesterMockWithLogParams {
	mmWithLog.mutex.RLock()

	argCopy := make([]*AsyncCallRequesterMockWithLogParams, len(mmWithLog.callArgs))
	copy(argCopy, mmWithLog.callArgs)

	mmWithLog.mutex.RUnlock()

	return argCopy
}

// MinimockWithLogDone returns true if the count of the WithLog invocations corresponds
// the number of defined expectations
func (m *AsyncCallRequesterMock) MinimockWithLogDone() bool {
	for _, e := range m.WithLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithLogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithLogCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithLog != nil && mm_atomic.LoadUint64(&m.afterWithLogCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithLogInspect logs each unmet expectation
func (m *AsyncCallRequesterMock) MinimockWithLogInspect() {
	for _, e := range m.WithLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AsyncCallRequesterMock.WithLog with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithLogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithLogCounter) < 1 {
		if m.WithLogMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AsyncCallRequesterMock.WithLog")
		} else {
			m.t.Errorf("Expected call to AsyncCallRequesterMock.WithLog with params: %#v", *m.WithLogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithLog != nil && mm_atomic.LoadUint64(&m.afterWithLogCounter) < 1 {
		m.t.Error("Expected call to AsyncCallRequesterMock.WithLog")
	}
}

type mAsyncCallRequesterMockWithNested struct {
	mock               *AsyncCallRequesterMock
	defaultExpectation *AsyncCallRequesterMockWithNestedExpectation
	expectations       []*AsyncCallRequesterMockWithNestedExpectation

	callArgs []*AsyncCallRequesterMockWithNestedParams
	mutex    sync.RWMutex
}

// AsyncCallRequesterMockWithNestedExpectation specifies expectation struct of the AsyncCallRequester.WithNested
type AsyncCallRequesterMockWithNestedExpectation struct {
	mock    *AsyncCallRequesterMock
	params  *AsyncCallRequesterMockWithNestedParams
	results *AsyncCallRequesterMockWithNestedResults
	Counter uint64
}

// AsyncCallRequesterMockWithNestedParams contains parameters of the AsyncCallRequester.WithNested
type AsyncCallRequesterMockWithNestedParams struct {
	c1 CreateFactoryFunc
}

// AsyncCallRequesterMockWithNestedResults contains results of the AsyncCallRequester.WithNested
type AsyncCallRequesterMockWithNestedResults struct {
	a1 AsyncCallRequester
}

// Expect sets up expected params for AsyncCallRequester.WithNested
func (mmWithNested *mAsyncCallRequesterMockWithNested) Expect(c1 CreateFactoryFunc) *mAsyncCallRequesterMockWithNested {
	if mmWithNested.mock.funcWithNested != nil {
		mmWithNested.mock.t.Fatalf("AsyncCallRequesterMock.WithNested mock is already set by Set")
	}

	if mmWithNested.defaultExpectation == nil {
		mmWithNested.defaultExpectation = &AsyncCallRequesterMockWithNestedExpectation{}
	}

	mmWithNested.defaultExpectation.params = &AsyncCallRequesterMockWithNestedParams{c1}
	for _, e := range mmWithNested.expectations {
		if minimock.Equal(e.params, mmWithNested.defaultExpectation.params) {
			mmWithNested.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithNested.defaultExpectation.params)
		}
	}

	return mmWithNested
}

// Inspect accepts an inspector function that has same arguments as the AsyncCallRequester.WithNested
func (mmWithNested *mAsyncCallRequesterMockWithNested) Inspect(f func(c1 CreateFactoryFunc)) *mAsyncCallRequesterMockWithNested {
	if mmWithNested.mock.inspectFuncWithNested != nil {
		mmWithNested.mock.t.Fatalf("Inspect function is already set for AsyncCallRequesterMock.WithNested")
	}

	mmWithNested.mock.inspectFuncWithNested = f

	return mmWithNested
}

// Return sets up results that will be returned by AsyncCallRequester.WithNested
func (mmWithNested *mAsyncCallRequesterMockWithNested) Return(a1 AsyncCallRequester) *AsyncCallRequesterMock {
	if mmWithNested.mock.funcWithNested != nil {
		mmWithNested.mock.t.Fatalf("AsyncCallRequesterMock.WithNested mock is already set by Set")
	}

	if mmWithNested.defaultExpectation == nil {
		mmWithNested.defaultExpectation = &AsyncCallRequesterMockWithNestedExpectation{mock: mmWithNested.mock}
	}
	mmWithNested.defaultExpectation.results = &AsyncCallRequesterMockWithNestedResults{a1}
	return mmWithNested.mock
}

//Set uses given function f to mock the AsyncCallRequester.WithNested method
func (mmWithNested *mAsyncCallRequesterMockWithNested) Set(f func(c1 CreateFactoryFunc) (a1 AsyncCallRequester)) *AsyncCallRequesterMock {
	if mmWithNested.defaultExpectation != nil {
		mmWithNested.mock.t.Fatalf("Default expectation is already set for the AsyncCallRequester.WithNested method")
	}

	if len(mmWithNested.expectations) > 0 {
		mmWithNested.mock.t.Fatalf("Some expectations are already set for the AsyncCallRequester.WithNested method")
	}

	mmWithNested.mock.funcWithNested = f
	return mmWithNested.mock
}

// When sets expectation for the AsyncCallRequester.WithNested which will trigger the result defined by the following
// Then helper
func (mmWithNested *mAsyncCallRequesterMockWithNested) When(c1 CreateFactoryFunc) *AsyncCallRequesterMockWithNestedExpectation {
	if mmWithNested.mock.funcWithNested != nil {
		mmWithNested.mock.t.Fatalf("AsyncCallRequesterMock.WithNested mock is already set by Set")
	}

	expectation := &AsyncCallRequesterMockWithNestedExpectation{
		mock:   mmWithNested.mock,
		params: &AsyncCallRequesterMockWithNestedParams{c1},
	}
	mmWithNested.expectations = append(mmWithNested.expectations, expectation)
	return expectation
}

// Then sets up AsyncCallRequester.WithNested return parameters for the expectation previously defined by the When method
func (e *AsyncCallRequesterMockWithNestedExpectation) Then(a1 AsyncCallRequester) *AsyncCallRequesterMock {
	e.results = &AsyncCallRequesterMockWithNestedResults{a1}
	return e.mock
}

// WithNested implements AsyncCallRequester
func (mmWithNested *AsyncCallRequesterMock) WithNested(c1 CreateFactoryFunc) (a1 AsyncCallRequester) {
	mm_atomic.AddUint64(&mmWithNested.beforeWithNestedCounter, 1)
	defer mm_atomic.AddUint64(&mmWithNested.afterWithNestedCounter, 1)

	if mmWithNested.inspectFuncWithNested != nil {
		mmWithNested.inspectFuncWithNested(c1)
	}

	mm_params := &AsyncCallRequesterMockWithNestedParams{c1}

	// Record call args
	mmWithNested.WithNestedMock.mutex.Lock()
	mmWithNested.WithNestedMock.callArgs = append(mmWithNested.WithNestedMock.callArgs, mm_params)
	mmWithNested.WithNestedMock.mutex.Unlock()

	for _, e := range mmWithNested.WithNestedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.a1
		}
	}

	if mmWithNested.WithNestedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithNested.WithNestedMock.defaultExpectation.Counter, 1)
		mm_want := mmWithNested.WithNestedMock.defaultExpectation.params
		mm_got := AsyncCallRequesterMockWithNestedParams{c1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithNested.t.Errorf("AsyncCallRequesterMock.WithNested got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithNested.WithNestedMock.defaultExpectation.results
		if mm_results == nil {
			mmWithNested.t.Fatal("No results are set for the AsyncCallRequesterMock.WithNested")
		}
		return (*mm_results).a1
	}
	if mmWithNested.funcWithNested != nil {
		return mmWithNested.funcWithNested(c1)
	}
	mmWithNested.t.Fatalf("Unexpected call to AsyncCallRequesterMock.WithNested. %v", c1)
	return
}

// WithNestedAfterCounter returns a count of finished AsyncCallRequesterMock.WithNested invocations
func (mmWithNested *AsyncCallRequesterMock) WithNestedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithNested.afterWithNestedCounter)
}

// WithNestedBeforeCounter returns a count of AsyncCallRequesterMock.WithNested invocations
func (mmWithNested *AsyncCallRequesterMock) WithNestedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithNested.beforeWithNestedCounter)
}

// Calls returns a list of arguments used in each call to AsyncCallRequesterMock.WithNested.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithNested *mAsyncCallRequesterMockWithNested) Calls() []*AsyncCallRequesterMockWithNestedParams {
	mmWithNested.mutex.RLock()

	argCopy := make([]*AsyncCallRequesterMockWithNestedParams, len(mmWithNested.callArgs))
	copy(argCopy, mmWithNested.callArgs)

	mmWithNested.mutex.RUnlock()

	return argCopy
}

// MinimockWithNestedDone returns true if the count of the WithNested invocations corresponds
// the number of defined expectations
func (m *AsyncCallRequesterMock) MinimockWithNestedDone() bool {
	for _, e := range m.WithNestedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithNestedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithNestedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithNested != nil && mm_atomic.LoadUint64(&m.afterWithNestedCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithNestedInspect logs each unmet expectation
func (m *AsyncCallRequesterMock) MinimockWithNestedInspect() {
	for _, e := range m.WithNestedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AsyncCallRequesterMock.WithNested with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithNestedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithNestedCounter) < 1 {
		if m.WithNestedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AsyncCallRequesterMock.WithNested")
		} else {
			m.t.Errorf("Expected call to AsyncCallRequesterMock.WithNested with params: %#v", *m.WithNestedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithNested != nil && mm_atomic.LoadUint64(&m.afterWithNestedCounter) < 1 {
		m.t.Error("Expected call to AsyncCallRequesterMock.WithNested")
	}
}

type mAsyncCallRequesterMockWithoutAutoWakeUp struct {
	mock               *AsyncCallRequesterMock
	defaultExpectation *AsyncCallRequesterMockWithoutAutoWakeUpExpectation
	expectations       []*AsyncCallRequesterMockWithoutAutoWakeUpExpectation
}

// AsyncCallRequesterMockWithoutAutoWakeUpExpectation specifies expectation struct of the AsyncCallRequester.WithoutAutoWakeUp
type AsyncCallRequesterMockWithoutAutoWakeUpExpectation struct {
	mock *AsyncCallRequesterMock

	results *AsyncCallRequesterMockWithoutAutoWakeUpResults
	Counter uint64
}

// AsyncCallRequesterMockWithoutAutoWakeUpResults contains results of the AsyncCallRequester.WithoutAutoWakeUp
type AsyncCallRequesterMockWithoutAutoWakeUpResults struct {
	a1 AsyncCallRequester
}

// Expect sets up expected params for AsyncCallRequester.WithoutAutoWakeUp
func (mmWithoutAutoWakeUp *mAsyncCallRequesterMockWithoutAutoWakeUp) Expect() *mAsyncCallRequesterMockWithoutAutoWakeUp {
	if mmWithoutAutoWakeUp.mock.funcWithoutAutoWakeUp != nil {
		mmWithoutAutoWakeUp.mock.t.Fatalf("AsyncCallRequesterMock.WithoutAutoWakeUp mock is already set by Set")
	}

	if mmWithoutAutoWakeUp.defaultExpectation == nil {
		mmWithoutAutoWakeUp.defaultExpectation = &AsyncCallRequesterMockWithoutAutoWakeUpExpectation{}
	}

	return mmWithoutAutoWakeUp
}

// Inspect accepts an inspector function that has same arguments as the AsyncCallRequester.WithoutAutoWakeUp
func (mmWithoutAutoWakeUp *mAsyncCallRequesterMockWithoutAutoWakeUp) Inspect(f func()) *mAsyncCallRequesterMockWithoutAutoWakeUp {
	if mmWithoutAutoWakeUp.mock.inspectFuncWithoutAutoWakeUp != nil {
		mmWithoutAutoWakeUp.mock.t.Fatalf("Inspect function is already set for AsyncCallRequesterMock.WithoutAutoWakeUp")
	}

	mmWithoutAutoWakeUp.mock.inspectFuncWithoutAutoWakeUp = f

	return mmWithoutAutoWakeUp
}

// Return sets up results that will be returned by AsyncCallRequester.WithoutAutoWakeUp
func (mmWithoutAutoWakeUp *mAsyncCallRequesterMockWithoutAutoWakeUp) Return(a1 AsyncCallRequester) *AsyncCallRequesterMock {
	if mmWithoutAutoWakeUp.mock.funcWithoutAutoWakeUp != nil {
		mmWithoutAutoWakeUp.mock.t.Fatalf("AsyncCallRequesterMock.WithoutAutoWakeUp mock is already set by Set")
	}

	if mmWithoutAutoWakeUp.defaultExpectation == nil {
		mmWithoutAutoWakeUp.defaultExpectation = &AsyncCallRequesterMockWithoutAutoWakeUpExpectation{mock: mmWithoutAutoWakeUp.mock}
	}
	mmWithoutAutoWakeUp.defaultExpectation.results = &AsyncCallRequesterMockWithoutAutoWakeUpResults{a1}
	return mmWithoutAutoWakeUp.mock
}

//Set uses given function f to mock the AsyncCallRequester.WithoutAutoWakeUp method
func (mmWithoutAutoWakeUp *mAsyncCallRequesterMockWithoutAutoWakeUp) Set(f func() (a1 AsyncCallRequester)) *AsyncCallRequesterMock {
	if mmWithoutAutoWakeUp.defaultExpectation != nil {
		mmWithoutAutoWakeUp.mock.t.Fatalf("Default expectation is already set for the AsyncCallRequester.WithoutAutoWakeUp method")
	}

	if len(mmWithoutAutoWakeUp.expectations) > 0 {
		mmWithoutAutoWakeUp.mock.t.Fatalf("Some expectations are already set for the AsyncCallRequester.WithoutAutoWakeUp method")
	}

	mmWithoutAutoWakeUp.mock.funcWithoutAutoWakeUp = f
	return mmWithoutAutoWakeUp.mock
}

// WithoutAutoWakeUp implements AsyncCallRequester
func (mmWithoutAutoWakeUp *AsyncCallRequesterMock) WithoutAutoWakeUp() (a1 AsyncCallRequester) {
	mm_atomic.AddUint64(&mmWithoutAutoWakeUp.beforeWithoutAutoWakeUpCounter, 1)
	defer mm_atomic.AddUint64(&mmWithoutAutoWakeUp.afterWithoutAutoWakeUpCounter, 1)

	if mmWithoutAutoWakeUp.inspectFuncWithoutAutoWakeUp != nil {
		mmWithoutAutoWakeUp.inspectFuncWithoutAutoWakeUp()
	}

	if mmWithoutAutoWakeUp.WithoutAutoWakeUpMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithoutAutoWakeUp.WithoutAutoWakeUpMock.defaultExpectation.Counter, 1)

		mm_results := mmWithoutAutoWakeUp.WithoutAutoWakeUpMock.defaultExpectation.results
		if mm_results == nil {
			mmWithoutAutoWakeUp.t.Fatal("No results are set for the AsyncCallRequesterMock.WithoutAutoWakeUp")
		}
		return (*mm_results).a1
	}
	if mmWithoutAutoWakeUp.funcWithoutAutoWakeUp != nil {
		return mmWithoutAutoWakeUp.funcWithoutAutoWakeUp()
	}
	mmWithoutAutoWakeUp.t.Fatalf("Unexpected call to AsyncCallRequesterMock.WithoutAutoWakeUp.")
	return
}

// WithoutAutoWakeUpAfterCounter returns a count of finished AsyncCallRequesterMock.WithoutAutoWakeUp invocations
func (mmWithoutAutoWakeUp *AsyncCallRequesterMock) WithoutAutoWakeUpAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithoutAutoWakeUp.afterWithoutAutoWakeUpCounter)
}

// WithoutAutoWakeUpBeforeCounter returns a count of AsyncCallRequesterMock.WithoutAutoWakeUp invocations
func (mmWithoutAutoWakeUp *AsyncCallRequesterMock) WithoutAutoWakeUpBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithoutAutoWakeUp.beforeWithoutAutoWakeUpCounter)
}

// MinimockWithoutAutoWakeUpDone returns true if the count of the WithoutAutoWakeUp invocations corresponds
// the number of defined expectations
func (m *AsyncCallRequesterMock) MinimockWithoutAutoWakeUpDone() bool {
	for _, e := range m.WithoutAutoWakeUpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithoutAutoWakeUpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithoutAutoWakeUpCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithoutAutoWakeUp != nil && mm_atomic.LoadUint64(&m.afterWithoutAutoWakeUpCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithoutAutoWakeUpInspect logs each unmet expectation
func (m *AsyncCallRequesterMock) MinimockWithoutAutoWakeUpInspect() {
	for _, e := range m.WithoutAutoWakeUpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncCallRequesterMock.WithoutAutoWakeUp")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithoutAutoWakeUpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithoutAutoWakeUpCounter) < 1 {
		m.t.Error("Expected call to AsyncCallRequesterMock.WithoutAutoWakeUp")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithoutAutoWakeUp != nil && mm_atomic.LoadUint64(&m.afterWithoutAutoWakeUpCounter) < 1 {
		m.t.Error("Expected call to AsyncCallRequesterMock.WithoutAutoWakeUp")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AsyncCallRequesterMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDelayedStartInspect()

		m.MinimockStartInspect()

		m.MinimockWithCancelInspect()

		m.MinimockWithFlagsInspect()

		m.MinimockWithLogInspect()

		m.MinimockWithNestedInspect()

		m.MinimockWithoutAutoWakeUpInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AsyncCallRequesterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AsyncCallRequesterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDelayedStartDone() &&
		m.MinimockStartDone() &&
		m.MinimockWithCancelDone() &&
		m.MinimockWithFlagsDone() &&
		m.MinimockWithLogDone() &&
		m.MinimockWithNestedDone() &&
		m.MinimockWithoutAutoWakeUpDone()
}
