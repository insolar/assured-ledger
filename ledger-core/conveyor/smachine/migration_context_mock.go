package smachine

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// MigrationContextMock implements MigrationContext
type MigrationContextMock struct {
	t minimock.Tester

	funcAcquire          func(s1 SyncLink) (b1 BoolDecision)
	inspectFuncAcquire   func(s1 SyncLink)
	afterAcquireCounter  uint64
	beforeAcquireCounter uint64
	AcquireMock          mMigrationContextMockAcquire

	funcAcquireAndRelease          func(s1 SyncLink) (b1 BoolDecision)
	inspectFuncAcquireAndRelease   func(s1 SyncLink)
	afterAcquireAndReleaseCounter  uint64
	beforeAcquireAndReleaseCounter uint64
	AcquireAndReleaseMock          mMigrationContextMockAcquireAndRelease

	funcAcquireExt          func(s1 SyncLink, a1 AcquireFlags) (b1 BoolDecision)
	inspectFuncAcquireExt   func(s1 SyncLink, a1 AcquireFlags)
	afterAcquireExtCounter  uint64
	beforeAcquireExtCounter uint64
	AcquireExtMock          mMigrationContextMockAcquireExt

	funcAcquireForThisStep          func(s1 SyncLink) (b1 BoolDecision)
	inspectFuncAcquireForThisStep   func(s1 SyncLink)
	afterAcquireForThisStepCounter  uint64
	beforeAcquireForThisStepCounter uint64
	AcquireForThisStepMock          mMigrationContextMockAcquireForThisStep

	funcAcquireForThisStepAndRelease          func(s1 SyncLink) (b1 BoolDecision)
	inspectFuncAcquireForThisStepAndRelease   func(s1 SyncLink)
	afterAcquireForThisStepAndReleaseCounter  uint64
	beforeAcquireForThisStepAndReleaseCounter uint64
	AcquireForThisStepAndReleaseMock          mMigrationContextMockAcquireForThisStepAndRelease

	funcAffectedStep          func() (s1 SlotStep)
	inspectFuncAffectedStep   func()
	afterAffectedStepCounter  uint64
	beforeAffectedStepCounter uint64
	AffectedStepMock          mMigrationContextMockAffectedStep

	funcApplyAdjustment          func(s1 SyncAdjustment) (b1 bool)
	inspectFuncApplyAdjustment   func(s1 SyncAdjustment)
	afterApplyAdjustmentCounter  uint64
	beforeApplyAdjustmentCounter uint64
	ApplyAdjustmentMock          mMigrationContextMockApplyAdjustment

	funcCallSubroutine          func(s1 SubroutineStateMachine, m1 MigrateFunc, s2 SubroutineExitFunc) (s3 StateUpdate)
	inspectFuncCallSubroutine   func(s1 SubroutineStateMachine, m1 MigrateFunc, s2 SubroutineExitFunc)
	afterCallSubroutineCounter  uint64
	beforeCallSubroutineCounter uint64
	CallSubroutineMock          mMigrationContextMockCallSubroutine

	funcCheck          func(s1 SyncLink) (b1 BoolDecision)
	inspectFuncCheck   func(s1 SyncLink)
	afterCheckCounter  uint64
	beforeCheckCounter uint64
	CheckMock          mMigrationContextMockCheck

	funcError          func(e1 error) (s1 StateUpdate)
	inspectFuncError   func(e1 error)
	afterErrorCounter  uint64
	beforeErrorCounter uint64
	ErrorMock          mMigrationContextMockError

	funcGetContext          func() (c1 context.Context)
	inspectFuncGetContext   func()
	afterGetContextCounter  uint64
	beforeGetContextCounter uint64
	GetContextMock          mMigrationContextMockGetContext

	funcGetPublished          func(key interface{}) (p1 interface{})
	inspectFuncGetPublished   func(key interface{})
	afterGetPublishedCounter  uint64
	beforeGetPublishedCounter uint64
	GetPublishedMock          mMigrationContextMockGetPublished

	funcGetPublishedGlobalAlias          func(key interface{}) (s1 SlotLink)
	inspectFuncGetPublishedGlobalAlias   func(key interface{})
	afterGetPublishedGlobalAliasCounter  uint64
	beforeGetPublishedGlobalAliasCounter uint64
	GetPublishedGlobalAliasMock          mMigrationContextMockGetPublishedGlobalAlias

	funcGetPublishedGlobalAliasAndBargeIn          func(key interface{}) (s1 SlotLink, b1 BargeInHolder)
	inspectFuncGetPublishedGlobalAliasAndBargeIn   func(key interface{})
	afterGetPublishedGlobalAliasAndBargeInCounter  uint64
	beforeGetPublishedGlobalAliasAndBargeInCounter uint64
	GetPublishedGlobalAliasAndBargeInMock          mMigrationContextMockGetPublishedGlobalAliasAndBargeIn

	funcGetPublishedLink          func(key interface{}) (s1 SharedDataLink)
	inspectFuncGetPublishedLink   func(key interface{})
	afterGetPublishedLinkCounter  uint64
	beforeGetPublishedLinkCounter uint64
	GetPublishedLinkMock          mMigrationContextMockGetPublishedLink

	funcGetTerminationResult          func() (p1 interface{})
	inspectFuncGetTerminationResult   func()
	afterGetTerminationResultCounter  uint64
	beforeGetTerminationResultCounter uint64
	GetTerminationResultMock          mMigrationContextMockGetTerminationResult

	funcJump          func(s1 StateFunc) (s2 StateUpdate)
	inspectFuncJump   func(s1 StateFunc)
	afterJumpCounter  uint64
	beforeJumpCounter uint64
	JumpMock          mMigrationContextMockJump

	funcJumpExt          func(s1 SlotStep) (s2 StateUpdate)
	inspectFuncJumpExt   func(s1 SlotStep)
	afterJumpExtCounter  uint64
	beforeJumpExtCounter uint64
	JumpExtMock          mMigrationContextMockJumpExt

	funcLog          func() (l1 Logger)
	inspectFuncLog   func()
	afterLogCounter  uint64
	beforeLogCounter uint64
	LogMock          mMigrationContextMockLog

	funcNewBargeIn          func() (b1 BargeInBuilder)
	inspectFuncNewBargeIn   func()
	afterNewBargeInCounter  uint64
	beforeNewBargeInCounter uint64
	NewBargeInMock          mMigrationContextMockNewBargeIn

	funcNewBargeInWithParam          func(b1 BargeInApplyFunc) (b2 BargeInWithParam)
	inspectFuncNewBargeInWithParam   func(b1 BargeInApplyFunc)
	afterNewBargeInWithParamCounter  uint64
	beforeNewBargeInWithParamCounter uint64
	NewBargeInWithParamMock          mMigrationContextMockNewBargeInWithParam

	funcOverrideDynamicBoost          func(b1 bool)
	inspectFuncOverrideDynamicBoost   func(b1 bool)
	afterOverrideDynamicBoostCounter  uint64
	beforeOverrideDynamicBoostCounter uint64
	OverrideDynamicBoostMock          mMigrationContextMockOverrideDynamicBoost

	funcParentLink          func() (s1 SlotLink)
	inspectFuncParentLink   func()
	afterParentLinkCounter  uint64
	beforeParentLinkCounter uint64
	ParentLinkMock          mMigrationContextMockParentLink

	funcPublish          func(key interface{}, data interface{}) (b1 bool)
	inspectFuncPublish   func(key interface{}, data interface{})
	afterPublishCounter  uint64
	beforePublishCounter uint64
	PublishMock          mMigrationContextMockPublish

	funcPublishGlobalAlias          func(key interface{}) (b1 bool)
	inspectFuncPublishGlobalAlias   func(key interface{})
	afterPublishGlobalAliasCounter  uint64
	beforePublishGlobalAliasCounter uint64
	PublishGlobalAliasMock          mMigrationContextMockPublishGlobalAlias

	funcPublishGlobalAliasAndBargeIn          func(key interface{}, handler BargeInHolder) (b1 bool)
	inspectFuncPublishGlobalAliasAndBargeIn   func(key interface{}, handler BargeInHolder)
	afterPublishGlobalAliasAndBargeInCounter  uint64
	beforePublishGlobalAliasAndBargeInCounter uint64
	PublishGlobalAliasAndBargeInMock          mMigrationContextMockPublishGlobalAliasAndBargeIn

	funcPublishReplacement          func(key interface{}, data interface{}) (b1 bool)
	inspectFuncPublishReplacement   func(key interface{}, data interface{})
	afterPublishReplacementCounter  uint64
	beforePublishReplacementCounter uint64
	PublishReplacementMock          mMigrationContextMockPublishReplacement

	funcRelease          func(s1 SyncLink) (b1 bool)
	inspectFuncRelease   func(s1 SyncLink)
	afterReleaseCounter  uint64
	beforeReleaseCounter uint64
	ReleaseMock          mMigrationContextMockRelease

	funcReleaseAll          func() (b1 bool)
	inspectFuncReleaseAll   func()
	afterReleaseAllCounter  uint64
	beforeReleaseAllCounter uint64
	ReleaseAllMock          mMigrationContextMockReleaseAll

	funcRestoreStep          func(s1 SlotStep) (s2 StateUpdate)
	inspectFuncRestoreStep   func(s1 SlotStep)
	afterRestoreStepCounter  uint64
	beforeRestoreStepCounter uint64
	RestoreStepMock          mMigrationContextMockRestoreStep

	funcSetDefaultErrorHandler          func(e1 ErrorHandlerFunc)
	inspectFuncSetDefaultErrorHandler   func(e1 ErrorHandlerFunc)
	afterSetDefaultErrorHandlerCounter  uint64
	beforeSetDefaultErrorHandlerCounter uint64
	SetDefaultErrorHandlerMock          mMigrationContextMockSetDefaultErrorHandler

	funcSetDefaultFlags          func(s1 StepFlags)
	inspectFuncSetDefaultFlags   func(s1 StepFlags)
	afterSetDefaultFlagsCounter  uint64
	beforeSetDefaultFlagsCounter uint64
	SetDefaultFlagsMock          mMigrationContextMockSetDefaultFlags

	funcSetDefaultMigration          func(m1 MigrateFunc)
	inspectFuncSetDefaultMigration   func(m1 MigrateFunc)
	afterSetDefaultMigrationCounter  uint64
	beforeSetDefaultMigrationCounter uint64
	SetDefaultMigrationMock          mMigrationContextMockSetDefaultMigration

	funcSetFinalizer          func(f1 FinalizeFunc)
	inspectFuncSetFinalizer   func(f1 FinalizeFunc)
	afterSetFinalizerCounter  uint64
	beforeSetFinalizerCounter uint64
	SetFinalizerMock          mMigrationContextMockSetFinalizer

	funcSetLogTracing          func(b1 bool)
	inspectFuncSetLogTracing   func(b1 bool)
	afterSetLogTracingCounter  uint64
	beforeSetLogTracingCounter uint64
	SetLogTracingMock          mMigrationContextMockSetLogTracing

	funcSetTerminationResult          func(p1 interface{})
	inspectFuncSetTerminationResult   func(p1 interface{})
	afterSetTerminationResultCounter  uint64
	beforeSetTerminationResultCounter uint64
	SetTerminationResultMock          mMigrationContextMockSetTerminationResult

	funcShare          func(data interface{}, flags ShareDataFlags) (s1 SharedDataLink)
	inspectFuncShare   func(data interface{}, flags ShareDataFlags)
	afterShareCounter  uint64
	beforeShareCounter uint64
	ShareMock          mMigrationContextMockShare

	funcSkipMultipleMigrations          func()
	inspectFuncSkipMultipleMigrations   func()
	afterSkipMultipleMigrationsCounter  uint64
	beforeSkipMultipleMigrationsCounter uint64
	SkipMultipleMigrationsMock          mMigrationContextMockSkipMultipleMigrations

	funcSlotLink          func() (s1 SlotLink)
	inspectFuncSlotLink   func()
	afterSlotLinkCounter  uint64
	beforeSlotLinkCounter uint64
	SlotLinkMock          mMigrationContextMockSlotLink

	funcStay          func() (s1 StateUpdate)
	inspectFuncStay   func()
	afterStayCounter  uint64
	beforeStayCounter uint64
	StayMock          mMigrationContextMockStay

	funcStop          func() (s1 StateUpdate)
	inspectFuncStop   func()
	afterStopCounter  uint64
	beforeStopCounter uint64
	StopMock          mMigrationContextMockStop

	funcUnpublish          func(key interface{}) (b1 bool)
	inspectFuncUnpublish   func(key interface{})
	afterUnpublishCounter  uint64
	beforeUnpublishCounter uint64
	UnpublishMock          mMigrationContextMockUnpublish

	funcUnpublishAll          func()
	inspectFuncUnpublishAll   func()
	afterUnpublishAllCounter  uint64
	beforeUnpublishAllCounter uint64
	UnpublishAllMock          mMigrationContextMockUnpublishAll

	funcUnpublishGlobalAlias          func(key interface{}) (b1 bool)
	inspectFuncUnpublishGlobalAlias   func(key interface{})
	afterUnpublishGlobalAliasCounter  uint64
	beforeUnpublishGlobalAliasCounter uint64
	UnpublishGlobalAliasMock          mMigrationContextMockUnpublishGlobalAlias

	funcUnshare          func(s1 SharedDataLink) (b1 bool)
	inspectFuncUnshare   func(s1 SharedDataLink)
	afterUnshareCounter  uint64
	beforeUnshareCounter uint64
	UnshareMock          mMigrationContextMockUnshare

	funcUpdateDefaultStepLogger          func(s1 StepLoggerUpdateFunc)
	inspectFuncUpdateDefaultStepLogger   func(s1 StepLoggerUpdateFunc)
	afterUpdateDefaultStepLoggerCounter  uint64
	beforeUpdateDefaultStepLoggerCounter uint64
	UpdateDefaultStepLoggerMock          mMigrationContextMockUpdateDefaultStepLogger

	funcWakeUp          func() (s1 StateUpdate)
	inspectFuncWakeUp   func()
	afterWakeUpCounter  uint64
	beforeWakeUpCounter uint64
	WakeUpMock          mMigrationContextMockWakeUp
}

// NewMigrationContextMock returns a mock for MigrationContext
func NewMigrationContextMock(t minimock.Tester) *MigrationContextMock {
	m := &MigrationContextMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AcquireMock = mMigrationContextMockAcquire{mock: m}
	m.AcquireMock.callArgs = []*MigrationContextMockAcquireParams{}

	m.AcquireAndReleaseMock = mMigrationContextMockAcquireAndRelease{mock: m}
	m.AcquireAndReleaseMock.callArgs = []*MigrationContextMockAcquireAndReleaseParams{}

	m.AcquireExtMock = mMigrationContextMockAcquireExt{mock: m}
	m.AcquireExtMock.callArgs = []*MigrationContextMockAcquireExtParams{}

	m.AcquireForThisStepMock = mMigrationContextMockAcquireForThisStep{mock: m}
	m.AcquireForThisStepMock.callArgs = []*MigrationContextMockAcquireForThisStepParams{}

	m.AcquireForThisStepAndReleaseMock = mMigrationContextMockAcquireForThisStepAndRelease{mock: m}
	m.AcquireForThisStepAndReleaseMock.callArgs = []*MigrationContextMockAcquireForThisStepAndReleaseParams{}

	m.AffectedStepMock = mMigrationContextMockAffectedStep{mock: m}

	m.ApplyAdjustmentMock = mMigrationContextMockApplyAdjustment{mock: m}
	m.ApplyAdjustmentMock.callArgs = []*MigrationContextMockApplyAdjustmentParams{}

	m.CallSubroutineMock = mMigrationContextMockCallSubroutine{mock: m}
	m.CallSubroutineMock.callArgs = []*MigrationContextMockCallSubroutineParams{}

	m.CheckMock = mMigrationContextMockCheck{mock: m}
	m.CheckMock.callArgs = []*MigrationContextMockCheckParams{}

	m.ErrorMock = mMigrationContextMockError{mock: m}
	m.ErrorMock.callArgs = []*MigrationContextMockErrorParams{}

	m.GetContextMock = mMigrationContextMockGetContext{mock: m}

	m.GetPublishedMock = mMigrationContextMockGetPublished{mock: m}
	m.GetPublishedMock.callArgs = []*MigrationContextMockGetPublishedParams{}

	m.GetPublishedGlobalAliasMock = mMigrationContextMockGetPublishedGlobalAlias{mock: m}
	m.GetPublishedGlobalAliasMock.callArgs = []*MigrationContextMockGetPublishedGlobalAliasParams{}

	m.GetPublishedGlobalAliasAndBargeInMock = mMigrationContextMockGetPublishedGlobalAliasAndBargeIn{mock: m}
	m.GetPublishedGlobalAliasAndBargeInMock.callArgs = []*MigrationContextMockGetPublishedGlobalAliasAndBargeInParams{}

	m.GetPublishedLinkMock = mMigrationContextMockGetPublishedLink{mock: m}
	m.GetPublishedLinkMock.callArgs = []*MigrationContextMockGetPublishedLinkParams{}

	m.GetTerminationResultMock = mMigrationContextMockGetTerminationResult{mock: m}

	m.JumpMock = mMigrationContextMockJump{mock: m}
	m.JumpMock.callArgs = []*MigrationContextMockJumpParams{}

	m.JumpExtMock = mMigrationContextMockJumpExt{mock: m}
	m.JumpExtMock.callArgs = []*MigrationContextMockJumpExtParams{}

	m.LogMock = mMigrationContextMockLog{mock: m}

	m.NewBargeInMock = mMigrationContextMockNewBargeIn{mock: m}

	m.NewBargeInWithParamMock = mMigrationContextMockNewBargeInWithParam{mock: m}
	m.NewBargeInWithParamMock.callArgs = []*MigrationContextMockNewBargeInWithParamParams{}

	m.OverrideDynamicBoostMock = mMigrationContextMockOverrideDynamicBoost{mock: m}
	m.OverrideDynamicBoostMock.callArgs = []*MigrationContextMockOverrideDynamicBoostParams{}

	m.ParentLinkMock = mMigrationContextMockParentLink{mock: m}

	m.PublishMock = mMigrationContextMockPublish{mock: m}
	m.PublishMock.callArgs = []*MigrationContextMockPublishParams{}

	m.PublishGlobalAliasMock = mMigrationContextMockPublishGlobalAlias{mock: m}
	m.PublishGlobalAliasMock.callArgs = []*MigrationContextMockPublishGlobalAliasParams{}

	m.PublishGlobalAliasAndBargeInMock = mMigrationContextMockPublishGlobalAliasAndBargeIn{mock: m}
	m.PublishGlobalAliasAndBargeInMock.callArgs = []*MigrationContextMockPublishGlobalAliasAndBargeInParams{}

	m.PublishReplacementMock = mMigrationContextMockPublishReplacement{mock: m}
	m.PublishReplacementMock.callArgs = []*MigrationContextMockPublishReplacementParams{}

	m.ReleaseMock = mMigrationContextMockRelease{mock: m}
	m.ReleaseMock.callArgs = []*MigrationContextMockReleaseParams{}

	m.ReleaseAllMock = mMigrationContextMockReleaseAll{mock: m}

	m.RestoreStepMock = mMigrationContextMockRestoreStep{mock: m}
	m.RestoreStepMock.callArgs = []*MigrationContextMockRestoreStepParams{}

	m.SetDefaultErrorHandlerMock = mMigrationContextMockSetDefaultErrorHandler{mock: m}
	m.SetDefaultErrorHandlerMock.callArgs = []*MigrationContextMockSetDefaultErrorHandlerParams{}

	m.SetDefaultFlagsMock = mMigrationContextMockSetDefaultFlags{mock: m}
	m.SetDefaultFlagsMock.callArgs = []*MigrationContextMockSetDefaultFlagsParams{}

	m.SetDefaultMigrationMock = mMigrationContextMockSetDefaultMigration{mock: m}
	m.SetDefaultMigrationMock.callArgs = []*MigrationContextMockSetDefaultMigrationParams{}

	m.SetFinalizerMock = mMigrationContextMockSetFinalizer{mock: m}
	m.SetFinalizerMock.callArgs = []*MigrationContextMockSetFinalizerParams{}

	m.SetLogTracingMock = mMigrationContextMockSetLogTracing{mock: m}
	m.SetLogTracingMock.callArgs = []*MigrationContextMockSetLogTracingParams{}

	m.SetTerminationResultMock = mMigrationContextMockSetTerminationResult{mock: m}
	m.SetTerminationResultMock.callArgs = []*MigrationContextMockSetTerminationResultParams{}

	m.ShareMock = mMigrationContextMockShare{mock: m}
	m.ShareMock.callArgs = []*MigrationContextMockShareParams{}

	m.SkipMultipleMigrationsMock = mMigrationContextMockSkipMultipleMigrations{mock: m}

	m.SlotLinkMock = mMigrationContextMockSlotLink{mock: m}

	m.StayMock = mMigrationContextMockStay{mock: m}

	m.StopMock = mMigrationContextMockStop{mock: m}

	m.UnpublishMock = mMigrationContextMockUnpublish{mock: m}
	m.UnpublishMock.callArgs = []*MigrationContextMockUnpublishParams{}

	m.UnpublishAllMock = mMigrationContextMockUnpublishAll{mock: m}

	m.UnpublishGlobalAliasMock = mMigrationContextMockUnpublishGlobalAlias{mock: m}
	m.UnpublishGlobalAliasMock.callArgs = []*MigrationContextMockUnpublishGlobalAliasParams{}

	m.UnshareMock = mMigrationContextMockUnshare{mock: m}
	m.UnshareMock.callArgs = []*MigrationContextMockUnshareParams{}

	m.UpdateDefaultStepLoggerMock = mMigrationContextMockUpdateDefaultStepLogger{mock: m}
	m.UpdateDefaultStepLoggerMock.callArgs = []*MigrationContextMockUpdateDefaultStepLoggerParams{}

	m.WakeUpMock = mMigrationContextMockWakeUp{mock: m}

	return m
}

type mMigrationContextMockAcquire struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockAcquireExpectation
	expectations       []*MigrationContextMockAcquireExpectation

	callArgs []*MigrationContextMockAcquireParams
	mutex    sync.RWMutex
}

// MigrationContextMockAcquireExpectation specifies expectation struct of the MigrationContext.Acquire
type MigrationContextMockAcquireExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockAcquireParams
	results *MigrationContextMockAcquireResults
	Counter uint64
}

// MigrationContextMockAcquireParams contains parameters of the MigrationContext.Acquire
type MigrationContextMockAcquireParams struct {
	s1 SyncLink
}

// MigrationContextMockAcquireResults contains results of the MigrationContext.Acquire
type MigrationContextMockAcquireResults struct {
	b1 BoolDecision
}

// Expect sets up expected params for MigrationContext.Acquire
func (mmAcquire *mMigrationContextMockAcquire) Expect(s1 SyncLink) *mMigrationContextMockAcquire {
	if mmAcquire.mock.funcAcquire != nil {
		mmAcquire.mock.t.Fatalf("MigrationContextMock.Acquire mock is already set by Set")
	}

	if mmAcquire.defaultExpectation == nil {
		mmAcquire.defaultExpectation = &MigrationContextMockAcquireExpectation{}
	}

	mmAcquire.defaultExpectation.params = &MigrationContextMockAcquireParams{s1}
	for _, e := range mmAcquire.expectations {
		if minimock.Equal(e.params, mmAcquire.defaultExpectation.params) {
			mmAcquire.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcquire.defaultExpectation.params)
		}
	}

	return mmAcquire
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.Acquire
func (mmAcquire *mMigrationContextMockAcquire) Inspect(f func(s1 SyncLink)) *mMigrationContextMockAcquire {
	if mmAcquire.mock.inspectFuncAcquire != nil {
		mmAcquire.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.Acquire")
	}

	mmAcquire.mock.inspectFuncAcquire = f

	return mmAcquire
}

// Return sets up results that will be returned by MigrationContext.Acquire
func (mmAcquire *mMigrationContextMockAcquire) Return(b1 BoolDecision) *MigrationContextMock {
	if mmAcquire.mock.funcAcquire != nil {
		mmAcquire.mock.t.Fatalf("MigrationContextMock.Acquire mock is already set by Set")
	}

	if mmAcquire.defaultExpectation == nil {
		mmAcquire.defaultExpectation = &MigrationContextMockAcquireExpectation{mock: mmAcquire.mock}
	}
	mmAcquire.defaultExpectation.results = &MigrationContextMockAcquireResults{b1}
	return mmAcquire.mock
}

//Set uses given function f to mock the MigrationContext.Acquire method
func (mmAcquire *mMigrationContextMockAcquire) Set(f func(s1 SyncLink) (b1 BoolDecision)) *MigrationContextMock {
	if mmAcquire.defaultExpectation != nil {
		mmAcquire.mock.t.Fatalf("Default expectation is already set for the MigrationContext.Acquire method")
	}

	if len(mmAcquire.expectations) > 0 {
		mmAcquire.mock.t.Fatalf("Some expectations are already set for the MigrationContext.Acquire method")
	}

	mmAcquire.mock.funcAcquire = f
	return mmAcquire.mock
}

// When sets expectation for the MigrationContext.Acquire which will trigger the result defined by the following
// Then helper
func (mmAcquire *mMigrationContextMockAcquire) When(s1 SyncLink) *MigrationContextMockAcquireExpectation {
	if mmAcquire.mock.funcAcquire != nil {
		mmAcquire.mock.t.Fatalf("MigrationContextMock.Acquire mock is already set by Set")
	}

	expectation := &MigrationContextMockAcquireExpectation{
		mock:   mmAcquire.mock,
		params: &MigrationContextMockAcquireParams{s1},
	}
	mmAcquire.expectations = append(mmAcquire.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.Acquire return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockAcquireExpectation) Then(b1 BoolDecision) *MigrationContextMock {
	e.results = &MigrationContextMockAcquireResults{b1}
	return e.mock
}

// Acquire implements MigrationContext
func (mmAcquire *MigrationContextMock) Acquire(s1 SyncLink) (b1 BoolDecision) {
	mm_atomic.AddUint64(&mmAcquire.beforeAcquireCounter, 1)
	defer mm_atomic.AddUint64(&mmAcquire.afterAcquireCounter, 1)

	if mmAcquire.inspectFuncAcquire != nil {
		mmAcquire.inspectFuncAcquire(s1)
	}

	mm_params := &MigrationContextMockAcquireParams{s1}

	// Record call args
	mmAcquire.AcquireMock.mutex.Lock()
	mmAcquire.AcquireMock.callArgs = append(mmAcquire.AcquireMock.callArgs, mm_params)
	mmAcquire.AcquireMock.mutex.Unlock()

	for _, e := range mmAcquire.AcquireMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmAcquire.AcquireMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcquire.AcquireMock.defaultExpectation.Counter, 1)
		mm_want := mmAcquire.AcquireMock.defaultExpectation.params
		mm_got := MigrationContextMockAcquireParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcquire.t.Errorf("MigrationContextMock.Acquire got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcquire.AcquireMock.defaultExpectation.results
		if mm_results == nil {
			mmAcquire.t.Fatal("No results are set for the MigrationContextMock.Acquire")
		}
		return (*mm_results).b1
	}
	if mmAcquire.funcAcquire != nil {
		return mmAcquire.funcAcquire(s1)
	}
	mmAcquire.t.Fatalf("Unexpected call to MigrationContextMock.Acquire. %v", s1)
	return
}

// AcquireAfterCounter returns a count of finished MigrationContextMock.Acquire invocations
func (mmAcquire *MigrationContextMock) AcquireAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquire.afterAcquireCounter)
}

// AcquireBeforeCounter returns a count of MigrationContextMock.Acquire invocations
func (mmAcquire *MigrationContextMock) AcquireBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquire.beforeAcquireCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.Acquire.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcquire *mMigrationContextMockAcquire) Calls() []*MigrationContextMockAcquireParams {
	mmAcquire.mutex.RLock()

	argCopy := make([]*MigrationContextMockAcquireParams, len(mmAcquire.callArgs))
	copy(argCopy, mmAcquire.callArgs)

	mmAcquire.mutex.RUnlock()

	return argCopy
}

// MinimockAcquireDone returns true if the count of the Acquire invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockAcquireDone() bool {
	for _, e := range m.AcquireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquire != nil && mm_atomic.LoadUint64(&m.afterAcquireCounter) < 1 {
		return false
	}
	return true
}

// MinimockAcquireInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockAcquireInspect() {
	for _, e := range m.AcquireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.Acquire with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireCounter) < 1 {
		if m.AcquireMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.Acquire")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.Acquire with params: %#v", *m.AcquireMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquire != nil && mm_atomic.LoadUint64(&m.afterAcquireCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.Acquire")
	}
}

type mMigrationContextMockAcquireAndRelease struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockAcquireAndReleaseExpectation
	expectations       []*MigrationContextMockAcquireAndReleaseExpectation

	callArgs []*MigrationContextMockAcquireAndReleaseParams
	mutex    sync.RWMutex
}

// MigrationContextMockAcquireAndReleaseExpectation specifies expectation struct of the MigrationContext.AcquireAndRelease
type MigrationContextMockAcquireAndReleaseExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockAcquireAndReleaseParams
	results *MigrationContextMockAcquireAndReleaseResults
	Counter uint64
}

// MigrationContextMockAcquireAndReleaseParams contains parameters of the MigrationContext.AcquireAndRelease
type MigrationContextMockAcquireAndReleaseParams struct {
	s1 SyncLink
}

// MigrationContextMockAcquireAndReleaseResults contains results of the MigrationContext.AcquireAndRelease
type MigrationContextMockAcquireAndReleaseResults struct {
	b1 BoolDecision
}

// Expect sets up expected params for MigrationContext.AcquireAndRelease
func (mmAcquireAndRelease *mMigrationContextMockAcquireAndRelease) Expect(s1 SyncLink) *mMigrationContextMockAcquireAndRelease {
	if mmAcquireAndRelease.mock.funcAcquireAndRelease != nil {
		mmAcquireAndRelease.mock.t.Fatalf("MigrationContextMock.AcquireAndRelease mock is already set by Set")
	}

	if mmAcquireAndRelease.defaultExpectation == nil {
		mmAcquireAndRelease.defaultExpectation = &MigrationContextMockAcquireAndReleaseExpectation{}
	}

	mmAcquireAndRelease.defaultExpectation.params = &MigrationContextMockAcquireAndReleaseParams{s1}
	for _, e := range mmAcquireAndRelease.expectations {
		if minimock.Equal(e.params, mmAcquireAndRelease.defaultExpectation.params) {
			mmAcquireAndRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcquireAndRelease.defaultExpectation.params)
		}
	}

	return mmAcquireAndRelease
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.AcquireAndRelease
func (mmAcquireAndRelease *mMigrationContextMockAcquireAndRelease) Inspect(f func(s1 SyncLink)) *mMigrationContextMockAcquireAndRelease {
	if mmAcquireAndRelease.mock.inspectFuncAcquireAndRelease != nil {
		mmAcquireAndRelease.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.AcquireAndRelease")
	}

	mmAcquireAndRelease.mock.inspectFuncAcquireAndRelease = f

	return mmAcquireAndRelease
}

// Return sets up results that will be returned by MigrationContext.AcquireAndRelease
func (mmAcquireAndRelease *mMigrationContextMockAcquireAndRelease) Return(b1 BoolDecision) *MigrationContextMock {
	if mmAcquireAndRelease.mock.funcAcquireAndRelease != nil {
		mmAcquireAndRelease.mock.t.Fatalf("MigrationContextMock.AcquireAndRelease mock is already set by Set")
	}

	if mmAcquireAndRelease.defaultExpectation == nil {
		mmAcquireAndRelease.defaultExpectation = &MigrationContextMockAcquireAndReleaseExpectation{mock: mmAcquireAndRelease.mock}
	}
	mmAcquireAndRelease.defaultExpectation.results = &MigrationContextMockAcquireAndReleaseResults{b1}
	return mmAcquireAndRelease.mock
}

//Set uses given function f to mock the MigrationContext.AcquireAndRelease method
func (mmAcquireAndRelease *mMigrationContextMockAcquireAndRelease) Set(f func(s1 SyncLink) (b1 BoolDecision)) *MigrationContextMock {
	if mmAcquireAndRelease.defaultExpectation != nil {
		mmAcquireAndRelease.mock.t.Fatalf("Default expectation is already set for the MigrationContext.AcquireAndRelease method")
	}

	if len(mmAcquireAndRelease.expectations) > 0 {
		mmAcquireAndRelease.mock.t.Fatalf("Some expectations are already set for the MigrationContext.AcquireAndRelease method")
	}

	mmAcquireAndRelease.mock.funcAcquireAndRelease = f
	return mmAcquireAndRelease.mock
}

// When sets expectation for the MigrationContext.AcquireAndRelease which will trigger the result defined by the following
// Then helper
func (mmAcquireAndRelease *mMigrationContextMockAcquireAndRelease) When(s1 SyncLink) *MigrationContextMockAcquireAndReleaseExpectation {
	if mmAcquireAndRelease.mock.funcAcquireAndRelease != nil {
		mmAcquireAndRelease.mock.t.Fatalf("MigrationContextMock.AcquireAndRelease mock is already set by Set")
	}

	expectation := &MigrationContextMockAcquireAndReleaseExpectation{
		mock:   mmAcquireAndRelease.mock,
		params: &MigrationContextMockAcquireAndReleaseParams{s1},
	}
	mmAcquireAndRelease.expectations = append(mmAcquireAndRelease.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.AcquireAndRelease return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockAcquireAndReleaseExpectation) Then(b1 BoolDecision) *MigrationContextMock {
	e.results = &MigrationContextMockAcquireAndReleaseResults{b1}
	return e.mock
}

// AcquireAndRelease implements MigrationContext
func (mmAcquireAndRelease *MigrationContextMock) AcquireAndRelease(s1 SyncLink) (b1 BoolDecision) {
	mm_atomic.AddUint64(&mmAcquireAndRelease.beforeAcquireAndReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmAcquireAndRelease.afterAcquireAndReleaseCounter, 1)

	if mmAcquireAndRelease.inspectFuncAcquireAndRelease != nil {
		mmAcquireAndRelease.inspectFuncAcquireAndRelease(s1)
	}

	mm_params := &MigrationContextMockAcquireAndReleaseParams{s1}

	// Record call args
	mmAcquireAndRelease.AcquireAndReleaseMock.mutex.Lock()
	mmAcquireAndRelease.AcquireAndReleaseMock.callArgs = append(mmAcquireAndRelease.AcquireAndReleaseMock.callArgs, mm_params)
	mmAcquireAndRelease.AcquireAndReleaseMock.mutex.Unlock()

	for _, e := range mmAcquireAndRelease.AcquireAndReleaseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmAcquireAndRelease.AcquireAndReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcquireAndRelease.AcquireAndReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmAcquireAndRelease.AcquireAndReleaseMock.defaultExpectation.params
		mm_got := MigrationContextMockAcquireAndReleaseParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcquireAndRelease.t.Errorf("MigrationContextMock.AcquireAndRelease got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcquireAndRelease.AcquireAndReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmAcquireAndRelease.t.Fatal("No results are set for the MigrationContextMock.AcquireAndRelease")
		}
		return (*mm_results).b1
	}
	if mmAcquireAndRelease.funcAcquireAndRelease != nil {
		return mmAcquireAndRelease.funcAcquireAndRelease(s1)
	}
	mmAcquireAndRelease.t.Fatalf("Unexpected call to MigrationContextMock.AcquireAndRelease. %v", s1)
	return
}

// AcquireAndReleaseAfterCounter returns a count of finished MigrationContextMock.AcquireAndRelease invocations
func (mmAcquireAndRelease *MigrationContextMock) AcquireAndReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireAndRelease.afterAcquireAndReleaseCounter)
}

// AcquireAndReleaseBeforeCounter returns a count of MigrationContextMock.AcquireAndRelease invocations
func (mmAcquireAndRelease *MigrationContextMock) AcquireAndReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireAndRelease.beforeAcquireAndReleaseCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.AcquireAndRelease.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcquireAndRelease *mMigrationContextMockAcquireAndRelease) Calls() []*MigrationContextMockAcquireAndReleaseParams {
	mmAcquireAndRelease.mutex.RLock()

	argCopy := make([]*MigrationContextMockAcquireAndReleaseParams, len(mmAcquireAndRelease.callArgs))
	copy(argCopy, mmAcquireAndRelease.callArgs)

	mmAcquireAndRelease.mutex.RUnlock()

	return argCopy
}

// MinimockAcquireAndReleaseDone returns true if the count of the AcquireAndRelease invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockAcquireAndReleaseDone() bool {
	for _, e := range m.AcquireAndReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireAndReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireAndReleaseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireAndRelease != nil && mm_atomic.LoadUint64(&m.afterAcquireAndReleaseCounter) < 1 {
		return false
	}
	return true
}

// MinimockAcquireAndReleaseInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockAcquireAndReleaseInspect() {
	for _, e := range m.AcquireAndReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.AcquireAndRelease with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireAndReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireAndReleaseCounter) < 1 {
		if m.AcquireAndReleaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.AcquireAndRelease")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.AcquireAndRelease with params: %#v", *m.AcquireAndReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireAndRelease != nil && mm_atomic.LoadUint64(&m.afterAcquireAndReleaseCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.AcquireAndRelease")
	}
}

type mMigrationContextMockAcquireExt struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockAcquireExtExpectation
	expectations       []*MigrationContextMockAcquireExtExpectation

	callArgs []*MigrationContextMockAcquireExtParams
	mutex    sync.RWMutex
}

// MigrationContextMockAcquireExtExpectation specifies expectation struct of the MigrationContext.AcquireExt
type MigrationContextMockAcquireExtExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockAcquireExtParams
	results *MigrationContextMockAcquireExtResults
	Counter uint64
}

// MigrationContextMockAcquireExtParams contains parameters of the MigrationContext.AcquireExt
type MigrationContextMockAcquireExtParams struct {
	s1 SyncLink
	a1 AcquireFlags
}

// MigrationContextMockAcquireExtResults contains results of the MigrationContext.AcquireExt
type MigrationContextMockAcquireExtResults struct {
	b1 BoolDecision
}

// Expect sets up expected params for MigrationContext.AcquireExt
func (mmAcquireExt *mMigrationContextMockAcquireExt) Expect(s1 SyncLink, a1 AcquireFlags) *mMigrationContextMockAcquireExt {
	if mmAcquireExt.mock.funcAcquireExt != nil {
		mmAcquireExt.mock.t.Fatalf("MigrationContextMock.AcquireExt mock is already set by Set")
	}

	if mmAcquireExt.defaultExpectation == nil {
		mmAcquireExt.defaultExpectation = &MigrationContextMockAcquireExtExpectation{}
	}

	mmAcquireExt.defaultExpectation.params = &MigrationContextMockAcquireExtParams{s1, a1}
	for _, e := range mmAcquireExt.expectations {
		if minimock.Equal(e.params, mmAcquireExt.defaultExpectation.params) {
			mmAcquireExt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcquireExt.defaultExpectation.params)
		}
	}

	return mmAcquireExt
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.AcquireExt
func (mmAcquireExt *mMigrationContextMockAcquireExt) Inspect(f func(s1 SyncLink, a1 AcquireFlags)) *mMigrationContextMockAcquireExt {
	if mmAcquireExt.mock.inspectFuncAcquireExt != nil {
		mmAcquireExt.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.AcquireExt")
	}

	mmAcquireExt.mock.inspectFuncAcquireExt = f

	return mmAcquireExt
}

// Return sets up results that will be returned by MigrationContext.AcquireExt
func (mmAcquireExt *mMigrationContextMockAcquireExt) Return(b1 BoolDecision) *MigrationContextMock {
	if mmAcquireExt.mock.funcAcquireExt != nil {
		mmAcquireExt.mock.t.Fatalf("MigrationContextMock.AcquireExt mock is already set by Set")
	}

	if mmAcquireExt.defaultExpectation == nil {
		mmAcquireExt.defaultExpectation = &MigrationContextMockAcquireExtExpectation{mock: mmAcquireExt.mock}
	}
	mmAcquireExt.defaultExpectation.results = &MigrationContextMockAcquireExtResults{b1}
	return mmAcquireExt.mock
}

//Set uses given function f to mock the MigrationContext.AcquireExt method
func (mmAcquireExt *mMigrationContextMockAcquireExt) Set(f func(s1 SyncLink, a1 AcquireFlags) (b1 BoolDecision)) *MigrationContextMock {
	if mmAcquireExt.defaultExpectation != nil {
		mmAcquireExt.mock.t.Fatalf("Default expectation is already set for the MigrationContext.AcquireExt method")
	}

	if len(mmAcquireExt.expectations) > 0 {
		mmAcquireExt.mock.t.Fatalf("Some expectations are already set for the MigrationContext.AcquireExt method")
	}

	mmAcquireExt.mock.funcAcquireExt = f
	return mmAcquireExt.mock
}

// When sets expectation for the MigrationContext.AcquireExt which will trigger the result defined by the following
// Then helper
func (mmAcquireExt *mMigrationContextMockAcquireExt) When(s1 SyncLink, a1 AcquireFlags) *MigrationContextMockAcquireExtExpectation {
	if mmAcquireExt.mock.funcAcquireExt != nil {
		mmAcquireExt.mock.t.Fatalf("MigrationContextMock.AcquireExt mock is already set by Set")
	}

	expectation := &MigrationContextMockAcquireExtExpectation{
		mock:   mmAcquireExt.mock,
		params: &MigrationContextMockAcquireExtParams{s1, a1},
	}
	mmAcquireExt.expectations = append(mmAcquireExt.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.AcquireExt return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockAcquireExtExpectation) Then(b1 BoolDecision) *MigrationContextMock {
	e.results = &MigrationContextMockAcquireExtResults{b1}
	return e.mock
}

// AcquireExt implements MigrationContext
func (mmAcquireExt *MigrationContextMock) AcquireExt(s1 SyncLink, a1 AcquireFlags) (b1 BoolDecision) {
	mm_atomic.AddUint64(&mmAcquireExt.beforeAcquireExtCounter, 1)
	defer mm_atomic.AddUint64(&mmAcquireExt.afterAcquireExtCounter, 1)

	if mmAcquireExt.inspectFuncAcquireExt != nil {
		mmAcquireExt.inspectFuncAcquireExt(s1, a1)
	}

	mm_params := &MigrationContextMockAcquireExtParams{s1, a1}

	// Record call args
	mmAcquireExt.AcquireExtMock.mutex.Lock()
	mmAcquireExt.AcquireExtMock.callArgs = append(mmAcquireExt.AcquireExtMock.callArgs, mm_params)
	mmAcquireExt.AcquireExtMock.mutex.Unlock()

	for _, e := range mmAcquireExt.AcquireExtMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmAcquireExt.AcquireExtMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcquireExt.AcquireExtMock.defaultExpectation.Counter, 1)
		mm_want := mmAcquireExt.AcquireExtMock.defaultExpectation.params
		mm_got := MigrationContextMockAcquireExtParams{s1, a1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcquireExt.t.Errorf("MigrationContextMock.AcquireExt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcquireExt.AcquireExtMock.defaultExpectation.results
		if mm_results == nil {
			mmAcquireExt.t.Fatal("No results are set for the MigrationContextMock.AcquireExt")
		}
		return (*mm_results).b1
	}
	if mmAcquireExt.funcAcquireExt != nil {
		return mmAcquireExt.funcAcquireExt(s1, a1)
	}
	mmAcquireExt.t.Fatalf("Unexpected call to MigrationContextMock.AcquireExt. %v %v", s1, a1)
	return
}

// AcquireExtAfterCounter returns a count of finished MigrationContextMock.AcquireExt invocations
func (mmAcquireExt *MigrationContextMock) AcquireExtAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireExt.afterAcquireExtCounter)
}

// AcquireExtBeforeCounter returns a count of MigrationContextMock.AcquireExt invocations
func (mmAcquireExt *MigrationContextMock) AcquireExtBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireExt.beforeAcquireExtCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.AcquireExt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcquireExt *mMigrationContextMockAcquireExt) Calls() []*MigrationContextMockAcquireExtParams {
	mmAcquireExt.mutex.RLock()

	argCopy := make([]*MigrationContextMockAcquireExtParams, len(mmAcquireExt.callArgs))
	copy(argCopy, mmAcquireExt.callArgs)

	mmAcquireExt.mutex.RUnlock()

	return argCopy
}

// MinimockAcquireExtDone returns true if the count of the AcquireExt invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockAcquireExtDone() bool {
	for _, e := range m.AcquireExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireExtCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireExt != nil && mm_atomic.LoadUint64(&m.afterAcquireExtCounter) < 1 {
		return false
	}
	return true
}

// MinimockAcquireExtInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockAcquireExtInspect() {
	for _, e := range m.AcquireExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.AcquireExt with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireExtCounter) < 1 {
		if m.AcquireExtMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.AcquireExt")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.AcquireExt with params: %#v", *m.AcquireExtMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireExt != nil && mm_atomic.LoadUint64(&m.afterAcquireExtCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.AcquireExt")
	}
}

type mMigrationContextMockAcquireForThisStep struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockAcquireForThisStepExpectation
	expectations       []*MigrationContextMockAcquireForThisStepExpectation

	callArgs []*MigrationContextMockAcquireForThisStepParams
	mutex    sync.RWMutex
}

// MigrationContextMockAcquireForThisStepExpectation specifies expectation struct of the MigrationContext.AcquireForThisStep
type MigrationContextMockAcquireForThisStepExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockAcquireForThisStepParams
	results *MigrationContextMockAcquireForThisStepResults
	Counter uint64
}

// MigrationContextMockAcquireForThisStepParams contains parameters of the MigrationContext.AcquireForThisStep
type MigrationContextMockAcquireForThisStepParams struct {
	s1 SyncLink
}

// MigrationContextMockAcquireForThisStepResults contains results of the MigrationContext.AcquireForThisStep
type MigrationContextMockAcquireForThisStepResults struct {
	b1 BoolDecision
}

// Expect sets up expected params for MigrationContext.AcquireForThisStep
func (mmAcquireForThisStep *mMigrationContextMockAcquireForThisStep) Expect(s1 SyncLink) *mMigrationContextMockAcquireForThisStep {
	if mmAcquireForThisStep.mock.funcAcquireForThisStep != nil {
		mmAcquireForThisStep.mock.t.Fatalf("MigrationContextMock.AcquireForThisStep mock is already set by Set")
	}

	if mmAcquireForThisStep.defaultExpectation == nil {
		mmAcquireForThisStep.defaultExpectation = &MigrationContextMockAcquireForThisStepExpectation{}
	}

	mmAcquireForThisStep.defaultExpectation.params = &MigrationContextMockAcquireForThisStepParams{s1}
	for _, e := range mmAcquireForThisStep.expectations {
		if minimock.Equal(e.params, mmAcquireForThisStep.defaultExpectation.params) {
			mmAcquireForThisStep.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcquireForThisStep.defaultExpectation.params)
		}
	}

	return mmAcquireForThisStep
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.AcquireForThisStep
func (mmAcquireForThisStep *mMigrationContextMockAcquireForThisStep) Inspect(f func(s1 SyncLink)) *mMigrationContextMockAcquireForThisStep {
	if mmAcquireForThisStep.mock.inspectFuncAcquireForThisStep != nil {
		mmAcquireForThisStep.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.AcquireForThisStep")
	}

	mmAcquireForThisStep.mock.inspectFuncAcquireForThisStep = f

	return mmAcquireForThisStep
}

// Return sets up results that will be returned by MigrationContext.AcquireForThisStep
func (mmAcquireForThisStep *mMigrationContextMockAcquireForThisStep) Return(b1 BoolDecision) *MigrationContextMock {
	if mmAcquireForThisStep.mock.funcAcquireForThisStep != nil {
		mmAcquireForThisStep.mock.t.Fatalf("MigrationContextMock.AcquireForThisStep mock is already set by Set")
	}

	if mmAcquireForThisStep.defaultExpectation == nil {
		mmAcquireForThisStep.defaultExpectation = &MigrationContextMockAcquireForThisStepExpectation{mock: mmAcquireForThisStep.mock}
	}
	mmAcquireForThisStep.defaultExpectation.results = &MigrationContextMockAcquireForThisStepResults{b1}
	return mmAcquireForThisStep.mock
}

//Set uses given function f to mock the MigrationContext.AcquireForThisStep method
func (mmAcquireForThisStep *mMigrationContextMockAcquireForThisStep) Set(f func(s1 SyncLink) (b1 BoolDecision)) *MigrationContextMock {
	if mmAcquireForThisStep.defaultExpectation != nil {
		mmAcquireForThisStep.mock.t.Fatalf("Default expectation is already set for the MigrationContext.AcquireForThisStep method")
	}

	if len(mmAcquireForThisStep.expectations) > 0 {
		mmAcquireForThisStep.mock.t.Fatalf("Some expectations are already set for the MigrationContext.AcquireForThisStep method")
	}

	mmAcquireForThisStep.mock.funcAcquireForThisStep = f
	return mmAcquireForThisStep.mock
}

// When sets expectation for the MigrationContext.AcquireForThisStep which will trigger the result defined by the following
// Then helper
func (mmAcquireForThisStep *mMigrationContextMockAcquireForThisStep) When(s1 SyncLink) *MigrationContextMockAcquireForThisStepExpectation {
	if mmAcquireForThisStep.mock.funcAcquireForThisStep != nil {
		mmAcquireForThisStep.mock.t.Fatalf("MigrationContextMock.AcquireForThisStep mock is already set by Set")
	}

	expectation := &MigrationContextMockAcquireForThisStepExpectation{
		mock:   mmAcquireForThisStep.mock,
		params: &MigrationContextMockAcquireForThisStepParams{s1},
	}
	mmAcquireForThisStep.expectations = append(mmAcquireForThisStep.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.AcquireForThisStep return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockAcquireForThisStepExpectation) Then(b1 BoolDecision) *MigrationContextMock {
	e.results = &MigrationContextMockAcquireForThisStepResults{b1}
	return e.mock
}

// AcquireForThisStep implements MigrationContext
func (mmAcquireForThisStep *MigrationContextMock) AcquireForThisStep(s1 SyncLink) (b1 BoolDecision) {
	mm_atomic.AddUint64(&mmAcquireForThisStep.beforeAcquireForThisStepCounter, 1)
	defer mm_atomic.AddUint64(&mmAcquireForThisStep.afterAcquireForThisStepCounter, 1)

	if mmAcquireForThisStep.inspectFuncAcquireForThisStep != nil {
		mmAcquireForThisStep.inspectFuncAcquireForThisStep(s1)
	}

	mm_params := &MigrationContextMockAcquireForThisStepParams{s1}

	// Record call args
	mmAcquireForThisStep.AcquireForThisStepMock.mutex.Lock()
	mmAcquireForThisStep.AcquireForThisStepMock.callArgs = append(mmAcquireForThisStep.AcquireForThisStepMock.callArgs, mm_params)
	mmAcquireForThisStep.AcquireForThisStepMock.mutex.Unlock()

	for _, e := range mmAcquireForThisStep.AcquireForThisStepMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmAcquireForThisStep.AcquireForThisStepMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcquireForThisStep.AcquireForThisStepMock.defaultExpectation.Counter, 1)
		mm_want := mmAcquireForThisStep.AcquireForThisStepMock.defaultExpectation.params
		mm_got := MigrationContextMockAcquireForThisStepParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcquireForThisStep.t.Errorf("MigrationContextMock.AcquireForThisStep got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcquireForThisStep.AcquireForThisStepMock.defaultExpectation.results
		if mm_results == nil {
			mmAcquireForThisStep.t.Fatal("No results are set for the MigrationContextMock.AcquireForThisStep")
		}
		return (*mm_results).b1
	}
	if mmAcquireForThisStep.funcAcquireForThisStep != nil {
		return mmAcquireForThisStep.funcAcquireForThisStep(s1)
	}
	mmAcquireForThisStep.t.Fatalf("Unexpected call to MigrationContextMock.AcquireForThisStep. %v", s1)
	return
}

// AcquireForThisStepAfterCounter returns a count of finished MigrationContextMock.AcquireForThisStep invocations
func (mmAcquireForThisStep *MigrationContextMock) AcquireForThisStepAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireForThisStep.afterAcquireForThisStepCounter)
}

// AcquireForThisStepBeforeCounter returns a count of MigrationContextMock.AcquireForThisStep invocations
func (mmAcquireForThisStep *MigrationContextMock) AcquireForThisStepBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireForThisStep.beforeAcquireForThisStepCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.AcquireForThisStep.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcquireForThisStep *mMigrationContextMockAcquireForThisStep) Calls() []*MigrationContextMockAcquireForThisStepParams {
	mmAcquireForThisStep.mutex.RLock()

	argCopy := make([]*MigrationContextMockAcquireForThisStepParams, len(mmAcquireForThisStep.callArgs))
	copy(argCopy, mmAcquireForThisStep.callArgs)

	mmAcquireForThisStep.mutex.RUnlock()

	return argCopy
}

// MinimockAcquireForThisStepDone returns true if the count of the AcquireForThisStep invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockAcquireForThisStepDone() bool {
	for _, e := range m.AcquireForThisStepMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireForThisStepMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireForThisStep != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepCounter) < 1 {
		return false
	}
	return true
}

// MinimockAcquireForThisStepInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockAcquireForThisStepInspect() {
	for _, e := range m.AcquireForThisStepMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.AcquireForThisStep with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireForThisStepMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepCounter) < 1 {
		if m.AcquireForThisStepMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.AcquireForThisStep")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.AcquireForThisStep with params: %#v", *m.AcquireForThisStepMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireForThisStep != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.AcquireForThisStep")
	}
}

type mMigrationContextMockAcquireForThisStepAndRelease struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockAcquireForThisStepAndReleaseExpectation
	expectations       []*MigrationContextMockAcquireForThisStepAndReleaseExpectation

	callArgs []*MigrationContextMockAcquireForThisStepAndReleaseParams
	mutex    sync.RWMutex
}

// MigrationContextMockAcquireForThisStepAndReleaseExpectation specifies expectation struct of the MigrationContext.AcquireForThisStepAndRelease
type MigrationContextMockAcquireForThisStepAndReleaseExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockAcquireForThisStepAndReleaseParams
	results *MigrationContextMockAcquireForThisStepAndReleaseResults
	Counter uint64
}

// MigrationContextMockAcquireForThisStepAndReleaseParams contains parameters of the MigrationContext.AcquireForThisStepAndRelease
type MigrationContextMockAcquireForThisStepAndReleaseParams struct {
	s1 SyncLink
}

// MigrationContextMockAcquireForThisStepAndReleaseResults contains results of the MigrationContext.AcquireForThisStepAndRelease
type MigrationContextMockAcquireForThisStepAndReleaseResults struct {
	b1 BoolDecision
}

// Expect sets up expected params for MigrationContext.AcquireForThisStepAndRelease
func (mmAcquireForThisStepAndRelease *mMigrationContextMockAcquireForThisStepAndRelease) Expect(s1 SyncLink) *mMigrationContextMockAcquireForThisStepAndRelease {
	if mmAcquireForThisStepAndRelease.mock.funcAcquireForThisStepAndRelease != nil {
		mmAcquireForThisStepAndRelease.mock.t.Fatalf("MigrationContextMock.AcquireForThisStepAndRelease mock is already set by Set")
	}

	if mmAcquireForThisStepAndRelease.defaultExpectation == nil {
		mmAcquireForThisStepAndRelease.defaultExpectation = &MigrationContextMockAcquireForThisStepAndReleaseExpectation{}
	}

	mmAcquireForThisStepAndRelease.defaultExpectation.params = &MigrationContextMockAcquireForThisStepAndReleaseParams{s1}
	for _, e := range mmAcquireForThisStepAndRelease.expectations {
		if minimock.Equal(e.params, mmAcquireForThisStepAndRelease.defaultExpectation.params) {
			mmAcquireForThisStepAndRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcquireForThisStepAndRelease.defaultExpectation.params)
		}
	}

	return mmAcquireForThisStepAndRelease
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.AcquireForThisStepAndRelease
func (mmAcquireForThisStepAndRelease *mMigrationContextMockAcquireForThisStepAndRelease) Inspect(f func(s1 SyncLink)) *mMigrationContextMockAcquireForThisStepAndRelease {
	if mmAcquireForThisStepAndRelease.mock.inspectFuncAcquireForThisStepAndRelease != nil {
		mmAcquireForThisStepAndRelease.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.AcquireForThisStepAndRelease")
	}

	mmAcquireForThisStepAndRelease.mock.inspectFuncAcquireForThisStepAndRelease = f

	return mmAcquireForThisStepAndRelease
}

// Return sets up results that will be returned by MigrationContext.AcquireForThisStepAndRelease
func (mmAcquireForThisStepAndRelease *mMigrationContextMockAcquireForThisStepAndRelease) Return(b1 BoolDecision) *MigrationContextMock {
	if mmAcquireForThisStepAndRelease.mock.funcAcquireForThisStepAndRelease != nil {
		mmAcquireForThisStepAndRelease.mock.t.Fatalf("MigrationContextMock.AcquireForThisStepAndRelease mock is already set by Set")
	}

	if mmAcquireForThisStepAndRelease.defaultExpectation == nil {
		mmAcquireForThisStepAndRelease.defaultExpectation = &MigrationContextMockAcquireForThisStepAndReleaseExpectation{mock: mmAcquireForThisStepAndRelease.mock}
	}
	mmAcquireForThisStepAndRelease.defaultExpectation.results = &MigrationContextMockAcquireForThisStepAndReleaseResults{b1}
	return mmAcquireForThisStepAndRelease.mock
}

//Set uses given function f to mock the MigrationContext.AcquireForThisStepAndRelease method
func (mmAcquireForThisStepAndRelease *mMigrationContextMockAcquireForThisStepAndRelease) Set(f func(s1 SyncLink) (b1 BoolDecision)) *MigrationContextMock {
	if mmAcquireForThisStepAndRelease.defaultExpectation != nil {
		mmAcquireForThisStepAndRelease.mock.t.Fatalf("Default expectation is already set for the MigrationContext.AcquireForThisStepAndRelease method")
	}

	if len(mmAcquireForThisStepAndRelease.expectations) > 0 {
		mmAcquireForThisStepAndRelease.mock.t.Fatalf("Some expectations are already set for the MigrationContext.AcquireForThisStepAndRelease method")
	}

	mmAcquireForThisStepAndRelease.mock.funcAcquireForThisStepAndRelease = f
	return mmAcquireForThisStepAndRelease.mock
}

// When sets expectation for the MigrationContext.AcquireForThisStepAndRelease which will trigger the result defined by the following
// Then helper
func (mmAcquireForThisStepAndRelease *mMigrationContextMockAcquireForThisStepAndRelease) When(s1 SyncLink) *MigrationContextMockAcquireForThisStepAndReleaseExpectation {
	if mmAcquireForThisStepAndRelease.mock.funcAcquireForThisStepAndRelease != nil {
		mmAcquireForThisStepAndRelease.mock.t.Fatalf("MigrationContextMock.AcquireForThisStepAndRelease mock is already set by Set")
	}

	expectation := &MigrationContextMockAcquireForThisStepAndReleaseExpectation{
		mock:   mmAcquireForThisStepAndRelease.mock,
		params: &MigrationContextMockAcquireForThisStepAndReleaseParams{s1},
	}
	mmAcquireForThisStepAndRelease.expectations = append(mmAcquireForThisStepAndRelease.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.AcquireForThisStepAndRelease return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockAcquireForThisStepAndReleaseExpectation) Then(b1 BoolDecision) *MigrationContextMock {
	e.results = &MigrationContextMockAcquireForThisStepAndReleaseResults{b1}
	return e.mock
}

// AcquireForThisStepAndRelease implements MigrationContext
func (mmAcquireForThisStepAndRelease *MigrationContextMock) AcquireForThisStepAndRelease(s1 SyncLink) (b1 BoolDecision) {
	mm_atomic.AddUint64(&mmAcquireForThisStepAndRelease.beforeAcquireForThisStepAndReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmAcquireForThisStepAndRelease.afterAcquireForThisStepAndReleaseCounter, 1)

	if mmAcquireForThisStepAndRelease.inspectFuncAcquireForThisStepAndRelease != nil {
		mmAcquireForThisStepAndRelease.inspectFuncAcquireForThisStepAndRelease(s1)
	}

	mm_params := &MigrationContextMockAcquireForThisStepAndReleaseParams{s1}

	// Record call args
	mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.mutex.Lock()
	mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.callArgs = append(mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.callArgs, mm_params)
	mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.mutex.Unlock()

	for _, e := range mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.defaultExpectation.params
		mm_got := MigrationContextMockAcquireForThisStepAndReleaseParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcquireForThisStepAndRelease.t.Errorf("MigrationContextMock.AcquireForThisStepAndRelease got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcquireForThisStepAndRelease.AcquireForThisStepAndReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmAcquireForThisStepAndRelease.t.Fatal("No results are set for the MigrationContextMock.AcquireForThisStepAndRelease")
		}
		return (*mm_results).b1
	}
	if mmAcquireForThisStepAndRelease.funcAcquireForThisStepAndRelease != nil {
		return mmAcquireForThisStepAndRelease.funcAcquireForThisStepAndRelease(s1)
	}
	mmAcquireForThisStepAndRelease.t.Fatalf("Unexpected call to MigrationContextMock.AcquireForThisStepAndRelease. %v", s1)
	return
}

// AcquireForThisStepAndReleaseAfterCounter returns a count of finished MigrationContextMock.AcquireForThisStepAndRelease invocations
func (mmAcquireForThisStepAndRelease *MigrationContextMock) AcquireForThisStepAndReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireForThisStepAndRelease.afterAcquireForThisStepAndReleaseCounter)
}

// AcquireForThisStepAndReleaseBeforeCounter returns a count of MigrationContextMock.AcquireForThisStepAndRelease invocations
func (mmAcquireForThisStepAndRelease *MigrationContextMock) AcquireForThisStepAndReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcquireForThisStepAndRelease.beforeAcquireForThisStepAndReleaseCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.AcquireForThisStepAndRelease.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcquireForThisStepAndRelease *mMigrationContextMockAcquireForThisStepAndRelease) Calls() []*MigrationContextMockAcquireForThisStepAndReleaseParams {
	mmAcquireForThisStepAndRelease.mutex.RLock()

	argCopy := make([]*MigrationContextMockAcquireForThisStepAndReleaseParams, len(mmAcquireForThisStepAndRelease.callArgs))
	copy(argCopy, mmAcquireForThisStepAndRelease.callArgs)

	mmAcquireForThisStepAndRelease.mutex.RUnlock()

	return argCopy
}

// MinimockAcquireForThisStepAndReleaseDone returns true if the count of the AcquireForThisStepAndRelease invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockAcquireForThisStepAndReleaseDone() bool {
	for _, e := range m.AcquireForThisStepAndReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireForThisStepAndReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepAndReleaseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireForThisStepAndRelease != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepAndReleaseCounter) < 1 {
		return false
	}
	return true
}

// MinimockAcquireForThisStepAndReleaseInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockAcquireForThisStepAndReleaseInspect() {
	for _, e := range m.AcquireForThisStepAndReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.AcquireForThisStepAndRelease with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcquireForThisStepAndReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepAndReleaseCounter) < 1 {
		if m.AcquireForThisStepAndReleaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.AcquireForThisStepAndRelease")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.AcquireForThisStepAndRelease with params: %#v", *m.AcquireForThisStepAndReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcquireForThisStepAndRelease != nil && mm_atomic.LoadUint64(&m.afterAcquireForThisStepAndReleaseCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.AcquireForThisStepAndRelease")
	}
}

type mMigrationContextMockAffectedStep struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockAffectedStepExpectation
	expectations       []*MigrationContextMockAffectedStepExpectation
}

// MigrationContextMockAffectedStepExpectation specifies expectation struct of the MigrationContext.AffectedStep
type MigrationContextMockAffectedStepExpectation struct {
	mock *MigrationContextMock

	results *MigrationContextMockAffectedStepResults
	Counter uint64
}

// MigrationContextMockAffectedStepResults contains results of the MigrationContext.AffectedStep
type MigrationContextMockAffectedStepResults struct {
	s1 SlotStep
}

// Expect sets up expected params for MigrationContext.AffectedStep
func (mmAffectedStep *mMigrationContextMockAffectedStep) Expect() *mMigrationContextMockAffectedStep {
	if mmAffectedStep.mock.funcAffectedStep != nil {
		mmAffectedStep.mock.t.Fatalf("MigrationContextMock.AffectedStep mock is already set by Set")
	}

	if mmAffectedStep.defaultExpectation == nil {
		mmAffectedStep.defaultExpectation = &MigrationContextMockAffectedStepExpectation{}
	}

	return mmAffectedStep
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.AffectedStep
func (mmAffectedStep *mMigrationContextMockAffectedStep) Inspect(f func()) *mMigrationContextMockAffectedStep {
	if mmAffectedStep.mock.inspectFuncAffectedStep != nil {
		mmAffectedStep.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.AffectedStep")
	}

	mmAffectedStep.mock.inspectFuncAffectedStep = f

	return mmAffectedStep
}

// Return sets up results that will be returned by MigrationContext.AffectedStep
func (mmAffectedStep *mMigrationContextMockAffectedStep) Return(s1 SlotStep) *MigrationContextMock {
	if mmAffectedStep.mock.funcAffectedStep != nil {
		mmAffectedStep.mock.t.Fatalf("MigrationContextMock.AffectedStep mock is already set by Set")
	}

	if mmAffectedStep.defaultExpectation == nil {
		mmAffectedStep.defaultExpectation = &MigrationContextMockAffectedStepExpectation{mock: mmAffectedStep.mock}
	}
	mmAffectedStep.defaultExpectation.results = &MigrationContextMockAffectedStepResults{s1}
	return mmAffectedStep.mock
}

//Set uses given function f to mock the MigrationContext.AffectedStep method
func (mmAffectedStep *mMigrationContextMockAffectedStep) Set(f func() (s1 SlotStep)) *MigrationContextMock {
	if mmAffectedStep.defaultExpectation != nil {
		mmAffectedStep.mock.t.Fatalf("Default expectation is already set for the MigrationContext.AffectedStep method")
	}

	if len(mmAffectedStep.expectations) > 0 {
		mmAffectedStep.mock.t.Fatalf("Some expectations are already set for the MigrationContext.AffectedStep method")
	}

	mmAffectedStep.mock.funcAffectedStep = f
	return mmAffectedStep.mock
}

// AffectedStep implements MigrationContext
func (mmAffectedStep *MigrationContextMock) AffectedStep() (s1 SlotStep) {
	mm_atomic.AddUint64(&mmAffectedStep.beforeAffectedStepCounter, 1)
	defer mm_atomic.AddUint64(&mmAffectedStep.afterAffectedStepCounter, 1)

	if mmAffectedStep.inspectFuncAffectedStep != nil {
		mmAffectedStep.inspectFuncAffectedStep()
	}

	if mmAffectedStep.AffectedStepMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAffectedStep.AffectedStepMock.defaultExpectation.Counter, 1)

		mm_results := mmAffectedStep.AffectedStepMock.defaultExpectation.results
		if mm_results == nil {
			mmAffectedStep.t.Fatal("No results are set for the MigrationContextMock.AffectedStep")
		}
		return (*mm_results).s1
	}
	if mmAffectedStep.funcAffectedStep != nil {
		return mmAffectedStep.funcAffectedStep()
	}
	mmAffectedStep.t.Fatalf("Unexpected call to MigrationContextMock.AffectedStep.")
	return
}

// AffectedStepAfterCounter returns a count of finished MigrationContextMock.AffectedStep invocations
func (mmAffectedStep *MigrationContextMock) AffectedStepAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAffectedStep.afterAffectedStepCounter)
}

// AffectedStepBeforeCounter returns a count of MigrationContextMock.AffectedStep invocations
func (mmAffectedStep *MigrationContextMock) AffectedStepBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAffectedStep.beforeAffectedStepCounter)
}

// MinimockAffectedStepDone returns true if the count of the AffectedStep invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockAffectedStepDone() bool {
	for _, e := range m.AffectedStepMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AffectedStepMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAffectedStepCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAffectedStep != nil && mm_atomic.LoadUint64(&m.afterAffectedStepCounter) < 1 {
		return false
	}
	return true
}

// MinimockAffectedStepInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockAffectedStepInspect() {
	for _, e := range m.AffectedStepMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MigrationContextMock.AffectedStep")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AffectedStepMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAffectedStepCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.AffectedStep")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAffectedStep != nil && mm_atomic.LoadUint64(&m.afterAffectedStepCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.AffectedStep")
	}
}

type mMigrationContextMockApplyAdjustment struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockApplyAdjustmentExpectation
	expectations       []*MigrationContextMockApplyAdjustmentExpectation

	callArgs []*MigrationContextMockApplyAdjustmentParams
	mutex    sync.RWMutex
}

// MigrationContextMockApplyAdjustmentExpectation specifies expectation struct of the MigrationContext.ApplyAdjustment
type MigrationContextMockApplyAdjustmentExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockApplyAdjustmentParams
	results *MigrationContextMockApplyAdjustmentResults
	Counter uint64
}

// MigrationContextMockApplyAdjustmentParams contains parameters of the MigrationContext.ApplyAdjustment
type MigrationContextMockApplyAdjustmentParams struct {
	s1 SyncAdjustment
}

// MigrationContextMockApplyAdjustmentResults contains results of the MigrationContext.ApplyAdjustment
type MigrationContextMockApplyAdjustmentResults struct {
	b1 bool
}

// Expect sets up expected params for MigrationContext.ApplyAdjustment
func (mmApplyAdjustment *mMigrationContextMockApplyAdjustment) Expect(s1 SyncAdjustment) *mMigrationContextMockApplyAdjustment {
	if mmApplyAdjustment.mock.funcApplyAdjustment != nil {
		mmApplyAdjustment.mock.t.Fatalf("MigrationContextMock.ApplyAdjustment mock is already set by Set")
	}

	if mmApplyAdjustment.defaultExpectation == nil {
		mmApplyAdjustment.defaultExpectation = &MigrationContextMockApplyAdjustmentExpectation{}
	}

	mmApplyAdjustment.defaultExpectation.params = &MigrationContextMockApplyAdjustmentParams{s1}
	for _, e := range mmApplyAdjustment.expectations {
		if minimock.Equal(e.params, mmApplyAdjustment.defaultExpectation.params) {
			mmApplyAdjustment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmApplyAdjustment.defaultExpectation.params)
		}
	}

	return mmApplyAdjustment
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.ApplyAdjustment
func (mmApplyAdjustment *mMigrationContextMockApplyAdjustment) Inspect(f func(s1 SyncAdjustment)) *mMigrationContextMockApplyAdjustment {
	if mmApplyAdjustment.mock.inspectFuncApplyAdjustment != nil {
		mmApplyAdjustment.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.ApplyAdjustment")
	}

	mmApplyAdjustment.mock.inspectFuncApplyAdjustment = f

	return mmApplyAdjustment
}

// Return sets up results that will be returned by MigrationContext.ApplyAdjustment
func (mmApplyAdjustment *mMigrationContextMockApplyAdjustment) Return(b1 bool) *MigrationContextMock {
	if mmApplyAdjustment.mock.funcApplyAdjustment != nil {
		mmApplyAdjustment.mock.t.Fatalf("MigrationContextMock.ApplyAdjustment mock is already set by Set")
	}

	if mmApplyAdjustment.defaultExpectation == nil {
		mmApplyAdjustment.defaultExpectation = &MigrationContextMockApplyAdjustmentExpectation{mock: mmApplyAdjustment.mock}
	}
	mmApplyAdjustment.defaultExpectation.results = &MigrationContextMockApplyAdjustmentResults{b1}
	return mmApplyAdjustment.mock
}

//Set uses given function f to mock the MigrationContext.ApplyAdjustment method
func (mmApplyAdjustment *mMigrationContextMockApplyAdjustment) Set(f func(s1 SyncAdjustment) (b1 bool)) *MigrationContextMock {
	if mmApplyAdjustment.defaultExpectation != nil {
		mmApplyAdjustment.mock.t.Fatalf("Default expectation is already set for the MigrationContext.ApplyAdjustment method")
	}

	if len(mmApplyAdjustment.expectations) > 0 {
		mmApplyAdjustment.mock.t.Fatalf("Some expectations are already set for the MigrationContext.ApplyAdjustment method")
	}

	mmApplyAdjustment.mock.funcApplyAdjustment = f
	return mmApplyAdjustment.mock
}

// When sets expectation for the MigrationContext.ApplyAdjustment which will trigger the result defined by the following
// Then helper
func (mmApplyAdjustment *mMigrationContextMockApplyAdjustment) When(s1 SyncAdjustment) *MigrationContextMockApplyAdjustmentExpectation {
	if mmApplyAdjustment.mock.funcApplyAdjustment != nil {
		mmApplyAdjustment.mock.t.Fatalf("MigrationContextMock.ApplyAdjustment mock is already set by Set")
	}

	expectation := &MigrationContextMockApplyAdjustmentExpectation{
		mock:   mmApplyAdjustment.mock,
		params: &MigrationContextMockApplyAdjustmentParams{s1},
	}
	mmApplyAdjustment.expectations = append(mmApplyAdjustment.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.ApplyAdjustment return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockApplyAdjustmentExpectation) Then(b1 bool) *MigrationContextMock {
	e.results = &MigrationContextMockApplyAdjustmentResults{b1}
	return e.mock
}

// ApplyAdjustment implements MigrationContext
func (mmApplyAdjustment *MigrationContextMock) ApplyAdjustment(s1 SyncAdjustment) (b1 bool) {
	mm_atomic.AddUint64(&mmApplyAdjustment.beforeApplyAdjustmentCounter, 1)
	defer mm_atomic.AddUint64(&mmApplyAdjustment.afterApplyAdjustmentCounter, 1)

	if mmApplyAdjustment.inspectFuncApplyAdjustment != nil {
		mmApplyAdjustment.inspectFuncApplyAdjustment(s1)
	}

	mm_params := &MigrationContextMockApplyAdjustmentParams{s1}

	// Record call args
	mmApplyAdjustment.ApplyAdjustmentMock.mutex.Lock()
	mmApplyAdjustment.ApplyAdjustmentMock.callArgs = append(mmApplyAdjustment.ApplyAdjustmentMock.callArgs, mm_params)
	mmApplyAdjustment.ApplyAdjustmentMock.mutex.Unlock()

	for _, e := range mmApplyAdjustment.ApplyAdjustmentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmApplyAdjustment.ApplyAdjustmentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmApplyAdjustment.ApplyAdjustmentMock.defaultExpectation.Counter, 1)
		mm_want := mmApplyAdjustment.ApplyAdjustmentMock.defaultExpectation.params
		mm_got := MigrationContextMockApplyAdjustmentParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmApplyAdjustment.t.Errorf("MigrationContextMock.ApplyAdjustment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmApplyAdjustment.ApplyAdjustmentMock.defaultExpectation.results
		if mm_results == nil {
			mmApplyAdjustment.t.Fatal("No results are set for the MigrationContextMock.ApplyAdjustment")
		}
		return (*mm_results).b1
	}
	if mmApplyAdjustment.funcApplyAdjustment != nil {
		return mmApplyAdjustment.funcApplyAdjustment(s1)
	}
	mmApplyAdjustment.t.Fatalf("Unexpected call to MigrationContextMock.ApplyAdjustment. %v", s1)
	return
}

// ApplyAdjustmentAfterCounter returns a count of finished MigrationContextMock.ApplyAdjustment invocations
func (mmApplyAdjustment *MigrationContextMock) ApplyAdjustmentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyAdjustment.afterApplyAdjustmentCounter)
}

// ApplyAdjustmentBeforeCounter returns a count of MigrationContextMock.ApplyAdjustment invocations
func (mmApplyAdjustment *MigrationContextMock) ApplyAdjustmentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyAdjustment.beforeApplyAdjustmentCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.ApplyAdjustment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmApplyAdjustment *mMigrationContextMockApplyAdjustment) Calls() []*MigrationContextMockApplyAdjustmentParams {
	mmApplyAdjustment.mutex.RLock()

	argCopy := make([]*MigrationContextMockApplyAdjustmentParams, len(mmApplyAdjustment.callArgs))
	copy(argCopy, mmApplyAdjustment.callArgs)

	mmApplyAdjustment.mutex.RUnlock()

	return argCopy
}

// MinimockApplyAdjustmentDone returns true if the count of the ApplyAdjustment invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockApplyAdjustmentDone() bool {
	for _, e := range m.ApplyAdjustmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyAdjustmentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterApplyAdjustmentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApplyAdjustment != nil && mm_atomic.LoadUint64(&m.afterApplyAdjustmentCounter) < 1 {
		return false
	}
	return true
}

// MinimockApplyAdjustmentInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockApplyAdjustmentInspect() {
	for _, e := range m.ApplyAdjustmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.ApplyAdjustment with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyAdjustmentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterApplyAdjustmentCounter) < 1 {
		if m.ApplyAdjustmentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.ApplyAdjustment")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.ApplyAdjustment with params: %#v", *m.ApplyAdjustmentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApplyAdjustment != nil && mm_atomic.LoadUint64(&m.afterApplyAdjustmentCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.ApplyAdjustment")
	}
}

type mMigrationContextMockCallSubroutine struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockCallSubroutineExpectation
	expectations       []*MigrationContextMockCallSubroutineExpectation

	callArgs []*MigrationContextMockCallSubroutineParams
	mutex    sync.RWMutex
}

// MigrationContextMockCallSubroutineExpectation specifies expectation struct of the MigrationContext.CallSubroutine
type MigrationContextMockCallSubroutineExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockCallSubroutineParams
	results *MigrationContextMockCallSubroutineResults
	Counter uint64
}

// MigrationContextMockCallSubroutineParams contains parameters of the MigrationContext.CallSubroutine
type MigrationContextMockCallSubroutineParams struct {
	s1 SubroutineStateMachine
	m1 MigrateFunc
	s2 SubroutineExitFunc
}

// MigrationContextMockCallSubroutineResults contains results of the MigrationContext.CallSubroutine
type MigrationContextMockCallSubroutineResults struct {
	s3 StateUpdate
}

// Expect sets up expected params for MigrationContext.CallSubroutine
func (mmCallSubroutine *mMigrationContextMockCallSubroutine) Expect(s1 SubroutineStateMachine, m1 MigrateFunc, s2 SubroutineExitFunc) *mMigrationContextMockCallSubroutine {
	if mmCallSubroutine.mock.funcCallSubroutine != nil {
		mmCallSubroutine.mock.t.Fatalf("MigrationContextMock.CallSubroutine mock is already set by Set")
	}

	if mmCallSubroutine.defaultExpectation == nil {
		mmCallSubroutine.defaultExpectation = &MigrationContextMockCallSubroutineExpectation{}
	}

	mmCallSubroutine.defaultExpectation.params = &MigrationContextMockCallSubroutineParams{s1, m1, s2}
	for _, e := range mmCallSubroutine.expectations {
		if minimock.Equal(e.params, mmCallSubroutine.defaultExpectation.params) {
			mmCallSubroutine.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCallSubroutine.defaultExpectation.params)
		}
	}

	return mmCallSubroutine
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.CallSubroutine
func (mmCallSubroutine *mMigrationContextMockCallSubroutine) Inspect(f func(s1 SubroutineStateMachine, m1 MigrateFunc, s2 SubroutineExitFunc)) *mMigrationContextMockCallSubroutine {
	if mmCallSubroutine.mock.inspectFuncCallSubroutine != nil {
		mmCallSubroutine.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.CallSubroutine")
	}

	mmCallSubroutine.mock.inspectFuncCallSubroutine = f

	return mmCallSubroutine
}

// Return sets up results that will be returned by MigrationContext.CallSubroutine
func (mmCallSubroutine *mMigrationContextMockCallSubroutine) Return(s3 StateUpdate) *MigrationContextMock {
	if mmCallSubroutine.mock.funcCallSubroutine != nil {
		mmCallSubroutine.mock.t.Fatalf("MigrationContextMock.CallSubroutine mock is already set by Set")
	}

	if mmCallSubroutine.defaultExpectation == nil {
		mmCallSubroutine.defaultExpectation = &MigrationContextMockCallSubroutineExpectation{mock: mmCallSubroutine.mock}
	}
	mmCallSubroutine.defaultExpectation.results = &MigrationContextMockCallSubroutineResults{s3}
	return mmCallSubroutine.mock
}

//Set uses given function f to mock the MigrationContext.CallSubroutine method
func (mmCallSubroutine *mMigrationContextMockCallSubroutine) Set(f func(s1 SubroutineStateMachine, m1 MigrateFunc, s2 SubroutineExitFunc) (s3 StateUpdate)) *MigrationContextMock {
	if mmCallSubroutine.defaultExpectation != nil {
		mmCallSubroutine.mock.t.Fatalf("Default expectation is already set for the MigrationContext.CallSubroutine method")
	}

	if len(mmCallSubroutine.expectations) > 0 {
		mmCallSubroutine.mock.t.Fatalf("Some expectations are already set for the MigrationContext.CallSubroutine method")
	}

	mmCallSubroutine.mock.funcCallSubroutine = f
	return mmCallSubroutine.mock
}

// When sets expectation for the MigrationContext.CallSubroutine which will trigger the result defined by the following
// Then helper
func (mmCallSubroutine *mMigrationContextMockCallSubroutine) When(s1 SubroutineStateMachine, m1 MigrateFunc, s2 SubroutineExitFunc) *MigrationContextMockCallSubroutineExpectation {
	if mmCallSubroutine.mock.funcCallSubroutine != nil {
		mmCallSubroutine.mock.t.Fatalf("MigrationContextMock.CallSubroutine mock is already set by Set")
	}

	expectation := &MigrationContextMockCallSubroutineExpectation{
		mock:   mmCallSubroutine.mock,
		params: &MigrationContextMockCallSubroutineParams{s1, m1, s2},
	}
	mmCallSubroutine.expectations = append(mmCallSubroutine.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.CallSubroutine return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockCallSubroutineExpectation) Then(s3 StateUpdate) *MigrationContextMock {
	e.results = &MigrationContextMockCallSubroutineResults{s3}
	return e.mock
}

// CallSubroutine implements MigrationContext
func (mmCallSubroutine *MigrationContextMock) CallSubroutine(s1 SubroutineStateMachine, m1 MigrateFunc, s2 SubroutineExitFunc) (s3 StateUpdate) {
	mm_atomic.AddUint64(&mmCallSubroutine.beforeCallSubroutineCounter, 1)
	defer mm_atomic.AddUint64(&mmCallSubroutine.afterCallSubroutineCounter, 1)

	if mmCallSubroutine.inspectFuncCallSubroutine != nil {
		mmCallSubroutine.inspectFuncCallSubroutine(s1, m1, s2)
	}

	mm_params := &MigrationContextMockCallSubroutineParams{s1, m1, s2}

	// Record call args
	mmCallSubroutine.CallSubroutineMock.mutex.Lock()
	mmCallSubroutine.CallSubroutineMock.callArgs = append(mmCallSubroutine.CallSubroutineMock.callArgs, mm_params)
	mmCallSubroutine.CallSubroutineMock.mutex.Unlock()

	for _, e := range mmCallSubroutine.CallSubroutineMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s3
		}
	}

	if mmCallSubroutine.CallSubroutineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCallSubroutine.CallSubroutineMock.defaultExpectation.Counter, 1)
		mm_want := mmCallSubroutine.CallSubroutineMock.defaultExpectation.params
		mm_got := MigrationContextMockCallSubroutineParams{s1, m1, s2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCallSubroutine.t.Errorf("MigrationContextMock.CallSubroutine got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCallSubroutine.CallSubroutineMock.defaultExpectation.results
		if mm_results == nil {
			mmCallSubroutine.t.Fatal("No results are set for the MigrationContextMock.CallSubroutine")
		}
		return (*mm_results).s3
	}
	if mmCallSubroutine.funcCallSubroutine != nil {
		return mmCallSubroutine.funcCallSubroutine(s1, m1, s2)
	}
	mmCallSubroutine.t.Fatalf("Unexpected call to MigrationContextMock.CallSubroutine. %v %v %v", s1, m1, s2)
	return
}

// CallSubroutineAfterCounter returns a count of finished MigrationContextMock.CallSubroutine invocations
func (mmCallSubroutine *MigrationContextMock) CallSubroutineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallSubroutine.afterCallSubroutineCounter)
}

// CallSubroutineBeforeCounter returns a count of MigrationContextMock.CallSubroutine invocations
func (mmCallSubroutine *MigrationContextMock) CallSubroutineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallSubroutine.beforeCallSubroutineCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.CallSubroutine.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCallSubroutine *mMigrationContextMockCallSubroutine) Calls() []*MigrationContextMockCallSubroutineParams {
	mmCallSubroutine.mutex.RLock()

	argCopy := make([]*MigrationContextMockCallSubroutineParams, len(mmCallSubroutine.callArgs))
	copy(argCopy, mmCallSubroutine.callArgs)

	mmCallSubroutine.mutex.RUnlock()

	return argCopy
}

// MinimockCallSubroutineDone returns true if the count of the CallSubroutine invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockCallSubroutineDone() bool {
	for _, e := range m.CallSubroutineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallSubroutineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallSubroutineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallSubroutine != nil && mm_atomic.LoadUint64(&m.afterCallSubroutineCounter) < 1 {
		return false
	}
	return true
}

// MinimockCallSubroutineInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockCallSubroutineInspect() {
	for _, e := range m.CallSubroutineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.CallSubroutine with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallSubroutineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallSubroutineCounter) < 1 {
		if m.CallSubroutineMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.CallSubroutine")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.CallSubroutine with params: %#v", *m.CallSubroutineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallSubroutine != nil && mm_atomic.LoadUint64(&m.afterCallSubroutineCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.CallSubroutine")
	}
}

type mMigrationContextMockCheck struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockCheckExpectation
	expectations       []*MigrationContextMockCheckExpectation

	callArgs []*MigrationContextMockCheckParams
	mutex    sync.RWMutex
}

// MigrationContextMockCheckExpectation specifies expectation struct of the MigrationContext.Check
type MigrationContextMockCheckExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockCheckParams
	results *MigrationContextMockCheckResults
	Counter uint64
}

// MigrationContextMockCheckParams contains parameters of the MigrationContext.Check
type MigrationContextMockCheckParams struct {
	s1 SyncLink
}

// MigrationContextMockCheckResults contains results of the MigrationContext.Check
type MigrationContextMockCheckResults struct {
	b1 BoolDecision
}

// Expect sets up expected params for MigrationContext.Check
func (mmCheck *mMigrationContextMockCheck) Expect(s1 SyncLink) *mMigrationContextMockCheck {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("MigrationContextMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &MigrationContextMockCheckExpectation{}
	}

	mmCheck.defaultExpectation.params = &MigrationContextMockCheckParams{s1}
	for _, e := range mmCheck.expectations {
		if minimock.Equal(e.params, mmCheck.defaultExpectation.params) {
			mmCheck.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheck.defaultExpectation.params)
		}
	}

	return mmCheck
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.Check
func (mmCheck *mMigrationContextMockCheck) Inspect(f func(s1 SyncLink)) *mMigrationContextMockCheck {
	if mmCheck.mock.inspectFuncCheck != nil {
		mmCheck.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.Check")
	}

	mmCheck.mock.inspectFuncCheck = f

	return mmCheck
}

// Return sets up results that will be returned by MigrationContext.Check
func (mmCheck *mMigrationContextMockCheck) Return(b1 BoolDecision) *MigrationContextMock {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("MigrationContextMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &MigrationContextMockCheckExpectation{mock: mmCheck.mock}
	}
	mmCheck.defaultExpectation.results = &MigrationContextMockCheckResults{b1}
	return mmCheck.mock
}

//Set uses given function f to mock the MigrationContext.Check method
func (mmCheck *mMigrationContextMockCheck) Set(f func(s1 SyncLink) (b1 BoolDecision)) *MigrationContextMock {
	if mmCheck.defaultExpectation != nil {
		mmCheck.mock.t.Fatalf("Default expectation is already set for the MigrationContext.Check method")
	}

	if len(mmCheck.expectations) > 0 {
		mmCheck.mock.t.Fatalf("Some expectations are already set for the MigrationContext.Check method")
	}

	mmCheck.mock.funcCheck = f
	return mmCheck.mock
}

// When sets expectation for the MigrationContext.Check which will trigger the result defined by the following
// Then helper
func (mmCheck *mMigrationContextMockCheck) When(s1 SyncLink) *MigrationContextMockCheckExpectation {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("MigrationContextMock.Check mock is already set by Set")
	}

	expectation := &MigrationContextMockCheckExpectation{
		mock:   mmCheck.mock,
		params: &MigrationContextMockCheckParams{s1},
	}
	mmCheck.expectations = append(mmCheck.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.Check return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockCheckExpectation) Then(b1 BoolDecision) *MigrationContextMock {
	e.results = &MigrationContextMockCheckResults{b1}
	return e.mock
}

// Check implements MigrationContext
func (mmCheck *MigrationContextMock) Check(s1 SyncLink) (b1 BoolDecision) {
	mm_atomic.AddUint64(&mmCheck.beforeCheckCounter, 1)
	defer mm_atomic.AddUint64(&mmCheck.afterCheckCounter, 1)

	if mmCheck.inspectFuncCheck != nil {
		mmCheck.inspectFuncCheck(s1)
	}

	mm_params := &MigrationContextMockCheckParams{s1}

	// Record call args
	mmCheck.CheckMock.mutex.Lock()
	mmCheck.CheckMock.callArgs = append(mmCheck.CheckMock.callArgs, mm_params)
	mmCheck.CheckMock.mutex.Unlock()

	for _, e := range mmCheck.CheckMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmCheck.CheckMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheck.CheckMock.defaultExpectation.Counter, 1)
		mm_want := mmCheck.CheckMock.defaultExpectation.params
		mm_got := MigrationContextMockCheckParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheck.t.Errorf("MigrationContextMock.Check got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheck.CheckMock.defaultExpectation.results
		if mm_results == nil {
			mmCheck.t.Fatal("No results are set for the MigrationContextMock.Check")
		}
		return (*mm_results).b1
	}
	if mmCheck.funcCheck != nil {
		return mmCheck.funcCheck(s1)
	}
	mmCheck.t.Fatalf("Unexpected call to MigrationContextMock.Check. %v", s1)
	return
}

// CheckAfterCounter returns a count of finished MigrationContextMock.Check invocations
func (mmCheck *MigrationContextMock) CheckAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheck.afterCheckCounter)
}

// CheckBeforeCounter returns a count of MigrationContextMock.Check invocations
func (mmCheck *MigrationContextMock) CheckBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheck.beforeCheckCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.Check.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheck *mMigrationContextMockCheck) Calls() []*MigrationContextMockCheckParams {
	mmCheck.mutex.RLock()

	argCopy := make([]*MigrationContextMockCheckParams, len(mmCheck.callArgs))
	copy(argCopy, mmCheck.callArgs)

	mmCheck.mutex.RUnlock()

	return argCopy
}

// MinimockCheckDone returns true if the count of the Check invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockCheckDone() bool {
	for _, e := range m.CheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheck != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		return false
	}
	return true
}

// MinimockCheckInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockCheckInspect() {
	for _, e := range m.CheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.Check with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		if m.CheckMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.Check")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.Check with params: %#v", *m.CheckMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheck != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.Check")
	}
}

type mMigrationContextMockError struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockErrorExpectation
	expectations       []*MigrationContextMockErrorExpectation

	callArgs []*MigrationContextMockErrorParams
	mutex    sync.RWMutex
}

// MigrationContextMockErrorExpectation specifies expectation struct of the MigrationContext.Error
type MigrationContextMockErrorExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockErrorParams
	results *MigrationContextMockErrorResults
	Counter uint64
}

// MigrationContextMockErrorParams contains parameters of the MigrationContext.Error
type MigrationContextMockErrorParams struct {
	e1 error
}

// MigrationContextMockErrorResults contains results of the MigrationContext.Error
type MigrationContextMockErrorResults struct {
	s1 StateUpdate
}

// Expect sets up expected params for MigrationContext.Error
func (mmError *mMigrationContextMockError) Expect(e1 error) *mMigrationContextMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("MigrationContextMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &MigrationContextMockErrorExpectation{}
	}

	mmError.defaultExpectation.params = &MigrationContextMockErrorParams{e1}
	for _, e := range mmError.expectations {
		if minimock.Equal(e.params, mmError.defaultExpectation.params) {
			mmError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmError.defaultExpectation.params)
		}
	}

	return mmError
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.Error
func (mmError *mMigrationContextMockError) Inspect(f func(e1 error)) *mMigrationContextMockError {
	if mmError.mock.inspectFuncError != nil {
		mmError.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.Error")
	}

	mmError.mock.inspectFuncError = f

	return mmError
}

// Return sets up results that will be returned by MigrationContext.Error
func (mmError *mMigrationContextMockError) Return(s1 StateUpdate) *MigrationContextMock {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("MigrationContextMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &MigrationContextMockErrorExpectation{mock: mmError.mock}
	}
	mmError.defaultExpectation.results = &MigrationContextMockErrorResults{s1}
	return mmError.mock
}

//Set uses given function f to mock the MigrationContext.Error method
func (mmError *mMigrationContextMockError) Set(f func(e1 error) (s1 StateUpdate)) *MigrationContextMock {
	if mmError.defaultExpectation != nil {
		mmError.mock.t.Fatalf("Default expectation is already set for the MigrationContext.Error method")
	}

	if len(mmError.expectations) > 0 {
		mmError.mock.t.Fatalf("Some expectations are already set for the MigrationContext.Error method")
	}

	mmError.mock.funcError = f
	return mmError.mock
}

// When sets expectation for the MigrationContext.Error which will trigger the result defined by the following
// Then helper
func (mmError *mMigrationContextMockError) When(e1 error) *MigrationContextMockErrorExpectation {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("MigrationContextMock.Error mock is already set by Set")
	}

	expectation := &MigrationContextMockErrorExpectation{
		mock:   mmError.mock,
		params: &MigrationContextMockErrorParams{e1},
	}
	mmError.expectations = append(mmError.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.Error return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockErrorExpectation) Then(s1 StateUpdate) *MigrationContextMock {
	e.results = &MigrationContextMockErrorResults{s1}
	return e.mock
}

// Error implements MigrationContext
func (mmError *MigrationContextMock) Error(e1 error) (s1 StateUpdate) {
	mm_atomic.AddUint64(&mmError.beforeErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmError.afterErrorCounter, 1)

	if mmError.inspectFuncError != nil {
		mmError.inspectFuncError(e1)
	}

	mm_params := &MigrationContextMockErrorParams{e1}

	// Record call args
	mmError.ErrorMock.mutex.Lock()
	mmError.ErrorMock.callArgs = append(mmError.ErrorMock.callArgs, mm_params)
	mmError.ErrorMock.mutex.Unlock()

	for _, e := range mmError.ErrorMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmError.ErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmError.ErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmError.ErrorMock.defaultExpectation.params
		mm_got := MigrationContextMockErrorParams{e1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmError.t.Errorf("MigrationContextMock.Error got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmError.ErrorMock.defaultExpectation.results
		if mm_results == nil {
			mmError.t.Fatal("No results are set for the MigrationContextMock.Error")
		}
		return (*mm_results).s1
	}
	if mmError.funcError != nil {
		return mmError.funcError(e1)
	}
	mmError.t.Fatalf("Unexpected call to MigrationContextMock.Error. %v", e1)
	return
}

// ErrorAfterCounter returns a count of finished MigrationContextMock.Error invocations
func (mmError *MigrationContextMock) ErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.afterErrorCounter)
}

// ErrorBeforeCounter returns a count of MigrationContextMock.Error invocations
func (mmError *MigrationContextMock) ErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.beforeErrorCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.Error.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmError *mMigrationContextMockError) Calls() []*MigrationContextMockErrorParams {
	mmError.mutex.RLock()

	argCopy := make([]*MigrationContextMockErrorParams, len(mmError.callArgs))
	copy(argCopy, mmError.callArgs)

	mmError.mutex.RUnlock()

	return argCopy
}

// MinimockErrorDone returns true if the count of the Error invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockErrorDone() bool {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	return true
}

// MinimockErrorInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockErrorInspect() {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.Error with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		if m.ErrorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.Error")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.Error with params: %#v", *m.ErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.Error")
	}
}

type mMigrationContextMockGetContext struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockGetContextExpectation
	expectations       []*MigrationContextMockGetContextExpectation
}

// MigrationContextMockGetContextExpectation specifies expectation struct of the MigrationContext.GetContext
type MigrationContextMockGetContextExpectation struct {
	mock *MigrationContextMock

	results *MigrationContextMockGetContextResults
	Counter uint64
}

// MigrationContextMockGetContextResults contains results of the MigrationContext.GetContext
type MigrationContextMockGetContextResults struct {
	c1 context.Context
}

// Expect sets up expected params for MigrationContext.GetContext
func (mmGetContext *mMigrationContextMockGetContext) Expect() *mMigrationContextMockGetContext {
	if mmGetContext.mock.funcGetContext != nil {
		mmGetContext.mock.t.Fatalf("MigrationContextMock.GetContext mock is already set by Set")
	}

	if mmGetContext.defaultExpectation == nil {
		mmGetContext.defaultExpectation = &MigrationContextMockGetContextExpectation{}
	}

	return mmGetContext
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.GetContext
func (mmGetContext *mMigrationContextMockGetContext) Inspect(f func()) *mMigrationContextMockGetContext {
	if mmGetContext.mock.inspectFuncGetContext != nil {
		mmGetContext.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.GetContext")
	}

	mmGetContext.mock.inspectFuncGetContext = f

	return mmGetContext
}

// Return sets up results that will be returned by MigrationContext.GetContext
func (mmGetContext *mMigrationContextMockGetContext) Return(c1 context.Context) *MigrationContextMock {
	if mmGetContext.mock.funcGetContext != nil {
		mmGetContext.mock.t.Fatalf("MigrationContextMock.GetContext mock is already set by Set")
	}

	if mmGetContext.defaultExpectation == nil {
		mmGetContext.defaultExpectation = &MigrationContextMockGetContextExpectation{mock: mmGetContext.mock}
	}
	mmGetContext.defaultExpectation.results = &MigrationContextMockGetContextResults{c1}
	return mmGetContext.mock
}

//Set uses given function f to mock the MigrationContext.GetContext method
func (mmGetContext *mMigrationContextMockGetContext) Set(f func() (c1 context.Context)) *MigrationContextMock {
	if mmGetContext.defaultExpectation != nil {
		mmGetContext.mock.t.Fatalf("Default expectation is already set for the MigrationContext.GetContext method")
	}

	if len(mmGetContext.expectations) > 0 {
		mmGetContext.mock.t.Fatalf("Some expectations are already set for the MigrationContext.GetContext method")
	}

	mmGetContext.mock.funcGetContext = f
	return mmGetContext.mock
}

// GetContext implements MigrationContext
func (mmGetContext *MigrationContextMock) GetContext() (c1 context.Context) {
	mm_atomic.AddUint64(&mmGetContext.beforeGetContextCounter, 1)
	defer mm_atomic.AddUint64(&mmGetContext.afterGetContextCounter, 1)

	if mmGetContext.inspectFuncGetContext != nil {
		mmGetContext.inspectFuncGetContext()
	}

	if mmGetContext.GetContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetContext.GetContextMock.defaultExpectation.Counter, 1)

		mm_results := mmGetContext.GetContextMock.defaultExpectation.results
		if mm_results == nil {
			mmGetContext.t.Fatal("No results are set for the MigrationContextMock.GetContext")
		}
		return (*mm_results).c1
	}
	if mmGetContext.funcGetContext != nil {
		return mmGetContext.funcGetContext()
	}
	mmGetContext.t.Fatalf("Unexpected call to MigrationContextMock.GetContext.")
	return
}

// GetContextAfterCounter returns a count of finished MigrationContextMock.GetContext invocations
func (mmGetContext *MigrationContextMock) GetContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContext.afterGetContextCounter)
}

// GetContextBeforeCounter returns a count of MigrationContextMock.GetContext invocations
func (mmGetContext *MigrationContextMock) GetContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContext.beforeGetContextCounter)
}

// MinimockGetContextDone returns true if the count of the GetContext invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockGetContextDone() bool {
	for _, e := range m.GetContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetContext != nil && mm_atomic.LoadUint64(&m.afterGetContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetContextInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockGetContextInspect() {
	for _, e := range m.GetContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MigrationContextMock.GetContext")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetContextCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.GetContext")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetContext != nil && mm_atomic.LoadUint64(&m.afterGetContextCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.GetContext")
	}
}

type mMigrationContextMockGetPublished struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockGetPublishedExpectation
	expectations       []*MigrationContextMockGetPublishedExpectation

	callArgs []*MigrationContextMockGetPublishedParams
	mutex    sync.RWMutex
}

// MigrationContextMockGetPublishedExpectation specifies expectation struct of the MigrationContext.GetPublished
type MigrationContextMockGetPublishedExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockGetPublishedParams
	results *MigrationContextMockGetPublishedResults
	Counter uint64
}

// MigrationContextMockGetPublishedParams contains parameters of the MigrationContext.GetPublished
type MigrationContextMockGetPublishedParams struct {
	key interface{}
}

// MigrationContextMockGetPublishedResults contains results of the MigrationContext.GetPublished
type MigrationContextMockGetPublishedResults struct {
	p1 interface{}
}

// Expect sets up expected params for MigrationContext.GetPublished
func (mmGetPublished *mMigrationContextMockGetPublished) Expect(key interface{}) *mMigrationContextMockGetPublished {
	if mmGetPublished.mock.funcGetPublished != nil {
		mmGetPublished.mock.t.Fatalf("MigrationContextMock.GetPublished mock is already set by Set")
	}

	if mmGetPublished.defaultExpectation == nil {
		mmGetPublished.defaultExpectation = &MigrationContextMockGetPublishedExpectation{}
	}

	mmGetPublished.defaultExpectation.params = &MigrationContextMockGetPublishedParams{key}
	for _, e := range mmGetPublished.expectations {
		if minimock.Equal(e.params, mmGetPublished.defaultExpectation.params) {
			mmGetPublished.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPublished.defaultExpectation.params)
		}
	}

	return mmGetPublished
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.GetPublished
func (mmGetPublished *mMigrationContextMockGetPublished) Inspect(f func(key interface{})) *mMigrationContextMockGetPublished {
	if mmGetPublished.mock.inspectFuncGetPublished != nil {
		mmGetPublished.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.GetPublished")
	}

	mmGetPublished.mock.inspectFuncGetPublished = f

	return mmGetPublished
}

// Return sets up results that will be returned by MigrationContext.GetPublished
func (mmGetPublished *mMigrationContextMockGetPublished) Return(p1 interface{}) *MigrationContextMock {
	if mmGetPublished.mock.funcGetPublished != nil {
		mmGetPublished.mock.t.Fatalf("MigrationContextMock.GetPublished mock is already set by Set")
	}

	if mmGetPublished.defaultExpectation == nil {
		mmGetPublished.defaultExpectation = &MigrationContextMockGetPublishedExpectation{mock: mmGetPublished.mock}
	}
	mmGetPublished.defaultExpectation.results = &MigrationContextMockGetPublishedResults{p1}
	return mmGetPublished.mock
}

//Set uses given function f to mock the MigrationContext.GetPublished method
func (mmGetPublished *mMigrationContextMockGetPublished) Set(f func(key interface{}) (p1 interface{})) *MigrationContextMock {
	if mmGetPublished.defaultExpectation != nil {
		mmGetPublished.mock.t.Fatalf("Default expectation is already set for the MigrationContext.GetPublished method")
	}

	if len(mmGetPublished.expectations) > 0 {
		mmGetPublished.mock.t.Fatalf("Some expectations are already set for the MigrationContext.GetPublished method")
	}

	mmGetPublished.mock.funcGetPublished = f
	return mmGetPublished.mock
}

// When sets expectation for the MigrationContext.GetPublished which will trigger the result defined by the following
// Then helper
func (mmGetPublished *mMigrationContextMockGetPublished) When(key interface{}) *MigrationContextMockGetPublishedExpectation {
	if mmGetPublished.mock.funcGetPublished != nil {
		mmGetPublished.mock.t.Fatalf("MigrationContextMock.GetPublished mock is already set by Set")
	}

	expectation := &MigrationContextMockGetPublishedExpectation{
		mock:   mmGetPublished.mock,
		params: &MigrationContextMockGetPublishedParams{key},
	}
	mmGetPublished.expectations = append(mmGetPublished.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.GetPublished return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockGetPublishedExpectation) Then(p1 interface{}) *MigrationContextMock {
	e.results = &MigrationContextMockGetPublishedResults{p1}
	return e.mock
}

// GetPublished implements MigrationContext
func (mmGetPublished *MigrationContextMock) GetPublished(key interface{}) (p1 interface{}) {
	mm_atomic.AddUint64(&mmGetPublished.beforeGetPublishedCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPublished.afterGetPublishedCounter, 1)

	if mmGetPublished.inspectFuncGetPublished != nil {
		mmGetPublished.inspectFuncGetPublished(key)
	}

	mm_params := &MigrationContextMockGetPublishedParams{key}

	// Record call args
	mmGetPublished.GetPublishedMock.mutex.Lock()
	mmGetPublished.GetPublishedMock.callArgs = append(mmGetPublished.GetPublishedMock.callArgs, mm_params)
	mmGetPublished.GetPublishedMock.mutex.Unlock()

	for _, e := range mmGetPublished.GetPublishedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1
		}
	}

	if mmGetPublished.GetPublishedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPublished.GetPublishedMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPublished.GetPublishedMock.defaultExpectation.params
		mm_got := MigrationContextMockGetPublishedParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPublished.t.Errorf("MigrationContextMock.GetPublished got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPublished.GetPublishedMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPublished.t.Fatal("No results are set for the MigrationContextMock.GetPublished")
		}
		return (*mm_results).p1
	}
	if mmGetPublished.funcGetPublished != nil {
		return mmGetPublished.funcGetPublished(key)
	}
	mmGetPublished.t.Fatalf("Unexpected call to MigrationContextMock.GetPublished. %v", key)
	return
}

// GetPublishedAfterCounter returns a count of finished MigrationContextMock.GetPublished invocations
func (mmGetPublished *MigrationContextMock) GetPublishedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublished.afterGetPublishedCounter)
}

// GetPublishedBeforeCounter returns a count of MigrationContextMock.GetPublished invocations
func (mmGetPublished *MigrationContextMock) GetPublishedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublished.beforeGetPublishedCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.GetPublished.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPublished *mMigrationContextMockGetPublished) Calls() []*MigrationContextMockGetPublishedParams {
	mmGetPublished.mutex.RLock()

	argCopy := make([]*MigrationContextMockGetPublishedParams, len(mmGetPublished.callArgs))
	copy(argCopy, mmGetPublished.callArgs)

	mmGetPublished.mutex.RUnlock()

	return argCopy
}

// MinimockGetPublishedDone returns true if the count of the GetPublished invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockGetPublishedDone() bool {
	for _, e := range m.GetPublishedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublished != nil && mm_atomic.LoadUint64(&m.afterGetPublishedCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPublishedInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockGetPublishedInspect() {
	for _, e := range m.GetPublishedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.GetPublished with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedCounter) < 1 {
		if m.GetPublishedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.GetPublished")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.GetPublished with params: %#v", *m.GetPublishedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublished != nil && mm_atomic.LoadUint64(&m.afterGetPublishedCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.GetPublished")
	}
}

type mMigrationContextMockGetPublishedGlobalAlias struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockGetPublishedGlobalAliasExpectation
	expectations       []*MigrationContextMockGetPublishedGlobalAliasExpectation

	callArgs []*MigrationContextMockGetPublishedGlobalAliasParams
	mutex    sync.RWMutex
}

// MigrationContextMockGetPublishedGlobalAliasExpectation specifies expectation struct of the MigrationContext.GetPublishedGlobalAlias
type MigrationContextMockGetPublishedGlobalAliasExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockGetPublishedGlobalAliasParams
	results *MigrationContextMockGetPublishedGlobalAliasResults
	Counter uint64
}

// MigrationContextMockGetPublishedGlobalAliasParams contains parameters of the MigrationContext.GetPublishedGlobalAlias
type MigrationContextMockGetPublishedGlobalAliasParams struct {
	key interface{}
}

// MigrationContextMockGetPublishedGlobalAliasResults contains results of the MigrationContext.GetPublishedGlobalAlias
type MigrationContextMockGetPublishedGlobalAliasResults struct {
	s1 SlotLink
}

// Expect sets up expected params for MigrationContext.GetPublishedGlobalAlias
func (mmGetPublishedGlobalAlias *mMigrationContextMockGetPublishedGlobalAlias) Expect(key interface{}) *mMigrationContextMockGetPublishedGlobalAlias {
	if mmGetPublishedGlobalAlias.mock.funcGetPublishedGlobalAlias != nil {
		mmGetPublishedGlobalAlias.mock.t.Fatalf("MigrationContextMock.GetPublishedGlobalAlias mock is already set by Set")
	}

	if mmGetPublishedGlobalAlias.defaultExpectation == nil {
		mmGetPublishedGlobalAlias.defaultExpectation = &MigrationContextMockGetPublishedGlobalAliasExpectation{}
	}

	mmGetPublishedGlobalAlias.defaultExpectation.params = &MigrationContextMockGetPublishedGlobalAliasParams{key}
	for _, e := range mmGetPublishedGlobalAlias.expectations {
		if minimock.Equal(e.params, mmGetPublishedGlobalAlias.defaultExpectation.params) {
			mmGetPublishedGlobalAlias.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPublishedGlobalAlias.defaultExpectation.params)
		}
	}

	return mmGetPublishedGlobalAlias
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.GetPublishedGlobalAlias
func (mmGetPublishedGlobalAlias *mMigrationContextMockGetPublishedGlobalAlias) Inspect(f func(key interface{})) *mMigrationContextMockGetPublishedGlobalAlias {
	if mmGetPublishedGlobalAlias.mock.inspectFuncGetPublishedGlobalAlias != nil {
		mmGetPublishedGlobalAlias.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.GetPublishedGlobalAlias")
	}

	mmGetPublishedGlobalAlias.mock.inspectFuncGetPublishedGlobalAlias = f

	return mmGetPublishedGlobalAlias
}

// Return sets up results that will be returned by MigrationContext.GetPublishedGlobalAlias
func (mmGetPublishedGlobalAlias *mMigrationContextMockGetPublishedGlobalAlias) Return(s1 SlotLink) *MigrationContextMock {
	if mmGetPublishedGlobalAlias.mock.funcGetPublishedGlobalAlias != nil {
		mmGetPublishedGlobalAlias.mock.t.Fatalf("MigrationContextMock.GetPublishedGlobalAlias mock is already set by Set")
	}

	if mmGetPublishedGlobalAlias.defaultExpectation == nil {
		mmGetPublishedGlobalAlias.defaultExpectation = &MigrationContextMockGetPublishedGlobalAliasExpectation{mock: mmGetPublishedGlobalAlias.mock}
	}
	mmGetPublishedGlobalAlias.defaultExpectation.results = &MigrationContextMockGetPublishedGlobalAliasResults{s1}
	return mmGetPublishedGlobalAlias.mock
}

//Set uses given function f to mock the MigrationContext.GetPublishedGlobalAlias method
func (mmGetPublishedGlobalAlias *mMigrationContextMockGetPublishedGlobalAlias) Set(f func(key interface{}) (s1 SlotLink)) *MigrationContextMock {
	if mmGetPublishedGlobalAlias.defaultExpectation != nil {
		mmGetPublishedGlobalAlias.mock.t.Fatalf("Default expectation is already set for the MigrationContext.GetPublishedGlobalAlias method")
	}

	if len(mmGetPublishedGlobalAlias.expectations) > 0 {
		mmGetPublishedGlobalAlias.mock.t.Fatalf("Some expectations are already set for the MigrationContext.GetPublishedGlobalAlias method")
	}

	mmGetPublishedGlobalAlias.mock.funcGetPublishedGlobalAlias = f
	return mmGetPublishedGlobalAlias.mock
}

// When sets expectation for the MigrationContext.GetPublishedGlobalAlias which will trigger the result defined by the following
// Then helper
func (mmGetPublishedGlobalAlias *mMigrationContextMockGetPublishedGlobalAlias) When(key interface{}) *MigrationContextMockGetPublishedGlobalAliasExpectation {
	if mmGetPublishedGlobalAlias.mock.funcGetPublishedGlobalAlias != nil {
		mmGetPublishedGlobalAlias.mock.t.Fatalf("MigrationContextMock.GetPublishedGlobalAlias mock is already set by Set")
	}

	expectation := &MigrationContextMockGetPublishedGlobalAliasExpectation{
		mock:   mmGetPublishedGlobalAlias.mock,
		params: &MigrationContextMockGetPublishedGlobalAliasParams{key},
	}
	mmGetPublishedGlobalAlias.expectations = append(mmGetPublishedGlobalAlias.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.GetPublishedGlobalAlias return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockGetPublishedGlobalAliasExpectation) Then(s1 SlotLink) *MigrationContextMock {
	e.results = &MigrationContextMockGetPublishedGlobalAliasResults{s1}
	return e.mock
}

// GetPublishedGlobalAlias implements MigrationContext
func (mmGetPublishedGlobalAlias *MigrationContextMock) GetPublishedGlobalAlias(key interface{}) (s1 SlotLink) {
	mm_atomic.AddUint64(&mmGetPublishedGlobalAlias.beforeGetPublishedGlobalAliasCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPublishedGlobalAlias.afterGetPublishedGlobalAliasCounter, 1)

	if mmGetPublishedGlobalAlias.inspectFuncGetPublishedGlobalAlias != nil {
		mmGetPublishedGlobalAlias.inspectFuncGetPublishedGlobalAlias(key)
	}

	mm_params := &MigrationContextMockGetPublishedGlobalAliasParams{key}

	// Record call args
	mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.mutex.Lock()
	mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.callArgs = append(mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.callArgs, mm_params)
	mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.mutex.Unlock()

	for _, e := range mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.defaultExpectation.params
		mm_got := MigrationContextMockGetPublishedGlobalAliasParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPublishedGlobalAlias.t.Errorf("MigrationContextMock.GetPublishedGlobalAlias got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPublishedGlobalAlias.GetPublishedGlobalAliasMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPublishedGlobalAlias.t.Fatal("No results are set for the MigrationContextMock.GetPublishedGlobalAlias")
		}
		return (*mm_results).s1
	}
	if mmGetPublishedGlobalAlias.funcGetPublishedGlobalAlias != nil {
		return mmGetPublishedGlobalAlias.funcGetPublishedGlobalAlias(key)
	}
	mmGetPublishedGlobalAlias.t.Fatalf("Unexpected call to MigrationContextMock.GetPublishedGlobalAlias. %v", key)
	return
}

// GetPublishedGlobalAliasAfterCounter returns a count of finished MigrationContextMock.GetPublishedGlobalAlias invocations
func (mmGetPublishedGlobalAlias *MigrationContextMock) GetPublishedGlobalAliasAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublishedGlobalAlias.afterGetPublishedGlobalAliasCounter)
}

// GetPublishedGlobalAliasBeforeCounter returns a count of MigrationContextMock.GetPublishedGlobalAlias invocations
func (mmGetPublishedGlobalAlias *MigrationContextMock) GetPublishedGlobalAliasBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublishedGlobalAlias.beforeGetPublishedGlobalAliasCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.GetPublishedGlobalAlias.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPublishedGlobalAlias *mMigrationContextMockGetPublishedGlobalAlias) Calls() []*MigrationContextMockGetPublishedGlobalAliasParams {
	mmGetPublishedGlobalAlias.mutex.RLock()

	argCopy := make([]*MigrationContextMockGetPublishedGlobalAliasParams, len(mmGetPublishedGlobalAlias.callArgs))
	copy(argCopy, mmGetPublishedGlobalAlias.callArgs)

	mmGetPublishedGlobalAlias.mutex.RUnlock()

	return argCopy
}

// MinimockGetPublishedGlobalAliasDone returns true if the count of the GetPublishedGlobalAlias invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockGetPublishedGlobalAliasDone() bool {
	for _, e := range m.GetPublishedGlobalAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedGlobalAliasMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublishedGlobalAlias != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPublishedGlobalAliasInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockGetPublishedGlobalAliasInspect() {
	for _, e := range m.GetPublishedGlobalAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.GetPublishedGlobalAlias with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedGlobalAliasMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasCounter) < 1 {
		if m.GetPublishedGlobalAliasMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.GetPublishedGlobalAlias")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.GetPublishedGlobalAlias with params: %#v", *m.GetPublishedGlobalAliasMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublishedGlobalAlias != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.GetPublishedGlobalAlias")
	}
}

type mMigrationContextMockGetPublishedGlobalAliasAndBargeIn struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockGetPublishedGlobalAliasAndBargeInExpectation
	expectations       []*MigrationContextMockGetPublishedGlobalAliasAndBargeInExpectation

	callArgs []*MigrationContextMockGetPublishedGlobalAliasAndBargeInParams
	mutex    sync.RWMutex
}

// MigrationContextMockGetPublishedGlobalAliasAndBargeInExpectation specifies expectation struct of the MigrationContext.GetPublishedGlobalAliasAndBargeIn
type MigrationContextMockGetPublishedGlobalAliasAndBargeInExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockGetPublishedGlobalAliasAndBargeInParams
	results *MigrationContextMockGetPublishedGlobalAliasAndBargeInResults
	Counter uint64
}

// MigrationContextMockGetPublishedGlobalAliasAndBargeInParams contains parameters of the MigrationContext.GetPublishedGlobalAliasAndBargeIn
type MigrationContextMockGetPublishedGlobalAliasAndBargeInParams struct {
	key interface{}
}

// MigrationContextMockGetPublishedGlobalAliasAndBargeInResults contains results of the MigrationContext.GetPublishedGlobalAliasAndBargeIn
type MigrationContextMockGetPublishedGlobalAliasAndBargeInResults struct {
	s1 SlotLink
	b1 BargeInHolder
}

// Expect sets up expected params for MigrationContext.GetPublishedGlobalAliasAndBargeIn
func (mmGetPublishedGlobalAliasAndBargeIn *mMigrationContextMockGetPublishedGlobalAliasAndBargeIn) Expect(key interface{}) *mMigrationContextMockGetPublishedGlobalAliasAndBargeIn {
	if mmGetPublishedGlobalAliasAndBargeIn.mock.funcGetPublishedGlobalAliasAndBargeIn != nil {
		mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("MigrationContextMock.GetPublishedGlobalAliasAndBargeIn mock is already set by Set")
	}

	if mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation == nil {
		mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation = &MigrationContextMockGetPublishedGlobalAliasAndBargeInExpectation{}
	}

	mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation.params = &MigrationContextMockGetPublishedGlobalAliasAndBargeInParams{key}
	for _, e := range mmGetPublishedGlobalAliasAndBargeIn.expectations {
		if minimock.Equal(e.params, mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation.params) {
			mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation.params)
		}
	}

	return mmGetPublishedGlobalAliasAndBargeIn
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.GetPublishedGlobalAliasAndBargeIn
func (mmGetPublishedGlobalAliasAndBargeIn *mMigrationContextMockGetPublishedGlobalAliasAndBargeIn) Inspect(f func(key interface{})) *mMigrationContextMockGetPublishedGlobalAliasAndBargeIn {
	if mmGetPublishedGlobalAliasAndBargeIn.mock.inspectFuncGetPublishedGlobalAliasAndBargeIn != nil {
		mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.GetPublishedGlobalAliasAndBargeIn")
	}

	mmGetPublishedGlobalAliasAndBargeIn.mock.inspectFuncGetPublishedGlobalAliasAndBargeIn = f

	return mmGetPublishedGlobalAliasAndBargeIn
}

// Return sets up results that will be returned by MigrationContext.GetPublishedGlobalAliasAndBargeIn
func (mmGetPublishedGlobalAliasAndBargeIn *mMigrationContextMockGetPublishedGlobalAliasAndBargeIn) Return(s1 SlotLink, b1 BargeInHolder) *MigrationContextMock {
	if mmGetPublishedGlobalAliasAndBargeIn.mock.funcGetPublishedGlobalAliasAndBargeIn != nil {
		mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("MigrationContextMock.GetPublishedGlobalAliasAndBargeIn mock is already set by Set")
	}

	if mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation == nil {
		mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation = &MigrationContextMockGetPublishedGlobalAliasAndBargeInExpectation{mock: mmGetPublishedGlobalAliasAndBargeIn.mock}
	}
	mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation.results = &MigrationContextMockGetPublishedGlobalAliasAndBargeInResults{s1, b1}
	return mmGetPublishedGlobalAliasAndBargeIn.mock
}

//Set uses given function f to mock the MigrationContext.GetPublishedGlobalAliasAndBargeIn method
func (mmGetPublishedGlobalAliasAndBargeIn *mMigrationContextMockGetPublishedGlobalAliasAndBargeIn) Set(f func(key interface{}) (s1 SlotLink, b1 BargeInHolder)) *MigrationContextMock {
	if mmGetPublishedGlobalAliasAndBargeIn.defaultExpectation != nil {
		mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("Default expectation is already set for the MigrationContext.GetPublishedGlobalAliasAndBargeIn method")
	}

	if len(mmGetPublishedGlobalAliasAndBargeIn.expectations) > 0 {
		mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("Some expectations are already set for the MigrationContext.GetPublishedGlobalAliasAndBargeIn method")
	}

	mmGetPublishedGlobalAliasAndBargeIn.mock.funcGetPublishedGlobalAliasAndBargeIn = f
	return mmGetPublishedGlobalAliasAndBargeIn.mock
}

// When sets expectation for the MigrationContext.GetPublishedGlobalAliasAndBargeIn which will trigger the result defined by the following
// Then helper
func (mmGetPublishedGlobalAliasAndBargeIn *mMigrationContextMockGetPublishedGlobalAliasAndBargeIn) When(key interface{}) *MigrationContextMockGetPublishedGlobalAliasAndBargeInExpectation {
	if mmGetPublishedGlobalAliasAndBargeIn.mock.funcGetPublishedGlobalAliasAndBargeIn != nil {
		mmGetPublishedGlobalAliasAndBargeIn.mock.t.Fatalf("MigrationContextMock.GetPublishedGlobalAliasAndBargeIn mock is already set by Set")
	}

	expectation := &MigrationContextMockGetPublishedGlobalAliasAndBargeInExpectation{
		mock:   mmGetPublishedGlobalAliasAndBargeIn.mock,
		params: &MigrationContextMockGetPublishedGlobalAliasAndBargeInParams{key},
	}
	mmGetPublishedGlobalAliasAndBargeIn.expectations = append(mmGetPublishedGlobalAliasAndBargeIn.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.GetPublishedGlobalAliasAndBargeIn return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockGetPublishedGlobalAliasAndBargeInExpectation) Then(s1 SlotLink, b1 BargeInHolder) *MigrationContextMock {
	e.results = &MigrationContextMockGetPublishedGlobalAliasAndBargeInResults{s1, b1}
	return e.mock
}

// GetPublishedGlobalAliasAndBargeIn implements MigrationContext
func (mmGetPublishedGlobalAliasAndBargeIn *MigrationContextMock) GetPublishedGlobalAliasAndBargeIn(key interface{}) (s1 SlotLink, b1 BargeInHolder) {
	mm_atomic.AddUint64(&mmGetPublishedGlobalAliasAndBargeIn.beforeGetPublishedGlobalAliasAndBargeInCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPublishedGlobalAliasAndBargeIn.afterGetPublishedGlobalAliasAndBargeInCounter, 1)

	if mmGetPublishedGlobalAliasAndBargeIn.inspectFuncGetPublishedGlobalAliasAndBargeIn != nil {
		mmGetPublishedGlobalAliasAndBargeIn.inspectFuncGetPublishedGlobalAliasAndBargeIn(key)
	}

	mm_params := &MigrationContextMockGetPublishedGlobalAliasAndBargeInParams{key}

	// Record call args
	mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.mutex.Lock()
	mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.callArgs = append(mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.callArgs, mm_params)
	mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.mutex.Unlock()

	for _, e := range mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.b1
		}
	}

	if mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation.params
		mm_got := MigrationContextMockGetPublishedGlobalAliasAndBargeInParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPublishedGlobalAliasAndBargeIn.t.Errorf("MigrationContextMock.GetPublishedGlobalAliasAndBargeIn got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPublishedGlobalAliasAndBargeIn.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPublishedGlobalAliasAndBargeIn.t.Fatal("No results are set for the MigrationContextMock.GetPublishedGlobalAliasAndBargeIn")
		}
		return (*mm_results).s1, (*mm_results).b1
	}
	if mmGetPublishedGlobalAliasAndBargeIn.funcGetPublishedGlobalAliasAndBargeIn != nil {
		return mmGetPublishedGlobalAliasAndBargeIn.funcGetPublishedGlobalAliasAndBargeIn(key)
	}
	mmGetPublishedGlobalAliasAndBargeIn.t.Fatalf("Unexpected call to MigrationContextMock.GetPublishedGlobalAliasAndBargeIn. %v", key)
	return
}

// GetPublishedGlobalAliasAndBargeInAfterCounter returns a count of finished MigrationContextMock.GetPublishedGlobalAliasAndBargeIn invocations
func (mmGetPublishedGlobalAliasAndBargeIn *MigrationContextMock) GetPublishedGlobalAliasAndBargeInAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublishedGlobalAliasAndBargeIn.afterGetPublishedGlobalAliasAndBargeInCounter)
}

// GetPublishedGlobalAliasAndBargeInBeforeCounter returns a count of MigrationContextMock.GetPublishedGlobalAliasAndBargeIn invocations
func (mmGetPublishedGlobalAliasAndBargeIn *MigrationContextMock) GetPublishedGlobalAliasAndBargeInBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublishedGlobalAliasAndBargeIn.beforeGetPublishedGlobalAliasAndBargeInCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.GetPublishedGlobalAliasAndBargeIn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPublishedGlobalAliasAndBargeIn *mMigrationContextMockGetPublishedGlobalAliasAndBargeIn) Calls() []*MigrationContextMockGetPublishedGlobalAliasAndBargeInParams {
	mmGetPublishedGlobalAliasAndBargeIn.mutex.RLock()

	argCopy := make([]*MigrationContextMockGetPublishedGlobalAliasAndBargeInParams, len(mmGetPublishedGlobalAliasAndBargeIn.callArgs))
	copy(argCopy, mmGetPublishedGlobalAliasAndBargeIn.callArgs)

	mmGetPublishedGlobalAliasAndBargeIn.mutex.RUnlock()

	return argCopy
}

// MinimockGetPublishedGlobalAliasAndBargeInDone returns true if the count of the GetPublishedGlobalAliasAndBargeIn invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockGetPublishedGlobalAliasAndBargeInDone() bool {
	for _, e := range m.GetPublishedGlobalAliasAndBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasAndBargeInCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublishedGlobalAliasAndBargeIn != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasAndBargeInCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPublishedGlobalAliasAndBargeInInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockGetPublishedGlobalAliasAndBargeInInspect() {
	for _, e := range m.GetPublishedGlobalAliasAndBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.GetPublishedGlobalAliasAndBargeIn with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasAndBargeInCounter) < 1 {
		if m.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.GetPublishedGlobalAliasAndBargeIn")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.GetPublishedGlobalAliasAndBargeIn with params: %#v", *m.GetPublishedGlobalAliasAndBargeInMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublishedGlobalAliasAndBargeIn != nil && mm_atomic.LoadUint64(&m.afterGetPublishedGlobalAliasAndBargeInCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.GetPublishedGlobalAliasAndBargeIn")
	}
}

type mMigrationContextMockGetPublishedLink struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockGetPublishedLinkExpectation
	expectations       []*MigrationContextMockGetPublishedLinkExpectation

	callArgs []*MigrationContextMockGetPublishedLinkParams
	mutex    sync.RWMutex
}

// MigrationContextMockGetPublishedLinkExpectation specifies expectation struct of the MigrationContext.GetPublishedLink
type MigrationContextMockGetPublishedLinkExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockGetPublishedLinkParams
	results *MigrationContextMockGetPublishedLinkResults
	Counter uint64
}

// MigrationContextMockGetPublishedLinkParams contains parameters of the MigrationContext.GetPublishedLink
type MigrationContextMockGetPublishedLinkParams struct {
	key interface{}
}

// MigrationContextMockGetPublishedLinkResults contains results of the MigrationContext.GetPublishedLink
type MigrationContextMockGetPublishedLinkResults struct {
	s1 SharedDataLink
}

// Expect sets up expected params for MigrationContext.GetPublishedLink
func (mmGetPublishedLink *mMigrationContextMockGetPublishedLink) Expect(key interface{}) *mMigrationContextMockGetPublishedLink {
	if mmGetPublishedLink.mock.funcGetPublishedLink != nil {
		mmGetPublishedLink.mock.t.Fatalf("MigrationContextMock.GetPublishedLink mock is already set by Set")
	}

	if mmGetPublishedLink.defaultExpectation == nil {
		mmGetPublishedLink.defaultExpectation = &MigrationContextMockGetPublishedLinkExpectation{}
	}

	mmGetPublishedLink.defaultExpectation.params = &MigrationContextMockGetPublishedLinkParams{key}
	for _, e := range mmGetPublishedLink.expectations {
		if minimock.Equal(e.params, mmGetPublishedLink.defaultExpectation.params) {
			mmGetPublishedLink.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPublishedLink.defaultExpectation.params)
		}
	}

	return mmGetPublishedLink
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.GetPublishedLink
func (mmGetPublishedLink *mMigrationContextMockGetPublishedLink) Inspect(f func(key interface{})) *mMigrationContextMockGetPublishedLink {
	if mmGetPublishedLink.mock.inspectFuncGetPublishedLink != nil {
		mmGetPublishedLink.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.GetPublishedLink")
	}

	mmGetPublishedLink.mock.inspectFuncGetPublishedLink = f

	return mmGetPublishedLink
}

// Return sets up results that will be returned by MigrationContext.GetPublishedLink
func (mmGetPublishedLink *mMigrationContextMockGetPublishedLink) Return(s1 SharedDataLink) *MigrationContextMock {
	if mmGetPublishedLink.mock.funcGetPublishedLink != nil {
		mmGetPublishedLink.mock.t.Fatalf("MigrationContextMock.GetPublishedLink mock is already set by Set")
	}

	if mmGetPublishedLink.defaultExpectation == nil {
		mmGetPublishedLink.defaultExpectation = &MigrationContextMockGetPublishedLinkExpectation{mock: mmGetPublishedLink.mock}
	}
	mmGetPublishedLink.defaultExpectation.results = &MigrationContextMockGetPublishedLinkResults{s1}
	return mmGetPublishedLink.mock
}

//Set uses given function f to mock the MigrationContext.GetPublishedLink method
func (mmGetPublishedLink *mMigrationContextMockGetPublishedLink) Set(f func(key interface{}) (s1 SharedDataLink)) *MigrationContextMock {
	if mmGetPublishedLink.defaultExpectation != nil {
		mmGetPublishedLink.mock.t.Fatalf("Default expectation is already set for the MigrationContext.GetPublishedLink method")
	}

	if len(mmGetPublishedLink.expectations) > 0 {
		mmGetPublishedLink.mock.t.Fatalf("Some expectations are already set for the MigrationContext.GetPublishedLink method")
	}

	mmGetPublishedLink.mock.funcGetPublishedLink = f
	return mmGetPublishedLink.mock
}

// When sets expectation for the MigrationContext.GetPublishedLink which will trigger the result defined by the following
// Then helper
func (mmGetPublishedLink *mMigrationContextMockGetPublishedLink) When(key interface{}) *MigrationContextMockGetPublishedLinkExpectation {
	if mmGetPublishedLink.mock.funcGetPublishedLink != nil {
		mmGetPublishedLink.mock.t.Fatalf("MigrationContextMock.GetPublishedLink mock is already set by Set")
	}

	expectation := &MigrationContextMockGetPublishedLinkExpectation{
		mock:   mmGetPublishedLink.mock,
		params: &MigrationContextMockGetPublishedLinkParams{key},
	}
	mmGetPublishedLink.expectations = append(mmGetPublishedLink.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.GetPublishedLink return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockGetPublishedLinkExpectation) Then(s1 SharedDataLink) *MigrationContextMock {
	e.results = &MigrationContextMockGetPublishedLinkResults{s1}
	return e.mock
}

// GetPublishedLink implements MigrationContext
func (mmGetPublishedLink *MigrationContextMock) GetPublishedLink(key interface{}) (s1 SharedDataLink) {
	mm_atomic.AddUint64(&mmGetPublishedLink.beforeGetPublishedLinkCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPublishedLink.afterGetPublishedLinkCounter, 1)

	if mmGetPublishedLink.inspectFuncGetPublishedLink != nil {
		mmGetPublishedLink.inspectFuncGetPublishedLink(key)
	}

	mm_params := &MigrationContextMockGetPublishedLinkParams{key}

	// Record call args
	mmGetPublishedLink.GetPublishedLinkMock.mutex.Lock()
	mmGetPublishedLink.GetPublishedLinkMock.callArgs = append(mmGetPublishedLink.GetPublishedLinkMock.callArgs, mm_params)
	mmGetPublishedLink.GetPublishedLinkMock.mutex.Unlock()

	for _, e := range mmGetPublishedLink.GetPublishedLinkMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmGetPublishedLink.GetPublishedLinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPublishedLink.GetPublishedLinkMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPublishedLink.GetPublishedLinkMock.defaultExpectation.params
		mm_got := MigrationContextMockGetPublishedLinkParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPublishedLink.t.Errorf("MigrationContextMock.GetPublishedLink got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPublishedLink.GetPublishedLinkMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPublishedLink.t.Fatal("No results are set for the MigrationContextMock.GetPublishedLink")
		}
		return (*mm_results).s1
	}
	if mmGetPublishedLink.funcGetPublishedLink != nil {
		return mmGetPublishedLink.funcGetPublishedLink(key)
	}
	mmGetPublishedLink.t.Fatalf("Unexpected call to MigrationContextMock.GetPublishedLink. %v", key)
	return
}

// GetPublishedLinkAfterCounter returns a count of finished MigrationContextMock.GetPublishedLink invocations
func (mmGetPublishedLink *MigrationContextMock) GetPublishedLinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublishedLink.afterGetPublishedLinkCounter)
}

// GetPublishedLinkBeforeCounter returns a count of MigrationContextMock.GetPublishedLink invocations
func (mmGetPublishedLink *MigrationContextMock) GetPublishedLinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublishedLink.beforeGetPublishedLinkCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.GetPublishedLink.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPublishedLink *mMigrationContextMockGetPublishedLink) Calls() []*MigrationContextMockGetPublishedLinkParams {
	mmGetPublishedLink.mutex.RLock()

	argCopy := make([]*MigrationContextMockGetPublishedLinkParams, len(mmGetPublishedLink.callArgs))
	copy(argCopy, mmGetPublishedLink.callArgs)

	mmGetPublishedLink.mutex.RUnlock()

	return argCopy
}

// MinimockGetPublishedLinkDone returns true if the count of the GetPublishedLink invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockGetPublishedLinkDone() bool {
	for _, e := range m.GetPublishedLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedLinkCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublishedLink != nil && mm_atomic.LoadUint64(&m.afterGetPublishedLinkCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPublishedLinkInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockGetPublishedLinkInspect() {
	for _, e := range m.GetPublishedLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.GetPublishedLink with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublishedLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublishedLinkCounter) < 1 {
		if m.GetPublishedLinkMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.GetPublishedLink")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.GetPublishedLink with params: %#v", *m.GetPublishedLinkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublishedLink != nil && mm_atomic.LoadUint64(&m.afterGetPublishedLinkCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.GetPublishedLink")
	}
}

type mMigrationContextMockGetTerminationResult struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockGetTerminationResultExpectation
	expectations       []*MigrationContextMockGetTerminationResultExpectation
}

// MigrationContextMockGetTerminationResultExpectation specifies expectation struct of the MigrationContext.GetTerminationResult
type MigrationContextMockGetTerminationResultExpectation struct {
	mock *MigrationContextMock

	results *MigrationContextMockGetTerminationResultResults
	Counter uint64
}

// MigrationContextMockGetTerminationResultResults contains results of the MigrationContext.GetTerminationResult
type MigrationContextMockGetTerminationResultResults struct {
	p1 interface{}
}

// Expect sets up expected params for MigrationContext.GetTerminationResult
func (mmGetTerminationResult *mMigrationContextMockGetTerminationResult) Expect() *mMigrationContextMockGetTerminationResult {
	if mmGetTerminationResult.mock.funcGetTerminationResult != nil {
		mmGetTerminationResult.mock.t.Fatalf("MigrationContextMock.GetTerminationResult mock is already set by Set")
	}

	if mmGetTerminationResult.defaultExpectation == nil {
		mmGetTerminationResult.defaultExpectation = &MigrationContextMockGetTerminationResultExpectation{}
	}

	return mmGetTerminationResult
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.GetTerminationResult
func (mmGetTerminationResult *mMigrationContextMockGetTerminationResult) Inspect(f func()) *mMigrationContextMockGetTerminationResult {
	if mmGetTerminationResult.mock.inspectFuncGetTerminationResult != nil {
		mmGetTerminationResult.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.GetTerminationResult")
	}

	mmGetTerminationResult.mock.inspectFuncGetTerminationResult = f

	return mmGetTerminationResult
}

// Return sets up results that will be returned by MigrationContext.GetTerminationResult
func (mmGetTerminationResult *mMigrationContextMockGetTerminationResult) Return(p1 interface{}) *MigrationContextMock {
	if mmGetTerminationResult.mock.funcGetTerminationResult != nil {
		mmGetTerminationResult.mock.t.Fatalf("MigrationContextMock.GetTerminationResult mock is already set by Set")
	}

	if mmGetTerminationResult.defaultExpectation == nil {
		mmGetTerminationResult.defaultExpectation = &MigrationContextMockGetTerminationResultExpectation{mock: mmGetTerminationResult.mock}
	}
	mmGetTerminationResult.defaultExpectation.results = &MigrationContextMockGetTerminationResultResults{p1}
	return mmGetTerminationResult.mock
}

//Set uses given function f to mock the MigrationContext.GetTerminationResult method
func (mmGetTerminationResult *mMigrationContextMockGetTerminationResult) Set(f func() (p1 interface{})) *MigrationContextMock {
	if mmGetTerminationResult.defaultExpectation != nil {
		mmGetTerminationResult.mock.t.Fatalf("Default expectation is already set for the MigrationContext.GetTerminationResult method")
	}

	if len(mmGetTerminationResult.expectations) > 0 {
		mmGetTerminationResult.mock.t.Fatalf("Some expectations are already set for the MigrationContext.GetTerminationResult method")
	}

	mmGetTerminationResult.mock.funcGetTerminationResult = f
	return mmGetTerminationResult.mock
}

// GetTerminationResult implements MigrationContext
func (mmGetTerminationResult *MigrationContextMock) GetTerminationResult() (p1 interface{}) {
	mm_atomic.AddUint64(&mmGetTerminationResult.beforeGetTerminationResultCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTerminationResult.afterGetTerminationResultCounter, 1)

	if mmGetTerminationResult.inspectFuncGetTerminationResult != nil {
		mmGetTerminationResult.inspectFuncGetTerminationResult()
	}

	if mmGetTerminationResult.GetTerminationResultMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTerminationResult.GetTerminationResultMock.defaultExpectation.Counter, 1)

		mm_results := mmGetTerminationResult.GetTerminationResultMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTerminationResult.t.Fatal("No results are set for the MigrationContextMock.GetTerminationResult")
		}
		return (*mm_results).p1
	}
	if mmGetTerminationResult.funcGetTerminationResult != nil {
		return mmGetTerminationResult.funcGetTerminationResult()
	}
	mmGetTerminationResult.t.Fatalf("Unexpected call to MigrationContextMock.GetTerminationResult.")
	return
}

// GetTerminationResultAfterCounter returns a count of finished MigrationContextMock.GetTerminationResult invocations
func (mmGetTerminationResult *MigrationContextMock) GetTerminationResultAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTerminationResult.afterGetTerminationResultCounter)
}

// GetTerminationResultBeforeCounter returns a count of MigrationContextMock.GetTerminationResult invocations
func (mmGetTerminationResult *MigrationContextMock) GetTerminationResultBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTerminationResult.beforeGetTerminationResultCounter)
}

// MinimockGetTerminationResultDone returns true if the count of the GetTerminationResult invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockGetTerminationResultDone() bool {
	for _, e := range m.GetTerminationResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTerminationResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTerminationResultCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTerminationResult != nil && mm_atomic.LoadUint64(&m.afterGetTerminationResultCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetTerminationResultInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockGetTerminationResultInspect() {
	for _, e := range m.GetTerminationResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MigrationContextMock.GetTerminationResult")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTerminationResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTerminationResultCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.GetTerminationResult")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTerminationResult != nil && mm_atomic.LoadUint64(&m.afterGetTerminationResultCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.GetTerminationResult")
	}
}

type mMigrationContextMockJump struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockJumpExpectation
	expectations       []*MigrationContextMockJumpExpectation

	callArgs []*MigrationContextMockJumpParams
	mutex    sync.RWMutex
}

// MigrationContextMockJumpExpectation specifies expectation struct of the MigrationContext.Jump
type MigrationContextMockJumpExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockJumpParams
	results *MigrationContextMockJumpResults
	Counter uint64
}

// MigrationContextMockJumpParams contains parameters of the MigrationContext.Jump
type MigrationContextMockJumpParams struct {
	s1 StateFunc
}

// MigrationContextMockJumpResults contains results of the MigrationContext.Jump
type MigrationContextMockJumpResults struct {
	s2 StateUpdate
}

// Expect sets up expected params for MigrationContext.Jump
func (mmJump *mMigrationContextMockJump) Expect(s1 StateFunc) *mMigrationContextMockJump {
	if mmJump.mock.funcJump != nil {
		mmJump.mock.t.Fatalf("MigrationContextMock.Jump mock is already set by Set")
	}

	if mmJump.defaultExpectation == nil {
		mmJump.defaultExpectation = &MigrationContextMockJumpExpectation{}
	}

	mmJump.defaultExpectation.params = &MigrationContextMockJumpParams{s1}
	for _, e := range mmJump.expectations {
		if minimock.Equal(e.params, mmJump.defaultExpectation.params) {
			mmJump.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmJump.defaultExpectation.params)
		}
	}

	return mmJump
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.Jump
func (mmJump *mMigrationContextMockJump) Inspect(f func(s1 StateFunc)) *mMigrationContextMockJump {
	if mmJump.mock.inspectFuncJump != nil {
		mmJump.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.Jump")
	}

	mmJump.mock.inspectFuncJump = f

	return mmJump
}

// Return sets up results that will be returned by MigrationContext.Jump
func (mmJump *mMigrationContextMockJump) Return(s2 StateUpdate) *MigrationContextMock {
	if mmJump.mock.funcJump != nil {
		mmJump.mock.t.Fatalf("MigrationContextMock.Jump mock is already set by Set")
	}

	if mmJump.defaultExpectation == nil {
		mmJump.defaultExpectation = &MigrationContextMockJumpExpectation{mock: mmJump.mock}
	}
	mmJump.defaultExpectation.results = &MigrationContextMockJumpResults{s2}
	return mmJump.mock
}

//Set uses given function f to mock the MigrationContext.Jump method
func (mmJump *mMigrationContextMockJump) Set(f func(s1 StateFunc) (s2 StateUpdate)) *MigrationContextMock {
	if mmJump.defaultExpectation != nil {
		mmJump.mock.t.Fatalf("Default expectation is already set for the MigrationContext.Jump method")
	}

	if len(mmJump.expectations) > 0 {
		mmJump.mock.t.Fatalf("Some expectations are already set for the MigrationContext.Jump method")
	}

	mmJump.mock.funcJump = f
	return mmJump.mock
}

// When sets expectation for the MigrationContext.Jump which will trigger the result defined by the following
// Then helper
func (mmJump *mMigrationContextMockJump) When(s1 StateFunc) *MigrationContextMockJumpExpectation {
	if mmJump.mock.funcJump != nil {
		mmJump.mock.t.Fatalf("MigrationContextMock.Jump mock is already set by Set")
	}

	expectation := &MigrationContextMockJumpExpectation{
		mock:   mmJump.mock,
		params: &MigrationContextMockJumpParams{s1},
	}
	mmJump.expectations = append(mmJump.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.Jump return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockJumpExpectation) Then(s2 StateUpdate) *MigrationContextMock {
	e.results = &MigrationContextMockJumpResults{s2}
	return e.mock
}

// Jump implements MigrationContext
func (mmJump *MigrationContextMock) Jump(s1 StateFunc) (s2 StateUpdate) {
	mm_atomic.AddUint64(&mmJump.beforeJumpCounter, 1)
	defer mm_atomic.AddUint64(&mmJump.afterJumpCounter, 1)

	if mmJump.inspectFuncJump != nil {
		mmJump.inspectFuncJump(s1)
	}

	mm_params := &MigrationContextMockJumpParams{s1}

	// Record call args
	mmJump.JumpMock.mutex.Lock()
	mmJump.JumpMock.callArgs = append(mmJump.JumpMock.callArgs, mm_params)
	mmJump.JumpMock.mutex.Unlock()

	for _, e := range mmJump.JumpMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2
		}
	}

	if mmJump.JumpMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmJump.JumpMock.defaultExpectation.Counter, 1)
		mm_want := mmJump.JumpMock.defaultExpectation.params
		mm_got := MigrationContextMockJumpParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmJump.t.Errorf("MigrationContextMock.Jump got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmJump.JumpMock.defaultExpectation.results
		if mm_results == nil {
			mmJump.t.Fatal("No results are set for the MigrationContextMock.Jump")
		}
		return (*mm_results).s2
	}
	if mmJump.funcJump != nil {
		return mmJump.funcJump(s1)
	}
	mmJump.t.Fatalf("Unexpected call to MigrationContextMock.Jump. %v", s1)
	return
}

// JumpAfterCounter returns a count of finished MigrationContextMock.Jump invocations
func (mmJump *MigrationContextMock) JumpAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJump.afterJumpCounter)
}

// JumpBeforeCounter returns a count of MigrationContextMock.Jump invocations
func (mmJump *MigrationContextMock) JumpBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJump.beforeJumpCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.Jump.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmJump *mMigrationContextMockJump) Calls() []*MigrationContextMockJumpParams {
	mmJump.mutex.RLock()

	argCopy := make([]*MigrationContextMockJumpParams, len(mmJump.callArgs))
	copy(argCopy, mmJump.callArgs)

	mmJump.mutex.RUnlock()

	return argCopy
}

// MinimockJumpDone returns true if the count of the Jump invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockJumpDone() bool {
	for _, e := range m.JumpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.JumpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterJumpCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJump != nil && mm_atomic.LoadUint64(&m.afterJumpCounter) < 1 {
		return false
	}
	return true
}

// MinimockJumpInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockJumpInspect() {
	for _, e := range m.JumpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.Jump with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.JumpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterJumpCounter) < 1 {
		if m.JumpMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.Jump")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.Jump with params: %#v", *m.JumpMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJump != nil && mm_atomic.LoadUint64(&m.afterJumpCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.Jump")
	}
}

type mMigrationContextMockJumpExt struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockJumpExtExpectation
	expectations       []*MigrationContextMockJumpExtExpectation

	callArgs []*MigrationContextMockJumpExtParams
	mutex    sync.RWMutex
}

// MigrationContextMockJumpExtExpectation specifies expectation struct of the MigrationContext.JumpExt
type MigrationContextMockJumpExtExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockJumpExtParams
	results *MigrationContextMockJumpExtResults
	Counter uint64
}

// MigrationContextMockJumpExtParams contains parameters of the MigrationContext.JumpExt
type MigrationContextMockJumpExtParams struct {
	s1 SlotStep
}

// MigrationContextMockJumpExtResults contains results of the MigrationContext.JumpExt
type MigrationContextMockJumpExtResults struct {
	s2 StateUpdate
}

// Expect sets up expected params for MigrationContext.JumpExt
func (mmJumpExt *mMigrationContextMockJumpExt) Expect(s1 SlotStep) *mMigrationContextMockJumpExt {
	if mmJumpExt.mock.funcJumpExt != nil {
		mmJumpExt.mock.t.Fatalf("MigrationContextMock.JumpExt mock is already set by Set")
	}

	if mmJumpExt.defaultExpectation == nil {
		mmJumpExt.defaultExpectation = &MigrationContextMockJumpExtExpectation{}
	}

	mmJumpExt.defaultExpectation.params = &MigrationContextMockJumpExtParams{s1}
	for _, e := range mmJumpExt.expectations {
		if minimock.Equal(e.params, mmJumpExt.defaultExpectation.params) {
			mmJumpExt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmJumpExt.defaultExpectation.params)
		}
	}

	return mmJumpExt
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.JumpExt
func (mmJumpExt *mMigrationContextMockJumpExt) Inspect(f func(s1 SlotStep)) *mMigrationContextMockJumpExt {
	if mmJumpExt.mock.inspectFuncJumpExt != nil {
		mmJumpExt.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.JumpExt")
	}

	mmJumpExt.mock.inspectFuncJumpExt = f

	return mmJumpExt
}

// Return sets up results that will be returned by MigrationContext.JumpExt
func (mmJumpExt *mMigrationContextMockJumpExt) Return(s2 StateUpdate) *MigrationContextMock {
	if mmJumpExt.mock.funcJumpExt != nil {
		mmJumpExt.mock.t.Fatalf("MigrationContextMock.JumpExt mock is already set by Set")
	}

	if mmJumpExt.defaultExpectation == nil {
		mmJumpExt.defaultExpectation = &MigrationContextMockJumpExtExpectation{mock: mmJumpExt.mock}
	}
	mmJumpExt.defaultExpectation.results = &MigrationContextMockJumpExtResults{s2}
	return mmJumpExt.mock
}

//Set uses given function f to mock the MigrationContext.JumpExt method
func (mmJumpExt *mMigrationContextMockJumpExt) Set(f func(s1 SlotStep) (s2 StateUpdate)) *MigrationContextMock {
	if mmJumpExt.defaultExpectation != nil {
		mmJumpExt.mock.t.Fatalf("Default expectation is already set for the MigrationContext.JumpExt method")
	}

	if len(mmJumpExt.expectations) > 0 {
		mmJumpExt.mock.t.Fatalf("Some expectations are already set for the MigrationContext.JumpExt method")
	}

	mmJumpExt.mock.funcJumpExt = f
	return mmJumpExt.mock
}

// When sets expectation for the MigrationContext.JumpExt which will trigger the result defined by the following
// Then helper
func (mmJumpExt *mMigrationContextMockJumpExt) When(s1 SlotStep) *MigrationContextMockJumpExtExpectation {
	if mmJumpExt.mock.funcJumpExt != nil {
		mmJumpExt.mock.t.Fatalf("MigrationContextMock.JumpExt mock is already set by Set")
	}

	expectation := &MigrationContextMockJumpExtExpectation{
		mock:   mmJumpExt.mock,
		params: &MigrationContextMockJumpExtParams{s1},
	}
	mmJumpExt.expectations = append(mmJumpExt.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.JumpExt return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockJumpExtExpectation) Then(s2 StateUpdate) *MigrationContextMock {
	e.results = &MigrationContextMockJumpExtResults{s2}
	return e.mock
}

// JumpExt implements MigrationContext
func (mmJumpExt *MigrationContextMock) JumpExt(s1 SlotStep) (s2 StateUpdate) {
	mm_atomic.AddUint64(&mmJumpExt.beforeJumpExtCounter, 1)
	defer mm_atomic.AddUint64(&mmJumpExt.afterJumpExtCounter, 1)

	if mmJumpExt.inspectFuncJumpExt != nil {
		mmJumpExt.inspectFuncJumpExt(s1)
	}

	mm_params := &MigrationContextMockJumpExtParams{s1}

	// Record call args
	mmJumpExt.JumpExtMock.mutex.Lock()
	mmJumpExt.JumpExtMock.callArgs = append(mmJumpExt.JumpExtMock.callArgs, mm_params)
	mmJumpExt.JumpExtMock.mutex.Unlock()

	for _, e := range mmJumpExt.JumpExtMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2
		}
	}

	if mmJumpExt.JumpExtMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmJumpExt.JumpExtMock.defaultExpectation.Counter, 1)
		mm_want := mmJumpExt.JumpExtMock.defaultExpectation.params
		mm_got := MigrationContextMockJumpExtParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmJumpExt.t.Errorf("MigrationContextMock.JumpExt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmJumpExt.JumpExtMock.defaultExpectation.results
		if mm_results == nil {
			mmJumpExt.t.Fatal("No results are set for the MigrationContextMock.JumpExt")
		}
		return (*mm_results).s2
	}
	if mmJumpExt.funcJumpExt != nil {
		return mmJumpExt.funcJumpExt(s1)
	}
	mmJumpExt.t.Fatalf("Unexpected call to MigrationContextMock.JumpExt. %v", s1)
	return
}

// JumpExtAfterCounter returns a count of finished MigrationContextMock.JumpExt invocations
func (mmJumpExt *MigrationContextMock) JumpExtAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJumpExt.afterJumpExtCounter)
}

// JumpExtBeforeCounter returns a count of MigrationContextMock.JumpExt invocations
func (mmJumpExt *MigrationContextMock) JumpExtBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJumpExt.beforeJumpExtCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.JumpExt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmJumpExt *mMigrationContextMockJumpExt) Calls() []*MigrationContextMockJumpExtParams {
	mmJumpExt.mutex.RLock()

	argCopy := make([]*MigrationContextMockJumpExtParams, len(mmJumpExt.callArgs))
	copy(argCopy, mmJumpExt.callArgs)

	mmJumpExt.mutex.RUnlock()

	return argCopy
}

// MinimockJumpExtDone returns true if the count of the JumpExt invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockJumpExtDone() bool {
	for _, e := range m.JumpExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.JumpExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterJumpExtCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJumpExt != nil && mm_atomic.LoadUint64(&m.afterJumpExtCounter) < 1 {
		return false
	}
	return true
}

// MinimockJumpExtInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockJumpExtInspect() {
	for _, e := range m.JumpExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.JumpExt with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.JumpExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterJumpExtCounter) < 1 {
		if m.JumpExtMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.JumpExt")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.JumpExt with params: %#v", *m.JumpExtMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJumpExt != nil && mm_atomic.LoadUint64(&m.afterJumpExtCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.JumpExt")
	}
}

type mMigrationContextMockLog struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockLogExpectation
	expectations       []*MigrationContextMockLogExpectation
}

// MigrationContextMockLogExpectation specifies expectation struct of the MigrationContext.Log
type MigrationContextMockLogExpectation struct {
	mock *MigrationContextMock

	results *MigrationContextMockLogResults
	Counter uint64
}

// MigrationContextMockLogResults contains results of the MigrationContext.Log
type MigrationContextMockLogResults struct {
	l1 Logger
}

// Expect sets up expected params for MigrationContext.Log
func (mmLog *mMigrationContextMockLog) Expect() *mMigrationContextMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("MigrationContextMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &MigrationContextMockLogExpectation{}
	}

	return mmLog
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.Log
func (mmLog *mMigrationContextMockLog) Inspect(f func()) *mMigrationContextMockLog {
	if mmLog.mock.inspectFuncLog != nil {
		mmLog.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.Log")
	}

	mmLog.mock.inspectFuncLog = f

	return mmLog
}

// Return sets up results that will be returned by MigrationContext.Log
func (mmLog *mMigrationContextMockLog) Return(l1 Logger) *MigrationContextMock {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("MigrationContextMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &MigrationContextMockLogExpectation{mock: mmLog.mock}
	}
	mmLog.defaultExpectation.results = &MigrationContextMockLogResults{l1}
	return mmLog.mock
}

//Set uses given function f to mock the MigrationContext.Log method
func (mmLog *mMigrationContextMockLog) Set(f func() (l1 Logger)) *MigrationContextMock {
	if mmLog.defaultExpectation != nil {
		mmLog.mock.t.Fatalf("Default expectation is already set for the MigrationContext.Log method")
	}

	if len(mmLog.expectations) > 0 {
		mmLog.mock.t.Fatalf("Some expectations are already set for the MigrationContext.Log method")
	}

	mmLog.mock.funcLog = f
	return mmLog.mock
}

// Log implements MigrationContext
func (mmLog *MigrationContextMock) Log() (l1 Logger) {
	mm_atomic.AddUint64(&mmLog.beforeLogCounter, 1)
	defer mm_atomic.AddUint64(&mmLog.afterLogCounter, 1)

	if mmLog.inspectFuncLog != nil {
		mmLog.inspectFuncLog()
	}

	if mmLog.LogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLog.LogMock.defaultExpectation.Counter, 1)

		mm_results := mmLog.LogMock.defaultExpectation.results
		if mm_results == nil {
			mmLog.t.Fatal("No results are set for the MigrationContextMock.Log")
		}
		return (*mm_results).l1
	}
	if mmLog.funcLog != nil {
		return mmLog.funcLog()
	}
	mmLog.t.Fatalf("Unexpected call to MigrationContextMock.Log.")
	return
}

// LogAfterCounter returns a count of finished MigrationContextMock.Log invocations
func (mmLog *MigrationContextMock) LogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLog.afterLogCounter)
}

// LogBeforeCounter returns a count of MigrationContextMock.Log invocations
func (mmLog *MigrationContextMock) LogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLog.beforeLogCounter)
}

// MinimockLogDone returns true if the count of the Log invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockLogDone() bool {
	for _, e := range m.LogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLogCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLog != nil && mm_atomic.LoadUint64(&m.afterLogCounter) < 1 {
		return false
	}
	return true
}

// MinimockLogInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockLogInspect() {
	for _, e := range m.LogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MigrationContextMock.Log")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLogCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.Log")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLog != nil && mm_atomic.LoadUint64(&m.afterLogCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.Log")
	}
}

type mMigrationContextMockNewBargeIn struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockNewBargeInExpectation
	expectations       []*MigrationContextMockNewBargeInExpectation
}

// MigrationContextMockNewBargeInExpectation specifies expectation struct of the MigrationContext.NewBargeIn
type MigrationContextMockNewBargeInExpectation struct {
	mock *MigrationContextMock

	results *MigrationContextMockNewBargeInResults
	Counter uint64
}

// MigrationContextMockNewBargeInResults contains results of the MigrationContext.NewBargeIn
type MigrationContextMockNewBargeInResults struct {
	b1 BargeInBuilder
}

// Expect sets up expected params for MigrationContext.NewBargeIn
func (mmNewBargeIn *mMigrationContextMockNewBargeIn) Expect() *mMigrationContextMockNewBargeIn {
	if mmNewBargeIn.mock.funcNewBargeIn != nil {
		mmNewBargeIn.mock.t.Fatalf("MigrationContextMock.NewBargeIn mock is already set by Set")
	}

	if mmNewBargeIn.defaultExpectation == nil {
		mmNewBargeIn.defaultExpectation = &MigrationContextMockNewBargeInExpectation{}
	}

	return mmNewBargeIn
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.NewBargeIn
func (mmNewBargeIn *mMigrationContextMockNewBargeIn) Inspect(f func()) *mMigrationContextMockNewBargeIn {
	if mmNewBargeIn.mock.inspectFuncNewBargeIn != nil {
		mmNewBargeIn.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.NewBargeIn")
	}

	mmNewBargeIn.mock.inspectFuncNewBargeIn = f

	return mmNewBargeIn
}

// Return sets up results that will be returned by MigrationContext.NewBargeIn
func (mmNewBargeIn *mMigrationContextMockNewBargeIn) Return(b1 BargeInBuilder) *MigrationContextMock {
	if mmNewBargeIn.mock.funcNewBargeIn != nil {
		mmNewBargeIn.mock.t.Fatalf("MigrationContextMock.NewBargeIn mock is already set by Set")
	}

	if mmNewBargeIn.defaultExpectation == nil {
		mmNewBargeIn.defaultExpectation = &MigrationContextMockNewBargeInExpectation{mock: mmNewBargeIn.mock}
	}
	mmNewBargeIn.defaultExpectation.results = &MigrationContextMockNewBargeInResults{b1}
	return mmNewBargeIn.mock
}

//Set uses given function f to mock the MigrationContext.NewBargeIn method
func (mmNewBargeIn *mMigrationContextMockNewBargeIn) Set(f func() (b1 BargeInBuilder)) *MigrationContextMock {
	if mmNewBargeIn.defaultExpectation != nil {
		mmNewBargeIn.mock.t.Fatalf("Default expectation is already set for the MigrationContext.NewBargeIn method")
	}

	if len(mmNewBargeIn.expectations) > 0 {
		mmNewBargeIn.mock.t.Fatalf("Some expectations are already set for the MigrationContext.NewBargeIn method")
	}

	mmNewBargeIn.mock.funcNewBargeIn = f
	return mmNewBargeIn.mock
}

// NewBargeIn implements MigrationContext
func (mmNewBargeIn *MigrationContextMock) NewBargeIn() (b1 BargeInBuilder) {
	mm_atomic.AddUint64(&mmNewBargeIn.beforeNewBargeInCounter, 1)
	defer mm_atomic.AddUint64(&mmNewBargeIn.afterNewBargeInCounter, 1)

	if mmNewBargeIn.inspectFuncNewBargeIn != nil {
		mmNewBargeIn.inspectFuncNewBargeIn()
	}

	if mmNewBargeIn.NewBargeInMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewBargeIn.NewBargeInMock.defaultExpectation.Counter, 1)

		mm_results := mmNewBargeIn.NewBargeInMock.defaultExpectation.results
		if mm_results == nil {
			mmNewBargeIn.t.Fatal("No results are set for the MigrationContextMock.NewBargeIn")
		}
		return (*mm_results).b1
	}
	if mmNewBargeIn.funcNewBargeIn != nil {
		return mmNewBargeIn.funcNewBargeIn()
	}
	mmNewBargeIn.t.Fatalf("Unexpected call to MigrationContextMock.NewBargeIn.")
	return
}

// NewBargeInAfterCounter returns a count of finished MigrationContextMock.NewBargeIn invocations
func (mmNewBargeIn *MigrationContextMock) NewBargeInAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewBargeIn.afterNewBargeInCounter)
}

// NewBargeInBeforeCounter returns a count of MigrationContextMock.NewBargeIn invocations
func (mmNewBargeIn *MigrationContextMock) NewBargeInBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewBargeIn.beforeNewBargeInCounter)
}

// MinimockNewBargeInDone returns true if the count of the NewBargeIn invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockNewBargeInDone() bool {
	for _, e := range m.NewBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewBargeInCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewBargeIn != nil && mm_atomic.LoadUint64(&m.afterNewBargeInCounter) < 1 {
		return false
	}
	return true
}

// MinimockNewBargeInInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockNewBargeInInspect() {
	for _, e := range m.NewBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MigrationContextMock.NewBargeIn")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewBargeInCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.NewBargeIn")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewBargeIn != nil && mm_atomic.LoadUint64(&m.afterNewBargeInCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.NewBargeIn")
	}
}

type mMigrationContextMockNewBargeInWithParam struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockNewBargeInWithParamExpectation
	expectations       []*MigrationContextMockNewBargeInWithParamExpectation

	callArgs []*MigrationContextMockNewBargeInWithParamParams
	mutex    sync.RWMutex
}

// MigrationContextMockNewBargeInWithParamExpectation specifies expectation struct of the MigrationContext.NewBargeInWithParam
type MigrationContextMockNewBargeInWithParamExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockNewBargeInWithParamParams
	results *MigrationContextMockNewBargeInWithParamResults
	Counter uint64
}

// MigrationContextMockNewBargeInWithParamParams contains parameters of the MigrationContext.NewBargeInWithParam
type MigrationContextMockNewBargeInWithParamParams struct {
	b1 BargeInApplyFunc
}

// MigrationContextMockNewBargeInWithParamResults contains results of the MigrationContext.NewBargeInWithParam
type MigrationContextMockNewBargeInWithParamResults struct {
	b2 BargeInWithParam
}

// Expect sets up expected params for MigrationContext.NewBargeInWithParam
func (mmNewBargeInWithParam *mMigrationContextMockNewBargeInWithParam) Expect(b1 BargeInApplyFunc) *mMigrationContextMockNewBargeInWithParam {
	if mmNewBargeInWithParam.mock.funcNewBargeInWithParam != nil {
		mmNewBargeInWithParam.mock.t.Fatalf("MigrationContextMock.NewBargeInWithParam mock is already set by Set")
	}

	if mmNewBargeInWithParam.defaultExpectation == nil {
		mmNewBargeInWithParam.defaultExpectation = &MigrationContextMockNewBargeInWithParamExpectation{}
	}

	mmNewBargeInWithParam.defaultExpectation.params = &MigrationContextMockNewBargeInWithParamParams{b1}
	for _, e := range mmNewBargeInWithParam.expectations {
		if minimock.Equal(e.params, mmNewBargeInWithParam.defaultExpectation.params) {
			mmNewBargeInWithParam.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNewBargeInWithParam.defaultExpectation.params)
		}
	}

	return mmNewBargeInWithParam
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.NewBargeInWithParam
func (mmNewBargeInWithParam *mMigrationContextMockNewBargeInWithParam) Inspect(f func(b1 BargeInApplyFunc)) *mMigrationContextMockNewBargeInWithParam {
	if mmNewBargeInWithParam.mock.inspectFuncNewBargeInWithParam != nil {
		mmNewBargeInWithParam.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.NewBargeInWithParam")
	}

	mmNewBargeInWithParam.mock.inspectFuncNewBargeInWithParam = f

	return mmNewBargeInWithParam
}

// Return sets up results that will be returned by MigrationContext.NewBargeInWithParam
func (mmNewBargeInWithParam *mMigrationContextMockNewBargeInWithParam) Return(b2 BargeInWithParam) *MigrationContextMock {
	if mmNewBargeInWithParam.mock.funcNewBargeInWithParam != nil {
		mmNewBargeInWithParam.mock.t.Fatalf("MigrationContextMock.NewBargeInWithParam mock is already set by Set")
	}

	if mmNewBargeInWithParam.defaultExpectation == nil {
		mmNewBargeInWithParam.defaultExpectation = &MigrationContextMockNewBargeInWithParamExpectation{mock: mmNewBargeInWithParam.mock}
	}
	mmNewBargeInWithParam.defaultExpectation.results = &MigrationContextMockNewBargeInWithParamResults{b2}
	return mmNewBargeInWithParam.mock
}

//Set uses given function f to mock the MigrationContext.NewBargeInWithParam method
func (mmNewBargeInWithParam *mMigrationContextMockNewBargeInWithParam) Set(f func(b1 BargeInApplyFunc) (b2 BargeInWithParam)) *MigrationContextMock {
	if mmNewBargeInWithParam.defaultExpectation != nil {
		mmNewBargeInWithParam.mock.t.Fatalf("Default expectation is already set for the MigrationContext.NewBargeInWithParam method")
	}

	if len(mmNewBargeInWithParam.expectations) > 0 {
		mmNewBargeInWithParam.mock.t.Fatalf("Some expectations are already set for the MigrationContext.NewBargeInWithParam method")
	}

	mmNewBargeInWithParam.mock.funcNewBargeInWithParam = f
	return mmNewBargeInWithParam.mock
}

// When sets expectation for the MigrationContext.NewBargeInWithParam which will trigger the result defined by the following
// Then helper
func (mmNewBargeInWithParam *mMigrationContextMockNewBargeInWithParam) When(b1 BargeInApplyFunc) *MigrationContextMockNewBargeInWithParamExpectation {
	if mmNewBargeInWithParam.mock.funcNewBargeInWithParam != nil {
		mmNewBargeInWithParam.mock.t.Fatalf("MigrationContextMock.NewBargeInWithParam mock is already set by Set")
	}

	expectation := &MigrationContextMockNewBargeInWithParamExpectation{
		mock:   mmNewBargeInWithParam.mock,
		params: &MigrationContextMockNewBargeInWithParamParams{b1},
	}
	mmNewBargeInWithParam.expectations = append(mmNewBargeInWithParam.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.NewBargeInWithParam return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockNewBargeInWithParamExpectation) Then(b2 BargeInWithParam) *MigrationContextMock {
	e.results = &MigrationContextMockNewBargeInWithParamResults{b2}
	return e.mock
}

// NewBargeInWithParam implements MigrationContext
func (mmNewBargeInWithParam *MigrationContextMock) NewBargeInWithParam(b1 BargeInApplyFunc) (b2 BargeInWithParam) {
	mm_atomic.AddUint64(&mmNewBargeInWithParam.beforeNewBargeInWithParamCounter, 1)
	defer mm_atomic.AddUint64(&mmNewBargeInWithParam.afterNewBargeInWithParamCounter, 1)

	if mmNewBargeInWithParam.inspectFuncNewBargeInWithParam != nil {
		mmNewBargeInWithParam.inspectFuncNewBargeInWithParam(b1)
	}

	mm_params := &MigrationContextMockNewBargeInWithParamParams{b1}

	// Record call args
	mmNewBargeInWithParam.NewBargeInWithParamMock.mutex.Lock()
	mmNewBargeInWithParam.NewBargeInWithParamMock.callArgs = append(mmNewBargeInWithParam.NewBargeInWithParamMock.callArgs, mm_params)
	mmNewBargeInWithParam.NewBargeInWithParamMock.mutex.Unlock()

	for _, e := range mmNewBargeInWithParam.NewBargeInWithParamMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b2
		}
	}

	if mmNewBargeInWithParam.NewBargeInWithParamMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewBargeInWithParam.NewBargeInWithParamMock.defaultExpectation.Counter, 1)
		mm_want := mmNewBargeInWithParam.NewBargeInWithParamMock.defaultExpectation.params
		mm_got := MigrationContextMockNewBargeInWithParamParams{b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNewBargeInWithParam.t.Errorf("MigrationContextMock.NewBargeInWithParam got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNewBargeInWithParam.NewBargeInWithParamMock.defaultExpectation.results
		if mm_results == nil {
			mmNewBargeInWithParam.t.Fatal("No results are set for the MigrationContextMock.NewBargeInWithParam")
		}
		return (*mm_results).b2
	}
	if mmNewBargeInWithParam.funcNewBargeInWithParam != nil {
		return mmNewBargeInWithParam.funcNewBargeInWithParam(b1)
	}
	mmNewBargeInWithParam.t.Fatalf("Unexpected call to MigrationContextMock.NewBargeInWithParam. %v", b1)
	return
}

// NewBargeInWithParamAfterCounter returns a count of finished MigrationContextMock.NewBargeInWithParam invocations
func (mmNewBargeInWithParam *MigrationContextMock) NewBargeInWithParamAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewBargeInWithParam.afterNewBargeInWithParamCounter)
}

// NewBargeInWithParamBeforeCounter returns a count of MigrationContextMock.NewBargeInWithParam invocations
func (mmNewBargeInWithParam *MigrationContextMock) NewBargeInWithParamBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewBargeInWithParam.beforeNewBargeInWithParamCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.NewBargeInWithParam.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNewBargeInWithParam *mMigrationContextMockNewBargeInWithParam) Calls() []*MigrationContextMockNewBargeInWithParamParams {
	mmNewBargeInWithParam.mutex.RLock()

	argCopy := make([]*MigrationContextMockNewBargeInWithParamParams, len(mmNewBargeInWithParam.callArgs))
	copy(argCopy, mmNewBargeInWithParam.callArgs)

	mmNewBargeInWithParam.mutex.RUnlock()

	return argCopy
}

// MinimockNewBargeInWithParamDone returns true if the count of the NewBargeInWithParam invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockNewBargeInWithParamDone() bool {
	for _, e := range m.NewBargeInWithParamMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewBargeInWithParamMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewBargeInWithParamCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewBargeInWithParam != nil && mm_atomic.LoadUint64(&m.afterNewBargeInWithParamCounter) < 1 {
		return false
	}
	return true
}

// MinimockNewBargeInWithParamInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockNewBargeInWithParamInspect() {
	for _, e := range m.NewBargeInWithParamMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.NewBargeInWithParam with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewBargeInWithParamMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewBargeInWithParamCounter) < 1 {
		if m.NewBargeInWithParamMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.NewBargeInWithParam")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.NewBargeInWithParam with params: %#v", *m.NewBargeInWithParamMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewBargeInWithParam != nil && mm_atomic.LoadUint64(&m.afterNewBargeInWithParamCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.NewBargeInWithParam")
	}
}

type mMigrationContextMockOverrideDynamicBoost struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockOverrideDynamicBoostExpectation
	expectations       []*MigrationContextMockOverrideDynamicBoostExpectation

	callArgs []*MigrationContextMockOverrideDynamicBoostParams
	mutex    sync.RWMutex
}

// MigrationContextMockOverrideDynamicBoostExpectation specifies expectation struct of the MigrationContext.OverrideDynamicBoost
type MigrationContextMockOverrideDynamicBoostExpectation struct {
	mock   *MigrationContextMock
	params *MigrationContextMockOverrideDynamicBoostParams

	Counter uint64
}

// MigrationContextMockOverrideDynamicBoostParams contains parameters of the MigrationContext.OverrideDynamicBoost
type MigrationContextMockOverrideDynamicBoostParams struct {
	b1 bool
}

// Expect sets up expected params for MigrationContext.OverrideDynamicBoost
func (mmOverrideDynamicBoost *mMigrationContextMockOverrideDynamicBoost) Expect(b1 bool) *mMigrationContextMockOverrideDynamicBoost {
	if mmOverrideDynamicBoost.mock.funcOverrideDynamicBoost != nil {
		mmOverrideDynamicBoost.mock.t.Fatalf("MigrationContextMock.OverrideDynamicBoost mock is already set by Set")
	}

	if mmOverrideDynamicBoost.defaultExpectation == nil {
		mmOverrideDynamicBoost.defaultExpectation = &MigrationContextMockOverrideDynamicBoostExpectation{}
	}

	mmOverrideDynamicBoost.defaultExpectation.params = &MigrationContextMockOverrideDynamicBoostParams{b1}
	for _, e := range mmOverrideDynamicBoost.expectations {
		if minimock.Equal(e.params, mmOverrideDynamicBoost.defaultExpectation.params) {
			mmOverrideDynamicBoost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOverrideDynamicBoost.defaultExpectation.params)
		}
	}

	return mmOverrideDynamicBoost
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.OverrideDynamicBoost
func (mmOverrideDynamicBoost *mMigrationContextMockOverrideDynamicBoost) Inspect(f func(b1 bool)) *mMigrationContextMockOverrideDynamicBoost {
	if mmOverrideDynamicBoost.mock.inspectFuncOverrideDynamicBoost != nil {
		mmOverrideDynamicBoost.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.OverrideDynamicBoost")
	}

	mmOverrideDynamicBoost.mock.inspectFuncOverrideDynamicBoost = f

	return mmOverrideDynamicBoost
}

// Return sets up results that will be returned by MigrationContext.OverrideDynamicBoost
func (mmOverrideDynamicBoost *mMigrationContextMockOverrideDynamicBoost) Return() *MigrationContextMock {
	if mmOverrideDynamicBoost.mock.funcOverrideDynamicBoost != nil {
		mmOverrideDynamicBoost.mock.t.Fatalf("MigrationContextMock.OverrideDynamicBoost mock is already set by Set")
	}

	if mmOverrideDynamicBoost.defaultExpectation == nil {
		mmOverrideDynamicBoost.defaultExpectation = &MigrationContextMockOverrideDynamicBoostExpectation{mock: mmOverrideDynamicBoost.mock}
	}

	return mmOverrideDynamicBoost.mock
}

//Set uses given function f to mock the MigrationContext.OverrideDynamicBoost method
func (mmOverrideDynamicBoost *mMigrationContextMockOverrideDynamicBoost) Set(f func(b1 bool)) *MigrationContextMock {
	if mmOverrideDynamicBoost.defaultExpectation != nil {
		mmOverrideDynamicBoost.mock.t.Fatalf("Default expectation is already set for the MigrationContext.OverrideDynamicBoost method")
	}

	if len(mmOverrideDynamicBoost.expectations) > 0 {
		mmOverrideDynamicBoost.mock.t.Fatalf("Some expectations are already set for the MigrationContext.OverrideDynamicBoost method")
	}

	mmOverrideDynamicBoost.mock.funcOverrideDynamicBoost = f
	return mmOverrideDynamicBoost.mock
}

// OverrideDynamicBoost implements MigrationContext
func (mmOverrideDynamicBoost *MigrationContextMock) OverrideDynamicBoost(b1 bool) {
	mm_atomic.AddUint64(&mmOverrideDynamicBoost.beforeOverrideDynamicBoostCounter, 1)
	defer mm_atomic.AddUint64(&mmOverrideDynamicBoost.afterOverrideDynamicBoostCounter, 1)

	if mmOverrideDynamicBoost.inspectFuncOverrideDynamicBoost != nil {
		mmOverrideDynamicBoost.inspectFuncOverrideDynamicBoost(b1)
	}

	mm_params := &MigrationContextMockOverrideDynamicBoostParams{b1}

	// Record call args
	mmOverrideDynamicBoost.OverrideDynamicBoostMock.mutex.Lock()
	mmOverrideDynamicBoost.OverrideDynamicBoostMock.callArgs = append(mmOverrideDynamicBoost.OverrideDynamicBoostMock.callArgs, mm_params)
	mmOverrideDynamicBoost.OverrideDynamicBoostMock.mutex.Unlock()

	for _, e := range mmOverrideDynamicBoost.OverrideDynamicBoostMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmOverrideDynamicBoost.OverrideDynamicBoostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOverrideDynamicBoost.OverrideDynamicBoostMock.defaultExpectation.Counter, 1)
		mm_want := mmOverrideDynamicBoost.OverrideDynamicBoostMock.defaultExpectation.params
		mm_got := MigrationContextMockOverrideDynamicBoostParams{b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOverrideDynamicBoost.t.Errorf("MigrationContextMock.OverrideDynamicBoost got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmOverrideDynamicBoost.funcOverrideDynamicBoost != nil {
		mmOverrideDynamicBoost.funcOverrideDynamicBoost(b1)
		return
	}
	mmOverrideDynamicBoost.t.Fatalf("Unexpected call to MigrationContextMock.OverrideDynamicBoost. %v", b1)

}

// OverrideDynamicBoostAfterCounter returns a count of finished MigrationContextMock.OverrideDynamicBoost invocations
func (mmOverrideDynamicBoost *MigrationContextMock) OverrideDynamicBoostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOverrideDynamicBoost.afterOverrideDynamicBoostCounter)
}

// OverrideDynamicBoostBeforeCounter returns a count of MigrationContextMock.OverrideDynamicBoost invocations
func (mmOverrideDynamicBoost *MigrationContextMock) OverrideDynamicBoostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOverrideDynamicBoost.beforeOverrideDynamicBoostCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.OverrideDynamicBoost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOverrideDynamicBoost *mMigrationContextMockOverrideDynamicBoost) Calls() []*MigrationContextMockOverrideDynamicBoostParams {
	mmOverrideDynamicBoost.mutex.RLock()

	argCopy := make([]*MigrationContextMockOverrideDynamicBoostParams, len(mmOverrideDynamicBoost.callArgs))
	copy(argCopy, mmOverrideDynamicBoost.callArgs)

	mmOverrideDynamicBoost.mutex.RUnlock()

	return argCopy
}

// MinimockOverrideDynamicBoostDone returns true if the count of the OverrideDynamicBoost invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockOverrideDynamicBoostDone() bool {
	for _, e := range m.OverrideDynamicBoostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OverrideDynamicBoostMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOverrideDynamicBoostCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOverrideDynamicBoost != nil && mm_atomic.LoadUint64(&m.afterOverrideDynamicBoostCounter) < 1 {
		return false
	}
	return true
}

// MinimockOverrideDynamicBoostInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockOverrideDynamicBoostInspect() {
	for _, e := range m.OverrideDynamicBoostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.OverrideDynamicBoost with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OverrideDynamicBoostMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOverrideDynamicBoostCounter) < 1 {
		if m.OverrideDynamicBoostMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.OverrideDynamicBoost")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.OverrideDynamicBoost with params: %#v", *m.OverrideDynamicBoostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOverrideDynamicBoost != nil && mm_atomic.LoadUint64(&m.afterOverrideDynamicBoostCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.OverrideDynamicBoost")
	}
}

type mMigrationContextMockParentLink struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockParentLinkExpectation
	expectations       []*MigrationContextMockParentLinkExpectation
}

// MigrationContextMockParentLinkExpectation specifies expectation struct of the MigrationContext.ParentLink
type MigrationContextMockParentLinkExpectation struct {
	mock *MigrationContextMock

	results *MigrationContextMockParentLinkResults
	Counter uint64
}

// MigrationContextMockParentLinkResults contains results of the MigrationContext.ParentLink
type MigrationContextMockParentLinkResults struct {
	s1 SlotLink
}

// Expect sets up expected params for MigrationContext.ParentLink
func (mmParentLink *mMigrationContextMockParentLink) Expect() *mMigrationContextMockParentLink {
	if mmParentLink.mock.funcParentLink != nil {
		mmParentLink.mock.t.Fatalf("MigrationContextMock.ParentLink mock is already set by Set")
	}

	if mmParentLink.defaultExpectation == nil {
		mmParentLink.defaultExpectation = &MigrationContextMockParentLinkExpectation{}
	}

	return mmParentLink
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.ParentLink
func (mmParentLink *mMigrationContextMockParentLink) Inspect(f func()) *mMigrationContextMockParentLink {
	if mmParentLink.mock.inspectFuncParentLink != nil {
		mmParentLink.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.ParentLink")
	}

	mmParentLink.mock.inspectFuncParentLink = f

	return mmParentLink
}

// Return sets up results that will be returned by MigrationContext.ParentLink
func (mmParentLink *mMigrationContextMockParentLink) Return(s1 SlotLink) *MigrationContextMock {
	if mmParentLink.mock.funcParentLink != nil {
		mmParentLink.mock.t.Fatalf("MigrationContextMock.ParentLink mock is already set by Set")
	}

	if mmParentLink.defaultExpectation == nil {
		mmParentLink.defaultExpectation = &MigrationContextMockParentLinkExpectation{mock: mmParentLink.mock}
	}
	mmParentLink.defaultExpectation.results = &MigrationContextMockParentLinkResults{s1}
	return mmParentLink.mock
}

//Set uses given function f to mock the MigrationContext.ParentLink method
func (mmParentLink *mMigrationContextMockParentLink) Set(f func() (s1 SlotLink)) *MigrationContextMock {
	if mmParentLink.defaultExpectation != nil {
		mmParentLink.mock.t.Fatalf("Default expectation is already set for the MigrationContext.ParentLink method")
	}

	if len(mmParentLink.expectations) > 0 {
		mmParentLink.mock.t.Fatalf("Some expectations are already set for the MigrationContext.ParentLink method")
	}

	mmParentLink.mock.funcParentLink = f
	return mmParentLink.mock
}

// ParentLink implements MigrationContext
func (mmParentLink *MigrationContextMock) ParentLink() (s1 SlotLink) {
	mm_atomic.AddUint64(&mmParentLink.beforeParentLinkCounter, 1)
	defer mm_atomic.AddUint64(&mmParentLink.afterParentLinkCounter, 1)

	if mmParentLink.inspectFuncParentLink != nil {
		mmParentLink.inspectFuncParentLink()
	}

	if mmParentLink.ParentLinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmParentLink.ParentLinkMock.defaultExpectation.Counter, 1)

		mm_results := mmParentLink.ParentLinkMock.defaultExpectation.results
		if mm_results == nil {
			mmParentLink.t.Fatal("No results are set for the MigrationContextMock.ParentLink")
		}
		return (*mm_results).s1
	}
	if mmParentLink.funcParentLink != nil {
		return mmParentLink.funcParentLink()
	}
	mmParentLink.t.Fatalf("Unexpected call to MigrationContextMock.ParentLink.")
	return
}

// ParentLinkAfterCounter returns a count of finished MigrationContextMock.ParentLink invocations
func (mmParentLink *MigrationContextMock) ParentLinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParentLink.afterParentLinkCounter)
}

// ParentLinkBeforeCounter returns a count of MigrationContextMock.ParentLink invocations
func (mmParentLink *MigrationContextMock) ParentLinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParentLink.beforeParentLinkCounter)
}

// MinimockParentLinkDone returns true if the count of the ParentLink invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockParentLinkDone() bool {
	for _, e := range m.ParentLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParentLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParentLinkCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParentLink != nil && mm_atomic.LoadUint64(&m.afterParentLinkCounter) < 1 {
		return false
	}
	return true
}

// MinimockParentLinkInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockParentLinkInspect() {
	for _, e := range m.ParentLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MigrationContextMock.ParentLink")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParentLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParentLinkCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.ParentLink")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParentLink != nil && mm_atomic.LoadUint64(&m.afterParentLinkCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.ParentLink")
	}
}

type mMigrationContextMockPublish struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockPublishExpectation
	expectations       []*MigrationContextMockPublishExpectation

	callArgs []*MigrationContextMockPublishParams
	mutex    sync.RWMutex
}

// MigrationContextMockPublishExpectation specifies expectation struct of the MigrationContext.Publish
type MigrationContextMockPublishExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockPublishParams
	results *MigrationContextMockPublishResults
	Counter uint64
}

// MigrationContextMockPublishParams contains parameters of the MigrationContext.Publish
type MigrationContextMockPublishParams struct {
	key  interface{}
	data interface{}
}

// MigrationContextMockPublishResults contains results of the MigrationContext.Publish
type MigrationContextMockPublishResults struct {
	b1 bool
}

// Expect sets up expected params for MigrationContext.Publish
func (mmPublish *mMigrationContextMockPublish) Expect(key interface{}, data interface{}) *mMigrationContextMockPublish {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("MigrationContextMock.Publish mock is already set by Set")
	}

	if mmPublish.defaultExpectation == nil {
		mmPublish.defaultExpectation = &MigrationContextMockPublishExpectation{}
	}

	mmPublish.defaultExpectation.params = &MigrationContextMockPublishParams{key, data}
	for _, e := range mmPublish.expectations {
		if minimock.Equal(e.params, mmPublish.defaultExpectation.params) {
			mmPublish.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPublish.defaultExpectation.params)
		}
	}

	return mmPublish
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.Publish
func (mmPublish *mMigrationContextMockPublish) Inspect(f func(key interface{}, data interface{})) *mMigrationContextMockPublish {
	if mmPublish.mock.inspectFuncPublish != nil {
		mmPublish.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.Publish")
	}

	mmPublish.mock.inspectFuncPublish = f

	return mmPublish
}

// Return sets up results that will be returned by MigrationContext.Publish
func (mmPublish *mMigrationContextMockPublish) Return(b1 bool) *MigrationContextMock {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("MigrationContextMock.Publish mock is already set by Set")
	}

	if mmPublish.defaultExpectation == nil {
		mmPublish.defaultExpectation = &MigrationContextMockPublishExpectation{mock: mmPublish.mock}
	}
	mmPublish.defaultExpectation.results = &MigrationContextMockPublishResults{b1}
	return mmPublish.mock
}

//Set uses given function f to mock the MigrationContext.Publish method
func (mmPublish *mMigrationContextMockPublish) Set(f func(key interface{}, data interface{}) (b1 bool)) *MigrationContextMock {
	if mmPublish.defaultExpectation != nil {
		mmPublish.mock.t.Fatalf("Default expectation is already set for the MigrationContext.Publish method")
	}

	if len(mmPublish.expectations) > 0 {
		mmPublish.mock.t.Fatalf("Some expectations are already set for the MigrationContext.Publish method")
	}

	mmPublish.mock.funcPublish = f
	return mmPublish.mock
}

// When sets expectation for the MigrationContext.Publish which will trigger the result defined by the following
// Then helper
func (mmPublish *mMigrationContextMockPublish) When(key interface{}, data interface{}) *MigrationContextMockPublishExpectation {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("MigrationContextMock.Publish mock is already set by Set")
	}

	expectation := &MigrationContextMockPublishExpectation{
		mock:   mmPublish.mock,
		params: &MigrationContextMockPublishParams{key, data},
	}
	mmPublish.expectations = append(mmPublish.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.Publish return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockPublishExpectation) Then(b1 bool) *MigrationContextMock {
	e.results = &MigrationContextMockPublishResults{b1}
	return e.mock
}

// Publish implements MigrationContext
func (mmPublish *MigrationContextMock) Publish(key interface{}, data interface{}) (b1 bool) {
	mm_atomic.AddUint64(&mmPublish.beforePublishCounter, 1)
	defer mm_atomic.AddUint64(&mmPublish.afterPublishCounter, 1)

	if mmPublish.inspectFuncPublish != nil {
		mmPublish.inspectFuncPublish(key, data)
	}

	mm_params := &MigrationContextMockPublishParams{key, data}

	// Record call args
	mmPublish.PublishMock.mutex.Lock()
	mmPublish.PublishMock.callArgs = append(mmPublish.PublishMock.callArgs, mm_params)
	mmPublish.PublishMock.mutex.Unlock()

	for _, e := range mmPublish.PublishMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmPublish.PublishMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublish.PublishMock.defaultExpectation.Counter, 1)
		mm_want := mmPublish.PublishMock.defaultExpectation.params
		mm_got := MigrationContextMockPublishParams{key, data}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPublish.t.Errorf("MigrationContextMock.Publish got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPublish.PublishMock.defaultExpectation.results
		if mm_results == nil {
			mmPublish.t.Fatal("No results are set for the MigrationContextMock.Publish")
		}
		return (*mm_results).b1
	}
	if mmPublish.funcPublish != nil {
		return mmPublish.funcPublish(key, data)
	}
	mmPublish.t.Fatalf("Unexpected call to MigrationContextMock.Publish. %v %v", key, data)
	return
}

// PublishAfterCounter returns a count of finished MigrationContextMock.Publish invocations
func (mmPublish *MigrationContextMock) PublishAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublish.afterPublishCounter)
}

// PublishBeforeCounter returns a count of MigrationContextMock.Publish invocations
func (mmPublish *MigrationContextMock) PublishBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublish.beforePublishCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.Publish.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPublish *mMigrationContextMockPublish) Calls() []*MigrationContextMockPublishParams {
	mmPublish.mutex.RLock()

	argCopy := make([]*MigrationContextMockPublishParams, len(mmPublish.callArgs))
	copy(argCopy, mmPublish.callArgs)

	mmPublish.mutex.RUnlock()

	return argCopy
}

// MinimockPublishDone returns true if the count of the Publish invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockPublishDone() bool {
	for _, e := range m.PublishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublish != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		return false
	}
	return true
}

// MinimockPublishInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockPublishInspect() {
	for _, e := range m.PublishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.Publish with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		if m.PublishMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.Publish")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.Publish with params: %#v", *m.PublishMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublish != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.Publish")
	}
}

type mMigrationContextMockPublishGlobalAlias struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockPublishGlobalAliasExpectation
	expectations       []*MigrationContextMockPublishGlobalAliasExpectation

	callArgs []*MigrationContextMockPublishGlobalAliasParams
	mutex    sync.RWMutex
}

// MigrationContextMockPublishGlobalAliasExpectation specifies expectation struct of the MigrationContext.PublishGlobalAlias
type MigrationContextMockPublishGlobalAliasExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockPublishGlobalAliasParams
	results *MigrationContextMockPublishGlobalAliasResults
	Counter uint64
}

// MigrationContextMockPublishGlobalAliasParams contains parameters of the MigrationContext.PublishGlobalAlias
type MigrationContextMockPublishGlobalAliasParams struct {
	key interface{}
}

// MigrationContextMockPublishGlobalAliasResults contains results of the MigrationContext.PublishGlobalAlias
type MigrationContextMockPublishGlobalAliasResults struct {
	b1 bool
}

// Expect sets up expected params for MigrationContext.PublishGlobalAlias
func (mmPublishGlobalAlias *mMigrationContextMockPublishGlobalAlias) Expect(key interface{}) *mMigrationContextMockPublishGlobalAlias {
	if mmPublishGlobalAlias.mock.funcPublishGlobalAlias != nil {
		mmPublishGlobalAlias.mock.t.Fatalf("MigrationContextMock.PublishGlobalAlias mock is already set by Set")
	}

	if mmPublishGlobalAlias.defaultExpectation == nil {
		mmPublishGlobalAlias.defaultExpectation = &MigrationContextMockPublishGlobalAliasExpectation{}
	}

	mmPublishGlobalAlias.defaultExpectation.params = &MigrationContextMockPublishGlobalAliasParams{key}
	for _, e := range mmPublishGlobalAlias.expectations {
		if minimock.Equal(e.params, mmPublishGlobalAlias.defaultExpectation.params) {
			mmPublishGlobalAlias.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPublishGlobalAlias.defaultExpectation.params)
		}
	}

	return mmPublishGlobalAlias
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.PublishGlobalAlias
func (mmPublishGlobalAlias *mMigrationContextMockPublishGlobalAlias) Inspect(f func(key interface{})) *mMigrationContextMockPublishGlobalAlias {
	if mmPublishGlobalAlias.mock.inspectFuncPublishGlobalAlias != nil {
		mmPublishGlobalAlias.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.PublishGlobalAlias")
	}

	mmPublishGlobalAlias.mock.inspectFuncPublishGlobalAlias = f

	return mmPublishGlobalAlias
}

// Return sets up results that will be returned by MigrationContext.PublishGlobalAlias
func (mmPublishGlobalAlias *mMigrationContextMockPublishGlobalAlias) Return(b1 bool) *MigrationContextMock {
	if mmPublishGlobalAlias.mock.funcPublishGlobalAlias != nil {
		mmPublishGlobalAlias.mock.t.Fatalf("MigrationContextMock.PublishGlobalAlias mock is already set by Set")
	}

	if mmPublishGlobalAlias.defaultExpectation == nil {
		mmPublishGlobalAlias.defaultExpectation = &MigrationContextMockPublishGlobalAliasExpectation{mock: mmPublishGlobalAlias.mock}
	}
	mmPublishGlobalAlias.defaultExpectation.results = &MigrationContextMockPublishGlobalAliasResults{b1}
	return mmPublishGlobalAlias.mock
}

//Set uses given function f to mock the MigrationContext.PublishGlobalAlias method
func (mmPublishGlobalAlias *mMigrationContextMockPublishGlobalAlias) Set(f func(key interface{}) (b1 bool)) *MigrationContextMock {
	if mmPublishGlobalAlias.defaultExpectation != nil {
		mmPublishGlobalAlias.mock.t.Fatalf("Default expectation is already set for the MigrationContext.PublishGlobalAlias method")
	}

	if len(mmPublishGlobalAlias.expectations) > 0 {
		mmPublishGlobalAlias.mock.t.Fatalf("Some expectations are already set for the MigrationContext.PublishGlobalAlias method")
	}

	mmPublishGlobalAlias.mock.funcPublishGlobalAlias = f
	return mmPublishGlobalAlias.mock
}

// When sets expectation for the MigrationContext.PublishGlobalAlias which will trigger the result defined by the following
// Then helper
func (mmPublishGlobalAlias *mMigrationContextMockPublishGlobalAlias) When(key interface{}) *MigrationContextMockPublishGlobalAliasExpectation {
	if mmPublishGlobalAlias.mock.funcPublishGlobalAlias != nil {
		mmPublishGlobalAlias.mock.t.Fatalf("MigrationContextMock.PublishGlobalAlias mock is already set by Set")
	}

	expectation := &MigrationContextMockPublishGlobalAliasExpectation{
		mock:   mmPublishGlobalAlias.mock,
		params: &MigrationContextMockPublishGlobalAliasParams{key},
	}
	mmPublishGlobalAlias.expectations = append(mmPublishGlobalAlias.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.PublishGlobalAlias return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockPublishGlobalAliasExpectation) Then(b1 bool) *MigrationContextMock {
	e.results = &MigrationContextMockPublishGlobalAliasResults{b1}
	return e.mock
}

// PublishGlobalAlias implements MigrationContext
func (mmPublishGlobalAlias *MigrationContextMock) PublishGlobalAlias(key interface{}) (b1 bool) {
	mm_atomic.AddUint64(&mmPublishGlobalAlias.beforePublishGlobalAliasCounter, 1)
	defer mm_atomic.AddUint64(&mmPublishGlobalAlias.afterPublishGlobalAliasCounter, 1)

	if mmPublishGlobalAlias.inspectFuncPublishGlobalAlias != nil {
		mmPublishGlobalAlias.inspectFuncPublishGlobalAlias(key)
	}

	mm_params := &MigrationContextMockPublishGlobalAliasParams{key}

	// Record call args
	mmPublishGlobalAlias.PublishGlobalAliasMock.mutex.Lock()
	mmPublishGlobalAlias.PublishGlobalAliasMock.callArgs = append(mmPublishGlobalAlias.PublishGlobalAliasMock.callArgs, mm_params)
	mmPublishGlobalAlias.PublishGlobalAliasMock.mutex.Unlock()

	for _, e := range mmPublishGlobalAlias.PublishGlobalAliasMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmPublishGlobalAlias.PublishGlobalAliasMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublishGlobalAlias.PublishGlobalAliasMock.defaultExpectation.Counter, 1)
		mm_want := mmPublishGlobalAlias.PublishGlobalAliasMock.defaultExpectation.params
		mm_got := MigrationContextMockPublishGlobalAliasParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPublishGlobalAlias.t.Errorf("MigrationContextMock.PublishGlobalAlias got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPublishGlobalAlias.PublishGlobalAliasMock.defaultExpectation.results
		if mm_results == nil {
			mmPublishGlobalAlias.t.Fatal("No results are set for the MigrationContextMock.PublishGlobalAlias")
		}
		return (*mm_results).b1
	}
	if mmPublishGlobalAlias.funcPublishGlobalAlias != nil {
		return mmPublishGlobalAlias.funcPublishGlobalAlias(key)
	}
	mmPublishGlobalAlias.t.Fatalf("Unexpected call to MigrationContextMock.PublishGlobalAlias. %v", key)
	return
}

// PublishGlobalAliasAfterCounter returns a count of finished MigrationContextMock.PublishGlobalAlias invocations
func (mmPublishGlobalAlias *MigrationContextMock) PublishGlobalAliasAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishGlobalAlias.afterPublishGlobalAliasCounter)
}

// PublishGlobalAliasBeforeCounter returns a count of MigrationContextMock.PublishGlobalAlias invocations
func (mmPublishGlobalAlias *MigrationContextMock) PublishGlobalAliasBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishGlobalAlias.beforePublishGlobalAliasCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.PublishGlobalAlias.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPublishGlobalAlias *mMigrationContextMockPublishGlobalAlias) Calls() []*MigrationContextMockPublishGlobalAliasParams {
	mmPublishGlobalAlias.mutex.RLock()

	argCopy := make([]*MigrationContextMockPublishGlobalAliasParams, len(mmPublishGlobalAlias.callArgs))
	copy(argCopy, mmPublishGlobalAlias.callArgs)

	mmPublishGlobalAlias.mutex.RUnlock()

	return argCopy
}

// MinimockPublishGlobalAliasDone returns true if the count of the PublishGlobalAlias invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockPublishGlobalAliasDone() bool {
	for _, e := range m.PublishGlobalAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishGlobalAliasMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublishGlobalAlias != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasCounter) < 1 {
		return false
	}
	return true
}

// MinimockPublishGlobalAliasInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockPublishGlobalAliasInspect() {
	for _, e := range m.PublishGlobalAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.PublishGlobalAlias with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishGlobalAliasMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasCounter) < 1 {
		if m.PublishGlobalAliasMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.PublishGlobalAlias")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.PublishGlobalAlias with params: %#v", *m.PublishGlobalAliasMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublishGlobalAlias != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.PublishGlobalAlias")
	}
}

type mMigrationContextMockPublishGlobalAliasAndBargeIn struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockPublishGlobalAliasAndBargeInExpectation
	expectations       []*MigrationContextMockPublishGlobalAliasAndBargeInExpectation

	callArgs []*MigrationContextMockPublishGlobalAliasAndBargeInParams
	mutex    sync.RWMutex
}

// MigrationContextMockPublishGlobalAliasAndBargeInExpectation specifies expectation struct of the MigrationContext.PublishGlobalAliasAndBargeIn
type MigrationContextMockPublishGlobalAliasAndBargeInExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockPublishGlobalAliasAndBargeInParams
	results *MigrationContextMockPublishGlobalAliasAndBargeInResults
	Counter uint64
}

// MigrationContextMockPublishGlobalAliasAndBargeInParams contains parameters of the MigrationContext.PublishGlobalAliasAndBargeIn
type MigrationContextMockPublishGlobalAliasAndBargeInParams struct {
	key     interface{}
	handler BargeInHolder
}

// MigrationContextMockPublishGlobalAliasAndBargeInResults contains results of the MigrationContext.PublishGlobalAliasAndBargeIn
type MigrationContextMockPublishGlobalAliasAndBargeInResults struct {
	b1 bool
}

// Expect sets up expected params for MigrationContext.PublishGlobalAliasAndBargeIn
func (mmPublishGlobalAliasAndBargeIn *mMigrationContextMockPublishGlobalAliasAndBargeIn) Expect(key interface{}, handler BargeInHolder) *mMigrationContextMockPublishGlobalAliasAndBargeIn {
	if mmPublishGlobalAliasAndBargeIn.mock.funcPublishGlobalAliasAndBargeIn != nil {
		mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("MigrationContextMock.PublishGlobalAliasAndBargeIn mock is already set by Set")
	}

	if mmPublishGlobalAliasAndBargeIn.defaultExpectation == nil {
		mmPublishGlobalAliasAndBargeIn.defaultExpectation = &MigrationContextMockPublishGlobalAliasAndBargeInExpectation{}
	}

	mmPublishGlobalAliasAndBargeIn.defaultExpectation.params = &MigrationContextMockPublishGlobalAliasAndBargeInParams{key, handler}
	for _, e := range mmPublishGlobalAliasAndBargeIn.expectations {
		if minimock.Equal(e.params, mmPublishGlobalAliasAndBargeIn.defaultExpectation.params) {
			mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPublishGlobalAliasAndBargeIn.defaultExpectation.params)
		}
	}

	return mmPublishGlobalAliasAndBargeIn
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.PublishGlobalAliasAndBargeIn
func (mmPublishGlobalAliasAndBargeIn *mMigrationContextMockPublishGlobalAliasAndBargeIn) Inspect(f func(key interface{}, handler BargeInHolder)) *mMigrationContextMockPublishGlobalAliasAndBargeIn {
	if mmPublishGlobalAliasAndBargeIn.mock.inspectFuncPublishGlobalAliasAndBargeIn != nil {
		mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.PublishGlobalAliasAndBargeIn")
	}

	mmPublishGlobalAliasAndBargeIn.mock.inspectFuncPublishGlobalAliasAndBargeIn = f

	return mmPublishGlobalAliasAndBargeIn
}

// Return sets up results that will be returned by MigrationContext.PublishGlobalAliasAndBargeIn
func (mmPublishGlobalAliasAndBargeIn *mMigrationContextMockPublishGlobalAliasAndBargeIn) Return(b1 bool) *MigrationContextMock {
	if mmPublishGlobalAliasAndBargeIn.mock.funcPublishGlobalAliasAndBargeIn != nil {
		mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("MigrationContextMock.PublishGlobalAliasAndBargeIn mock is already set by Set")
	}

	if mmPublishGlobalAliasAndBargeIn.defaultExpectation == nil {
		mmPublishGlobalAliasAndBargeIn.defaultExpectation = &MigrationContextMockPublishGlobalAliasAndBargeInExpectation{mock: mmPublishGlobalAliasAndBargeIn.mock}
	}
	mmPublishGlobalAliasAndBargeIn.defaultExpectation.results = &MigrationContextMockPublishGlobalAliasAndBargeInResults{b1}
	return mmPublishGlobalAliasAndBargeIn.mock
}

//Set uses given function f to mock the MigrationContext.PublishGlobalAliasAndBargeIn method
func (mmPublishGlobalAliasAndBargeIn *mMigrationContextMockPublishGlobalAliasAndBargeIn) Set(f func(key interface{}, handler BargeInHolder) (b1 bool)) *MigrationContextMock {
	if mmPublishGlobalAliasAndBargeIn.defaultExpectation != nil {
		mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("Default expectation is already set for the MigrationContext.PublishGlobalAliasAndBargeIn method")
	}

	if len(mmPublishGlobalAliasAndBargeIn.expectations) > 0 {
		mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("Some expectations are already set for the MigrationContext.PublishGlobalAliasAndBargeIn method")
	}

	mmPublishGlobalAliasAndBargeIn.mock.funcPublishGlobalAliasAndBargeIn = f
	return mmPublishGlobalAliasAndBargeIn.mock
}

// When sets expectation for the MigrationContext.PublishGlobalAliasAndBargeIn which will trigger the result defined by the following
// Then helper
func (mmPublishGlobalAliasAndBargeIn *mMigrationContextMockPublishGlobalAliasAndBargeIn) When(key interface{}, handler BargeInHolder) *MigrationContextMockPublishGlobalAliasAndBargeInExpectation {
	if mmPublishGlobalAliasAndBargeIn.mock.funcPublishGlobalAliasAndBargeIn != nil {
		mmPublishGlobalAliasAndBargeIn.mock.t.Fatalf("MigrationContextMock.PublishGlobalAliasAndBargeIn mock is already set by Set")
	}

	expectation := &MigrationContextMockPublishGlobalAliasAndBargeInExpectation{
		mock:   mmPublishGlobalAliasAndBargeIn.mock,
		params: &MigrationContextMockPublishGlobalAliasAndBargeInParams{key, handler},
	}
	mmPublishGlobalAliasAndBargeIn.expectations = append(mmPublishGlobalAliasAndBargeIn.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.PublishGlobalAliasAndBargeIn return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockPublishGlobalAliasAndBargeInExpectation) Then(b1 bool) *MigrationContextMock {
	e.results = &MigrationContextMockPublishGlobalAliasAndBargeInResults{b1}
	return e.mock
}

// PublishGlobalAliasAndBargeIn implements MigrationContext
func (mmPublishGlobalAliasAndBargeIn *MigrationContextMock) PublishGlobalAliasAndBargeIn(key interface{}, handler BargeInHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmPublishGlobalAliasAndBargeIn.beforePublishGlobalAliasAndBargeInCounter, 1)
	defer mm_atomic.AddUint64(&mmPublishGlobalAliasAndBargeIn.afterPublishGlobalAliasAndBargeInCounter, 1)

	if mmPublishGlobalAliasAndBargeIn.inspectFuncPublishGlobalAliasAndBargeIn != nil {
		mmPublishGlobalAliasAndBargeIn.inspectFuncPublishGlobalAliasAndBargeIn(key, handler)
	}

	mm_params := &MigrationContextMockPublishGlobalAliasAndBargeInParams{key, handler}

	// Record call args
	mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.mutex.Lock()
	mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.callArgs = append(mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.callArgs, mm_params)
	mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.mutex.Unlock()

	for _, e := range mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.defaultExpectation.Counter, 1)
		mm_want := mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.defaultExpectation.params
		mm_got := MigrationContextMockPublishGlobalAliasAndBargeInParams{key, handler}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPublishGlobalAliasAndBargeIn.t.Errorf("MigrationContextMock.PublishGlobalAliasAndBargeIn got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPublishGlobalAliasAndBargeIn.PublishGlobalAliasAndBargeInMock.defaultExpectation.results
		if mm_results == nil {
			mmPublishGlobalAliasAndBargeIn.t.Fatal("No results are set for the MigrationContextMock.PublishGlobalAliasAndBargeIn")
		}
		return (*mm_results).b1
	}
	if mmPublishGlobalAliasAndBargeIn.funcPublishGlobalAliasAndBargeIn != nil {
		return mmPublishGlobalAliasAndBargeIn.funcPublishGlobalAliasAndBargeIn(key, handler)
	}
	mmPublishGlobalAliasAndBargeIn.t.Fatalf("Unexpected call to MigrationContextMock.PublishGlobalAliasAndBargeIn. %v %v", key, handler)
	return
}

// PublishGlobalAliasAndBargeInAfterCounter returns a count of finished MigrationContextMock.PublishGlobalAliasAndBargeIn invocations
func (mmPublishGlobalAliasAndBargeIn *MigrationContextMock) PublishGlobalAliasAndBargeInAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishGlobalAliasAndBargeIn.afterPublishGlobalAliasAndBargeInCounter)
}

// PublishGlobalAliasAndBargeInBeforeCounter returns a count of MigrationContextMock.PublishGlobalAliasAndBargeIn invocations
func (mmPublishGlobalAliasAndBargeIn *MigrationContextMock) PublishGlobalAliasAndBargeInBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishGlobalAliasAndBargeIn.beforePublishGlobalAliasAndBargeInCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.PublishGlobalAliasAndBargeIn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPublishGlobalAliasAndBargeIn *mMigrationContextMockPublishGlobalAliasAndBargeIn) Calls() []*MigrationContextMockPublishGlobalAliasAndBargeInParams {
	mmPublishGlobalAliasAndBargeIn.mutex.RLock()

	argCopy := make([]*MigrationContextMockPublishGlobalAliasAndBargeInParams, len(mmPublishGlobalAliasAndBargeIn.callArgs))
	copy(argCopy, mmPublishGlobalAliasAndBargeIn.callArgs)

	mmPublishGlobalAliasAndBargeIn.mutex.RUnlock()

	return argCopy
}

// MinimockPublishGlobalAliasAndBargeInDone returns true if the count of the PublishGlobalAliasAndBargeIn invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockPublishGlobalAliasAndBargeInDone() bool {
	for _, e := range m.PublishGlobalAliasAndBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishGlobalAliasAndBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasAndBargeInCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublishGlobalAliasAndBargeIn != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasAndBargeInCounter) < 1 {
		return false
	}
	return true
}

// MinimockPublishGlobalAliasAndBargeInInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockPublishGlobalAliasAndBargeInInspect() {
	for _, e := range m.PublishGlobalAliasAndBargeInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.PublishGlobalAliasAndBargeIn with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishGlobalAliasAndBargeInMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasAndBargeInCounter) < 1 {
		if m.PublishGlobalAliasAndBargeInMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.PublishGlobalAliasAndBargeIn")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.PublishGlobalAliasAndBargeIn with params: %#v", *m.PublishGlobalAliasAndBargeInMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublishGlobalAliasAndBargeIn != nil && mm_atomic.LoadUint64(&m.afterPublishGlobalAliasAndBargeInCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.PublishGlobalAliasAndBargeIn")
	}
}

type mMigrationContextMockPublishReplacement struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockPublishReplacementExpectation
	expectations       []*MigrationContextMockPublishReplacementExpectation

	callArgs []*MigrationContextMockPublishReplacementParams
	mutex    sync.RWMutex
}

// MigrationContextMockPublishReplacementExpectation specifies expectation struct of the MigrationContext.PublishReplacement
type MigrationContextMockPublishReplacementExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockPublishReplacementParams
	results *MigrationContextMockPublishReplacementResults
	Counter uint64
}

// MigrationContextMockPublishReplacementParams contains parameters of the MigrationContext.PublishReplacement
type MigrationContextMockPublishReplacementParams struct {
	key  interface{}
	data interface{}
}

// MigrationContextMockPublishReplacementResults contains results of the MigrationContext.PublishReplacement
type MigrationContextMockPublishReplacementResults struct {
	b1 bool
}

// Expect sets up expected params for MigrationContext.PublishReplacement
func (mmPublishReplacement *mMigrationContextMockPublishReplacement) Expect(key interface{}, data interface{}) *mMigrationContextMockPublishReplacement {
	if mmPublishReplacement.mock.funcPublishReplacement != nil {
		mmPublishReplacement.mock.t.Fatalf("MigrationContextMock.PublishReplacement mock is already set by Set")
	}

	if mmPublishReplacement.defaultExpectation == nil {
		mmPublishReplacement.defaultExpectation = &MigrationContextMockPublishReplacementExpectation{}
	}

	mmPublishReplacement.defaultExpectation.params = &MigrationContextMockPublishReplacementParams{key, data}
	for _, e := range mmPublishReplacement.expectations {
		if minimock.Equal(e.params, mmPublishReplacement.defaultExpectation.params) {
			mmPublishReplacement.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPublishReplacement.defaultExpectation.params)
		}
	}

	return mmPublishReplacement
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.PublishReplacement
func (mmPublishReplacement *mMigrationContextMockPublishReplacement) Inspect(f func(key interface{}, data interface{})) *mMigrationContextMockPublishReplacement {
	if mmPublishReplacement.mock.inspectFuncPublishReplacement != nil {
		mmPublishReplacement.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.PublishReplacement")
	}

	mmPublishReplacement.mock.inspectFuncPublishReplacement = f

	return mmPublishReplacement
}

// Return sets up results that will be returned by MigrationContext.PublishReplacement
func (mmPublishReplacement *mMigrationContextMockPublishReplacement) Return(b1 bool) *MigrationContextMock {
	if mmPublishReplacement.mock.funcPublishReplacement != nil {
		mmPublishReplacement.mock.t.Fatalf("MigrationContextMock.PublishReplacement mock is already set by Set")
	}

	if mmPublishReplacement.defaultExpectation == nil {
		mmPublishReplacement.defaultExpectation = &MigrationContextMockPublishReplacementExpectation{mock: mmPublishReplacement.mock}
	}
	mmPublishReplacement.defaultExpectation.results = &MigrationContextMockPublishReplacementResults{b1}
	return mmPublishReplacement.mock
}

//Set uses given function f to mock the MigrationContext.PublishReplacement method
func (mmPublishReplacement *mMigrationContextMockPublishReplacement) Set(f func(key interface{}, data interface{}) (b1 bool)) *MigrationContextMock {
	if mmPublishReplacement.defaultExpectation != nil {
		mmPublishReplacement.mock.t.Fatalf("Default expectation is already set for the MigrationContext.PublishReplacement method")
	}

	if len(mmPublishReplacement.expectations) > 0 {
		mmPublishReplacement.mock.t.Fatalf("Some expectations are already set for the MigrationContext.PublishReplacement method")
	}

	mmPublishReplacement.mock.funcPublishReplacement = f
	return mmPublishReplacement.mock
}

// When sets expectation for the MigrationContext.PublishReplacement which will trigger the result defined by the following
// Then helper
func (mmPublishReplacement *mMigrationContextMockPublishReplacement) When(key interface{}, data interface{}) *MigrationContextMockPublishReplacementExpectation {
	if mmPublishReplacement.mock.funcPublishReplacement != nil {
		mmPublishReplacement.mock.t.Fatalf("MigrationContextMock.PublishReplacement mock is already set by Set")
	}

	expectation := &MigrationContextMockPublishReplacementExpectation{
		mock:   mmPublishReplacement.mock,
		params: &MigrationContextMockPublishReplacementParams{key, data},
	}
	mmPublishReplacement.expectations = append(mmPublishReplacement.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.PublishReplacement return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockPublishReplacementExpectation) Then(b1 bool) *MigrationContextMock {
	e.results = &MigrationContextMockPublishReplacementResults{b1}
	return e.mock
}

// PublishReplacement implements MigrationContext
func (mmPublishReplacement *MigrationContextMock) PublishReplacement(key interface{}, data interface{}) (b1 bool) {
	mm_atomic.AddUint64(&mmPublishReplacement.beforePublishReplacementCounter, 1)
	defer mm_atomic.AddUint64(&mmPublishReplacement.afterPublishReplacementCounter, 1)

	if mmPublishReplacement.inspectFuncPublishReplacement != nil {
		mmPublishReplacement.inspectFuncPublishReplacement(key, data)
	}

	mm_params := &MigrationContextMockPublishReplacementParams{key, data}

	// Record call args
	mmPublishReplacement.PublishReplacementMock.mutex.Lock()
	mmPublishReplacement.PublishReplacementMock.callArgs = append(mmPublishReplacement.PublishReplacementMock.callArgs, mm_params)
	mmPublishReplacement.PublishReplacementMock.mutex.Unlock()

	for _, e := range mmPublishReplacement.PublishReplacementMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmPublishReplacement.PublishReplacementMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublishReplacement.PublishReplacementMock.defaultExpectation.Counter, 1)
		mm_want := mmPublishReplacement.PublishReplacementMock.defaultExpectation.params
		mm_got := MigrationContextMockPublishReplacementParams{key, data}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPublishReplacement.t.Errorf("MigrationContextMock.PublishReplacement got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPublishReplacement.PublishReplacementMock.defaultExpectation.results
		if mm_results == nil {
			mmPublishReplacement.t.Fatal("No results are set for the MigrationContextMock.PublishReplacement")
		}
		return (*mm_results).b1
	}
	if mmPublishReplacement.funcPublishReplacement != nil {
		return mmPublishReplacement.funcPublishReplacement(key, data)
	}
	mmPublishReplacement.t.Fatalf("Unexpected call to MigrationContextMock.PublishReplacement. %v %v", key, data)
	return
}

// PublishReplacementAfterCounter returns a count of finished MigrationContextMock.PublishReplacement invocations
func (mmPublishReplacement *MigrationContextMock) PublishReplacementAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishReplacement.afterPublishReplacementCounter)
}

// PublishReplacementBeforeCounter returns a count of MigrationContextMock.PublishReplacement invocations
func (mmPublishReplacement *MigrationContextMock) PublishReplacementBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishReplacement.beforePublishReplacementCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.PublishReplacement.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPublishReplacement *mMigrationContextMockPublishReplacement) Calls() []*MigrationContextMockPublishReplacementParams {
	mmPublishReplacement.mutex.RLock()

	argCopy := make([]*MigrationContextMockPublishReplacementParams, len(mmPublishReplacement.callArgs))
	copy(argCopy, mmPublishReplacement.callArgs)

	mmPublishReplacement.mutex.RUnlock()

	return argCopy
}

// MinimockPublishReplacementDone returns true if the count of the PublishReplacement invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockPublishReplacementDone() bool {
	for _, e := range m.PublishReplacementMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishReplacementMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishReplacementCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublishReplacement != nil && mm_atomic.LoadUint64(&m.afterPublishReplacementCounter) < 1 {
		return false
	}
	return true
}

// MinimockPublishReplacementInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockPublishReplacementInspect() {
	for _, e := range m.PublishReplacementMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.PublishReplacement with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishReplacementMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishReplacementCounter) < 1 {
		if m.PublishReplacementMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.PublishReplacement")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.PublishReplacement with params: %#v", *m.PublishReplacementMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublishReplacement != nil && mm_atomic.LoadUint64(&m.afterPublishReplacementCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.PublishReplacement")
	}
}

type mMigrationContextMockRelease struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockReleaseExpectation
	expectations       []*MigrationContextMockReleaseExpectation

	callArgs []*MigrationContextMockReleaseParams
	mutex    sync.RWMutex
}

// MigrationContextMockReleaseExpectation specifies expectation struct of the MigrationContext.Release
type MigrationContextMockReleaseExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockReleaseParams
	results *MigrationContextMockReleaseResults
	Counter uint64
}

// MigrationContextMockReleaseParams contains parameters of the MigrationContext.Release
type MigrationContextMockReleaseParams struct {
	s1 SyncLink
}

// MigrationContextMockReleaseResults contains results of the MigrationContext.Release
type MigrationContextMockReleaseResults struct {
	b1 bool
}

// Expect sets up expected params for MigrationContext.Release
func (mmRelease *mMigrationContextMockRelease) Expect(s1 SyncLink) *mMigrationContextMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("MigrationContextMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &MigrationContextMockReleaseExpectation{}
	}

	mmRelease.defaultExpectation.params = &MigrationContextMockReleaseParams{s1}
	for _, e := range mmRelease.expectations {
		if minimock.Equal(e.params, mmRelease.defaultExpectation.params) {
			mmRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRelease.defaultExpectation.params)
		}
	}

	return mmRelease
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.Release
func (mmRelease *mMigrationContextMockRelease) Inspect(f func(s1 SyncLink)) *mMigrationContextMockRelease {
	if mmRelease.mock.inspectFuncRelease != nil {
		mmRelease.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.Release")
	}

	mmRelease.mock.inspectFuncRelease = f

	return mmRelease
}

// Return sets up results that will be returned by MigrationContext.Release
func (mmRelease *mMigrationContextMockRelease) Return(b1 bool) *MigrationContextMock {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("MigrationContextMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &MigrationContextMockReleaseExpectation{mock: mmRelease.mock}
	}
	mmRelease.defaultExpectation.results = &MigrationContextMockReleaseResults{b1}
	return mmRelease.mock
}

//Set uses given function f to mock the MigrationContext.Release method
func (mmRelease *mMigrationContextMockRelease) Set(f func(s1 SyncLink) (b1 bool)) *MigrationContextMock {
	if mmRelease.defaultExpectation != nil {
		mmRelease.mock.t.Fatalf("Default expectation is already set for the MigrationContext.Release method")
	}

	if len(mmRelease.expectations) > 0 {
		mmRelease.mock.t.Fatalf("Some expectations are already set for the MigrationContext.Release method")
	}

	mmRelease.mock.funcRelease = f
	return mmRelease.mock
}

// When sets expectation for the MigrationContext.Release which will trigger the result defined by the following
// Then helper
func (mmRelease *mMigrationContextMockRelease) When(s1 SyncLink) *MigrationContextMockReleaseExpectation {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("MigrationContextMock.Release mock is already set by Set")
	}

	expectation := &MigrationContextMockReleaseExpectation{
		mock:   mmRelease.mock,
		params: &MigrationContextMockReleaseParams{s1},
	}
	mmRelease.expectations = append(mmRelease.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.Release return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockReleaseExpectation) Then(b1 bool) *MigrationContextMock {
	e.results = &MigrationContextMockReleaseResults{b1}
	return e.mock
}

// Release implements MigrationContext
func (mmRelease *MigrationContextMock) Release(s1 SyncLink) (b1 bool) {
	mm_atomic.AddUint64(&mmRelease.beforeReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmRelease.afterReleaseCounter, 1)

	if mmRelease.inspectFuncRelease != nil {
		mmRelease.inspectFuncRelease(s1)
	}

	mm_params := &MigrationContextMockReleaseParams{s1}

	// Record call args
	mmRelease.ReleaseMock.mutex.Lock()
	mmRelease.ReleaseMock.callArgs = append(mmRelease.ReleaseMock.callArgs, mm_params)
	mmRelease.ReleaseMock.mutex.Unlock()

	for _, e := range mmRelease.ReleaseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmRelease.ReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRelease.ReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmRelease.ReleaseMock.defaultExpectation.params
		mm_got := MigrationContextMockReleaseParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRelease.t.Errorf("MigrationContextMock.Release got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRelease.ReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmRelease.t.Fatal("No results are set for the MigrationContextMock.Release")
		}
		return (*mm_results).b1
	}
	if mmRelease.funcRelease != nil {
		return mmRelease.funcRelease(s1)
	}
	mmRelease.t.Fatalf("Unexpected call to MigrationContextMock.Release. %v", s1)
	return
}

// ReleaseAfterCounter returns a count of finished MigrationContextMock.Release invocations
func (mmRelease *MigrationContextMock) ReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.afterReleaseCounter)
}

// ReleaseBeforeCounter returns a count of MigrationContextMock.Release invocations
func (mmRelease *MigrationContextMock) ReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.beforeReleaseCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.Release.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRelease *mMigrationContextMockRelease) Calls() []*MigrationContextMockReleaseParams {
	mmRelease.mutex.RLock()

	argCopy := make([]*MigrationContextMockReleaseParams, len(mmRelease.callArgs))
	copy(argCopy, mmRelease.callArgs)

	mmRelease.mutex.RUnlock()

	return argCopy
}

// MinimockReleaseDone returns true if the count of the Release invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockReleaseDone() bool {
	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReleaseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRelease != nil && mm_atomic.LoadUint64(&m.afterReleaseCounter) < 1 {
		return false
	}
	return true
}

// MinimockReleaseInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockReleaseInspect() {
	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.Release with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReleaseCounter) < 1 {
		if m.ReleaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.Release")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.Release with params: %#v", *m.ReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRelease != nil && mm_atomic.LoadUint64(&m.afterReleaseCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.Release")
	}
}

type mMigrationContextMockReleaseAll struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockReleaseAllExpectation
	expectations       []*MigrationContextMockReleaseAllExpectation
}

// MigrationContextMockReleaseAllExpectation specifies expectation struct of the MigrationContext.ReleaseAll
type MigrationContextMockReleaseAllExpectation struct {
	mock *MigrationContextMock

	results *MigrationContextMockReleaseAllResults
	Counter uint64
}

// MigrationContextMockReleaseAllResults contains results of the MigrationContext.ReleaseAll
type MigrationContextMockReleaseAllResults struct {
	b1 bool
}

// Expect sets up expected params for MigrationContext.ReleaseAll
func (mmReleaseAll *mMigrationContextMockReleaseAll) Expect() *mMigrationContextMockReleaseAll {
	if mmReleaseAll.mock.funcReleaseAll != nil {
		mmReleaseAll.mock.t.Fatalf("MigrationContextMock.ReleaseAll mock is already set by Set")
	}

	if mmReleaseAll.defaultExpectation == nil {
		mmReleaseAll.defaultExpectation = &MigrationContextMockReleaseAllExpectation{}
	}

	return mmReleaseAll
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.ReleaseAll
func (mmReleaseAll *mMigrationContextMockReleaseAll) Inspect(f func()) *mMigrationContextMockReleaseAll {
	if mmReleaseAll.mock.inspectFuncReleaseAll != nil {
		mmReleaseAll.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.ReleaseAll")
	}

	mmReleaseAll.mock.inspectFuncReleaseAll = f

	return mmReleaseAll
}

// Return sets up results that will be returned by MigrationContext.ReleaseAll
func (mmReleaseAll *mMigrationContextMockReleaseAll) Return(b1 bool) *MigrationContextMock {
	if mmReleaseAll.mock.funcReleaseAll != nil {
		mmReleaseAll.mock.t.Fatalf("MigrationContextMock.ReleaseAll mock is already set by Set")
	}

	if mmReleaseAll.defaultExpectation == nil {
		mmReleaseAll.defaultExpectation = &MigrationContextMockReleaseAllExpectation{mock: mmReleaseAll.mock}
	}
	mmReleaseAll.defaultExpectation.results = &MigrationContextMockReleaseAllResults{b1}
	return mmReleaseAll.mock
}

//Set uses given function f to mock the MigrationContext.ReleaseAll method
func (mmReleaseAll *mMigrationContextMockReleaseAll) Set(f func() (b1 bool)) *MigrationContextMock {
	if mmReleaseAll.defaultExpectation != nil {
		mmReleaseAll.mock.t.Fatalf("Default expectation is already set for the MigrationContext.ReleaseAll method")
	}

	if len(mmReleaseAll.expectations) > 0 {
		mmReleaseAll.mock.t.Fatalf("Some expectations are already set for the MigrationContext.ReleaseAll method")
	}

	mmReleaseAll.mock.funcReleaseAll = f
	return mmReleaseAll.mock
}

// ReleaseAll implements MigrationContext
func (mmReleaseAll *MigrationContextMock) ReleaseAll() (b1 bool) {
	mm_atomic.AddUint64(&mmReleaseAll.beforeReleaseAllCounter, 1)
	defer mm_atomic.AddUint64(&mmReleaseAll.afterReleaseAllCounter, 1)

	if mmReleaseAll.inspectFuncReleaseAll != nil {
		mmReleaseAll.inspectFuncReleaseAll()
	}

	if mmReleaseAll.ReleaseAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReleaseAll.ReleaseAllMock.defaultExpectation.Counter, 1)

		mm_results := mmReleaseAll.ReleaseAllMock.defaultExpectation.results
		if mm_results == nil {
			mmReleaseAll.t.Fatal("No results are set for the MigrationContextMock.ReleaseAll")
		}
		return (*mm_results).b1
	}
	if mmReleaseAll.funcReleaseAll != nil {
		return mmReleaseAll.funcReleaseAll()
	}
	mmReleaseAll.t.Fatalf("Unexpected call to MigrationContextMock.ReleaseAll.")
	return
}

// ReleaseAllAfterCounter returns a count of finished MigrationContextMock.ReleaseAll invocations
func (mmReleaseAll *MigrationContextMock) ReleaseAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReleaseAll.afterReleaseAllCounter)
}

// ReleaseAllBeforeCounter returns a count of MigrationContextMock.ReleaseAll invocations
func (mmReleaseAll *MigrationContextMock) ReleaseAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReleaseAll.beforeReleaseAllCounter)
}

// MinimockReleaseAllDone returns true if the count of the ReleaseAll invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockReleaseAllDone() bool {
	for _, e := range m.ReleaseAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReleaseAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReleaseAll != nil && mm_atomic.LoadUint64(&m.afterReleaseAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockReleaseAllInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockReleaseAllInspect() {
	for _, e := range m.ReleaseAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MigrationContextMock.ReleaseAll")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReleaseAllCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.ReleaseAll")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReleaseAll != nil && mm_atomic.LoadUint64(&m.afterReleaseAllCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.ReleaseAll")
	}
}

type mMigrationContextMockRestoreStep struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockRestoreStepExpectation
	expectations       []*MigrationContextMockRestoreStepExpectation

	callArgs []*MigrationContextMockRestoreStepParams
	mutex    sync.RWMutex
}

// MigrationContextMockRestoreStepExpectation specifies expectation struct of the MigrationContext.RestoreStep
type MigrationContextMockRestoreStepExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockRestoreStepParams
	results *MigrationContextMockRestoreStepResults
	Counter uint64
}

// MigrationContextMockRestoreStepParams contains parameters of the MigrationContext.RestoreStep
type MigrationContextMockRestoreStepParams struct {
	s1 SlotStep
}

// MigrationContextMockRestoreStepResults contains results of the MigrationContext.RestoreStep
type MigrationContextMockRestoreStepResults struct {
	s2 StateUpdate
}

// Expect sets up expected params for MigrationContext.RestoreStep
func (mmRestoreStep *mMigrationContextMockRestoreStep) Expect(s1 SlotStep) *mMigrationContextMockRestoreStep {
	if mmRestoreStep.mock.funcRestoreStep != nil {
		mmRestoreStep.mock.t.Fatalf("MigrationContextMock.RestoreStep mock is already set by Set")
	}

	if mmRestoreStep.defaultExpectation == nil {
		mmRestoreStep.defaultExpectation = &MigrationContextMockRestoreStepExpectation{}
	}

	mmRestoreStep.defaultExpectation.params = &MigrationContextMockRestoreStepParams{s1}
	for _, e := range mmRestoreStep.expectations {
		if minimock.Equal(e.params, mmRestoreStep.defaultExpectation.params) {
			mmRestoreStep.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRestoreStep.defaultExpectation.params)
		}
	}

	return mmRestoreStep
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.RestoreStep
func (mmRestoreStep *mMigrationContextMockRestoreStep) Inspect(f func(s1 SlotStep)) *mMigrationContextMockRestoreStep {
	if mmRestoreStep.mock.inspectFuncRestoreStep != nil {
		mmRestoreStep.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.RestoreStep")
	}

	mmRestoreStep.mock.inspectFuncRestoreStep = f

	return mmRestoreStep
}

// Return sets up results that will be returned by MigrationContext.RestoreStep
func (mmRestoreStep *mMigrationContextMockRestoreStep) Return(s2 StateUpdate) *MigrationContextMock {
	if mmRestoreStep.mock.funcRestoreStep != nil {
		mmRestoreStep.mock.t.Fatalf("MigrationContextMock.RestoreStep mock is already set by Set")
	}

	if mmRestoreStep.defaultExpectation == nil {
		mmRestoreStep.defaultExpectation = &MigrationContextMockRestoreStepExpectation{mock: mmRestoreStep.mock}
	}
	mmRestoreStep.defaultExpectation.results = &MigrationContextMockRestoreStepResults{s2}
	return mmRestoreStep.mock
}

//Set uses given function f to mock the MigrationContext.RestoreStep method
func (mmRestoreStep *mMigrationContextMockRestoreStep) Set(f func(s1 SlotStep) (s2 StateUpdate)) *MigrationContextMock {
	if mmRestoreStep.defaultExpectation != nil {
		mmRestoreStep.mock.t.Fatalf("Default expectation is already set for the MigrationContext.RestoreStep method")
	}

	if len(mmRestoreStep.expectations) > 0 {
		mmRestoreStep.mock.t.Fatalf("Some expectations are already set for the MigrationContext.RestoreStep method")
	}

	mmRestoreStep.mock.funcRestoreStep = f
	return mmRestoreStep.mock
}

// When sets expectation for the MigrationContext.RestoreStep which will trigger the result defined by the following
// Then helper
func (mmRestoreStep *mMigrationContextMockRestoreStep) When(s1 SlotStep) *MigrationContextMockRestoreStepExpectation {
	if mmRestoreStep.mock.funcRestoreStep != nil {
		mmRestoreStep.mock.t.Fatalf("MigrationContextMock.RestoreStep mock is already set by Set")
	}

	expectation := &MigrationContextMockRestoreStepExpectation{
		mock:   mmRestoreStep.mock,
		params: &MigrationContextMockRestoreStepParams{s1},
	}
	mmRestoreStep.expectations = append(mmRestoreStep.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.RestoreStep return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockRestoreStepExpectation) Then(s2 StateUpdate) *MigrationContextMock {
	e.results = &MigrationContextMockRestoreStepResults{s2}
	return e.mock
}

// RestoreStep implements MigrationContext
func (mmRestoreStep *MigrationContextMock) RestoreStep(s1 SlotStep) (s2 StateUpdate) {
	mm_atomic.AddUint64(&mmRestoreStep.beforeRestoreStepCounter, 1)
	defer mm_atomic.AddUint64(&mmRestoreStep.afterRestoreStepCounter, 1)

	if mmRestoreStep.inspectFuncRestoreStep != nil {
		mmRestoreStep.inspectFuncRestoreStep(s1)
	}

	mm_params := &MigrationContextMockRestoreStepParams{s1}

	// Record call args
	mmRestoreStep.RestoreStepMock.mutex.Lock()
	mmRestoreStep.RestoreStepMock.callArgs = append(mmRestoreStep.RestoreStepMock.callArgs, mm_params)
	mmRestoreStep.RestoreStepMock.mutex.Unlock()

	for _, e := range mmRestoreStep.RestoreStepMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2
		}
	}

	if mmRestoreStep.RestoreStepMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRestoreStep.RestoreStepMock.defaultExpectation.Counter, 1)
		mm_want := mmRestoreStep.RestoreStepMock.defaultExpectation.params
		mm_got := MigrationContextMockRestoreStepParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRestoreStep.t.Errorf("MigrationContextMock.RestoreStep got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRestoreStep.RestoreStepMock.defaultExpectation.results
		if mm_results == nil {
			mmRestoreStep.t.Fatal("No results are set for the MigrationContextMock.RestoreStep")
		}
		return (*mm_results).s2
	}
	if mmRestoreStep.funcRestoreStep != nil {
		return mmRestoreStep.funcRestoreStep(s1)
	}
	mmRestoreStep.t.Fatalf("Unexpected call to MigrationContextMock.RestoreStep. %v", s1)
	return
}

// RestoreStepAfterCounter returns a count of finished MigrationContextMock.RestoreStep invocations
func (mmRestoreStep *MigrationContextMock) RestoreStepAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRestoreStep.afterRestoreStepCounter)
}

// RestoreStepBeforeCounter returns a count of MigrationContextMock.RestoreStep invocations
func (mmRestoreStep *MigrationContextMock) RestoreStepBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRestoreStep.beforeRestoreStepCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.RestoreStep.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRestoreStep *mMigrationContextMockRestoreStep) Calls() []*MigrationContextMockRestoreStepParams {
	mmRestoreStep.mutex.RLock()

	argCopy := make([]*MigrationContextMockRestoreStepParams, len(mmRestoreStep.callArgs))
	copy(argCopy, mmRestoreStep.callArgs)

	mmRestoreStep.mutex.RUnlock()

	return argCopy
}

// MinimockRestoreStepDone returns true if the count of the RestoreStep invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockRestoreStepDone() bool {
	for _, e := range m.RestoreStepMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RestoreStepMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRestoreStepCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRestoreStep != nil && mm_atomic.LoadUint64(&m.afterRestoreStepCounter) < 1 {
		return false
	}
	return true
}

// MinimockRestoreStepInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockRestoreStepInspect() {
	for _, e := range m.RestoreStepMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.RestoreStep with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RestoreStepMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRestoreStepCounter) < 1 {
		if m.RestoreStepMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.RestoreStep")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.RestoreStep with params: %#v", *m.RestoreStepMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRestoreStep != nil && mm_atomic.LoadUint64(&m.afterRestoreStepCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.RestoreStep")
	}
}

type mMigrationContextMockSetDefaultErrorHandler struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockSetDefaultErrorHandlerExpectation
	expectations       []*MigrationContextMockSetDefaultErrorHandlerExpectation

	callArgs []*MigrationContextMockSetDefaultErrorHandlerParams
	mutex    sync.RWMutex
}

// MigrationContextMockSetDefaultErrorHandlerExpectation specifies expectation struct of the MigrationContext.SetDefaultErrorHandler
type MigrationContextMockSetDefaultErrorHandlerExpectation struct {
	mock   *MigrationContextMock
	params *MigrationContextMockSetDefaultErrorHandlerParams

	Counter uint64
}

// MigrationContextMockSetDefaultErrorHandlerParams contains parameters of the MigrationContext.SetDefaultErrorHandler
type MigrationContextMockSetDefaultErrorHandlerParams struct {
	e1 ErrorHandlerFunc
}

// Expect sets up expected params for MigrationContext.SetDefaultErrorHandler
func (mmSetDefaultErrorHandler *mMigrationContextMockSetDefaultErrorHandler) Expect(e1 ErrorHandlerFunc) *mMigrationContextMockSetDefaultErrorHandler {
	if mmSetDefaultErrorHandler.mock.funcSetDefaultErrorHandler != nil {
		mmSetDefaultErrorHandler.mock.t.Fatalf("MigrationContextMock.SetDefaultErrorHandler mock is already set by Set")
	}

	if mmSetDefaultErrorHandler.defaultExpectation == nil {
		mmSetDefaultErrorHandler.defaultExpectation = &MigrationContextMockSetDefaultErrorHandlerExpectation{}
	}

	mmSetDefaultErrorHandler.defaultExpectation.params = &MigrationContextMockSetDefaultErrorHandlerParams{e1}
	for _, e := range mmSetDefaultErrorHandler.expectations {
		if minimock.Equal(e.params, mmSetDefaultErrorHandler.defaultExpectation.params) {
			mmSetDefaultErrorHandler.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetDefaultErrorHandler.defaultExpectation.params)
		}
	}

	return mmSetDefaultErrorHandler
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.SetDefaultErrorHandler
func (mmSetDefaultErrorHandler *mMigrationContextMockSetDefaultErrorHandler) Inspect(f func(e1 ErrorHandlerFunc)) *mMigrationContextMockSetDefaultErrorHandler {
	if mmSetDefaultErrorHandler.mock.inspectFuncSetDefaultErrorHandler != nil {
		mmSetDefaultErrorHandler.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.SetDefaultErrorHandler")
	}

	mmSetDefaultErrorHandler.mock.inspectFuncSetDefaultErrorHandler = f

	return mmSetDefaultErrorHandler
}

// Return sets up results that will be returned by MigrationContext.SetDefaultErrorHandler
func (mmSetDefaultErrorHandler *mMigrationContextMockSetDefaultErrorHandler) Return() *MigrationContextMock {
	if mmSetDefaultErrorHandler.mock.funcSetDefaultErrorHandler != nil {
		mmSetDefaultErrorHandler.mock.t.Fatalf("MigrationContextMock.SetDefaultErrorHandler mock is already set by Set")
	}

	if mmSetDefaultErrorHandler.defaultExpectation == nil {
		mmSetDefaultErrorHandler.defaultExpectation = &MigrationContextMockSetDefaultErrorHandlerExpectation{mock: mmSetDefaultErrorHandler.mock}
	}

	return mmSetDefaultErrorHandler.mock
}

//Set uses given function f to mock the MigrationContext.SetDefaultErrorHandler method
func (mmSetDefaultErrorHandler *mMigrationContextMockSetDefaultErrorHandler) Set(f func(e1 ErrorHandlerFunc)) *MigrationContextMock {
	if mmSetDefaultErrorHandler.defaultExpectation != nil {
		mmSetDefaultErrorHandler.mock.t.Fatalf("Default expectation is already set for the MigrationContext.SetDefaultErrorHandler method")
	}

	if len(mmSetDefaultErrorHandler.expectations) > 0 {
		mmSetDefaultErrorHandler.mock.t.Fatalf("Some expectations are already set for the MigrationContext.SetDefaultErrorHandler method")
	}

	mmSetDefaultErrorHandler.mock.funcSetDefaultErrorHandler = f
	return mmSetDefaultErrorHandler.mock
}

// SetDefaultErrorHandler implements MigrationContext
func (mmSetDefaultErrorHandler *MigrationContextMock) SetDefaultErrorHandler(e1 ErrorHandlerFunc) {
	mm_atomic.AddUint64(&mmSetDefaultErrorHandler.beforeSetDefaultErrorHandlerCounter, 1)
	defer mm_atomic.AddUint64(&mmSetDefaultErrorHandler.afterSetDefaultErrorHandlerCounter, 1)

	if mmSetDefaultErrorHandler.inspectFuncSetDefaultErrorHandler != nil {
		mmSetDefaultErrorHandler.inspectFuncSetDefaultErrorHandler(e1)
	}

	mm_params := &MigrationContextMockSetDefaultErrorHandlerParams{e1}

	// Record call args
	mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.mutex.Lock()
	mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.callArgs = append(mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.callArgs, mm_params)
	mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.mutex.Unlock()

	for _, e := range mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.defaultExpectation.Counter, 1)
		mm_want := mmSetDefaultErrorHandler.SetDefaultErrorHandlerMock.defaultExpectation.params
		mm_got := MigrationContextMockSetDefaultErrorHandlerParams{e1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetDefaultErrorHandler.t.Errorf("MigrationContextMock.SetDefaultErrorHandler got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetDefaultErrorHandler.funcSetDefaultErrorHandler != nil {
		mmSetDefaultErrorHandler.funcSetDefaultErrorHandler(e1)
		return
	}
	mmSetDefaultErrorHandler.t.Fatalf("Unexpected call to MigrationContextMock.SetDefaultErrorHandler. %v", e1)

}

// SetDefaultErrorHandlerAfterCounter returns a count of finished MigrationContextMock.SetDefaultErrorHandler invocations
func (mmSetDefaultErrorHandler *MigrationContextMock) SetDefaultErrorHandlerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultErrorHandler.afterSetDefaultErrorHandlerCounter)
}

// SetDefaultErrorHandlerBeforeCounter returns a count of MigrationContextMock.SetDefaultErrorHandler invocations
func (mmSetDefaultErrorHandler *MigrationContextMock) SetDefaultErrorHandlerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultErrorHandler.beforeSetDefaultErrorHandlerCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.SetDefaultErrorHandler.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetDefaultErrorHandler *mMigrationContextMockSetDefaultErrorHandler) Calls() []*MigrationContextMockSetDefaultErrorHandlerParams {
	mmSetDefaultErrorHandler.mutex.RLock()

	argCopy := make([]*MigrationContextMockSetDefaultErrorHandlerParams, len(mmSetDefaultErrorHandler.callArgs))
	copy(argCopy, mmSetDefaultErrorHandler.callArgs)

	mmSetDefaultErrorHandler.mutex.RUnlock()

	return argCopy
}

// MinimockSetDefaultErrorHandlerDone returns true if the count of the SetDefaultErrorHandler invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockSetDefaultErrorHandlerDone() bool {
	for _, e := range m.SetDefaultErrorHandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultErrorHandlerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultErrorHandlerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultErrorHandler != nil && mm_atomic.LoadUint64(&m.afterSetDefaultErrorHandlerCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetDefaultErrorHandlerInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockSetDefaultErrorHandlerInspect() {
	for _, e := range m.SetDefaultErrorHandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.SetDefaultErrorHandler with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultErrorHandlerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultErrorHandlerCounter) < 1 {
		if m.SetDefaultErrorHandlerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.SetDefaultErrorHandler")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.SetDefaultErrorHandler with params: %#v", *m.SetDefaultErrorHandlerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultErrorHandler != nil && mm_atomic.LoadUint64(&m.afterSetDefaultErrorHandlerCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.SetDefaultErrorHandler")
	}
}

type mMigrationContextMockSetDefaultFlags struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockSetDefaultFlagsExpectation
	expectations       []*MigrationContextMockSetDefaultFlagsExpectation

	callArgs []*MigrationContextMockSetDefaultFlagsParams
	mutex    sync.RWMutex
}

// MigrationContextMockSetDefaultFlagsExpectation specifies expectation struct of the MigrationContext.SetDefaultFlags
type MigrationContextMockSetDefaultFlagsExpectation struct {
	mock   *MigrationContextMock
	params *MigrationContextMockSetDefaultFlagsParams

	Counter uint64
}

// MigrationContextMockSetDefaultFlagsParams contains parameters of the MigrationContext.SetDefaultFlags
type MigrationContextMockSetDefaultFlagsParams struct {
	s1 StepFlags
}

// Expect sets up expected params for MigrationContext.SetDefaultFlags
func (mmSetDefaultFlags *mMigrationContextMockSetDefaultFlags) Expect(s1 StepFlags) *mMigrationContextMockSetDefaultFlags {
	if mmSetDefaultFlags.mock.funcSetDefaultFlags != nil {
		mmSetDefaultFlags.mock.t.Fatalf("MigrationContextMock.SetDefaultFlags mock is already set by Set")
	}

	if mmSetDefaultFlags.defaultExpectation == nil {
		mmSetDefaultFlags.defaultExpectation = &MigrationContextMockSetDefaultFlagsExpectation{}
	}

	mmSetDefaultFlags.defaultExpectation.params = &MigrationContextMockSetDefaultFlagsParams{s1}
	for _, e := range mmSetDefaultFlags.expectations {
		if minimock.Equal(e.params, mmSetDefaultFlags.defaultExpectation.params) {
			mmSetDefaultFlags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetDefaultFlags.defaultExpectation.params)
		}
	}

	return mmSetDefaultFlags
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.SetDefaultFlags
func (mmSetDefaultFlags *mMigrationContextMockSetDefaultFlags) Inspect(f func(s1 StepFlags)) *mMigrationContextMockSetDefaultFlags {
	if mmSetDefaultFlags.mock.inspectFuncSetDefaultFlags != nil {
		mmSetDefaultFlags.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.SetDefaultFlags")
	}

	mmSetDefaultFlags.mock.inspectFuncSetDefaultFlags = f

	return mmSetDefaultFlags
}

// Return sets up results that will be returned by MigrationContext.SetDefaultFlags
func (mmSetDefaultFlags *mMigrationContextMockSetDefaultFlags) Return() *MigrationContextMock {
	if mmSetDefaultFlags.mock.funcSetDefaultFlags != nil {
		mmSetDefaultFlags.mock.t.Fatalf("MigrationContextMock.SetDefaultFlags mock is already set by Set")
	}

	if mmSetDefaultFlags.defaultExpectation == nil {
		mmSetDefaultFlags.defaultExpectation = &MigrationContextMockSetDefaultFlagsExpectation{mock: mmSetDefaultFlags.mock}
	}

	return mmSetDefaultFlags.mock
}

//Set uses given function f to mock the MigrationContext.SetDefaultFlags method
func (mmSetDefaultFlags *mMigrationContextMockSetDefaultFlags) Set(f func(s1 StepFlags)) *MigrationContextMock {
	if mmSetDefaultFlags.defaultExpectation != nil {
		mmSetDefaultFlags.mock.t.Fatalf("Default expectation is already set for the MigrationContext.SetDefaultFlags method")
	}

	if len(mmSetDefaultFlags.expectations) > 0 {
		mmSetDefaultFlags.mock.t.Fatalf("Some expectations are already set for the MigrationContext.SetDefaultFlags method")
	}

	mmSetDefaultFlags.mock.funcSetDefaultFlags = f
	return mmSetDefaultFlags.mock
}

// SetDefaultFlags implements MigrationContext
func (mmSetDefaultFlags *MigrationContextMock) SetDefaultFlags(s1 StepFlags) {
	mm_atomic.AddUint64(&mmSetDefaultFlags.beforeSetDefaultFlagsCounter, 1)
	defer mm_atomic.AddUint64(&mmSetDefaultFlags.afterSetDefaultFlagsCounter, 1)

	if mmSetDefaultFlags.inspectFuncSetDefaultFlags != nil {
		mmSetDefaultFlags.inspectFuncSetDefaultFlags(s1)
	}

	mm_params := &MigrationContextMockSetDefaultFlagsParams{s1}

	// Record call args
	mmSetDefaultFlags.SetDefaultFlagsMock.mutex.Lock()
	mmSetDefaultFlags.SetDefaultFlagsMock.callArgs = append(mmSetDefaultFlags.SetDefaultFlagsMock.callArgs, mm_params)
	mmSetDefaultFlags.SetDefaultFlagsMock.mutex.Unlock()

	for _, e := range mmSetDefaultFlags.SetDefaultFlagsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetDefaultFlags.SetDefaultFlagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetDefaultFlags.SetDefaultFlagsMock.defaultExpectation.Counter, 1)
		mm_want := mmSetDefaultFlags.SetDefaultFlagsMock.defaultExpectation.params
		mm_got := MigrationContextMockSetDefaultFlagsParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetDefaultFlags.t.Errorf("MigrationContextMock.SetDefaultFlags got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetDefaultFlags.funcSetDefaultFlags != nil {
		mmSetDefaultFlags.funcSetDefaultFlags(s1)
		return
	}
	mmSetDefaultFlags.t.Fatalf("Unexpected call to MigrationContextMock.SetDefaultFlags. %v", s1)

}

// SetDefaultFlagsAfterCounter returns a count of finished MigrationContextMock.SetDefaultFlags invocations
func (mmSetDefaultFlags *MigrationContextMock) SetDefaultFlagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultFlags.afterSetDefaultFlagsCounter)
}

// SetDefaultFlagsBeforeCounter returns a count of MigrationContextMock.SetDefaultFlags invocations
func (mmSetDefaultFlags *MigrationContextMock) SetDefaultFlagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultFlags.beforeSetDefaultFlagsCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.SetDefaultFlags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetDefaultFlags *mMigrationContextMockSetDefaultFlags) Calls() []*MigrationContextMockSetDefaultFlagsParams {
	mmSetDefaultFlags.mutex.RLock()

	argCopy := make([]*MigrationContextMockSetDefaultFlagsParams, len(mmSetDefaultFlags.callArgs))
	copy(argCopy, mmSetDefaultFlags.callArgs)

	mmSetDefaultFlags.mutex.RUnlock()

	return argCopy
}

// MinimockSetDefaultFlagsDone returns true if the count of the SetDefaultFlags invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockSetDefaultFlagsDone() bool {
	for _, e := range m.SetDefaultFlagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultFlagsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultFlagsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultFlags != nil && mm_atomic.LoadUint64(&m.afterSetDefaultFlagsCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetDefaultFlagsInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockSetDefaultFlagsInspect() {
	for _, e := range m.SetDefaultFlagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.SetDefaultFlags with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultFlagsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultFlagsCounter) < 1 {
		if m.SetDefaultFlagsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.SetDefaultFlags")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.SetDefaultFlags with params: %#v", *m.SetDefaultFlagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultFlags != nil && mm_atomic.LoadUint64(&m.afterSetDefaultFlagsCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.SetDefaultFlags")
	}
}

type mMigrationContextMockSetDefaultMigration struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockSetDefaultMigrationExpectation
	expectations       []*MigrationContextMockSetDefaultMigrationExpectation

	callArgs []*MigrationContextMockSetDefaultMigrationParams
	mutex    sync.RWMutex
}

// MigrationContextMockSetDefaultMigrationExpectation specifies expectation struct of the MigrationContext.SetDefaultMigration
type MigrationContextMockSetDefaultMigrationExpectation struct {
	mock   *MigrationContextMock
	params *MigrationContextMockSetDefaultMigrationParams

	Counter uint64
}

// MigrationContextMockSetDefaultMigrationParams contains parameters of the MigrationContext.SetDefaultMigration
type MigrationContextMockSetDefaultMigrationParams struct {
	m1 MigrateFunc
}

// Expect sets up expected params for MigrationContext.SetDefaultMigration
func (mmSetDefaultMigration *mMigrationContextMockSetDefaultMigration) Expect(m1 MigrateFunc) *mMigrationContextMockSetDefaultMigration {
	if mmSetDefaultMigration.mock.funcSetDefaultMigration != nil {
		mmSetDefaultMigration.mock.t.Fatalf("MigrationContextMock.SetDefaultMigration mock is already set by Set")
	}

	if mmSetDefaultMigration.defaultExpectation == nil {
		mmSetDefaultMigration.defaultExpectation = &MigrationContextMockSetDefaultMigrationExpectation{}
	}

	mmSetDefaultMigration.defaultExpectation.params = &MigrationContextMockSetDefaultMigrationParams{m1}
	for _, e := range mmSetDefaultMigration.expectations {
		if minimock.Equal(e.params, mmSetDefaultMigration.defaultExpectation.params) {
			mmSetDefaultMigration.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetDefaultMigration.defaultExpectation.params)
		}
	}

	return mmSetDefaultMigration
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.SetDefaultMigration
func (mmSetDefaultMigration *mMigrationContextMockSetDefaultMigration) Inspect(f func(m1 MigrateFunc)) *mMigrationContextMockSetDefaultMigration {
	if mmSetDefaultMigration.mock.inspectFuncSetDefaultMigration != nil {
		mmSetDefaultMigration.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.SetDefaultMigration")
	}

	mmSetDefaultMigration.mock.inspectFuncSetDefaultMigration = f

	return mmSetDefaultMigration
}

// Return sets up results that will be returned by MigrationContext.SetDefaultMigration
func (mmSetDefaultMigration *mMigrationContextMockSetDefaultMigration) Return() *MigrationContextMock {
	if mmSetDefaultMigration.mock.funcSetDefaultMigration != nil {
		mmSetDefaultMigration.mock.t.Fatalf("MigrationContextMock.SetDefaultMigration mock is already set by Set")
	}

	if mmSetDefaultMigration.defaultExpectation == nil {
		mmSetDefaultMigration.defaultExpectation = &MigrationContextMockSetDefaultMigrationExpectation{mock: mmSetDefaultMigration.mock}
	}

	return mmSetDefaultMigration.mock
}

//Set uses given function f to mock the MigrationContext.SetDefaultMigration method
func (mmSetDefaultMigration *mMigrationContextMockSetDefaultMigration) Set(f func(m1 MigrateFunc)) *MigrationContextMock {
	if mmSetDefaultMigration.defaultExpectation != nil {
		mmSetDefaultMigration.mock.t.Fatalf("Default expectation is already set for the MigrationContext.SetDefaultMigration method")
	}

	if len(mmSetDefaultMigration.expectations) > 0 {
		mmSetDefaultMigration.mock.t.Fatalf("Some expectations are already set for the MigrationContext.SetDefaultMigration method")
	}

	mmSetDefaultMigration.mock.funcSetDefaultMigration = f
	return mmSetDefaultMigration.mock
}

// SetDefaultMigration implements MigrationContext
func (mmSetDefaultMigration *MigrationContextMock) SetDefaultMigration(m1 MigrateFunc) {
	mm_atomic.AddUint64(&mmSetDefaultMigration.beforeSetDefaultMigrationCounter, 1)
	defer mm_atomic.AddUint64(&mmSetDefaultMigration.afterSetDefaultMigrationCounter, 1)

	if mmSetDefaultMigration.inspectFuncSetDefaultMigration != nil {
		mmSetDefaultMigration.inspectFuncSetDefaultMigration(m1)
	}

	mm_params := &MigrationContextMockSetDefaultMigrationParams{m1}

	// Record call args
	mmSetDefaultMigration.SetDefaultMigrationMock.mutex.Lock()
	mmSetDefaultMigration.SetDefaultMigrationMock.callArgs = append(mmSetDefaultMigration.SetDefaultMigrationMock.callArgs, mm_params)
	mmSetDefaultMigration.SetDefaultMigrationMock.mutex.Unlock()

	for _, e := range mmSetDefaultMigration.SetDefaultMigrationMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetDefaultMigration.SetDefaultMigrationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetDefaultMigration.SetDefaultMigrationMock.defaultExpectation.Counter, 1)
		mm_want := mmSetDefaultMigration.SetDefaultMigrationMock.defaultExpectation.params
		mm_got := MigrationContextMockSetDefaultMigrationParams{m1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetDefaultMigration.t.Errorf("MigrationContextMock.SetDefaultMigration got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetDefaultMigration.funcSetDefaultMigration != nil {
		mmSetDefaultMigration.funcSetDefaultMigration(m1)
		return
	}
	mmSetDefaultMigration.t.Fatalf("Unexpected call to MigrationContextMock.SetDefaultMigration. %v", m1)

}

// SetDefaultMigrationAfterCounter returns a count of finished MigrationContextMock.SetDefaultMigration invocations
func (mmSetDefaultMigration *MigrationContextMock) SetDefaultMigrationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultMigration.afterSetDefaultMigrationCounter)
}

// SetDefaultMigrationBeforeCounter returns a count of MigrationContextMock.SetDefaultMigration invocations
func (mmSetDefaultMigration *MigrationContextMock) SetDefaultMigrationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultMigration.beforeSetDefaultMigrationCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.SetDefaultMigration.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetDefaultMigration *mMigrationContextMockSetDefaultMigration) Calls() []*MigrationContextMockSetDefaultMigrationParams {
	mmSetDefaultMigration.mutex.RLock()

	argCopy := make([]*MigrationContextMockSetDefaultMigrationParams, len(mmSetDefaultMigration.callArgs))
	copy(argCopy, mmSetDefaultMigration.callArgs)

	mmSetDefaultMigration.mutex.RUnlock()

	return argCopy
}

// MinimockSetDefaultMigrationDone returns true if the count of the SetDefaultMigration invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockSetDefaultMigrationDone() bool {
	for _, e := range m.SetDefaultMigrationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultMigrationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultMigrationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultMigration != nil && mm_atomic.LoadUint64(&m.afterSetDefaultMigrationCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetDefaultMigrationInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockSetDefaultMigrationInspect() {
	for _, e := range m.SetDefaultMigrationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.SetDefaultMigration with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultMigrationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultMigrationCounter) < 1 {
		if m.SetDefaultMigrationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.SetDefaultMigration")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.SetDefaultMigration with params: %#v", *m.SetDefaultMigrationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultMigration != nil && mm_atomic.LoadUint64(&m.afterSetDefaultMigrationCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.SetDefaultMigration")
	}
}

type mMigrationContextMockSetFinalizer struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockSetFinalizerExpectation
	expectations       []*MigrationContextMockSetFinalizerExpectation

	callArgs []*MigrationContextMockSetFinalizerParams
	mutex    sync.RWMutex
}

// MigrationContextMockSetFinalizerExpectation specifies expectation struct of the MigrationContext.SetFinalizer
type MigrationContextMockSetFinalizerExpectation struct {
	mock   *MigrationContextMock
	params *MigrationContextMockSetFinalizerParams

	Counter uint64
}

// MigrationContextMockSetFinalizerParams contains parameters of the MigrationContext.SetFinalizer
type MigrationContextMockSetFinalizerParams struct {
	f1 FinalizeFunc
}

// Expect sets up expected params for MigrationContext.SetFinalizer
func (mmSetFinalizer *mMigrationContextMockSetFinalizer) Expect(f1 FinalizeFunc) *mMigrationContextMockSetFinalizer {
	if mmSetFinalizer.mock.funcSetFinalizer != nil {
		mmSetFinalizer.mock.t.Fatalf("MigrationContextMock.SetFinalizer mock is already set by Set")
	}

	if mmSetFinalizer.defaultExpectation == nil {
		mmSetFinalizer.defaultExpectation = &MigrationContextMockSetFinalizerExpectation{}
	}

	mmSetFinalizer.defaultExpectation.params = &MigrationContextMockSetFinalizerParams{f1}
	for _, e := range mmSetFinalizer.expectations {
		if minimock.Equal(e.params, mmSetFinalizer.defaultExpectation.params) {
			mmSetFinalizer.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetFinalizer.defaultExpectation.params)
		}
	}

	return mmSetFinalizer
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.SetFinalizer
func (mmSetFinalizer *mMigrationContextMockSetFinalizer) Inspect(f func(f1 FinalizeFunc)) *mMigrationContextMockSetFinalizer {
	if mmSetFinalizer.mock.inspectFuncSetFinalizer != nil {
		mmSetFinalizer.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.SetFinalizer")
	}

	mmSetFinalizer.mock.inspectFuncSetFinalizer = f

	return mmSetFinalizer
}

// Return sets up results that will be returned by MigrationContext.SetFinalizer
func (mmSetFinalizer *mMigrationContextMockSetFinalizer) Return() *MigrationContextMock {
	if mmSetFinalizer.mock.funcSetFinalizer != nil {
		mmSetFinalizer.mock.t.Fatalf("MigrationContextMock.SetFinalizer mock is already set by Set")
	}

	if mmSetFinalizer.defaultExpectation == nil {
		mmSetFinalizer.defaultExpectation = &MigrationContextMockSetFinalizerExpectation{mock: mmSetFinalizer.mock}
	}

	return mmSetFinalizer.mock
}

//Set uses given function f to mock the MigrationContext.SetFinalizer method
func (mmSetFinalizer *mMigrationContextMockSetFinalizer) Set(f func(f1 FinalizeFunc)) *MigrationContextMock {
	if mmSetFinalizer.defaultExpectation != nil {
		mmSetFinalizer.mock.t.Fatalf("Default expectation is already set for the MigrationContext.SetFinalizer method")
	}

	if len(mmSetFinalizer.expectations) > 0 {
		mmSetFinalizer.mock.t.Fatalf("Some expectations are already set for the MigrationContext.SetFinalizer method")
	}

	mmSetFinalizer.mock.funcSetFinalizer = f
	return mmSetFinalizer.mock
}

// SetFinalizer implements MigrationContext
func (mmSetFinalizer *MigrationContextMock) SetFinalizer(f1 FinalizeFunc) {
	mm_atomic.AddUint64(&mmSetFinalizer.beforeSetFinalizerCounter, 1)
	defer mm_atomic.AddUint64(&mmSetFinalizer.afterSetFinalizerCounter, 1)

	if mmSetFinalizer.inspectFuncSetFinalizer != nil {
		mmSetFinalizer.inspectFuncSetFinalizer(f1)
	}

	mm_params := &MigrationContextMockSetFinalizerParams{f1}

	// Record call args
	mmSetFinalizer.SetFinalizerMock.mutex.Lock()
	mmSetFinalizer.SetFinalizerMock.callArgs = append(mmSetFinalizer.SetFinalizerMock.callArgs, mm_params)
	mmSetFinalizer.SetFinalizerMock.mutex.Unlock()

	for _, e := range mmSetFinalizer.SetFinalizerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetFinalizer.SetFinalizerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetFinalizer.SetFinalizerMock.defaultExpectation.Counter, 1)
		mm_want := mmSetFinalizer.SetFinalizerMock.defaultExpectation.params
		mm_got := MigrationContextMockSetFinalizerParams{f1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetFinalizer.t.Errorf("MigrationContextMock.SetFinalizer got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetFinalizer.funcSetFinalizer != nil {
		mmSetFinalizer.funcSetFinalizer(f1)
		return
	}
	mmSetFinalizer.t.Fatalf("Unexpected call to MigrationContextMock.SetFinalizer. %v", f1)

}

// SetFinalizerAfterCounter returns a count of finished MigrationContextMock.SetFinalizer invocations
func (mmSetFinalizer *MigrationContextMock) SetFinalizerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetFinalizer.afterSetFinalizerCounter)
}

// SetFinalizerBeforeCounter returns a count of MigrationContextMock.SetFinalizer invocations
func (mmSetFinalizer *MigrationContextMock) SetFinalizerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetFinalizer.beforeSetFinalizerCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.SetFinalizer.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetFinalizer *mMigrationContextMockSetFinalizer) Calls() []*MigrationContextMockSetFinalizerParams {
	mmSetFinalizer.mutex.RLock()

	argCopy := make([]*MigrationContextMockSetFinalizerParams, len(mmSetFinalizer.callArgs))
	copy(argCopy, mmSetFinalizer.callArgs)

	mmSetFinalizer.mutex.RUnlock()

	return argCopy
}

// MinimockSetFinalizerDone returns true if the count of the SetFinalizer invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockSetFinalizerDone() bool {
	for _, e := range m.SetFinalizerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetFinalizerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetFinalizerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetFinalizer != nil && mm_atomic.LoadUint64(&m.afterSetFinalizerCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetFinalizerInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockSetFinalizerInspect() {
	for _, e := range m.SetFinalizerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.SetFinalizer with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetFinalizerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetFinalizerCounter) < 1 {
		if m.SetFinalizerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.SetFinalizer")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.SetFinalizer with params: %#v", *m.SetFinalizerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetFinalizer != nil && mm_atomic.LoadUint64(&m.afterSetFinalizerCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.SetFinalizer")
	}
}

type mMigrationContextMockSetLogTracing struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockSetLogTracingExpectation
	expectations       []*MigrationContextMockSetLogTracingExpectation

	callArgs []*MigrationContextMockSetLogTracingParams
	mutex    sync.RWMutex
}

// MigrationContextMockSetLogTracingExpectation specifies expectation struct of the MigrationContext.SetLogTracing
type MigrationContextMockSetLogTracingExpectation struct {
	mock   *MigrationContextMock
	params *MigrationContextMockSetLogTracingParams

	Counter uint64
}

// MigrationContextMockSetLogTracingParams contains parameters of the MigrationContext.SetLogTracing
type MigrationContextMockSetLogTracingParams struct {
	b1 bool
}

// Expect sets up expected params for MigrationContext.SetLogTracing
func (mmSetLogTracing *mMigrationContextMockSetLogTracing) Expect(b1 bool) *mMigrationContextMockSetLogTracing {
	if mmSetLogTracing.mock.funcSetLogTracing != nil {
		mmSetLogTracing.mock.t.Fatalf("MigrationContextMock.SetLogTracing mock is already set by Set")
	}

	if mmSetLogTracing.defaultExpectation == nil {
		mmSetLogTracing.defaultExpectation = &MigrationContextMockSetLogTracingExpectation{}
	}

	mmSetLogTracing.defaultExpectation.params = &MigrationContextMockSetLogTracingParams{b1}
	for _, e := range mmSetLogTracing.expectations {
		if minimock.Equal(e.params, mmSetLogTracing.defaultExpectation.params) {
			mmSetLogTracing.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetLogTracing.defaultExpectation.params)
		}
	}

	return mmSetLogTracing
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.SetLogTracing
func (mmSetLogTracing *mMigrationContextMockSetLogTracing) Inspect(f func(b1 bool)) *mMigrationContextMockSetLogTracing {
	if mmSetLogTracing.mock.inspectFuncSetLogTracing != nil {
		mmSetLogTracing.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.SetLogTracing")
	}

	mmSetLogTracing.mock.inspectFuncSetLogTracing = f

	return mmSetLogTracing
}

// Return sets up results that will be returned by MigrationContext.SetLogTracing
func (mmSetLogTracing *mMigrationContextMockSetLogTracing) Return() *MigrationContextMock {
	if mmSetLogTracing.mock.funcSetLogTracing != nil {
		mmSetLogTracing.mock.t.Fatalf("MigrationContextMock.SetLogTracing mock is already set by Set")
	}

	if mmSetLogTracing.defaultExpectation == nil {
		mmSetLogTracing.defaultExpectation = &MigrationContextMockSetLogTracingExpectation{mock: mmSetLogTracing.mock}
	}

	return mmSetLogTracing.mock
}

//Set uses given function f to mock the MigrationContext.SetLogTracing method
func (mmSetLogTracing *mMigrationContextMockSetLogTracing) Set(f func(b1 bool)) *MigrationContextMock {
	if mmSetLogTracing.defaultExpectation != nil {
		mmSetLogTracing.mock.t.Fatalf("Default expectation is already set for the MigrationContext.SetLogTracing method")
	}

	if len(mmSetLogTracing.expectations) > 0 {
		mmSetLogTracing.mock.t.Fatalf("Some expectations are already set for the MigrationContext.SetLogTracing method")
	}

	mmSetLogTracing.mock.funcSetLogTracing = f
	return mmSetLogTracing.mock
}

// SetLogTracing implements MigrationContext
func (mmSetLogTracing *MigrationContextMock) SetLogTracing(b1 bool) {
	mm_atomic.AddUint64(&mmSetLogTracing.beforeSetLogTracingCounter, 1)
	defer mm_atomic.AddUint64(&mmSetLogTracing.afterSetLogTracingCounter, 1)

	if mmSetLogTracing.inspectFuncSetLogTracing != nil {
		mmSetLogTracing.inspectFuncSetLogTracing(b1)
	}

	mm_params := &MigrationContextMockSetLogTracingParams{b1}

	// Record call args
	mmSetLogTracing.SetLogTracingMock.mutex.Lock()
	mmSetLogTracing.SetLogTracingMock.callArgs = append(mmSetLogTracing.SetLogTracingMock.callArgs, mm_params)
	mmSetLogTracing.SetLogTracingMock.mutex.Unlock()

	for _, e := range mmSetLogTracing.SetLogTracingMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetLogTracing.SetLogTracingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetLogTracing.SetLogTracingMock.defaultExpectation.Counter, 1)
		mm_want := mmSetLogTracing.SetLogTracingMock.defaultExpectation.params
		mm_got := MigrationContextMockSetLogTracingParams{b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetLogTracing.t.Errorf("MigrationContextMock.SetLogTracing got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetLogTracing.funcSetLogTracing != nil {
		mmSetLogTracing.funcSetLogTracing(b1)
		return
	}
	mmSetLogTracing.t.Fatalf("Unexpected call to MigrationContextMock.SetLogTracing. %v", b1)

}

// SetLogTracingAfterCounter returns a count of finished MigrationContextMock.SetLogTracing invocations
func (mmSetLogTracing *MigrationContextMock) SetLogTracingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetLogTracing.afterSetLogTracingCounter)
}

// SetLogTracingBeforeCounter returns a count of MigrationContextMock.SetLogTracing invocations
func (mmSetLogTracing *MigrationContextMock) SetLogTracingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetLogTracing.beforeSetLogTracingCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.SetLogTracing.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetLogTracing *mMigrationContextMockSetLogTracing) Calls() []*MigrationContextMockSetLogTracingParams {
	mmSetLogTracing.mutex.RLock()

	argCopy := make([]*MigrationContextMockSetLogTracingParams, len(mmSetLogTracing.callArgs))
	copy(argCopy, mmSetLogTracing.callArgs)

	mmSetLogTracing.mutex.RUnlock()

	return argCopy
}

// MinimockSetLogTracingDone returns true if the count of the SetLogTracing invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockSetLogTracingDone() bool {
	for _, e := range m.SetLogTracingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetLogTracingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetLogTracingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetLogTracing != nil && mm_atomic.LoadUint64(&m.afterSetLogTracingCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetLogTracingInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockSetLogTracingInspect() {
	for _, e := range m.SetLogTracingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.SetLogTracing with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetLogTracingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetLogTracingCounter) < 1 {
		if m.SetLogTracingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.SetLogTracing")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.SetLogTracing with params: %#v", *m.SetLogTracingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetLogTracing != nil && mm_atomic.LoadUint64(&m.afterSetLogTracingCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.SetLogTracing")
	}
}

type mMigrationContextMockSetTerminationResult struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockSetTerminationResultExpectation
	expectations       []*MigrationContextMockSetTerminationResultExpectation

	callArgs []*MigrationContextMockSetTerminationResultParams
	mutex    sync.RWMutex
}

// MigrationContextMockSetTerminationResultExpectation specifies expectation struct of the MigrationContext.SetTerminationResult
type MigrationContextMockSetTerminationResultExpectation struct {
	mock   *MigrationContextMock
	params *MigrationContextMockSetTerminationResultParams

	Counter uint64
}

// MigrationContextMockSetTerminationResultParams contains parameters of the MigrationContext.SetTerminationResult
type MigrationContextMockSetTerminationResultParams struct {
	p1 interface{}
}

// Expect sets up expected params for MigrationContext.SetTerminationResult
func (mmSetTerminationResult *mMigrationContextMockSetTerminationResult) Expect(p1 interface{}) *mMigrationContextMockSetTerminationResult {
	if mmSetTerminationResult.mock.funcSetTerminationResult != nil {
		mmSetTerminationResult.mock.t.Fatalf("MigrationContextMock.SetTerminationResult mock is already set by Set")
	}

	if mmSetTerminationResult.defaultExpectation == nil {
		mmSetTerminationResult.defaultExpectation = &MigrationContextMockSetTerminationResultExpectation{}
	}

	mmSetTerminationResult.defaultExpectation.params = &MigrationContextMockSetTerminationResultParams{p1}
	for _, e := range mmSetTerminationResult.expectations {
		if minimock.Equal(e.params, mmSetTerminationResult.defaultExpectation.params) {
			mmSetTerminationResult.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetTerminationResult.defaultExpectation.params)
		}
	}

	return mmSetTerminationResult
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.SetTerminationResult
func (mmSetTerminationResult *mMigrationContextMockSetTerminationResult) Inspect(f func(p1 interface{})) *mMigrationContextMockSetTerminationResult {
	if mmSetTerminationResult.mock.inspectFuncSetTerminationResult != nil {
		mmSetTerminationResult.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.SetTerminationResult")
	}

	mmSetTerminationResult.mock.inspectFuncSetTerminationResult = f

	return mmSetTerminationResult
}

// Return sets up results that will be returned by MigrationContext.SetTerminationResult
func (mmSetTerminationResult *mMigrationContextMockSetTerminationResult) Return() *MigrationContextMock {
	if mmSetTerminationResult.mock.funcSetTerminationResult != nil {
		mmSetTerminationResult.mock.t.Fatalf("MigrationContextMock.SetTerminationResult mock is already set by Set")
	}

	if mmSetTerminationResult.defaultExpectation == nil {
		mmSetTerminationResult.defaultExpectation = &MigrationContextMockSetTerminationResultExpectation{mock: mmSetTerminationResult.mock}
	}

	return mmSetTerminationResult.mock
}

//Set uses given function f to mock the MigrationContext.SetTerminationResult method
func (mmSetTerminationResult *mMigrationContextMockSetTerminationResult) Set(f func(p1 interface{})) *MigrationContextMock {
	if mmSetTerminationResult.defaultExpectation != nil {
		mmSetTerminationResult.mock.t.Fatalf("Default expectation is already set for the MigrationContext.SetTerminationResult method")
	}

	if len(mmSetTerminationResult.expectations) > 0 {
		mmSetTerminationResult.mock.t.Fatalf("Some expectations are already set for the MigrationContext.SetTerminationResult method")
	}

	mmSetTerminationResult.mock.funcSetTerminationResult = f
	return mmSetTerminationResult.mock
}

// SetTerminationResult implements MigrationContext
func (mmSetTerminationResult *MigrationContextMock) SetTerminationResult(p1 interface{}) {
	mm_atomic.AddUint64(&mmSetTerminationResult.beforeSetTerminationResultCounter, 1)
	defer mm_atomic.AddUint64(&mmSetTerminationResult.afterSetTerminationResultCounter, 1)

	if mmSetTerminationResult.inspectFuncSetTerminationResult != nil {
		mmSetTerminationResult.inspectFuncSetTerminationResult(p1)
	}

	mm_params := &MigrationContextMockSetTerminationResultParams{p1}

	// Record call args
	mmSetTerminationResult.SetTerminationResultMock.mutex.Lock()
	mmSetTerminationResult.SetTerminationResultMock.callArgs = append(mmSetTerminationResult.SetTerminationResultMock.callArgs, mm_params)
	mmSetTerminationResult.SetTerminationResultMock.mutex.Unlock()

	for _, e := range mmSetTerminationResult.SetTerminationResultMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetTerminationResult.SetTerminationResultMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetTerminationResult.SetTerminationResultMock.defaultExpectation.Counter, 1)
		mm_want := mmSetTerminationResult.SetTerminationResultMock.defaultExpectation.params
		mm_got := MigrationContextMockSetTerminationResultParams{p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetTerminationResult.t.Errorf("MigrationContextMock.SetTerminationResult got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetTerminationResult.funcSetTerminationResult != nil {
		mmSetTerminationResult.funcSetTerminationResult(p1)
		return
	}
	mmSetTerminationResult.t.Fatalf("Unexpected call to MigrationContextMock.SetTerminationResult. %v", p1)

}

// SetTerminationResultAfterCounter returns a count of finished MigrationContextMock.SetTerminationResult invocations
func (mmSetTerminationResult *MigrationContextMock) SetTerminationResultAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTerminationResult.afterSetTerminationResultCounter)
}

// SetTerminationResultBeforeCounter returns a count of MigrationContextMock.SetTerminationResult invocations
func (mmSetTerminationResult *MigrationContextMock) SetTerminationResultBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTerminationResult.beforeSetTerminationResultCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.SetTerminationResult.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetTerminationResult *mMigrationContextMockSetTerminationResult) Calls() []*MigrationContextMockSetTerminationResultParams {
	mmSetTerminationResult.mutex.RLock()

	argCopy := make([]*MigrationContextMockSetTerminationResultParams, len(mmSetTerminationResult.callArgs))
	copy(argCopy, mmSetTerminationResult.callArgs)

	mmSetTerminationResult.mutex.RUnlock()

	return argCopy
}

// MinimockSetTerminationResultDone returns true if the count of the SetTerminationResult invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockSetTerminationResultDone() bool {
	for _, e := range m.SetTerminationResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTerminationResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTerminationResultCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTerminationResult != nil && mm_atomic.LoadUint64(&m.afterSetTerminationResultCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetTerminationResultInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockSetTerminationResultInspect() {
	for _, e := range m.SetTerminationResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.SetTerminationResult with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTerminationResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTerminationResultCounter) < 1 {
		if m.SetTerminationResultMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.SetTerminationResult")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.SetTerminationResult with params: %#v", *m.SetTerminationResultMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTerminationResult != nil && mm_atomic.LoadUint64(&m.afterSetTerminationResultCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.SetTerminationResult")
	}
}

type mMigrationContextMockShare struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockShareExpectation
	expectations       []*MigrationContextMockShareExpectation

	callArgs []*MigrationContextMockShareParams
	mutex    sync.RWMutex
}

// MigrationContextMockShareExpectation specifies expectation struct of the MigrationContext.Share
type MigrationContextMockShareExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockShareParams
	results *MigrationContextMockShareResults
	Counter uint64
}

// MigrationContextMockShareParams contains parameters of the MigrationContext.Share
type MigrationContextMockShareParams struct {
	data  interface{}
	flags ShareDataFlags
}

// MigrationContextMockShareResults contains results of the MigrationContext.Share
type MigrationContextMockShareResults struct {
	s1 SharedDataLink
}

// Expect sets up expected params for MigrationContext.Share
func (mmShare *mMigrationContextMockShare) Expect(data interface{}, flags ShareDataFlags) *mMigrationContextMockShare {
	if mmShare.mock.funcShare != nil {
		mmShare.mock.t.Fatalf("MigrationContextMock.Share mock is already set by Set")
	}

	if mmShare.defaultExpectation == nil {
		mmShare.defaultExpectation = &MigrationContextMockShareExpectation{}
	}

	mmShare.defaultExpectation.params = &MigrationContextMockShareParams{data, flags}
	for _, e := range mmShare.expectations {
		if minimock.Equal(e.params, mmShare.defaultExpectation.params) {
			mmShare.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmShare.defaultExpectation.params)
		}
	}

	return mmShare
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.Share
func (mmShare *mMigrationContextMockShare) Inspect(f func(data interface{}, flags ShareDataFlags)) *mMigrationContextMockShare {
	if mmShare.mock.inspectFuncShare != nil {
		mmShare.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.Share")
	}

	mmShare.mock.inspectFuncShare = f

	return mmShare
}

// Return sets up results that will be returned by MigrationContext.Share
func (mmShare *mMigrationContextMockShare) Return(s1 SharedDataLink) *MigrationContextMock {
	if mmShare.mock.funcShare != nil {
		mmShare.mock.t.Fatalf("MigrationContextMock.Share mock is already set by Set")
	}

	if mmShare.defaultExpectation == nil {
		mmShare.defaultExpectation = &MigrationContextMockShareExpectation{mock: mmShare.mock}
	}
	mmShare.defaultExpectation.results = &MigrationContextMockShareResults{s1}
	return mmShare.mock
}

//Set uses given function f to mock the MigrationContext.Share method
func (mmShare *mMigrationContextMockShare) Set(f func(data interface{}, flags ShareDataFlags) (s1 SharedDataLink)) *MigrationContextMock {
	if mmShare.defaultExpectation != nil {
		mmShare.mock.t.Fatalf("Default expectation is already set for the MigrationContext.Share method")
	}

	if len(mmShare.expectations) > 0 {
		mmShare.mock.t.Fatalf("Some expectations are already set for the MigrationContext.Share method")
	}

	mmShare.mock.funcShare = f
	return mmShare.mock
}

// When sets expectation for the MigrationContext.Share which will trigger the result defined by the following
// Then helper
func (mmShare *mMigrationContextMockShare) When(data interface{}, flags ShareDataFlags) *MigrationContextMockShareExpectation {
	if mmShare.mock.funcShare != nil {
		mmShare.mock.t.Fatalf("MigrationContextMock.Share mock is already set by Set")
	}

	expectation := &MigrationContextMockShareExpectation{
		mock:   mmShare.mock,
		params: &MigrationContextMockShareParams{data, flags},
	}
	mmShare.expectations = append(mmShare.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.Share return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockShareExpectation) Then(s1 SharedDataLink) *MigrationContextMock {
	e.results = &MigrationContextMockShareResults{s1}
	return e.mock
}

// Share implements MigrationContext
func (mmShare *MigrationContextMock) Share(data interface{}, flags ShareDataFlags) (s1 SharedDataLink) {
	mm_atomic.AddUint64(&mmShare.beforeShareCounter, 1)
	defer mm_atomic.AddUint64(&mmShare.afterShareCounter, 1)

	if mmShare.inspectFuncShare != nil {
		mmShare.inspectFuncShare(data, flags)
	}

	mm_params := &MigrationContextMockShareParams{data, flags}

	// Record call args
	mmShare.ShareMock.mutex.Lock()
	mmShare.ShareMock.callArgs = append(mmShare.ShareMock.callArgs, mm_params)
	mmShare.ShareMock.mutex.Unlock()

	for _, e := range mmShare.ShareMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmShare.ShareMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShare.ShareMock.defaultExpectation.Counter, 1)
		mm_want := mmShare.ShareMock.defaultExpectation.params
		mm_got := MigrationContextMockShareParams{data, flags}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmShare.t.Errorf("MigrationContextMock.Share got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmShare.ShareMock.defaultExpectation.results
		if mm_results == nil {
			mmShare.t.Fatal("No results are set for the MigrationContextMock.Share")
		}
		return (*mm_results).s1
	}
	if mmShare.funcShare != nil {
		return mmShare.funcShare(data, flags)
	}
	mmShare.t.Fatalf("Unexpected call to MigrationContextMock.Share. %v %v", data, flags)
	return
}

// ShareAfterCounter returns a count of finished MigrationContextMock.Share invocations
func (mmShare *MigrationContextMock) ShareAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShare.afterShareCounter)
}

// ShareBeforeCounter returns a count of MigrationContextMock.Share invocations
func (mmShare *MigrationContextMock) ShareBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShare.beforeShareCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.Share.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmShare *mMigrationContextMockShare) Calls() []*MigrationContextMockShareParams {
	mmShare.mutex.RLock()

	argCopy := make([]*MigrationContextMockShareParams, len(mmShare.callArgs))
	copy(argCopy, mmShare.callArgs)

	mmShare.mutex.RUnlock()

	return argCopy
}

// MinimockShareDone returns true if the count of the Share invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockShareDone() bool {
	for _, e := range m.ShareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShareCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShare != nil && mm_atomic.LoadUint64(&m.afterShareCounter) < 1 {
		return false
	}
	return true
}

// MinimockShareInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockShareInspect() {
	for _, e := range m.ShareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.Share with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShareCounter) < 1 {
		if m.ShareMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.Share")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.Share with params: %#v", *m.ShareMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShare != nil && mm_atomic.LoadUint64(&m.afterShareCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.Share")
	}
}

type mMigrationContextMockSkipMultipleMigrations struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockSkipMultipleMigrationsExpectation
	expectations       []*MigrationContextMockSkipMultipleMigrationsExpectation
}

// MigrationContextMockSkipMultipleMigrationsExpectation specifies expectation struct of the MigrationContext.SkipMultipleMigrations
type MigrationContextMockSkipMultipleMigrationsExpectation struct {
	mock *MigrationContextMock

	Counter uint64
}

// Expect sets up expected params for MigrationContext.SkipMultipleMigrations
func (mmSkipMultipleMigrations *mMigrationContextMockSkipMultipleMigrations) Expect() *mMigrationContextMockSkipMultipleMigrations {
	if mmSkipMultipleMigrations.mock.funcSkipMultipleMigrations != nil {
		mmSkipMultipleMigrations.mock.t.Fatalf("MigrationContextMock.SkipMultipleMigrations mock is already set by Set")
	}

	if mmSkipMultipleMigrations.defaultExpectation == nil {
		mmSkipMultipleMigrations.defaultExpectation = &MigrationContextMockSkipMultipleMigrationsExpectation{}
	}

	return mmSkipMultipleMigrations
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.SkipMultipleMigrations
func (mmSkipMultipleMigrations *mMigrationContextMockSkipMultipleMigrations) Inspect(f func()) *mMigrationContextMockSkipMultipleMigrations {
	if mmSkipMultipleMigrations.mock.inspectFuncSkipMultipleMigrations != nil {
		mmSkipMultipleMigrations.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.SkipMultipleMigrations")
	}

	mmSkipMultipleMigrations.mock.inspectFuncSkipMultipleMigrations = f

	return mmSkipMultipleMigrations
}

// Return sets up results that will be returned by MigrationContext.SkipMultipleMigrations
func (mmSkipMultipleMigrations *mMigrationContextMockSkipMultipleMigrations) Return() *MigrationContextMock {
	if mmSkipMultipleMigrations.mock.funcSkipMultipleMigrations != nil {
		mmSkipMultipleMigrations.mock.t.Fatalf("MigrationContextMock.SkipMultipleMigrations mock is already set by Set")
	}

	if mmSkipMultipleMigrations.defaultExpectation == nil {
		mmSkipMultipleMigrations.defaultExpectation = &MigrationContextMockSkipMultipleMigrationsExpectation{mock: mmSkipMultipleMigrations.mock}
	}

	return mmSkipMultipleMigrations.mock
}

//Set uses given function f to mock the MigrationContext.SkipMultipleMigrations method
func (mmSkipMultipleMigrations *mMigrationContextMockSkipMultipleMigrations) Set(f func()) *MigrationContextMock {
	if mmSkipMultipleMigrations.defaultExpectation != nil {
		mmSkipMultipleMigrations.mock.t.Fatalf("Default expectation is already set for the MigrationContext.SkipMultipleMigrations method")
	}

	if len(mmSkipMultipleMigrations.expectations) > 0 {
		mmSkipMultipleMigrations.mock.t.Fatalf("Some expectations are already set for the MigrationContext.SkipMultipleMigrations method")
	}

	mmSkipMultipleMigrations.mock.funcSkipMultipleMigrations = f
	return mmSkipMultipleMigrations.mock
}

// SkipMultipleMigrations implements MigrationContext
func (mmSkipMultipleMigrations *MigrationContextMock) SkipMultipleMigrations() {
	mm_atomic.AddUint64(&mmSkipMultipleMigrations.beforeSkipMultipleMigrationsCounter, 1)
	defer mm_atomic.AddUint64(&mmSkipMultipleMigrations.afterSkipMultipleMigrationsCounter, 1)

	if mmSkipMultipleMigrations.inspectFuncSkipMultipleMigrations != nil {
		mmSkipMultipleMigrations.inspectFuncSkipMultipleMigrations()
	}

	if mmSkipMultipleMigrations.SkipMultipleMigrationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSkipMultipleMigrations.SkipMultipleMigrationsMock.defaultExpectation.Counter, 1)

		return

	}
	if mmSkipMultipleMigrations.funcSkipMultipleMigrations != nil {
		mmSkipMultipleMigrations.funcSkipMultipleMigrations()
		return
	}
	mmSkipMultipleMigrations.t.Fatalf("Unexpected call to MigrationContextMock.SkipMultipleMigrations.")

}

// SkipMultipleMigrationsAfterCounter returns a count of finished MigrationContextMock.SkipMultipleMigrations invocations
func (mmSkipMultipleMigrations *MigrationContextMock) SkipMultipleMigrationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSkipMultipleMigrations.afterSkipMultipleMigrationsCounter)
}

// SkipMultipleMigrationsBeforeCounter returns a count of MigrationContextMock.SkipMultipleMigrations invocations
func (mmSkipMultipleMigrations *MigrationContextMock) SkipMultipleMigrationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSkipMultipleMigrations.beforeSkipMultipleMigrationsCounter)
}

// MinimockSkipMultipleMigrationsDone returns true if the count of the SkipMultipleMigrations invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockSkipMultipleMigrationsDone() bool {
	for _, e := range m.SkipMultipleMigrationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SkipMultipleMigrationsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSkipMultipleMigrationsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSkipMultipleMigrations != nil && mm_atomic.LoadUint64(&m.afterSkipMultipleMigrationsCounter) < 1 {
		return false
	}
	return true
}

// MinimockSkipMultipleMigrationsInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockSkipMultipleMigrationsInspect() {
	for _, e := range m.SkipMultipleMigrationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MigrationContextMock.SkipMultipleMigrations")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SkipMultipleMigrationsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSkipMultipleMigrationsCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.SkipMultipleMigrations")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSkipMultipleMigrations != nil && mm_atomic.LoadUint64(&m.afterSkipMultipleMigrationsCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.SkipMultipleMigrations")
	}
}

type mMigrationContextMockSlotLink struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockSlotLinkExpectation
	expectations       []*MigrationContextMockSlotLinkExpectation
}

// MigrationContextMockSlotLinkExpectation specifies expectation struct of the MigrationContext.SlotLink
type MigrationContextMockSlotLinkExpectation struct {
	mock *MigrationContextMock

	results *MigrationContextMockSlotLinkResults
	Counter uint64
}

// MigrationContextMockSlotLinkResults contains results of the MigrationContext.SlotLink
type MigrationContextMockSlotLinkResults struct {
	s1 SlotLink
}

// Expect sets up expected params for MigrationContext.SlotLink
func (mmSlotLink *mMigrationContextMockSlotLink) Expect() *mMigrationContextMockSlotLink {
	if mmSlotLink.mock.funcSlotLink != nil {
		mmSlotLink.mock.t.Fatalf("MigrationContextMock.SlotLink mock is already set by Set")
	}

	if mmSlotLink.defaultExpectation == nil {
		mmSlotLink.defaultExpectation = &MigrationContextMockSlotLinkExpectation{}
	}

	return mmSlotLink
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.SlotLink
func (mmSlotLink *mMigrationContextMockSlotLink) Inspect(f func()) *mMigrationContextMockSlotLink {
	if mmSlotLink.mock.inspectFuncSlotLink != nil {
		mmSlotLink.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.SlotLink")
	}

	mmSlotLink.mock.inspectFuncSlotLink = f

	return mmSlotLink
}

// Return sets up results that will be returned by MigrationContext.SlotLink
func (mmSlotLink *mMigrationContextMockSlotLink) Return(s1 SlotLink) *MigrationContextMock {
	if mmSlotLink.mock.funcSlotLink != nil {
		mmSlotLink.mock.t.Fatalf("MigrationContextMock.SlotLink mock is already set by Set")
	}

	if mmSlotLink.defaultExpectation == nil {
		mmSlotLink.defaultExpectation = &MigrationContextMockSlotLinkExpectation{mock: mmSlotLink.mock}
	}
	mmSlotLink.defaultExpectation.results = &MigrationContextMockSlotLinkResults{s1}
	return mmSlotLink.mock
}

//Set uses given function f to mock the MigrationContext.SlotLink method
func (mmSlotLink *mMigrationContextMockSlotLink) Set(f func() (s1 SlotLink)) *MigrationContextMock {
	if mmSlotLink.defaultExpectation != nil {
		mmSlotLink.mock.t.Fatalf("Default expectation is already set for the MigrationContext.SlotLink method")
	}

	if len(mmSlotLink.expectations) > 0 {
		mmSlotLink.mock.t.Fatalf("Some expectations are already set for the MigrationContext.SlotLink method")
	}

	mmSlotLink.mock.funcSlotLink = f
	return mmSlotLink.mock
}

// SlotLink implements MigrationContext
func (mmSlotLink *MigrationContextMock) SlotLink() (s1 SlotLink) {
	mm_atomic.AddUint64(&mmSlotLink.beforeSlotLinkCounter, 1)
	defer mm_atomic.AddUint64(&mmSlotLink.afterSlotLinkCounter, 1)

	if mmSlotLink.inspectFuncSlotLink != nil {
		mmSlotLink.inspectFuncSlotLink()
	}

	if mmSlotLink.SlotLinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSlotLink.SlotLinkMock.defaultExpectation.Counter, 1)

		mm_results := mmSlotLink.SlotLinkMock.defaultExpectation.results
		if mm_results == nil {
			mmSlotLink.t.Fatal("No results are set for the MigrationContextMock.SlotLink")
		}
		return (*mm_results).s1
	}
	if mmSlotLink.funcSlotLink != nil {
		return mmSlotLink.funcSlotLink()
	}
	mmSlotLink.t.Fatalf("Unexpected call to MigrationContextMock.SlotLink.")
	return
}

// SlotLinkAfterCounter returns a count of finished MigrationContextMock.SlotLink invocations
func (mmSlotLink *MigrationContextMock) SlotLinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSlotLink.afterSlotLinkCounter)
}

// SlotLinkBeforeCounter returns a count of MigrationContextMock.SlotLink invocations
func (mmSlotLink *MigrationContextMock) SlotLinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSlotLink.beforeSlotLinkCounter)
}

// MinimockSlotLinkDone returns true if the count of the SlotLink invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockSlotLinkDone() bool {
	for _, e := range m.SlotLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SlotLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSlotLinkCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSlotLink != nil && mm_atomic.LoadUint64(&m.afterSlotLinkCounter) < 1 {
		return false
	}
	return true
}

// MinimockSlotLinkInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockSlotLinkInspect() {
	for _, e := range m.SlotLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MigrationContextMock.SlotLink")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SlotLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSlotLinkCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.SlotLink")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSlotLink != nil && mm_atomic.LoadUint64(&m.afterSlotLinkCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.SlotLink")
	}
}

type mMigrationContextMockStay struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockStayExpectation
	expectations       []*MigrationContextMockStayExpectation
}

// MigrationContextMockStayExpectation specifies expectation struct of the MigrationContext.Stay
type MigrationContextMockStayExpectation struct {
	mock *MigrationContextMock

	results *MigrationContextMockStayResults
	Counter uint64
}

// MigrationContextMockStayResults contains results of the MigrationContext.Stay
type MigrationContextMockStayResults struct {
	s1 StateUpdate
}

// Expect sets up expected params for MigrationContext.Stay
func (mmStay *mMigrationContextMockStay) Expect() *mMigrationContextMockStay {
	if mmStay.mock.funcStay != nil {
		mmStay.mock.t.Fatalf("MigrationContextMock.Stay mock is already set by Set")
	}

	if mmStay.defaultExpectation == nil {
		mmStay.defaultExpectation = &MigrationContextMockStayExpectation{}
	}

	return mmStay
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.Stay
func (mmStay *mMigrationContextMockStay) Inspect(f func()) *mMigrationContextMockStay {
	if mmStay.mock.inspectFuncStay != nil {
		mmStay.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.Stay")
	}

	mmStay.mock.inspectFuncStay = f

	return mmStay
}

// Return sets up results that will be returned by MigrationContext.Stay
func (mmStay *mMigrationContextMockStay) Return(s1 StateUpdate) *MigrationContextMock {
	if mmStay.mock.funcStay != nil {
		mmStay.mock.t.Fatalf("MigrationContextMock.Stay mock is already set by Set")
	}

	if mmStay.defaultExpectation == nil {
		mmStay.defaultExpectation = &MigrationContextMockStayExpectation{mock: mmStay.mock}
	}
	mmStay.defaultExpectation.results = &MigrationContextMockStayResults{s1}
	return mmStay.mock
}

//Set uses given function f to mock the MigrationContext.Stay method
func (mmStay *mMigrationContextMockStay) Set(f func() (s1 StateUpdate)) *MigrationContextMock {
	if mmStay.defaultExpectation != nil {
		mmStay.mock.t.Fatalf("Default expectation is already set for the MigrationContext.Stay method")
	}

	if len(mmStay.expectations) > 0 {
		mmStay.mock.t.Fatalf("Some expectations are already set for the MigrationContext.Stay method")
	}

	mmStay.mock.funcStay = f
	return mmStay.mock
}

// Stay implements MigrationContext
func (mmStay *MigrationContextMock) Stay() (s1 StateUpdate) {
	mm_atomic.AddUint64(&mmStay.beforeStayCounter, 1)
	defer mm_atomic.AddUint64(&mmStay.afterStayCounter, 1)

	if mmStay.inspectFuncStay != nil {
		mmStay.inspectFuncStay()
	}

	if mmStay.StayMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStay.StayMock.defaultExpectation.Counter, 1)

		mm_results := mmStay.StayMock.defaultExpectation.results
		if mm_results == nil {
			mmStay.t.Fatal("No results are set for the MigrationContextMock.Stay")
		}
		return (*mm_results).s1
	}
	if mmStay.funcStay != nil {
		return mmStay.funcStay()
	}
	mmStay.t.Fatalf("Unexpected call to MigrationContextMock.Stay.")
	return
}

// StayAfterCounter returns a count of finished MigrationContextMock.Stay invocations
func (mmStay *MigrationContextMock) StayAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStay.afterStayCounter)
}

// StayBeforeCounter returns a count of MigrationContextMock.Stay invocations
func (mmStay *MigrationContextMock) StayBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStay.beforeStayCounter)
}

// MinimockStayDone returns true if the count of the Stay invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockStayDone() bool {
	for _, e := range m.StayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StayMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStayCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStay != nil && mm_atomic.LoadUint64(&m.afterStayCounter) < 1 {
		return false
	}
	return true
}

// MinimockStayInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockStayInspect() {
	for _, e := range m.StayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MigrationContextMock.Stay")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StayMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStayCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.Stay")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStay != nil && mm_atomic.LoadUint64(&m.afterStayCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.Stay")
	}
}

type mMigrationContextMockStop struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockStopExpectation
	expectations       []*MigrationContextMockStopExpectation
}

// MigrationContextMockStopExpectation specifies expectation struct of the MigrationContext.Stop
type MigrationContextMockStopExpectation struct {
	mock *MigrationContextMock

	results *MigrationContextMockStopResults
	Counter uint64
}

// MigrationContextMockStopResults contains results of the MigrationContext.Stop
type MigrationContextMockStopResults struct {
	s1 StateUpdate
}

// Expect sets up expected params for MigrationContext.Stop
func (mmStop *mMigrationContextMockStop) Expect() *mMigrationContextMockStop {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("MigrationContextMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &MigrationContextMockStopExpectation{}
	}

	return mmStop
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.Stop
func (mmStop *mMigrationContextMockStop) Inspect(f func()) *mMigrationContextMockStop {
	if mmStop.mock.inspectFuncStop != nil {
		mmStop.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.Stop")
	}

	mmStop.mock.inspectFuncStop = f

	return mmStop
}

// Return sets up results that will be returned by MigrationContext.Stop
func (mmStop *mMigrationContextMockStop) Return(s1 StateUpdate) *MigrationContextMock {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("MigrationContextMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &MigrationContextMockStopExpectation{mock: mmStop.mock}
	}
	mmStop.defaultExpectation.results = &MigrationContextMockStopResults{s1}
	return mmStop.mock
}

//Set uses given function f to mock the MigrationContext.Stop method
func (mmStop *mMigrationContextMockStop) Set(f func() (s1 StateUpdate)) *MigrationContextMock {
	if mmStop.defaultExpectation != nil {
		mmStop.mock.t.Fatalf("Default expectation is already set for the MigrationContext.Stop method")
	}

	if len(mmStop.expectations) > 0 {
		mmStop.mock.t.Fatalf("Some expectations are already set for the MigrationContext.Stop method")
	}

	mmStop.mock.funcStop = f
	return mmStop.mock
}

// Stop implements MigrationContext
func (mmStop *MigrationContextMock) Stop() (s1 StateUpdate) {
	mm_atomic.AddUint64(&mmStop.beforeStopCounter, 1)
	defer mm_atomic.AddUint64(&mmStop.afterStopCounter, 1)

	if mmStop.inspectFuncStop != nil {
		mmStop.inspectFuncStop()
	}

	if mmStop.StopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStop.StopMock.defaultExpectation.Counter, 1)

		mm_results := mmStop.StopMock.defaultExpectation.results
		if mm_results == nil {
			mmStop.t.Fatal("No results are set for the MigrationContextMock.Stop")
		}
		return (*mm_results).s1
	}
	if mmStop.funcStop != nil {
		return mmStop.funcStop()
	}
	mmStop.t.Fatalf("Unexpected call to MigrationContextMock.Stop.")
	return
}

// StopAfterCounter returns a count of finished MigrationContextMock.Stop invocations
func (mmStop *MigrationContextMock) StopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.afterStopCounter)
}

// StopBeforeCounter returns a count of MigrationContextMock.Stop invocations
func (mmStop *MigrationContextMock) StopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.beforeStopCounter)
}

// MinimockStopDone returns true if the count of the Stop invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockStopDone() bool {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	return true
}

// MinimockStopInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockStopInspect() {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MigrationContextMock.Stop")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.Stop")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.Stop")
	}
}

type mMigrationContextMockUnpublish struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockUnpublishExpectation
	expectations       []*MigrationContextMockUnpublishExpectation

	callArgs []*MigrationContextMockUnpublishParams
	mutex    sync.RWMutex
}

// MigrationContextMockUnpublishExpectation specifies expectation struct of the MigrationContext.Unpublish
type MigrationContextMockUnpublishExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockUnpublishParams
	results *MigrationContextMockUnpublishResults
	Counter uint64
}

// MigrationContextMockUnpublishParams contains parameters of the MigrationContext.Unpublish
type MigrationContextMockUnpublishParams struct {
	key interface{}
}

// MigrationContextMockUnpublishResults contains results of the MigrationContext.Unpublish
type MigrationContextMockUnpublishResults struct {
	b1 bool
}

// Expect sets up expected params for MigrationContext.Unpublish
func (mmUnpublish *mMigrationContextMockUnpublish) Expect(key interface{}) *mMigrationContextMockUnpublish {
	if mmUnpublish.mock.funcUnpublish != nil {
		mmUnpublish.mock.t.Fatalf("MigrationContextMock.Unpublish mock is already set by Set")
	}

	if mmUnpublish.defaultExpectation == nil {
		mmUnpublish.defaultExpectation = &MigrationContextMockUnpublishExpectation{}
	}

	mmUnpublish.defaultExpectation.params = &MigrationContextMockUnpublishParams{key}
	for _, e := range mmUnpublish.expectations {
		if minimock.Equal(e.params, mmUnpublish.defaultExpectation.params) {
			mmUnpublish.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnpublish.defaultExpectation.params)
		}
	}

	return mmUnpublish
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.Unpublish
func (mmUnpublish *mMigrationContextMockUnpublish) Inspect(f func(key interface{})) *mMigrationContextMockUnpublish {
	if mmUnpublish.mock.inspectFuncUnpublish != nil {
		mmUnpublish.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.Unpublish")
	}

	mmUnpublish.mock.inspectFuncUnpublish = f

	return mmUnpublish
}

// Return sets up results that will be returned by MigrationContext.Unpublish
func (mmUnpublish *mMigrationContextMockUnpublish) Return(b1 bool) *MigrationContextMock {
	if mmUnpublish.mock.funcUnpublish != nil {
		mmUnpublish.mock.t.Fatalf("MigrationContextMock.Unpublish mock is already set by Set")
	}

	if mmUnpublish.defaultExpectation == nil {
		mmUnpublish.defaultExpectation = &MigrationContextMockUnpublishExpectation{mock: mmUnpublish.mock}
	}
	mmUnpublish.defaultExpectation.results = &MigrationContextMockUnpublishResults{b1}
	return mmUnpublish.mock
}

//Set uses given function f to mock the MigrationContext.Unpublish method
func (mmUnpublish *mMigrationContextMockUnpublish) Set(f func(key interface{}) (b1 bool)) *MigrationContextMock {
	if mmUnpublish.defaultExpectation != nil {
		mmUnpublish.mock.t.Fatalf("Default expectation is already set for the MigrationContext.Unpublish method")
	}

	if len(mmUnpublish.expectations) > 0 {
		mmUnpublish.mock.t.Fatalf("Some expectations are already set for the MigrationContext.Unpublish method")
	}

	mmUnpublish.mock.funcUnpublish = f
	return mmUnpublish.mock
}

// When sets expectation for the MigrationContext.Unpublish which will trigger the result defined by the following
// Then helper
func (mmUnpublish *mMigrationContextMockUnpublish) When(key interface{}) *MigrationContextMockUnpublishExpectation {
	if mmUnpublish.mock.funcUnpublish != nil {
		mmUnpublish.mock.t.Fatalf("MigrationContextMock.Unpublish mock is already set by Set")
	}

	expectation := &MigrationContextMockUnpublishExpectation{
		mock:   mmUnpublish.mock,
		params: &MigrationContextMockUnpublishParams{key},
	}
	mmUnpublish.expectations = append(mmUnpublish.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.Unpublish return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockUnpublishExpectation) Then(b1 bool) *MigrationContextMock {
	e.results = &MigrationContextMockUnpublishResults{b1}
	return e.mock
}

// Unpublish implements MigrationContext
func (mmUnpublish *MigrationContextMock) Unpublish(key interface{}) (b1 bool) {
	mm_atomic.AddUint64(&mmUnpublish.beforeUnpublishCounter, 1)
	defer mm_atomic.AddUint64(&mmUnpublish.afterUnpublishCounter, 1)

	if mmUnpublish.inspectFuncUnpublish != nil {
		mmUnpublish.inspectFuncUnpublish(key)
	}

	mm_params := &MigrationContextMockUnpublishParams{key}

	// Record call args
	mmUnpublish.UnpublishMock.mutex.Lock()
	mmUnpublish.UnpublishMock.callArgs = append(mmUnpublish.UnpublishMock.callArgs, mm_params)
	mmUnpublish.UnpublishMock.mutex.Unlock()

	for _, e := range mmUnpublish.UnpublishMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmUnpublish.UnpublishMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnpublish.UnpublishMock.defaultExpectation.Counter, 1)
		mm_want := mmUnpublish.UnpublishMock.defaultExpectation.params
		mm_got := MigrationContextMockUnpublishParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnpublish.t.Errorf("MigrationContextMock.Unpublish got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnpublish.UnpublishMock.defaultExpectation.results
		if mm_results == nil {
			mmUnpublish.t.Fatal("No results are set for the MigrationContextMock.Unpublish")
		}
		return (*mm_results).b1
	}
	if mmUnpublish.funcUnpublish != nil {
		return mmUnpublish.funcUnpublish(key)
	}
	mmUnpublish.t.Fatalf("Unexpected call to MigrationContextMock.Unpublish. %v", key)
	return
}

// UnpublishAfterCounter returns a count of finished MigrationContextMock.Unpublish invocations
func (mmUnpublish *MigrationContextMock) UnpublishAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpublish.afterUnpublishCounter)
}

// UnpublishBeforeCounter returns a count of MigrationContextMock.Unpublish invocations
func (mmUnpublish *MigrationContextMock) UnpublishBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpublish.beforeUnpublishCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.Unpublish.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnpublish *mMigrationContextMockUnpublish) Calls() []*MigrationContextMockUnpublishParams {
	mmUnpublish.mutex.RLock()

	argCopy := make([]*MigrationContextMockUnpublishParams, len(mmUnpublish.callArgs))
	copy(argCopy, mmUnpublish.callArgs)

	mmUnpublish.mutex.RUnlock()

	return argCopy
}

// MinimockUnpublishDone returns true if the count of the Unpublish invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockUnpublishDone() bool {
	for _, e := range m.UnpublishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpublishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpublishCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpublish != nil && mm_atomic.LoadUint64(&m.afterUnpublishCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnpublishInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockUnpublishInspect() {
	for _, e := range m.UnpublishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.Unpublish with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpublishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpublishCounter) < 1 {
		if m.UnpublishMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.Unpublish")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.Unpublish with params: %#v", *m.UnpublishMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpublish != nil && mm_atomic.LoadUint64(&m.afterUnpublishCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.Unpublish")
	}
}

type mMigrationContextMockUnpublishAll struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockUnpublishAllExpectation
	expectations       []*MigrationContextMockUnpublishAllExpectation
}

// MigrationContextMockUnpublishAllExpectation specifies expectation struct of the MigrationContext.UnpublishAll
type MigrationContextMockUnpublishAllExpectation struct {
	mock *MigrationContextMock

	Counter uint64
}

// Expect sets up expected params for MigrationContext.UnpublishAll
func (mmUnpublishAll *mMigrationContextMockUnpublishAll) Expect() *mMigrationContextMockUnpublishAll {
	if mmUnpublishAll.mock.funcUnpublishAll != nil {
		mmUnpublishAll.mock.t.Fatalf("MigrationContextMock.UnpublishAll mock is already set by Set")
	}

	if mmUnpublishAll.defaultExpectation == nil {
		mmUnpublishAll.defaultExpectation = &MigrationContextMockUnpublishAllExpectation{}
	}

	return mmUnpublishAll
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.UnpublishAll
func (mmUnpublishAll *mMigrationContextMockUnpublishAll) Inspect(f func()) *mMigrationContextMockUnpublishAll {
	if mmUnpublishAll.mock.inspectFuncUnpublishAll != nil {
		mmUnpublishAll.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.UnpublishAll")
	}

	mmUnpublishAll.mock.inspectFuncUnpublishAll = f

	return mmUnpublishAll
}

// Return sets up results that will be returned by MigrationContext.UnpublishAll
func (mmUnpublishAll *mMigrationContextMockUnpublishAll) Return() *MigrationContextMock {
	if mmUnpublishAll.mock.funcUnpublishAll != nil {
		mmUnpublishAll.mock.t.Fatalf("MigrationContextMock.UnpublishAll mock is already set by Set")
	}

	if mmUnpublishAll.defaultExpectation == nil {
		mmUnpublishAll.defaultExpectation = &MigrationContextMockUnpublishAllExpectation{mock: mmUnpublishAll.mock}
	}

	return mmUnpublishAll.mock
}

//Set uses given function f to mock the MigrationContext.UnpublishAll method
func (mmUnpublishAll *mMigrationContextMockUnpublishAll) Set(f func()) *MigrationContextMock {
	if mmUnpublishAll.defaultExpectation != nil {
		mmUnpublishAll.mock.t.Fatalf("Default expectation is already set for the MigrationContext.UnpublishAll method")
	}

	if len(mmUnpublishAll.expectations) > 0 {
		mmUnpublishAll.mock.t.Fatalf("Some expectations are already set for the MigrationContext.UnpublishAll method")
	}

	mmUnpublishAll.mock.funcUnpublishAll = f
	return mmUnpublishAll.mock
}

// UnpublishAll implements MigrationContext
func (mmUnpublishAll *MigrationContextMock) UnpublishAll() {
	mm_atomic.AddUint64(&mmUnpublishAll.beforeUnpublishAllCounter, 1)
	defer mm_atomic.AddUint64(&mmUnpublishAll.afterUnpublishAllCounter, 1)

	if mmUnpublishAll.inspectFuncUnpublishAll != nil {
		mmUnpublishAll.inspectFuncUnpublishAll()
	}

	if mmUnpublishAll.UnpublishAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnpublishAll.UnpublishAllMock.defaultExpectation.Counter, 1)

		return

	}
	if mmUnpublishAll.funcUnpublishAll != nil {
		mmUnpublishAll.funcUnpublishAll()
		return
	}
	mmUnpublishAll.t.Fatalf("Unexpected call to MigrationContextMock.UnpublishAll.")

}

// UnpublishAllAfterCounter returns a count of finished MigrationContextMock.UnpublishAll invocations
func (mmUnpublishAll *MigrationContextMock) UnpublishAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpublishAll.afterUnpublishAllCounter)
}

// UnpublishAllBeforeCounter returns a count of MigrationContextMock.UnpublishAll invocations
func (mmUnpublishAll *MigrationContextMock) UnpublishAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpublishAll.beforeUnpublishAllCounter)
}

// MinimockUnpublishAllDone returns true if the count of the UnpublishAll invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockUnpublishAllDone() bool {
	for _, e := range m.UnpublishAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpublishAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpublishAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpublishAll != nil && mm_atomic.LoadUint64(&m.afterUnpublishAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnpublishAllInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockUnpublishAllInspect() {
	for _, e := range m.UnpublishAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MigrationContextMock.UnpublishAll")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpublishAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpublishAllCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.UnpublishAll")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpublishAll != nil && mm_atomic.LoadUint64(&m.afterUnpublishAllCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.UnpublishAll")
	}
}

type mMigrationContextMockUnpublishGlobalAlias struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockUnpublishGlobalAliasExpectation
	expectations       []*MigrationContextMockUnpublishGlobalAliasExpectation

	callArgs []*MigrationContextMockUnpublishGlobalAliasParams
	mutex    sync.RWMutex
}

// MigrationContextMockUnpublishGlobalAliasExpectation specifies expectation struct of the MigrationContext.UnpublishGlobalAlias
type MigrationContextMockUnpublishGlobalAliasExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockUnpublishGlobalAliasParams
	results *MigrationContextMockUnpublishGlobalAliasResults
	Counter uint64
}

// MigrationContextMockUnpublishGlobalAliasParams contains parameters of the MigrationContext.UnpublishGlobalAlias
type MigrationContextMockUnpublishGlobalAliasParams struct {
	key interface{}
}

// MigrationContextMockUnpublishGlobalAliasResults contains results of the MigrationContext.UnpublishGlobalAlias
type MigrationContextMockUnpublishGlobalAliasResults struct {
	b1 bool
}

// Expect sets up expected params for MigrationContext.UnpublishGlobalAlias
func (mmUnpublishGlobalAlias *mMigrationContextMockUnpublishGlobalAlias) Expect(key interface{}) *mMigrationContextMockUnpublishGlobalAlias {
	if mmUnpublishGlobalAlias.mock.funcUnpublishGlobalAlias != nil {
		mmUnpublishGlobalAlias.mock.t.Fatalf("MigrationContextMock.UnpublishGlobalAlias mock is already set by Set")
	}

	if mmUnpublishGlobalAlias.defaultExpectation == nil {
		mmUnpublishGlobalAlias.defaultExpectation = &MigrationContextMockUnpublishGlobalAliasExpectation{}
	}

	mmUnpublishGlobalAlias.defaultExpectation.params = &MigrationContextMockUnpublishGlobalAliasParams{key}
	for _, e := range mmUnpublishGlobalAlias.expectations {
		if minimock.Equal(e.params, mmUnpublishGlobalAlias.defaultExpectation.params) {
			mmUnpublishGlobalAlias.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnpublishGlobalAlias.defaultExpectation.params)
		}
	}

	return mmUnpublishGlobalAlias
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.UnpublishGlobalAlias
func (mmUnpublishGlobalAlias *mMigrationContextMockUnpublishGlobalAlias) Inspect(f func(key interface{})) *mMigrationContextMockUnpublishGlobalAlias {
	if mmUnpublishGlobalAlias.mock.inspectFuncUnpublishGlobalAlias != nil {
		mmUnpublishGlobalAlias.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.UnpublishGlobalAlias")
	}

	mmUnpublishGlobalAlias.mock.inspectFuncUnpublishGlobalAlias = f

	return mmUnpublishGlobalAlias
}

// Return sets up results that will be returned by MigrationContext.UnpublishGlobalAlias
func (mmUnpublishGlobalAlias *mMigrationContextMockUnpublishGlobalAlias) Return(b1 bool) *MigrationContextMock {
	if mmUnpublishGlobalAlias.mock.funcUnpublishGlobalAlias != nil {
		mmUnpublishGlobalAlias.mock.t.Fatalf("MigrationContextMock.UnpublishGlobalAlias mock is already set by Set")
	}

	if mmUnpublishGlobalAlias.defaultExpectation == nil {
		mmUnpublishGlobalAlias.defaultExpectation = &MigrationContextMockUnpublishGlobalAliasExpectation{mock: mmUnpublishGlobalAlias.mock}
	}
	mmUnpublishGlobalAlias.defaultExpectation.results = &MigrationContextMockUnpublishGlobalAliasResults{b1}
	return mmUnpublishGlobalAlias.mock
}

//Set uses given function f to mock the MigrationContext.UnpublishGlobalAlias method
func (mmUnpublishGlobalAlias *mMigrationContextMockUnpublishGlobalAlias) Set(f func(key interface{}) (b1 bool)) *MigrationContextMock {
	if mmUnpublishGlobalAlias.defaultExpectation != nil {
		mmUnpublishGlobalAlias.mock.t.Fatalf("Default expectation is already set for the MigrationContext.UnpublishGlobalAlias method")
	}

	if len(mmUnpublishGlobalAlias.expectations) > 0 {
		mmUnpublishGlobalAlias.mock.t.Fatalf("Some expectations are already set for the MigrationContext.UnpublishGlobalAlias method")
	}

	mmUnpublishGlobalAlias.mock.funcUnpublishGlobalAlias = f
	return mmUnpublishGlobalAlias.mock
}

// When sets expectation for the MigrationContext.UnpublishGlobalAlias which will trigger the result defined by the following
// Then helper
func (mmUnpublishGlobalAlias *mMigrationContextMockUnpublishGlobalAlias) When(key interface{}) *MigrationContextMockUnpublishGlobalAliasExpectation {
	if mmUnpublishGlobalAlias.mock.funcUnpublishGlobalAlias != nil {
		mmUnpublishGlobalAlias.mock.t.Fatalf("MigrationContextMock.UnpublishGlobalAlias mock is already set by Set")
	}

	expectation := &MigrationContextMockUnpublishGlobalAliasExpectation{
		mock:   mmUnpublishGlobalAlias.mock,
		params: &MigrationContextMockUnpublishGlobalAliasParams{key},
	}
	mmUnpublishGlobalAlias.expectations = append(mmUnpublishGlobalAlias.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.UnpublishGlobalAlias return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockUnpublishGlobalAliasExpectation) Then(b1 bool) *MigrationContextMock {
	e.results = &MigrationContextMockUnpublishGlobalAliasResults{b1}
	return e.mock
}

// UnpublishGlobalAlias implements MigrationContext
func (mmUnpublishGlobalAlias *MigrationContextMock) UnpublishGlobalAlias(key interface{}) (b1 bool) {
	mm_atomic.AddUint64(&mmUnpublishGlobalAlias.beforeUnpublishGlobalAliasCounter, 1)
	defer mm_atomic.AddUint64(&mmUnpublishGlobalAlias.afterUnpublishGlobalAliasCounter, 1)

	if mmUnpublishGlobalAlias.inspectFuncUnpublishGlobalAlias != nil {
		mmUnpublishGlobalAlias.inspectFuncUnpublishGlobalAlias(key)
	}

	mm_params := &MigrationContextMockUnpublishGlobalAliasParams{key}

	// Record call args
	mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.mutex.Lock()
	mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.callArgs = append(mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.callArgs, mm_params)
	mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.mutex.Unlock()

	for _, e := range mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.defaultExpectation.Counter, 1)
		mm_want := mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.defaultExpectation.params
		mm_got := MigrationContextMockUnpublishGlobalAliasParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnpublishGlobalAlias.t.Errorf("MigrationContextMock.UnpublishGlobalAlias got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnpublishGlobalAlias.UnpublishGlobalAliasMock.defaultExpectation.results
		if mm_results == nil {
			mmUnpublishGlobalAlias.t.Fatal("No results are set for the MigrationContextMock.UnpublishGlobalAlias")
		}
		return (*mm_results).b1
	}
	if mmUnpublishGlobalAlias.funcUnpublishGlobalAlias != nil {
		return mmUnpublishGlobalAlias.funcUnpublishGlobalAlias(key)
	}
	mmUnpublishGlobalAlias.t.Fatalf("Unexpected call to MigrationContextMock.UnpublishGlobalAlias. %v", key)
	return
}

// UnpublishGlobalAliasAfterCounter returns a count of finished MigrationContextMock.UnpublishGlobalAlias invocations
func (mmUnpublishGlobalAlias *MigrationContextMock) UnpublishGlobalAliasAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpublishGlobalAlias.afterUnpublishGlobalAliasCounter)
}

// UnpublishGlobalAliasBeforeCounter returns a count of MigrationContextMock.UnpublishGlobalAlias invocations
func (mmUnpublishGlobalAlias *MigrationContextMock) UnpublishGlobalAliasBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnpublishGlobalAlias.beforeUnpublishGlobalAliasCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.UnpublishGlobalAlias.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnpublishGlobalAlias *mMigrationContextMockUnpublishGlobalAlias) Calls() []*MigrationContextMockUnpublishGlobalAliasParams {
	mmUnpublishGlobalAlias.mutex.RLock()

	argCopy := make([]*MigrationContextMockUnpublishGlobalAliasParams, len(mmUnpublishGlobalAlias.callArgs))
	copy(argCopy, mmUnpublishGlobalAlias.callArgs)

	mmUnpublishGlobalAlias.mutex.RUnlock()

	return argCopy
}

// MinimockUnpublishGlobalAliasDone returns true if the count of the UnpublishGlobalAlias invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockUnpublishGlobalAliasDone() bool {
	for _, e := range m.UnpublishGlobalAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpublishGlobalAliasMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpublishGlobalAliasCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpublishGlobalAlias != nil && mm_atomic.LoadUint64(&m.afterUnpublishGlobalAliasCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnpublishGlobalAliasInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockUnpublishGlobalAliasInspect() {
	for _, e := range m.UnpublishGlobalAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.UnpublishGlobalAlias with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnpublishGlobalAliasMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnpublishGlobalAliasCounter) < 1 {
		if m.UnpublishGlobalAliasMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.UnpublishGlobalAlias")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.UnpublishGlobalAlias with params: %#v", *m.UnpublishGlobalAliasMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnpublishGlobalAlias != nil && mm_atomic.LoadUint64(&m.afterUnpublishGlobalAliasCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.UnpublishGlobalAlias")
	}
}

type mMigrationContextMockUnshare struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockUnshareExpectation
	expectations       []*MigrationContextMockUnshareExpectation

	callArgs []*MigrationContextMockUnshareParams
	mutex    sync.RWMutex
}

// MigrationContextMockUnshareExpectation specifies expectation struct of the MigrationContext.Unshare
type MigrationContextMockUnshareExpectation struct {
	mock    *MigrationContextMock
	params  *MigrationContextMockUnshareParams
	results *MigrationContextMockUnshareResults
	Counter uint64
}

// MigrationContextMockUnshareParams contains parameters of the MigrationContext.Unshare
type MigrationContextMockUnshareParams struct {
	s1 SharedDataLink
}

// MigrationContextMockUnshareResults contains results of the MigrationContext.Unshare
type MigrationContextMockUnshareResults struct {
	b1 bool
}

// Expect sets up expected params for MigrationContext.Unshare
func (mmUnshare *mMigrationContextMockUnshare) Expect(s1 SharedDataLink) *mMigrationContextMockUnshare {
	if mmUnshare.mock.funcUnshare != nil {
		mmUnshare.mock.t.Fatalf("MigrationContextMock.Unshare mock is already set by Set")
	}

	if mmUnshare.defaultExpectation == nil {
		mmUnshare.defaultExpectation = &MigrationContextMockUnshareExpectation{}
	}

	mmUnshare.defaultExpectation.params = &MigrationContextMockUnshareParams{s1}
	for _, e := range mmUnshare.expectations {
		if minimock.Equal(e.params, mmUnshare.defaultExpectation.params) {
			mmUnshare.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnshare.defaultExpectation.params)
		}
	}

	return mmUnshare
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.Unshare
func (mmUnshare *mMigrationContextMockUnshare) Inspect(f func(s1 SharedDataLink)) *mMigrationContextMockUnshare {
	if mmUnshare.mock.inspectFuncUnshare != nil {
		mmUnshare.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.Unshare")
	}

	mmUnshare.mock.inspectFuncUnshare = f

	return mmUnshare
}

// Return sets up results that will be returned by MigrationContext.Unshare
func (mmUnshare *mMigrationContextMockUnshare) Return(b1 bool) *MigrationContextMock {
	if mmUnshare.mock.funcUnshare != nil {
		mmUnshare.mock.t.Fatalf("MigrationContextMock.Unshare mock is already set by Set")
	}

	if mmUnshare.defaultExpectation == nil {
		mmUnshare.defaultExpectation = &MigrationContextMockUnshareExpectation{mock: mmUnshare.mock}
	}
	mmUnshare.defaultExpectation.results = &MigrationContextMockUnshareResults{b1}
	return mmUnshare.mock
}

//Set uses given function f to mock the MigrationContext.Unshare method
func (mmUnshare *mMigrationContextMockUnshare) Set(f func(s1 SharedDataLink) (b1 bool)) *MigrationContextMock {
	if mmUnshare.defaultExpectation != nil {
		mmUnshare.mock.t.Fatalf("Default expectation is already set for the MigrationContext.Unshare method")
	}

	if len(mmUnshare.expectations) > 0 {
		mmUnshare.mock.t.Fatalf("Some expectations are already set for the MigrationContext.Unshare method")
	}

	mmUnshare.mock.funcUnshare = f
	return mmUnshare.mock
}

// When sets expectation for the MigrationContext.Unshare which will trigger the result defined by the following
// Then helper
func (mmUnshare *mMigrationContextMockUnshare) When(s1 SharedDataLink) *MigrationContextMockUnshareExpectation {
	if mmUnshare.mock.funcUnshare != nil {
		mmUnshare.mock.t.Fatalf("MigrationContextMock.Unshare mock is already set by Set")
	}

	expectation := &MigrationContextMockUnshareExpectation{
		mock:   mmUnshare.mock,
		params: &MigrationContextMockUnshareParams{s1},
	}
	mmUnshare.expectations = append(mmUnshare.expectations, expectation)
	return expectation
}

// Then sets up MigrationContext.Unshare return parameters for the expectation previously defined by the When method
func (e *MigrationContextMockUnshareExpectation) Then(b1 bool) *MigrationContextMock {
	e.results = &MigrationContextMockUnshareResults{b1}
	return e.mock
}

// Unshare implements MigrationContext
func (mmUnshare *MigrationContextMock) Unshare(s1 SharedDataLink) (b1 bool) {
	mm_atomic.AddUint64(&mmUnshare.beforeUnshareCounter, 1)
	defer mm_atomic.AddUint64(&mmUnshare.afterUnshareCounter, 1)

	if mmUnshare.inspectFuncUnshare != nil {
		mmUnshare.inspectFuncUnshare(s1)
	}

	mm_params := &MigrationContextMockUnshareParams{s1}

	// Record call args
	mmUnshare.UnshareMock.mutex.Lock()
	mmUnshare.UnshareMock.callArgs = append(mmUnshare.UnshareMock.callArgs, mm_params)
	mmUnshare.UnshareMock.mutex.Unlock()

	for _, e := range mmUnshare.UnshareMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmUnshare.UnshareMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnshare.UnshareMock.defaultExpectation.Counter, 1)
		mm_want := mmUnshare.UnshareMock.defaultExpectation.params
		mm_got := MigrationContextMockUnshareParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnshare.t.Errorf("MigrationContextMock.Unshare got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnshare.UnshareMock.defaultExpectation.results
		if mm_results == nil {
			mmUnshare.t.Fatal("No results are set for the MigrationContextMock.Unshare")
		}
		return (*mm_results).b1
	}
	if mmUnshare.funcUnshare != nil {
		return mmUnshare.funcUnshare(s1)
	}
	mmUnshare.t.Fatalf("Unexpected call to MigrationContextMock.Unshare. %v", s1)
	return
}

// UnshareAfterCounter returns a count of finished MigrationContextMock.Unshare invocations
func (mmUnshare *MigrationContextMock) UnshareAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnshare.afterUnshareCounter)
}

// UnshareBeforeCounter returns a count of MigrationContextMock.Unshare invocations
func (mmUnshare *MigrationContextMock) UnshareBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnshare.beforeUnshareCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.Unshare.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnshare *mMigrationContextMockUnshare) Calls() []*MigrationContextMockUnshareParams {
	mmUnshare.mutex.RLock()

	argCopy := make([]*MigrationContextMockUnshareParams, len(mmUnshare.callArgs))
	copy(argCopy, mmUnshare.callArgs)

	mmUnshare.mutex.RUnlock()

	return argCopy
}

// MinimockUnshareDone returns true if the count of the Unshare invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockUnshareDone() bool {
	for _, e := range m.UnshareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnshareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnshareCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnshare != nil && mm_atomic.LoadUint64(&m.afterUnshareCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnshareInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockUnshareInspect() {
	for _, e := range m.UnshareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.Unshare with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnshareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnshareCounter) < 1 {
		if m.UnshareMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.Unshare")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.Unshare with params: %#v", *m.UnshareMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnshare != nil && mm_atomic.LoadUint64(&m.afterUnshareCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.Unshare")
	}
}

type mMigrationContextMockUpdateDefaultStepLogger struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockUpdateDefaultStepLoggerExpectation
	expectations       []*MigrationContextMockUpdateDefaultStepLoggerExpectation

	callArgs []*MigrationContextMockUpdateDefaultStepLoggerParams
	mutex    sync.RWMutex
}

// MigrationContextMockUpdateDefaultStepLoggerExpectation specifies expectation struct of the MigrationContext.UpdateDefaultStepLogger
type MigrationContextMockUpdateDefaultStepLoggerExpectation struct {
	mock   *MigrationContextMock
	params *MigrationContextMockUpdateDefaultStepLoggerParams

	Counter uint64
}

// MigrationContextMockUpdateDefaultStepLoggerParams contains parameters of the MigrationContext.UpdateDefaultStepLogger
type MigrationContextMockUpdateDefaultStepLoggerParams struct {
	s1 StepLoggerUpdateFunc
}

// Expect sets up expected params for MigrationContext.UpdateDefaultStepLogger
func (mmUpdateDefaultStepLogger *mMigrationContextMockUpdateDefaultStepLogger) Expect(s1 StepLoggerUpdateFunc) *mMigrationContextMockUpdateDefaultStepLogger {
	if mmUpdateDefaultStepLogger.mock.funcUpdateDefaultStepLogger != nil {
		mmUpdateDefaultStepLogger.mock.t.Fatalf("MigrationContextMock.UpdateDefaultStepLogger mock is already set by Set")
	}

	if mmUpdateDefaultStepLogger.defaultExpectation == nil {
		mmUpdateDefaultStepLogger.defaultExpectation = &MigrationContextMockUpdateDefaultStepLoggerExpectation{}
	}

	mmUpdateDefaultStepLogger.defaultExpectation.params = &MigrationContextMockUpdateDefaultStepLoggerParams{s1}
	for _, e := range mmUpdateDefaultStepLogger.expectations {
		if minimock.Equal(e.params, mmUpdateDefaultStepLogger.defaultExpectation.params) {
			mmUpdateDefaultStepLogger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateDefaultStepLogger.defaultExpectation.params)
		}
	}

	return mmUpdateDefaultStepLogger
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.UpdateDefaultStepLogger
func (mmUpdateDefaultStepLogger *mMigrationContextMockUpdateDefaultStepLogger) Inspect(f func(s1 StepLoggerUpdateFunc)) *mMigrationContextMockUpdateDefaultStepLogger {
	if mmUpdateDefaultStepLogger.mock.inspectFuncUpdateDefaultStepLogger != nil {
		mmUpdateDefaultStepLogger.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.UpdateDefaultStepLogger")
	}

	mmUpdateDefaultStepLogger.mock.inspectFuncUpdateDefaultStepLogger = f

	return mmUpdateDefaultStepLogger
}

// Return sets up results that will be returned by MigrationContext.UpdateDefaultStepLogger
func (mmUpdateDefaultStepLogger *mMigrationContextMockUpdateDefaultStepLogger) Return() *MigrationContextMock {
	if mmUpdateDefaultStepLogger.mock.funcUpdateDefaultStepLogger != nil {
		mmUpdateDefaultStepLogger.mock.t.Fatalf("MigrationContextMock.UpdateDefaultStepLogger mock is already set by Set")
	}

	if mmUpdateDefaultStepLogger.defaultExpectation == nil {
		mmUpdateDefaultStepLogger.defaultExpectation = &MigrationContextMockUpdateDefaultStepLoggerExpectation{mock: mmUpdateDefaultStepLogger.mock}
	}

	return mmUpdateDefaultStepLogger.mock
}

//Set uses given function f to mock the MigrationContext.UpdateDefaultStepLogger method
func (mmUpdateDefaultStepLogger *mMigrationContextMockUpdateDefaultStepLogger) Set(f func(s1 StepLoggerUpdateFunc)) *MigrationContextMock {
	if mmUpdateDefaultStepLogger.defaultExpectation != nil {
		mmUpdateDefaultStepLogger.mock.t.Fatalf("Default expectation is already set for the MigrationContext.UpdateDefaultStepLogger method")
	}

	if len(mmUpdateDefaultStepLogger.expectations) > 0 {
		mmUpdateDefaultStepLogger.mock.t.Fatalf("Some expectations are already set for the MigrationContext.UpdateDefaultStepLogger method")
	}

	mmUpdateDefaultStepLogger.mock.funcUpdateDefaultStepLogger = f
	return mmUpdateDefaultStepLogger.mock
}

// UpdateDefaultStepLogger implements MigrationContext
func (mmUpdateDefaultStepLogger *MigrationContextMock) UpdateDefaultStepLogger(s1 StepLoggerUpdateFunc) {
	mm_atomic.AddUint64(&mmUpdateDefaultStepLogger.beforeUpdateDefaultStepLoggerCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateDefaultStepLogger.afterUpdateDefaultStepLoggerCounter, 1)

	if mmUpdateDefaultStepLogger.inspectFuncUpdateDefaultStepLogger != nil {
		mmUpdateDefaultStepLogger.inspectFuncUpdateDefaultStepLogger(s1)
	}

	mm_params := &MigrationContextMockUpdateDefaultStepLoggerParams{s1}

	// Record call args
	mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.mutex.Lock()
	mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.callArgs = append(mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.callArgs, mm_params)
	mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.mutex.Unlock()

	for _, e := range mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateDefaultStepLogger.UpdateDefaultStepLoggerMock.defaultExpectation.params
		mm_got := MigrationContextMockUpdateDefaultStepLoggerParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateDefaultStepLogger.t.Errorf("MigrationContextMock.UpdateDefaultStepLogger got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmUpdateDefaultStepLogger.funcUpdateDefaultStepLogger != nil {
		mmUpdateDefaultStepLogger.funcUpdateDefaultStepLogger(s1)
		return
	}
	mmUpdateDefaultStepLogger.t.Fatalf("Unexpected call to MigrationContextMock.UpdateDefaultStepLogger. %v", s1)

}

// UpdateDefaultStepLoggerAfterCounter returns a count of finished MigrationContextMock.UpdateDefaultStepLogger invocations
func (mmUpdateDefaultStepLogger *MigrationContextMock) UpdateDefaultStepLoggerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateDefaultStepLogger.afterUpdateDefaultStepLoggerCounter)
}

// UpdateDefaultStepLoggerBeforeCounter returns a count of MigrationContextMock.UpdateDefaultStepLogger invocations
func (mmUpdateDefaultStepLogger *MigrationContextMock) UpdateDefaultStepLoggerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateDefaultStepLogger.beforeUpdateDefaultStepLoggerCounter)
}

// Calls returns a list of arguments used in each call to MigrationContextMock.UpdateDefaultStepLogger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateDefaultStepLogger *mMigrationContextMockUpdateDefaultStepLogger) Calls() []*MigrationContextMockUpdateDefaultStepLoggerParams {
	mmUpdateDefaultStepLogger.mutex.RLock()

	argCopy := make([]*MigrationContextMockUpdateDefaultStepLoggerParams, len(mmUpdateDefaultStepLogger.callArgs))
	copy(argCopy, mmUpdateDefaultStepLogger.callArgs)

	mmUpdateDefaultStepLogger.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDefaultStepLoggerDone returns true if the count of the UpdateDefaultStepLogger invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockUpdateDefaultStepLoggerDone() bool {
	for _, e := range m.UpdateDefaultStepLoggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateDefaultStepLoggerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateDefaultStepLoggerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateDefaultStepLogger != nil && mm_atomic.LoadUint64(&m.afterUpdateDefaultStepLoggerCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateDefaultStepLoggerInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockUpdateDefaultStepLoggerInspect() {
	for _, e := range m.UpdateDefaultStepLoggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationContextMock.UpdateDefaultStepLogger with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateDefaultStepLoggerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateDefaultStepLoggerCounter) < 1 {
		if m.UpdateDefaultStepLoggerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationContextMock.UpdateDefaultStepLogger")
		} else {
			m.t.Errorf("Expected call to MigrationContextMock.UpdateDefaultStepLogger with params: %#v", *m.UpdateDefaultStepLoggerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateDefaultStepLogger != nil && mm_atomic.LoadUint64(&m.afterUpdateDefaultStepLoggerCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.UpdateDefaultStepLogger")
	}
}

type mMigrationContextMockWakeUp struct {
	mock               *MigrationContextMock
	defaultExpectation *MigrationContextMockWakeUpExpectation
	expectations       []*MigrationContextMockWakeUpExpectation
}

// MigrationContextMockWakeUpExpectation specifies expectation struct of the MigrationContext.WakeUp
type MigrationContextMockWakeUpExpectation struct {
	mock *MigrationContextMock

	results *MigrationContextMockWakeUpResults
	Counter uint64
}

// MigrationContextMockWakeUpResults contains results of the MigrationContext.WakeUp
type MigrationContextMockWakeUpResults struct {
	s1 StateUpdate
}

// Expect sets up expected params for MigrationContext.WakeUp
func (mmWakeUp *mMigrationContextMockWakeUp) Expect() *mMigrationContextMockWakeUp {
	if mmWakeUp.mock.funcWakeUp != nil {
		mmWakeUp.mock.t.Fatalf("MigrationContextMock.WakeUp mock is already set by Set")
	}

	if mmWakeUp.defaultExpectation == nil {
		mmWakeUp.defaultExpectation = &MigrationContextMockWakeUpExpectation{}
	}

	return mmWakeUp
}

// Inspect accepts an inspector function that has same arguments as the MigrationContext.WakeUp
func (mmWakeUp *mMigrationContextMockWakeUp) Inspect(f func()) *mMigrationContextMockWakeUp {
	if mmWakeUp.mock.inspectFuncWakeUp != nil {
		mmWakeUp.mock.t.Fatalf("Inspect function is already set for MigrationContextMock.WakeUp")
	}

	mmWakeUp.mock.inspectFuncWakeUp = f

	return mmWakeUp
}

// Return sets up results that will be returned by MigrationContext.WakeUp
func (mmWakeUp *mMigrationContextMockWakeUp) Return(s1 StateUpdate) *MigrationContextMock {
	if mmWakeUp.mock.funcWakeUp != nil {
		mmWakeUp.mock.t.Fatalf("MigrationContextMock.WakeUp mock is already set by Set")
	}

	if mmWakeUp.defaultExpectation == nil {
		mmWakeUp.defaultExpectation = &MigrationContextMockWakeUpExpectation{mock: mmWakeUp.mock}
	}
	mmWakeUp.defaultExpectation.results = &MigrationContextMockWakeUpResults{s1}
	return mmWakeUp.mock
}

//Set uses given function f to mock the MigrationContext.WakeUp method
func (mmWakeUp *mMigrationContextMockWakeUp) Set(f func() (s1 StateUpdate)) *MigrationContextMock {
	if mmWakeUp.defaultExpectation != nil {
		mmWakeUp.mock.t.Fatalf("Default expectation is already set for the MigrationContext.WakeUp method")
	}

	if len(mmWakeUp.expectations) > 0 {
		mmWakeUp.mock.t.Fatalf("Some expectations are already set for the MigrationContext.WakeUp method")
	}

	mmWakeUp.mock.funcWakeUp = f
	return mmWakeUp.mock
}

// WakeUp implements MigrationContext
func (mmWakeUp *MigrationContextMock) WakeUp() (s1 StateUpdate) {
	mm_atomic.AddUint64(&mmWakeUp.beforeWakeUpCounter, 1)
	defer mm_atomic.AddUint64(&mmWakeUp.afterWakeUpCounter, 1)

	if mmWakeUp.inspectFuncWakeUp != nil {
		mmWakeUp.inspectFuncWakeUp()
	}

	if mmWakeUp.WakeUpMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWakeUp.WakeUpMock.defaultExpectation.Counter, 1)

		mm_results := mmWakeUp.WakeUpMock.defaultExpectation.results
		if mm_results == nil {
			mmWakeUp.t.Fatal("No results are set for the MigrationContextMock.WakeUp")
		}
		return (*mm_results).s1
	}
	if mmWakeUp.funcWakeUp != nil {
		return mmWakeUp.funcWakeUp()
	}
	mmWakeUp.t.Fatalf("Unexpected call to MigrationContextMock.WakeUp.")
	return
}

// WakeUpAfterCounter returns a count of finished MigrationContextMock.WakeUp invocations
func (mmWakeUp *MigrationContextMock) WakeUpAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWakeUp.afterWakeUpCounter)
}

// WakeUpBeforeCounter returns a count of MigrationContextMock.WakeUp invocations
func (mmWakeUp *MigrationContextMock) WakeUpBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWakeUp.beforeWakeUpCounter)
}

// MinimockWakeUpDone returns true if the count of the WakeUp invocations corresponds
// the number of defined expectations
func (m *MigrationContextMock) MinimockWakeUpDone() bool {
	for _, e := range m.WakeUpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WakeUpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWakeUpCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWakeUp != nil && mm_atomic.LoadUint64(&m.afterWakeUpCounter) < 1 {
		return false
	}
	return true
}

// MinimockWakeUpInspect logs each unmet expectation
func (m *MigrationContextMock) MinimockWakeUpInspect() {
	for _, e := range m.WakeUpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MigrationContextMock.WakeUp")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WakeUpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWakeUpCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.WakeUp")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWakeUp != nil && mm_atomic.LoadUint64(&m.afterWakeUpCounter) < 1 {
		m.t.Error("Expected call to MigrationContextMock.WakeUp")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MigrationContextMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAcquireInspect()

		m.MinimockAcquireAndReleaseInspect()

		m.MinimockAcquireExtInspect()

		m.MinimockAcquireForThisStepInspect()

		m.MinimockAcquireForThisStepAndReleaseInspect()

		m.MinimockAffectedStepInspect()

		m.MinimockApplyAdjustmentInspect()

		m.MinimockCallSubroutineInspect()

		m.MinimockCheckInspect()

		m.MinimockErrorInspect()

		m.MinimockGetContextInspect()

		m.MinimockGetPublishedInspect()

		m.MinimockGetPublishedGlobalAliasInspect()

		m.MinimockGetPublishedGlobalAliasAndBargeInInspect()

		m.MinimockGetPublishedLinkInspect()

		m.MinimockGetTerminationResultInspect()

		m.MinimockJumpInspect()

		m.MinimockJumpExtInspect()

		m.MinimockLogInspect()

		m.MinimockNewBargeInInspect()

		m.MinimockNewBargeInWithParamInspect()

		m.MinimockOverrideDynamicBoostInspect()

		m.MinimockParentLinkInspect()

		m.MinimockPublishInspect()

		m.MinimockPublishGlobalAliasInspect()

		m.MinimockPublishGlobalAliasAndBargeInInspect()

		m.MinimockPublishReplacementInspect()

		m.MinimockReleaseInspect()

		m.MinimockReleaseAllInspect()

		m.MinimockRestoreStepInspect()

		m.MinimockSetDefaultErrorHandlerInspect()

		m.MinimockSetDefaultFlagsInspect()

		m.MinimockSetDefaultMigrationInspect()

		m.MinimockSetFinalizerInspect()

		m.MinimockSetLogTracingInspect()

		m.MinimockSetTerminationResultInspect()

		m.MinimockShareInspect()

		m.MinimockSkipMultipleMigrationsInspect()

		m.MinimockSlotLinkInspect()

		m.MinimockStayInspect()

		m.MinimockStopInspect()

		m.MinimockUnpublishInspect()

		m.MinimockUnpublishAllInspect()

		m.MinimockUnpublishGlobalAliasInspect()

		m.MinimockUnshareInspect()

		m.MinimockUpdateDefaultStepLoggerInspect()

		m.MinimockWakeUpInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MigrationContextMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MigrationContextMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAcquireDone() &&
		m.MinimockAcquireAndReleaseDone() &&
		m.MinimockAcquireExtDone() &&
		m.MinimockAcquireForThisStepDone() &&
		m.MinimockAcquireForThisStepAndReleaseDone() &&
		m.MinimockAffectedStepDone() &&
		m.MinimockApplyAdjustmentDone() &&
		m.MinimockCallSubroutineDone() &&
		m.MinimockCheckDone() &&
		m.MinimockErrorDone() &&
		m.MinimockGetContextDone() &&
		m.MinimockGetPublishedDone() &&
		m.MinimockGetPublishedGlobalAliasDone() &&
		m.MinimockGetPublishedGlobalAliasAndBargeInDone() &&
		m.MinimockGetPublishedLinkDone() &&
		m.MinimockGetTerminationResultDone() &&
		m.MinimockJumpDone() &&
		m.MinimockJumpExtDone() &&
		m.MinimockLogDone() &&
		m.MinimockNewBargeInDone() &&
		m.MinimockNewBargeInWithParamDone() &&
		m.MinimockOverrideDynamicBoostDone() &&
		m.MinimockParentLinkDone() &&
		m.MinimockPublishDone() &&
		m.MinimockPublishGlobalAliasDone() &&
		m.MinimockPublishGlobalAliasAndBargeInDone() &&
		m.MinimockPublishReplacementDone() &&
		m.MinimockReleaseDone() &&
		m.MinimockReleaseAllDone() &&
		m.MinimockRestoreStepDone() &&
		m.MinimockSetDefaultErrorHandlerDone() &&
		m.MinimockSetDefaultFlagsDone() &&
		m.MinimockSetDefaultMigrationDone() &&
		m.MinimockSetFinalizerDone() &&
		m.MinimockSetLogTracingDone() &&
		m.MinimockSetTerminationResultDone() &&
		m.MinimockShareDone() &&
		m.MinimockSkipMultipleMigrationsDone() &&
		m.MinimockSlotLinkDone() &&
		m.MinimockStayDone() &&
		m.MinimockStopDone() &&
		m.MinimockUnpublishDone() &&
		m.MinimockUnpublishAllDone() &&
		m.MinimockUnpublishGlobalAliasDone() &&
		m.MinimockUnshareDone() &&
		m.MinimockUpdateDefaultStepLoggerDone() &&
		m.MinimockWakeUpDone()
}
