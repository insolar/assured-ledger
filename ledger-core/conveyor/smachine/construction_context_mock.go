package smachine

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ConstructionContextMock implements ConstructionContext
type ConstructionContextMock struct {
	t minimock.Tester

	funcGetContext          func() (c1 context.Context)
	inspectFuncGetContext   func()
	afterGetContextCounter  uint64
	beforeGetContextCounter uint64
	GetContextMock          mConstructionContextMockGetContext

	funcOverrideDependency          func(id string, v interface{})
	inspectFuncOverrideDependency   func(id string, v interface{})
	afterOverrideDependencyCounter  uint64
	beforeOverrideDependencyCounter uint64
	OverrideDependencyMock          mConstructionContextMockOverrideDependency

	funcParentLink          func() (s1 SlotLink)
	inspectFuncParentLink   func()
	afterParentLinkCounter  uint64
	beforeParentLinkCounter uint64
	ParentLinkMock          mConstructionContextMockParentLink

	funcSetContext          func(ctx context.Context)
	inspectFuncSetContext   func(ctx context.Context)
	afterSetContextCounter  uint64
	beforeSetContextCounter uint64
	SetContextMock          mConstructionContextMockSetContext

	funcSetDefaultTerminationResult          func(p1 interface{})
	inspectFuncSetDefaultTerminationResult   func(p1 interface{})
	afterSetDefaultTerminationResultCounter  uint64
	beforeSetDefaultTerminationResultCounter uint64
	SetDefaultTerminationResultMock          mConstructionContextMockSetDefaultTerminationResult

	funcSetDependencyInheritanceMode          func(d1 DependencyInheritanceMode)
	inspectFuncSetDependencyInheritanceMode   func(d1 DependencyInheritanceMode)
	afterSetDependencyInheritanceModeCounter  uint64
	beforeSetDependencyInheritanceModeCounter uint64
	SetDependencyInheritanceModeMock          mConstructionContextMockSetDependencyInheritanceMode

	funcSetLogTracing          func(b1 bool)
	inspectFuncSetLogTracing   func(b1 bool)
	afterSetLogTracingCounter  uint64
	beforeSetLogTracingCounter uint64
	SetLogTracingMock          mConstructionContextMockSetLogTracing

	funcSetParentLink          func(s1 SlotLink)
	inspectFuncSetParentLink   func(s1 SlotLink)
	afterSetParentLinkCounter  uint64
	beforeSetParentLinkCounter uint64
	SetParentLinkMock          mConstructionContextMockSetParentLink

	funcSetTerminationCallback          func(receiver ExecutionContext, getResultFn TerminationCallbackFunc)
	inspectFuncSetTerminationCallback   func(receiver ExecutionContext, getResultFn TerminationCallbackFunc)
	afterSetTerminationCallbackCounter  uint64
	beforeSetTerminationCallbackCounter uint64
	SetTerminationCallbackMock          mConstructionContextMockSetTerminationCallback

	funcSetTracerID          func(t1 TracerID)
	inspectFuncSetTracerID   func(t1 TracerID)
	afterSetTracerIDCounter  uint64
	beforeSetTracerIDCounter uint64
	SetTracerIDMock          mConstructionContextMockSetTracerID

	funcSlotLink          func() (s1 SlotLink)
	inspectFuncSlotLink   func()
	afterSlotLinkCounter  uint64
	beforeSlotLinkCounter uint64
	SlotLinkMock          mConstructionContextMockSlotLink
}

// NewConstructionContextMock returns a mock for ConstructionContext
func NewConstructionContextMock(t minimock.Tester) *ConstructionContextMock {
	m := &ConstructionContextMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetContextMock = mConstructionContextMockGetContext{mock: m}

	m.OverrideDependencyMock = mConstructionContextMockOverrideDependency{mock: m}
	m.OverrideDependencyMock.callArgs = []*ConstructionContextMockOverrideDependencyParams{}

	m.ParentLinkMock = mConstructionContextMockParentLink{mock: m}

	m.SetContextMock = mConstructionContextMockSetContext{mock: m}
	m.SetContextMock.callArgs = []*ConstructionContextMockSetContextParams{}

	m.SetDefaultTerminationResultMock = mConstructionContextMockSetDefaultTerminationResult{mock: m}
	m.SetDefaultTerminationResultMock.callArgs = []*ConstructionContextMockSetDefaultTerminationResultParams{}

	m.SetDependencyInheritanceModeMock = mConstructionContextMockSetDependencyInheritanceMode{mock: m}
	m.SetDependencyInheritanceModeMock.callArgs = []*ConstructionContextMockSetDependencyInheritanceModeParams{}

	m.SetLogTracingMock = mConstructionContextMockSetLogTracing{mock: m}
	m.SetLogTracingMock.callArgs = []*ConstructionContextMockSetLogTracingParams{}

	m.SetParentLinkMock = mConstructionContextMockSetParentLink{mock: m}
	m.SetParentLinkMock.callArgs = []*ConstructionContextMockSetParentLinkParams{}

	m.SetTerminationCallbackMock = mConstructionContextMockSetTerminationCallback{mock: m}
	m.SetTerminationCallbackMock.callArgs = []*ConstructionContextMockSetTerminationCallbackParams{}

	m.SetTracerIDMock = mConstructionContextMockSetTracerID{mock: m}
	m.SetTracerIDMock.callArgs = []*ConstructionContextMockSetTracerIDParams{}

	m.SlotLinkMock = mConstructionContextMockSlotLink{mock: m}

	return m
}

type mConstructionContextMockGetContext struct {
	mock               *ConstructionContextMock
	defaultExpectation *ConstructionContextMockGetContextExpectation
	expectations       []*ConstructionContextMockGetContextExpectation
}

// ConstructionContextMockGetContextExpectation specifies expectation struct of the ConstructionContext.GetContext
type ConstructionContextMockGetContextExpectation struct {
	mock *ConstructionContextMock

	results *ConstructionContextMockGetContextResults
	Counter uint64
}

// ConstructionContextMockGetContextResults contains results of the ConstructionContext.GetContext
type ConstructionContextMockGetContextResults struct {
	c1 context.Context
}

// Expect sets up expected params for ConstructionContext.GetContext
func (mmGetContext *mConstructionContextMockGetContext) Expect() *mConstructionContextMockGetContext {
	if mmGetContext.mock.funcGetContext != nil {
		mmGetContext.mock.t.Fatalf("ConstructionContextMock.GetContext mock is already set by Set")
	}

	if mmGetContext.defaultExpectation == nil {
		mmGetContext.defaultExpectation = &ConstructionContextMockGetContextExpectation{}
	}

	return mmGetContext
}

// Inspect accepts an inspector function that has same arguments as the ConstructionContext.GetContext
func (mmGetContext *mConstructionContextMockGetContext) Inspect(f func()) *mConstructionContextMockGetContext {
	if mmGetContext.mock.inspectFuncGetContext != nil {
		mmGetContext.mock.t.Fatalf("Inspect function is already set for ConstructionContextMock.GetContext")
	}

	mmGetContext.mock.inspectFuncGetContext = f

	return mmGetContext
}

// Return sets up results that will be returned by ConstructionContext.GetContext
func (mmGetContext *mConstructionContextMockGetContext) Return(c1 context.Context) *ConstructionContextMock {
	if mmGetContext.mock.funcGetContext != nil {
		mmGetContext.mock.t.Fatalf("ConstructionContextMock.GetContext mock is already set by Set")
	}

	if mmGetContext.defaultExpectation == nil {
		mmGetContext.defaultExpectation = &ConstructionContextMockGetContextExpectation{mock: mmGetContext.mock}
	}
	mmGetContext.defaultExpectation.results = &ConstructionContextMockGetContextResults{c1}
	return mmGetContext.mock
}

//Set uses given function f to mock the ConstructionContext.GetContext method
func (mmGetContext *mConstructionContextMockGetContext) Set(f func() (c1 context.Context)) *ConstructionContextMock {
	if mmGetContext.defaultExpectation != nil {
		mmGetContext.mock.t.Fatalf("Default expectation is already set for the ConstructionContext.GetContext method")
	}

	if len(mmGetContext.expectations) > 0 {
		mmGetContext.mock.t.Fatalf("Some expectations are already set for the ConstructionContext.GetContext method")
	}

	mmGetContext.mock.funcGetContext = f
	return mmGetContext.mock
}

// GetContext implements ConstructionContext
func (mmGetContext *ConstructionContextMock) GetContext() (c1 context.Context) {
	mm_atomic.AddUint64(&mmGetContext.beforeGetContextCounter, 1)
	defer mm_atomic.AddUint64(&mmGetContext.afterGetContextCounter, 1)

	if mmGetContext.inspectFuncGetContext != nil {
		mmGetContext.inspectFuncGetContext()
	}

	if mmGetContext.GetContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetContext.GetContextMock.defaultExpectation.Counter, 1)

		mm_results := mmGetContext.GetContextMock.defaultExpectation.results
		if mm_results == nil {
			mmGetContext.t.Fatal("No results are set for the ConstructionContextMock.GetContext")
		}
		return (*mm_results).c1
	}
	if mmGetContext.funcGetContext != nil {
		return mmGetContext.funcGetContext()
	}
	mmGetContext.t.Fatalf("Unexpected call to ConstructionContextMock.GetContext.")
	return
}

// GetContextAfterCounter returns a count of finished ConstructionContextMock.GetContext invocations
func (mmGetContext *ConstructionContextMock) GetContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContext.afterGetContextCounter)
}

// GetContextBeforeCounter returns a count of ConstructionContextMock.GetContext invocations
func (mmGetContext *ConstructionContextMock) GetContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContext.beforeGetContextCounter)
}

// MinimockGetContextDone returns true if the count of the GetContext invocations corresponds
// the number of defined expectations
func (m *ConstructionContextMock) MinimockGetContextDone() bool {
	for _, e := range m.GetContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetContext != nil && mm_atomic.LoadUint64(&m.afterGetContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetContextInspect logs each unmet expectation
func (m *ConstructionContextMock) MinimockGetContextInspect() {
	for _, e := range m.GetContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConstructionContextMock.GetContext")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetContextCounter) < 1 {
		m.t.Error("Expected call to ConstructionContextMock.GetContext")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetContext != nil && mm_atomic.LoadUint64(&m.afterGetContextCounter) < 1 {
		m.t.Error("Expected call to ConstructionContextMock.GetContext")
	}
}

type mConstructionContextMockOverrideDependency struct {
	mock               *ConstructionContextMock
	defaultExpectation *ConstructionContextMockOverrideDependencyExpectation
	expectations       []*ConstructionContextMockOverrideDependencyExpectation

	callArgs []*ConstructionContextMockOverrideDependencyParams
	mutex    sync.RWMutex
}

// ConstructionContextMockOverrideDependencyExpectation specifies expectation struct of the ConstructionContext.OverrideDependency
type ConstructionContextMockOverrideDependencyExpectation struct {
	mock   *ConstructionContextMock
	params *ConstructionContextMockOverrideDependencyParams

	Counter uint64
}

// ConstructionContextMockOverrideDependencyParams contains parameters of the ConstructionContext.OverrideDependency
type ConstructionContextMockOverrideDependencyParams struct {
	id string
	v  interface{}
}

// Expect sets up expected params for ConstructionContext.OverrideDependency
func (mmOverrideDependency *mConstructionContextMockOverrideDependency) Expect(id string, v interface{}) *mConstructionContextMockOverrideDependency {
	if mmOverrideDependency.mock.funcOverrideDependency != nil {
		mmOverrideDependency.mock.t.Fatalf("ConstructionContextMock.OverrideDependency mock is already set by Set")
	}

	if mmOverrideDependency.defaultExpectation == nil {
		mmOverrideDependency.defaultExpectation = &ConstructionContextMockOverrideDependencyExpectation{}
	}

	mmOverrideDependency.defaultExpectation.params = &ConstructionContextMockOverrideDependencyParams{id, v}
	for _, e := range mmOverrideDependency.expectations {
		if minimock.Equal(e.params, mmOverrideDependency.defaultExpectation.params) {
			mmOverrideDependency.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOverrideDependency.defaultExpectation.params)
		}
	}

	return mmOverrideDependency
}

// Inspect accepts an inspector function that has same arguments as the ConstructionContext.OverrideDependency
func (mmOverrideDependency *mConstructionContextMockOverrideDependency) Inspect(f func(id string, v interface{})) *mConstructionContextMockOverrideDependency {
	if mmOverrideDependency.mock.inspectFuncOverrideDependency != nil {
		mmOverrideDependency.mock.t.Fatalf("Inspect function is already set for ConstructionContextMock.OverrideDependency")
	}

	mmOverrideDependency.mock.inspectFuncOverrideDependency = f

	return mmOverrideDependency
}

// Return sets up results that will be returned by ConstructionContext.OverrideDependency
func (mmOverrideDependency *mConstructionContextMockOverrideDependency) Return() *ConstructionContextMock {
	if mmOverrideDependency.mock.funcOverrideDependency != nil {
		mmOverrideDependency.mock.t.Fatalf("ConstructionContextMock.OverrideDependency mock is already set by Set")
	}

	if mmOverrideDependency.defaultExpectation == nil {
		mmOverrideDependency.defaultExpectation = &ConstructionContextMockOverrideDependencyExpectation{mock: mmOverrideDependency.mock}
	}

	return mmOverrideDependency.mock
}

//Set uses given function f to mock the ConstructionContext.OverrideDependency method
func (mmOverrideDependency *mConstructionContextMockOverrideDependency) Set(f func(id string, v interface{})) *ConstructionContextMock {
	if mmOverrideDependency.defaultExpectation != nil {
		mmOverrideDependency.mock.t.Fatalf("Default expectation is already set for the ConstructionContext.OverrideDependency method")
	}

	if len(mmOverrideDependency.expectations) > 0 {
		mmOverrideDependency.mock.t.Fatalf("Some expectations are already set for the ConstructionContext.OverrideDependency method")
	}

	mmOverrideDependency.mock.funcOverrideDependency = f
	return mmOverrideDependency.mock
}

// OverrideDependency implements ConstructionContext
func (mmOverrideDependency *ConstructionContextMock) OverrideDependency(id string, v interface{}) {
	mm_atomic.AddUint64(&mmOverrideDependency.beforeOverrideDependencyCounter, 1)
	defer mm_atomic.AddUint64(&mmOverrideDependency.afterOverrideDependencyCounter, 1)

	if mmOverrideDependency.inspectFuncOverrideDependency != nil {
		mmOverrideDependency.inspectFuncOverrideDependency(id, v)
	}

	mm_params := &ConstructionContextMockOverrideDependencyParams{id, v}

	// Record call args
	mmOverrideDependency.OverrideDependencyMock.mutex.Lock()
	mmOverrideDependency.OverrideDependencyMock.callArgs = append(mmOverrideDependency.OverrideDependencyMock.callArgs, mm_params)
	mmOverrideDependency.OverrideDependencyMock.mutex.Unlock()

	for _, e := range mmOverrideDependency.OverrideDependencyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmOverrideDependency.OverrideDependencyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOverrideDependency.OverrideDependencyMock.defaultExpectation.Counter, 1)
		mm_want := mmOverrideDependency.OverrideDependencyMock.defaultExpectation.params
		mm_got := ConstructionContextMockOverrideDependencyParams{id, v}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOverrideDependency.t.Errorf("ConstructionContextMock.OverrideDependency got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmOverrideDependency.funcOverrideDependency != nil {
		mmOverrideDependency.funcOverrideDependency(id, v)
		return
	}
	mmOverrideDependency.t.Fatalf("Unexpected call to ConstructionContextMock.OverrideDependency. %v %v", id, v)

}

// OverrideDependencyAfterCounter returns a count of finished ConstructionContextMock.OverrideDependency invocations
func (mmOverrideDependency *ConstructionContextMock) OverrideDependencyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOverrideDependency.afterOverrideDependencyCounter)
}

// OverrideDependencyBeforeCounter returns a count of ConstructionContextMock.OverrideDependency invocations
func (mmOverrideDependency *ConstructionContextMock) OverrideDependencyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOverrideDependency.beforeOverrideDependencyCounter)
}

// Calls returns a list of arguments used in each call to ConstructionContextMock.OverrideDependency.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOverrideDependency *mConstructionContextMockOverrideDependency) Calls() []*ConstructionContextMockOverrideDependencyParams {
	mmOverrideDependency.mutex.RLock()

	argCopy := make([]*ConstructionContextMockOverrideDependencyParams, len(mmOverrideDependency.callArgs))
	copy(argCopy, mmOverrideDependency.callArgs)

	mmOverrideDependency.mutex.RUnlock()

	return argCopy
}

// MinimockOverrideDependencyDone returns true if the count of the OverrideDependency invocations corresponds
// the number of defined expectations
func (m *ConstructionContextMock) MinimockOverrideDependencyDone() bool {
	for _, e := range m.OverrideDependencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OverrideDependencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOverrideDependencyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOverrideDependency != nil && mm_atomic.LoadUint64(&m.afterOverrideDependencyCounter) < 1 {
		return false
	}
	return true
}

// MinimockOverrideDependencyInspect logs each unmet expectation
func (m *ConstructionContextMock) MinimockOverrideDependencyInspect() {
	for _, e := range m.OverrideDependencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConstructionContextMock.OverrideDependency with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OverrideDependencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOverrideDependencyCounter) < 1 {
		if m.OverrideDependencyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConstructionContextMock.OverrideDependency")
		} else {
			m.t.Errorf("Expected call to ConstructionContextMock.OverrideDependency with params: %#v", *m.OverrideDependencyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOverrideDependency != nil && mm_atomic.LoadUint64(&m.afterOverrideDependencyCounter) < 1 {
		m.t.Error("Expected call to ConstructionContextMock.OverrideDependency")
	}
}

type mConstructionContextMockParentLink struct {
	mock               *ConstructionContextMock
	defaultExpectation *ConstructionContextMockParentLinkExpectation
	expectations       []*ConstructionContextMockParentLinkExpectation
}

// ConstructionContextMockParentLinkExpectation specifies expectation struct of the ConstructionContext.ParentLink
type ConstructionContextMockParentLinkExpectation struct {
	mock *ConstructionContextMock

	results *ConstructionContextMockParentLinkResults
	Counter uint64
}

// ConstructionContextMockParentLinkResults contains results of the ConstructionContext.ParentLink
type ConstructionContextMockParentLinkResults struct {
	s1 SlotLink
}

// Expect sets up expected params for ConstructionContext.ParentLink
func (mmParentLink *mConstructionContextMockParentLink) Expect() *mConstructionContextMockParentLink {
	if mmParentLink.mock.funcParentLink != nil {
		mmParentLink.mock.t.Fatalf("ConstructionContextMock.ParentLink mock is already set by Set")
	}

	if mmParentLink.defaultExpectation == nil {
		mmParentLink.defaultExpectation = &ConstructionContextMockParentLinkExpectation{}
	}

	return mmParentLink
}

// Inspect accepts an inspector function that has same arguments as the ConstructionContext.ParentLink
func (mmParentLink *mConstructionContextMockParentLink) Inspect(f func()) *mConstructionContextMockParentLink {
	if mmParentLink.mock.inspectFuncParentLink != nil {
		mmParentLink.mock.t.Fatalf("Inspect function is already set for ConstructionContextMock.ParentLink")
	}

	mmParentLink.mock.inspectFuncParentLink = f

	return mmParentLink
}

// Return sets up results that will be returned by ConstructionContext.ParentLink
func (mmParentLink *mConstructionContextMockParentLink) Return(s1 SlotLink) *ConstructionContextMock {
	if mmParentLink.mock.funcParentLink != nil {
		mmParentLink.mock.t.Fatalf("ConstructionContextMock.ParentLink mock is already set by Set")
	}

	if mmParentLink.defaultExpectation == nil {
		mmParentLink.defaultExpectation = &ConstructionContextMockParentLinkExpectation{mock: mmParentLink.mock}
	}
	mmParentLink.defaultExpectation.results = &ConstructionContextMockParentLinkResults{s1}
	return mmParentLink.mock
}

//Set uses given function f to mock the ConstructionContext.ParentLink method
func (mmParentLink *mConstructionContextMockParentLink) Set(f func() (s1 SlotLink)) *ConstructionContextMock {
	if mmParentLink.defaultExpectation != nil {
		mmParentLink.mock.t.Fatalf("Default expectation is already set for the ConstructionContext.ParentLink method")
	}

	if len(mmParentLink.expectations) > 0 {
		mmParentLink.mock.t.Fatalf("Some expectations are already set for the ConstructionContext.ParentLink method")
	}

	mmParentLink.mock.funcParentLink = f
	return mmParentLink.mock
}

// ParentLink implements ConstructionContext
func (mmParentLink *ConstructionContextMock) ParentLink() (s1 SlotLink) {
	mm_atomic.AddUint64(&mmParentLink.beforeParentLinkCounter, 1)
	defer mm_atomic.AddUint64(&mmParentLink.afterParentLinkCounter, 1)

	if mmParentLink.inspectFuncParentLink != nil {
		mmParentLink.inspectFuncParentLink()
	}

	if mmParentLink.ParentLinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmParentLink.ParentLinkMock.defaultExpectation.Counter, 1)

		mm_results := mmParentLink.ParentLinkMock.defaultExpectation.results
		if mm_results == nil {
			mmParentLink.t.Fatal("No results are set for the ConstructionContextMock.ParentLink")
		}
		return (*mm_results).s1
	}
	if mmParentLink.funcParentLink != nil {
		return mmParentLink.funcParentLink()
	}
	mmParentLink.t.Fatalf("Unexpected call to ConstructionContextMock.ParentLink.")
	return
}

// ParentLinkAfterCounter returns a count of finished ConstructionContextMock.ParentLink invocations
func (mmParentLink *ConstructionContextMock) ParentLinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParentLink.afterParentLinkCounter)
}

// ParentLinkBeforeCounter returns a count of ConstructionContextMock.ParentLink invocations
func (mmParentLink *ConstructionContextMock) ParentLinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParentLink.beforeParentLinkCounter)
}

// MinimockParentLinkDone returns true if the count of the ParentLink invocations corresponds
// the number of defined expectations
func (m *ConstructionContextMock) MinimockParentLinkDone() bool {
	for _, e := range m.ParentLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParentLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParentLinkCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParentLink != nil && mm_atomic.LoadUint64(&m.afterParentLinkCounter) < 1 {
		return false
	}
	return true
}

// MinimockParentLinkInspect logs each unmet expectation
func (m *ConstructionContextMock) MinimockParentLinkInspect() {
	for _, e := range m.ParentLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConstructionContextMock.ParentLink")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParentLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParentLinkCounter) < 1 {
		m.t.Error("Expected call to ConstructionContextMock.ParentLink")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParentLink != nil && mm_atomic.LoadUint64(&m.afterParentLinkCounter) < 1 {
		m.t.Error("Expected call to ConstructionContextMock.ParentLink")
	}
}

type mConstructionContextMockSetContext struct {
	mock               *ConstructionContextMock
	defaultExpectation *ConstructionContextMockSetContextExpectation
	expectations       []*ConstructionContextMockSetContextExpectation

	callArgs []*ConstructionContextMockSetContextParams
	mutex    sync.RWMutex
}

// ConstructionContextMockSetContextExpectation specifies expectation struct of the ConstructionContext.SetContext
type ConstructionContextMockSetContextExpectation struct {
	mock   *ConstructionContextMock
	params *ConstructionContextMockSetContextParams

	Counter uint64
}

// ConstructionContextMockSetContextParams contains parameters of the ConstructionContext.SetContext
type ConstructionContextMockSetContextParams struct {
	ctx context.Context
}

// Expect sets up expected params for ConstructionContext.SetContext
func (mmSetContext *mConstructionContextMockSetContext) Expect(ctx context.Context) *mConstructionContextMockSetContext {
	if mmSetContext.mock.funcSetContext != nil {
		mmSetContext.mock.t.Fatalf("ConstructionContextMock.SetContext mock is already set by Set")
	}

	if mmSetContext.defaultExpectation == nil {
		mmSetContext.defaultExpectation = &ConstructionContextMockSetContextExpectation{}
	}

	mmSetContext.defaultExpectation.params = &ConstructionContextMockSetContextParams{ctx}
	for _, e := range mmSetContext.expectations {
		if minimock.Equal(e.params, mmSetContext.defaultExpectation.params) {
			mmSetContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetContext.defaultExpectation.params)
		}
	}

	return mmSetContext
}

// Inspect accepts an inspector function that has same arguments as the ConstructionContext.SetContext
func (mmSetContext *mConstructionContextMockSetContext) Inspect(f func(ctx context.Context)) *mConstructionContextMockSetContext {
	if mmSetContext.mock.inspectFuncSetContext != nil {
		mmSetContext.mock.t.Fatalf("Inspect function is already set for ConstructionContextMock.SetContext")
	}

	mmSetContext.mock.inspectFuncSetContext = f

	return mmSetContext
}

// Return sets up results that will be returned by ConstructionContext.SetContext
func (mmSetContext *mConstructionContextMockSetContext) Return() *ConstructionContextMock {
	if mmSetContext.mock.funcSetContext != nil {
		mmSetContext.mock.t.Fatalf("ConstructionContextMock.SetContext mock is already set by Set")
	}

	if mmSetContext.defaultExpectation == nil {
		mmSetContext.defaultExpectation = &ConstructionContextMockSetContextExpectation{mock: mmSetContext.mock}
	}

	return mmSetContext.mock
}

//Set uses given function f to mock the ConstructionContext.SetContext method
func (mmSetContext *mConstructionContextMockSetContext) Set(f func(ctx context.Context)) *ConstructionContextMock {
	if mmSetContext.defaultExpectation != nil {
		mmSetContext.mock.t.Fatalf("Default expectation is already set for the ConstructionContext.SetContext method")
	}

	if len(mmSetContext.expectations) > 0 {
		mmSetContext.mock.t.Fatalf("Some expectations are already set for the ConstructionContext.SetContext method")
	}

	mmSetContext.mock.funcSetContext = f
	return mmSetContext.mock
}

// SetContext implements ConstructionContext
func (mmSetContext *ConstructionContextMock) SetContext(ctx context.Context) {
	mm_atomic.AddUint64(&mmSetContext.beforeSetContextCounter, 1)
	defer mm_atomic.AddUint64(&mmSetContext.afterSetContextCounter, 1)

	if mmSetContext.inspectFuncSetContext != nil {
		mmSetContext.inspectFuncSetContext(ctx)
	}

	mm_params := &ConstructionContextMockSetContextParams{ctx}

	// Record call args
	mmSetContext.SetContextMock.mutex.Lock()
	mmSetContext.SetContextMock.callArgs = append(mmSetContext.SetContextMock.callArgs, mm_params)
	mmSetContext.SetContextMock.mutex.Unlock()

	for _, e := range mmSetContext.SetContextMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetContext.SetContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetContext.SetContextMock.defaultExpectation.Counter, 1)
		mm_want := mmSetContext.SetContextMock.defaultExpectation.params
		mm_got := ConstructionContextMockSetContextParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetContext.t.Errorf("ConstructionContextMock.SetContext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetContext.funcSetContext != nil {
		mmSetContext.funcSetContext(ctx)
		return
	}
	mmSetContext.t.Fatalf("Unexpected call to ConstructionContextMock.SetContext. %v", ctx)

}

// SetContextAfterCounter returns a count of finished ConstructionContextMock.SetContext invocations
func (mmSetContext *ConstructionContextMock) SetContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetContext.afterSetContextCounter)
}

// SetContextBeforeCounter returns a count of ConstructionContextMock.SetContext invocations
func (mmSetContext *ConstructionContextMock) SetContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetContext.beforeSetContextCounter)
}

// Calls returns a list of arguments used in each call to ConstructionContextMock.SetContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetContext *mConstructionContextMockSetContext) Calls() []*ConstructionContextMockSetContextParams {
	mmSetContext.mutex.RLock()

	argCopy := make([]*ConstructionContextMockSetContextParams, len(mmSetContext.callArgs))
	copy(argCopy, mmSetContext.callArgs)

	mmSetContext.mutex.RUnlock()

	return argCopy
}

// MinimockSetContextDone returns true if the count of the SetContext invocations corresponds
// the number of defined expectations
func (m *ConstructionContextMock) MinimockSetContextDone() bool {
	for _, e := range m.SetContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetContext != nil && mm_atomic.LoadUint64(&m.afterSetContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetContextInspect logs each unmet expectation
func (m *ConstructionContextMock) MinimockSetContextInspect() {
	for _, e := range m.SetContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConstructionContextMock.SetContext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetContextCounter) < 1 {
		if m.SetContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConstructionContextMock.SetContext")
		} else {
			m.t.Errorf("Expected call to ConstructionContextMock.SetContext with params: %#v", *m.SetContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetContext != nil && mm_atomic.LoadUint64(&m.afterSetContextCounter) < 1 {
		m.t.Error("Expected call to ConstructionContextMock.SetContext")
	}
}

type mConstructionContextMockSetDefaultTerminationResult struct {
	mock               *ConstructionContextMock
	defaultExpectation *ConstructionContextMockSetDefaultTerminationResultExpectation
	expectations       []*ConstructionContextMockSetDefaultTerminationResultExpectation

	callArgs []*ConstructionContextMockSetDefaultTerminationResultParams
	mutex    sync.RWMutex
}

// ConstructionContextMockSetDefaultTerminationResultExpectation specifies expectation struct of the ConstructionContext.SetDefaultTerminationResult
type ConstructionContextMockSetDefaultTerminationResultExpectation struct {
	mock   *ConstructionContextMock
	params *ConstructionContextMockSetDefaultTerminationResultParams

	Counter uint64
}

// ConstructionContextMockSetDefaultTerminationResultParams contains parameters of the ConstructionContext.SetDefaultTerminationResult
type ConstructionContextMockSetDefaultTerminationResultParams struct {
	p1 interface{}
}

// Expect sets up expected params for ConstructionContext.SetDefaultTerminationResult
func (mmSetDefaultTerminationResult *mConstructionContextMockSetDefaultTerminationResult) Expect(p1 interface{}) *mConstructionContextMockSetDefaultTerminationResult {
	if mmSetDefaultTerminationResult.mock.funcSetDefaultTerminationResult != nil {
		mmSetDefaultTerminationResult.mock.t.Fatalf("ConstructionContextMock.SetTerminationResult mock is already set by Set")
	}

	if mmSetDefaultTerminationResult.defaultExpectation == nil {
		mmSetDefaultTerminationResult.defaultExpectation = &ConstructionContextMockSetDefaultTerminationResultExpectation{}
	}

	mmSetDefaultTerminationResult.defaultExpectation.params = &ConstructionContextMockSetDefaultTerminationResultParams{p1}
	for _, e := range mmSetDefaultTerminationResult.expectations {
		if minimock.Equal(e.params, mmSetDefaultTerminationResult.defaultExpectation.params) {
			mmSetDefaultTerminationResult.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetDefaultTerminationResult.defaultExpectation.params)
		}
	}

	return mmSetDefaultTerminationResult
}

// Inspect accepts an inspector function that has same arguments as the ConstructionContext.SetDefaultTerminationResult
func (mmSetDefaultTerminationResult *mConstructionContextMockSetDefaultTerminationResult) Inspect(f func(p1 interface{})) *mConstructionContextMockSetDefaultTerminationResult {
	if mmSetDefaultTerminationResult.mock.inspectFuncSetDefaultTerminationResult != nil {
		mmSetDefaultTerminationResult.mock.t.Fatalf("Inspect function is already set for ConstructionContextMock.SetTerminationResult")
	}

	mmSetDefaultTerminationResult.mock.inspectFuncSetDefaultTerminationResult = f

	return mmSetDefaultTerminationResult
}

// Return sets up results that will be returned by ConstructionContext.SetDefaultTerminationResult
func (mmSetDefaultTerminationResult *mConstructionContextMockSetDefaultTerminationResult) Return() *ConstructionContextMock {
	if mmSetDefaultTerminationResult.mock.funcSetDefaultTerminationResult != nil {
		mmSetDefaultTerminationResult.mock.t.Fatalf("ConstructionContextMock.SetTerminationResult mock is already set by Set")
	}

	if mmSetDefaultTerminationResult.defaultExpectation == nil {
		mmSetDefaultTerminationResult.defaultExpectation = &ConstructionContextMockSetDefaultTerminationResultExpectation{mock: mmSetDefaultTerminationResult.mock}
	}

	return mmSetDefaultTerminationResult.mock
}

//Set uses given function f to mock the ConstructionContext.SetDefaultTerminationResult method
func (mmSetDefaultTerminationResult *mConstructionContextMockSetDefaultTerminationResult) Set(f func(p1 interface{})) *ConstructionContextMock {
	if mmSetDefaultTerminationResult.defaultExpectation != nil {
		mmSetDefaultTerminationResult.mock.t.Fatalf("Default expectation is already set for the ConstructionContext.SetTerminationResult method")
	}

	if len(mmSetDefaultTerminationResult.expectations) > 0 {
		mmSetDefaultTerminationResult.mock.t.Fatalf("Some expectations are already set for the ConstructionContext.SetTerminationResult method")
	}

	mmSetDefaultTerminationResult.mock.funcSetDefaultTerminationResult = f
	return mmSetDefaultTerminationResult.mock
}

// SetDefaultTerminationResult implements ConstructionContext
func (mmSetDefaultTerminationResult *ConstructionContextMock) SetDefaultTerminationResult(p1 interface{}) {
	mm_atomic.AddUint64(&mmSetDefaultTerminationResult.beforeSetDefaultTerminationResultCounter, 1)
	defer mm_atomic.AddUint64(&mmSetDefaultTerminationResult.afterSetDefaultTerminationResultCounter, 1)

	if mmSetDefaultTerminationResult.inspectFuncSetDefaultTerminationResult != nil {
		mmSetDefaultTerminationResult.inspectFuncSetDefaultTerminationResult(p1)
	}

	mm_params := &ConstructionContextMockSetDefaultTerminationResultParams{p1}

	// Record call args
	mmSetDefaultTerminationResult.SetDefaultTerminationResultMock.mutex.Lock()
	mmSetDefaultTerminationResult.SetDefaultTerminationResultMock.callArgs = append(mmSetDefaultTerminationResult.SetDefaultTerminationResultMock.callArgs, mm_params)
	mmSetDefaultTerminationResult.SetDefaultTerminationResultMock.mutex.Unlock()

	for _, e := range mmSetDefaultTerminationResult.SetDefaultTerminationResultMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetDefaultTerminationResult.SetDefaultTerminationResultMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetDefaultTerminationResult.SetDefaultTerminationResultMock.defaultExpectation.Counter, 1)
		mm_want := mmSetDefaultTerminationResult.SetDefaultTerminationResultMock.defaultExpectation.params
		mm_got := ConstructionContextMockSetDefaultTerminationResultParams{p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetDefaultTerminationResult.t.Errorf("ConstructionContextMock.SetTerminationResult got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetDefaultTerminationResult.funcSetDefaultTerminationResult != nil {
		mmSetDefaultTerminationResult.funcSetDefaultTerminationResult(p1)
		return
	}
	mmSetDefaultTerminationResult.t.Fatalf("Unexpected call to ConstructionContextMock.SetTerminationResult. %v", p1)

}

// SetDefaultTerminationResultAfterCounter returns a count of finished ConstructionContextMock.SetDefaultTerminationResult invocations
func (mmSetDefaultTerminationResult *ConstructionContextMock) SetDefaultTerminationResultAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultTerminationResult.afterSetDefaultTerminationResultCounter)
}

// SetDefaultTerminationResultBeforeCounter returns a count of ConstructionContextMock.SetDefaultTerminationResult invocations
func (mmSetDefaultTerminationResult *ConstructionContextMock) SetDefaultTerminationResultBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultTerminationResult.beforeSetDefaultTerminationResultCounter)
}

// Calls returns a list of arguments used in each call to ConstructionContextMock.SetDefaultTerminationResult.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetDefaultTerminationResult *mConstructionContextMockSetDefaultTerminationResult) Calls() []*ConstructionContextMockSetDefaultTerminationResultParams {
	mmSetDefaultTerminationResult.mutex.RLock()

	argCopy := make([]*ConstructionContextMockSetDefaultTerminationResultParams, len(mmSetDefaultTerminationResult.callArgs))
	copy(argCopy, mmSetDefaultTerminationResult.callArgs)

	mmSetDefaultTerminationResult.mutex.RUnlock()

	return argCopy
}

// MinimockSetDefaultTerminationResultDone returns true if the count of the SetDefaultTerminationResult invocations corresponds
// the number of defined expectations
func (m *ConstructionContextMock) MinimockSetDefaultTerminationResultDone() bool {
	for _, e := range m.SetDefaultTerminationResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultTerminationResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultTerminationResultCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultTerminationResult != nil && mm_atomic.LoadUint64(&m.afterSetDefaultTerminationResultCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetDefaultTerminationResultInspect logs each unmet expectation
func (m *ConstructionContextMock) MinimockSetDefaultTerminationResultInspect() {
	for _, e := range m.SetDefaultTerminationResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConstructionContextMock.SetTerminationResult with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultTerminationResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDefaultTerminationResultCounter) < 1 {
		if m.SetDefaultTerminationResultMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConstructionContextMock.SetTerminationResult")
		} else {
			m.t.Errorf("Expected call to ConstructionContextMock.SetTerminationResult with params: %#v", *m.SetDefaultTerminationResultMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultTerminationResult != nil && mm_atomic.LoadUint64(&m.afterSetDefaultTerminationResultCounter) < 1 {
		m.t.Error("Expected call to ConstructionContextMock.SetTerminationResult")
	}
}

type mConstructionContextMockSetDependencyInheritanceMode struct {
	mock               *ConstructionContextMock
	defaultExpectation *ConstructionContextMockSetDependencyInheritanceModeExpectation
	expectations       []*ConstructionContextMockSetDependencyInheritanceModeExpectation

	callArgs []*ConstructionContextMockSetDependencyInheritanceModeParams
	mutex    sync.RWMutex
}

// ConstructionContextMockSetDependencyInheritanceModeExpectation specifies expectation struct of the ConstructionContext.SetDependencyInheritanceMode
type ConstructionContextMockSetDependencyInheritanceModeExpectation struct {
	mock   *ConstructionContextMock
	params *ConstructionContextMockSetDependencyInheritanceModeParams

	Counter uint64
}

// ConstructionContextMockSetDependencyInheritanceModeParams contains parameters of the ConstructionContext.SetDependencyInheritanceMode
type ConstructionContextMockSetDependencyInheritanceModeParams struct {
	d1 DependencyInheritanceMode
}

// Expect sets up expected params for ConstructionContext.SetDependencyInheritanceMode
func (mmSetDependencyInheritanceMode *mConstructionContextMockSetDependencyInheritanceMode) Expect(d1 DependencyInheritanceMode) *mConstructionContextMockSetDependencyInheritanceMode {
	if mmSetDependencyInheritanceMode.mock.funcSetDependencyInheritanceMode != nil {
		mmSetDependencyInheritanceMode.mock.t.Fatalf("ConstructionContextMock.SetDependencyInheritanceMode mock is already set by Set")
	}

	if mmSetDependencyInheritanceMode.defaultExpectation == nil {
		mmSetDependencyInheritanceMode.defaultExpectation = &ConstructionContextMockSetDependencyInheritanceModeExpectation{}
	}

	mmSetDependencyInheritanceMode.defaultExpectation.params = &ConstructionContextMockSetDependencyInheritanceModeParams{d1}
	for _, e := range mmSetDependencyInheritanceMode.expectations {
		if minimock.Equal(e.params, mmSetDependencyInheritanceMode.defaultExpectation.params) {
			mmSetDependencyInheritanceMode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetDependencyInheritanceMode.defaultExpectation.params)
		}
	}

	return mmSetDependencyInheritanceMode
}

// Inspect accepts an inspector function that has same arguments as the ConstructionContext.SetDependencyInheritanceMode
func (mmSetDependencyInheritanceMode *mConstructionContextMockSetDependencyInheritanceMode) Inspect(f func(d1 DependencyInheritanceMode)) *mConstructionContextMockSetDependencyInheritanceMode {
	if mmSetDependencyInheritanceMode.mock.inspectFuncSetDependencyInheritanceMode != nil {
		mmSetDependencyInheritanceMode.mock.t.Fatalf("Inspect function is already set for ConstructionContextMock.SetDependencyInheritanceMode")
	}

	mmSetDependencyInheritanceMode.mock.inspectFuncSetDependencyInheritanceMode = f

	return mmSetDependencyInheritanceMode
}

// Return sets up results that will be returned by ConstructionContext.SetDependencyInheritanceMode
func (mmSetDependencyInheritanceMode *mConstructionContextMockSetDependencyInheritanceMode) Return() *ConstructionContextMock {
	if mmSetDependencyInheritanceMode.mock.funcSetDependencyInheritanceMode != nil {
		mmSetDependencyInheritanceMode.mock.t.Fatalf("ConstructionContextMock.SetDependencyInheritanceMode mock is already set by Set")
	}

	if mmSetDependencyInheritanceMode.defaultExpectation == nil {
		mmSetDependencyInheritanceMode.defaultExpectation = &ConstructionContextMockSetDependencyInheritanceModeExpectation{mock: mmSetDependencyInheritanceMode.mock}
	}

	return mmSetDependencyInheritanceMode.mock
}

//Set uses given function f to mock the ConstructionContext.SetDependencyInheritanceMode method
func (mmSetDependencyInheritanceMode *mConstructionContextMockSetDependencyInheritanceMode) Set(f func(d1 DependencyInheritanceMode)) *ConstructionContextMock {
	if mmSetDependencyInheritanceMode.defaultExpectation != nil {
		mmSetDependencyInheritanceMode.mock.t.Fatalf("Default expectation is already set for the ConstructionContext.SetDependencyInheritanceMode method")
	}

	if len(mmSetDependencyInheritanceMode.expectations) > 0 {
		mmSetDependencyInheritanceMode.mock.t.Fatalf("Some expectations are already set for the ConstructionContext.SetDependencyInheritanceMode method")
	}

	mmSetDependencyInheritanceMode.mock.funcSetDependencyInheritanceMode = f
	return mmSetDependencyInheritanceMode.mock
}

// SetDependencyInheritanceMode implements ConstructionContext
func (mmSetDependencyInheritanceMode *ConstructionContextMock) SetDependencyInheritanceMode(d1 DependencyInheritanceMode) {
	mm_atomic.AddUint64(&mmSetDependencyInheritanceMode.beforeSetDependencyInheritanceModeCounter, 1)
	defer mm_atomic.AddUint64(&mmSetDependencyInheritanceMode.afterSetDependencyInheritanceModeCounter, 1)

	if mmSetDependencyInheritanceMode.inspectFuncSetDependencyInheritanceMode != nil {
		mmSetDependencyInheritanceMode.inspectFuncSetDependencyInheritanceMode(d1)
	}

	mm_params := &ConstructionContextMockSetDependencyInheritanceModeParams{d1}

	// Record call args
	mmSetDependencyInheritanceMode.SetDependencyInheritanceModeMock.mutex.Lock()
	mmSetDependencyInheritanceMode.SetDependencyInheritanceModeMock.callArgs = append(mmSetDependencyInheritanceMode.SetDependencyInheritanceModeMock.callArgs, mm_params)
	mmSetDependencyInheritanceMode.SetDependencyInheritanceModeMock.mutex.Unlock()

	for _, e := range mmSetDependencyInheritanceMode.SetDependencyInheritanceModeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetDependencyInheritanceMode.SetDependencyInheritanceModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetDependencyInheritanceMode.SetDependencyInheritanceModeMock.defaultExpectation.Counter, 1)
		mm_want := mmSetDependencyInheritanceMode.SetDependencyInheritanceModeMock.defaultExpectation.params
		mm_got := ConstructionContextMockSetDependencyInheritanceModeParams{d1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetDependencyInheritanceMode.t.Errorf("ConstructionContextMock.SetDependencyInheritanceMode got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetDependencyInheritanceMode.funcSetDependencyInheritanceMode != nil {
		mmSetDependencyInheritanceMode.funcSetDependencyInheritanceMode(d1)
		return
	}
	mmSetDependencyInheritanceMode.t.Fatalf("Unexpected call to ConstructionContextMock.SetDependencyInheritanceMode. %v", d1)

}

// SetDependencyInheritanceModeAfterCounter returns a count of finished ConstructionContextMock.SetDependencyInheritanceMode invocations
func (mmSetDependencyInheritanceMode *ConstructionContextMock) SetDependencyInheritanceModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDependencyInheritanceMode.afterSetDependencyInheritanceModeCounter)
}

// SetDependencyInheritanceModeBeforeCounter returns a count of ConstructionContextMock.SetDependencyInheritanceMode invocations
func (mmSetDependencyInheritanceMode *ConstructionContextMock) SetDependencyInheritanceModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDependencyInheritanceMode.beforeSetDependencyInheritanceModeCounter)
}

// Calls returns a list of arguments used in each call to ConstructionContextMock.SetDependencyInheritanceMode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetDependencyInheritanceMode *mConstructionContextMockSetDependencyInheritanceMode) Calls() []*ConstructionContextMockSetDependencyInheritanceModeParams {
	mmSetDependencyInheritanceMode.mutex.RLock()

	argCopy := make([]*ConstructionContextMockSetDependencyInheritanceModeParams, len(mmSetDependencyInheritanceMode.callArgs))
	copy(argCopy, mmSetDependencyInheritanceMode.callArgs)

	mmSetDependencyInheritanceMode.mutex.RUnlock()

	return argCopy
}

// MinimockSetDependencyInheritanceModeDone returns true if the count of the SetDependencyInheritanceMode invocations corresponds
// the number of defined expectations
func (m *ConstructionContextMock) MinimockSetDependencyInheritanceModeDone() bool {
	for _, e := range m.SetDependencyInheritanceModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDependencyInheritanceModeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDependencyInheritanceModeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDependencyInheritanceMode != nil && mm_atomic.LoadUint64(&m.afterSetDependencyInheritanceModeCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetDependencyInheritanceModeInspect logs each unmet expectation
func (m *ConstructionContextMock) MinimockSetDependencyInheritanceModeInspect() {
	for _, e := range m.SetDependencyInheritanceModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConstructionContextMock.SetDependencyInheritanceMode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDependencyInheritanceModeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDependencyInheritanceModeCounter) < 1 {
		if m.SetDependencyInheritanceModeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConstructionContextMock.SetDependencyInheritanceMode")
		} else {
			m.t.Errorf("Expected call to ConstructionContextMock.SetDependencyInheritanceMode with params: %#v", *m.SetDependencyInheritanceModeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDependencyInheritanceMode != nil && mm_atomic.LoadUint64(&m.afterSetDependencyInheritanceModeCounter) < 1 {
		m.t.Error("Expected call to ConstructionContextMock.SetDependencyInheritanceMode")
	}
}

type mConstructionContextMockSetLogTracing struct {
	mock               *ConstructionContextMock
	defaultExpectation *ConstructionContextMockSetLogTracingExpectation
	expectations       []*ConstructionContextMockSetLogTracingExpectation

	callArgs []*ConstructionContextMockSetLogTracingParams
	mutex    sync.RWMutex
}

// ConstructionContextMockSetLogTracingExpectation specifies expectation struct of the ConstructionContext.SetLogTracing
type ConstructionContextMockSetLogTracingExpectation struct {
	mock   *ConstructionContextMock
	params *ConstructionContextMockSetLogTracingParams

	Counter uint64
}

// ConstructionContextMockSetLogTracingParams contains parameters of the ConstructionContext.SetLogTracing
type ConstructionContextMockSetLogTracingParams struct {
	b1 bool
}

// Expect sets up expected params for ConstructionContext.SetLogTracing
func (mmSetLogTracing *mConstructionContextMockSetLogTracing) Expect(b1 bool) *mConstructionContextMockSetLogTracing {
	if mmSetLogTracing.mock.funcSetLogTracing != nil {
		mmSetLogTracing.mock.t.Fatalf("ConstructionContextMock.SetLogTracing mock is already set by Set")
	}

	if mmSetLogTracing.defaultExpectation == nil {
		mmSetLogTracing.defaultExpectation = &ConstructionContextMockSetLogTracingExpectation{}
	}

	mmSetLogTracing.defaultExpectation.params = &ConstructionContextMockSetLogTracingParams{b1}
	for _, e := range mmSetLogTracing.expectations {
		if minimock.Equal(e.params, mmSetLogTracing.defaultExpectation.params) {
			mmSetLogTracing.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetLogTracing.defaultExpectation.params)
		}
	}

	return mmSetLogTracing
}

// Inspect accepts an inspector function that has same arguments as the ConstructionContext.SetLogTracing
func (mmSetLogTracing *mConstructionContextMockSetLogTracing) Inspect(f func(b1 bool)) *mConstructionContextMockSetLogTracing {
	if mmSetLogTracing.mock.inspectFuncSetLogTracing != nil {
		mmSetLogTracing.mock.t.Fatalf("Inspect function is already set for ConstructionContextMock.SetLogTracing")
	}

	mmSetLogTracing.mock.inspectFuncSetLogTracing = f

	return mmSetLogTracing
}

// Return sets up results that will be returned by ConstructionContext.SetLogTracing
func (mmSetLogTracing *mConstructionContextMockSetLogTracing) Return() *ConstructionContextMock {
	if mmSetLogTracing.mock.funcSetLogTracing != nil {
		mmSetLogTracing.mock.t.Fatalf("ConstructionContextMock.SetLogTracing mock is already set by Set")
	}

	if mmSetLogTracing.defaultExpectation == nil {
		mmSetLogTracing.defaultExpectation = &ConstructionContextMockSetLogTracingExpectation{mock: mmSetLogTracing.mock}
	}

	return mmSetLogTracing.mock
}

//Set uses given function f to mock the ConstructionContext.SetLogTracing method
func (mmSetLogTracing *mConstructionContextMockSetLogTracing) Set(f func(b1 bool)) *ConstructionContextMock {
	if mmSetLogTracing.defaultExpectation != nil {
		mmSetLogTracing.mock.t.Fatalf("Default expectation is already set for the ConstructionContext.SetLogTracing method")
	}

	if len(mmSetLogTracing.expectations) > 0 {
		mmSetLogTracing.mock.t.Fatalf("Some expectations are already set for the ConstructionContext.SetLogTracing method")
	}

	mmSetLogTracing.mock.funcSetLogTracing = f
	return mmSetLogTracing.mock
}

// SetLogTracing implements ConstructionContext
func (mmSetLogTracing *ConstructionContextMock) SetLogTracing(b1 bool) {
	mm_atomic.AddUint64(&mmSetLogTracing.beforeSetLogTracingCounter, 1)
	defer mm_atomic.AddUint64(&mmSetLogTracing.afterSetLogTracingCounter, 1)

	if mmSetLogTracing.inspectFuncSetLogTracing != nil {
		mmSetLogTracing.inspectFuncSetLogTracing(b1)
	}

	mm_params := &ConstructionContextMockSetLogTracingParams{b1}

	// Record call args
	mmSetLogTracing.SetLogTracingMock.mutex.Lock()
	mmSetLogTracing.SetLogTracingMock.callArgs = append(mmSetLogTracing.SetLogTracingMock.callArgs, mm_params)
	mmSetLogTracing.SetLogTracingMock.mutex.Unlock()

	for _, e := range mmSetLogTracing.SetLogTracingMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetLogTracing.SetLogTracingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetLogTracing.SetLogTracingMock.defaultExpectation.Counter, 1)
		mm_want := mmSetLogTracing.SetLogTracingMock.defaultExpectation.params
		mm_got := ConstructionContextMockSetLogTracingParams{b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetLogTracing.t.Errorf("ConstructionContextMock.SetLogTracing got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetLogTracing.funcSetLogTracing != nil {
		mmSetLogTracing.funcSetLogTracing(b1)
		return
	}
	mmSetLogTracing.t.Fatalf("Unexpected call to ConstructionContextMock.SetLogTracing. %v", b1)

}

// SetLogTracingAfterCounter returns a count of finished ConstructionContextMock.SetLogTracing invocations
func (mmSetLogTracing *ConstructionContextMock) SetLogTracingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetLogTracing.afterSetLogTracingCounter)
}

// SetLogTracingBeforeCounter returns a count of ConstructionContextMock.SetLogTracing invocations
func (mmSetLogTracing *ConstructionContextMock) SetLogTracingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetLogTracing.beforeSetLogTracingCounter)
}

// Calls returns a list of arguments used in each call to ConstructionContextMock.SetLogTracing.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetLogTracing *mConstructionContextMockSetLogTracing) Calls() []*ConstructionContextMockSetLogTracingParams {
	mmSetLogTracing.mutex.RLock()

	argCopy := make([]*ConstructionContextMockSetLogTracingParams, len(mmSetLogTracing.callArgs))
	copy(argCopy, mmSetLogTracing.callArgs)

	mmSetLogTracing.mutex.RUnlock()

	return argCopy
}

// MinimockSetLogTracingDone returns true if the count of the SetLogTracing invocations corresponds
// the number of defined expectations
func (m *ConstructionContextMock) MinimockSetLogTracingDone() bool {
	for _, e := range m.SetLogTracingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetLogTracingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetLogTracingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetLogTracing != nil && mm_atomic.LoadUint64(&m.afterSetLogTracingCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetLogTracingInspect logs each unmet expectation
func (m *ConstructionContextMock) MinimockSetLogTracingInspect() {
	for _, e := range m.SetLogTracingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConstructionContextMock.SetLogTracing with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetLogTracingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetLogTracingCounter) < 1 {
		if m.SetLogTracingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConstructionContextMock.SetLogTracing")
		} else {
			m.t.Errorf("Expected call to ConstructionContextMock.SetLogTracing with params: %#v", *m.SetLogTracingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetLogTracing != nil && mm_atomic.LoadUint64(&m.afterSetLogTracingCounter) < 1 {
		m.t.Error("Expected call to ConstructionContextMock.SetLogTracing")
	}
}

type mConstructionContextMockSetParentLink struct {
	mock               *ConstructionContextMock
	defaultExpectation *ConstructionContextMockSetParentLinkExpectation
	expectations       []*ConstructionContextMockSetParentLinkExpectation

	callArgs []*ConstructionContextMockSetParentLinkParams
	mutex    sync.RWMutex
}

// ConstructionContextMockSetParentLinkExpectation specifies expectation struct of the ConstructionContext.SetParentLink
type ConstructionContextMockSetParentLinkExpectation struct {
	mock   *ConstructionContextMock
	params *ConstructionContextMockSetParentLinkParams

	Counter uint64
}

// ConstructionContextMockSetParentLinkParams contains parameters of the ConstructionContext.SetParentLink
type ConstructionContextMockSetParentLinkParams struct {
	s1 SlotLink
}

// Expect sets up expected params for ConstructionContext.SetParentLink
func (mmSetParentLink *mConstructionContextMockSetParentLink) Expect(s1 SlotLink) *mConstructionContextMockSetParentLink {
	if mmSetParentLink.mock.funcSetParentLink != nil {
		mmSetParentLink.mock.t.Fatalf("ConstructionContextMock.SetParentLink mock is already set by Set")
	}

	if mmSetParentLink.defaultExpectation == nil {
		mmSetParentLink.defaultExpectation = &ConstructionContextMockSetParentLinkExpectation{}
	}

	mmSetParentLink.defaultExpectation.params = &ConstructionContextMockSetParentLinkParams{s1}
	for _, e := range mmSetParentLink.expectations {
		if minimock.Equal(e.params, mmSetParentLink.defaultExpectation.params) {
			mmSetParentLink.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetParentLink.defaultExpectation.params)
		}
	}

	return mmSetParentLink
}

// Inspect accepts an inspector function that has same arguments as the ConstructionContext.SetParentLink
func (mmSetParentLink *mConstructionContextMockSetParentLink) Inspect(f func(s1 SlotLink)) *mConstructionContextMockSetParentLink {
	if mmSetParentLink.mock.inspectFuncSetParentLink != nil {
		mmSetParentLink.mock.t.Fatalf("Inspect function is already set for ConstructionContextMock.SetParentLink")
	}

	mmSetParentLink.mock.inspectFuncSetParentLink = f

	return mmSetParentLink
}

// Return sets up results that will be returned by ConstructionContext.SetParentLink
func (mmSetParentLink *mConstructionContextMockSetParentLink) Return() *ConstructionContextMock {
	if mmSetParentLink.mock.funcSetParentLink != nil {
		mmSetParentLink.mock.t.Fatalf("ConstructionContextMock.SetParentLink mock is already set by Set")
	}

	if mmSetParentLink.defaultExpectation == nil {
		mmSetParentLink.defaultExpectation = &ConstructionContextMockSetParentLinkExpectation{mock: mmSetParentLink.mock}
	}

	return mmSetParentLink.mock
}

//Set uses given function f to mock the ConstructionContext.SetParentLink method
func (mmSetParentLink *mConstructionContextMockSetParentLink) Set(f func(s1 SlotLink)) *ConstructionContextMock {
	if mmSetParentLink.defaultExpectation != nil {
		mmSetParentLink.mock.t.Fatalf("Default expectation is already set for the ConstructionContext.SetParentLink method")
	}

	if len(mmSetParentLink.expectations) > 0 {
		mmSetParentLink.mock.t.Fatalf("Some expectations are already set for the ConstructionContext.SetParentLink method")
	}

	mmSetParentLink.mock.funcSetParentLink = f
	return mmSetParentLink.mock
}

// SetParentLink implements ConstructionContext
func (mmSetParentLink *ConstructionContextMock) SetParentLink(s1 SlotLink) {
	mm_atomic.AddUint64(&mmSetParentLink.beforeSetParentLinkCounter, 1)
	defer mm_atomic.AddUint64(&mmSetParentLink.afterSetParentLinkCounter, 1)

	if mmSetParentLink.inspectFuncSetParentLink != nil {
		mmSetParentLink.inspectFuncSetParentLink(s1)
	}

	mm_params := &ConstructionContextMockSetParentLinkParams{s1}

	// Record call args
	mmSetParentLink.SetParentLinkMock.mutex.Lock()
	mmSetParentLink.SetParentLinkMock.callArgs = append(mmSetParentLink.SetParentLinkMock.callArgs, mm_params)
	mmSetParentLink.SetParentLinkMock.mutex.Unlock()

	for _, e := range mmSetParentLink.SetParentLinkMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetParentLink.SetParentLinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetParentLink.SetParentLinkMock.defaultExpectation.Counter, 1)
		mm_want := mmSetParentLink.SetParentLinkMock.defaultExpectation.params
		mm_got := ConstructionContextMockSetParentLinkParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetParentLink.t.Errorf("ConstructionContextMock.SetParentLink got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetParentLink.funcSetParentLink != nil {
		mmSetParentLink.funcSetParentLink(s1)
		return
	}
	mmSetParentLink.t.Fatalf("Unexpected call to ConstructionContextMock.SetParentLink. %v", s1)

}

// SetParentLinkAfterCounter returns a count of finished ConstructionContextMock.SetParentLink invocations
func (mmSetParentLink *ConstructionContextMock) SetParentLinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetParentLink.afterSetParentLinkCounter)
}

// SetParentLinkBeforeCounter returns a count of ConstructionContextMock.SetParentLink invocations
func (mmSetParentLink *ConstructionContextMock) SetParentLinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetParentLink.beforeSetParentLinkCounter)
}

// Calls returns a list of arguments used in each call to ConstructionContextMock.SetParentLink.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetParentLink *mConstructionContextMockSetParentLink) Calls() []*ConstructionContextMockSetParentLinkParams {
	mmSetParentLink.mutex.RLock()

	argCopy := make([]*ConstructionContextMockSetParentLinkParams, len(mmSetParentLink.callArgs))
	copy(argCopy, mmSetParentLink.callArgs)

	mmSetParentLink.mutex.RUnlock()

	return argCopy
}

// MinimockSetParentLinkDone returns true if the count of the SetParentLink invocations corresponds
// the number of defined expectations
func (m *ConstructionContextMock) MinimockSetParentLinkDone() bool {
	for _, e := range m.SetParentLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetParentLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetParentLinkCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetParentLink != nil && mm_atomic.LoadUint64(&m.afterSetParentLinkCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetParentLinkInspect logs each unmet expectation
func (m *ConstructionContextMock) MinimockSetParentLinkInspect() {
	for _, e := range m.SetParentLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConstructionContextMock.SetParentLink with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetParentLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetParentLinkCounter) < 1 {
		if m.SetParentLinkMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConstructionContextMock.SetParentLink")
		} else {
			m.t.Errorf("Expected call to ConstructionContextMock.SetParentLink with params: %#v", *m.SetParentLinkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetParentLink != nil && mm_atomic.LoadUint64(&m.afterSetParentLinkCounter) < 1 {
		m.t.Error("Expected call to ConstructionContextMock.SetParentLink")
	}
}

type mConstructionContextMockSetTerminationCallback struct {
	mock               *ConstructionContextMock
	defaultExpectation *ConstructionContextMockSetTerminationCallbackExpectation
	expectations       []*ConstructionContextMockSetTerminationCallbackExpectation

	callArgs []*ConstructionContextMockSetTerminationCallbackParams
	mutex    sync.RWMutex
}

// ConstructionContextMockSetTerminationCallbackExpectation specifies expectation struct of the ConstructionContext.SetTerminationCallback
type ConstructionContextMockSetTerminationCallbackExpectation struct {
	mock   *ConstructionContextMock
	params *ConstructionContextMockSetTerminationCallbackParams

	Counter uint64
}

// ConstructionContextMockSetTerminationCallbackParams contains parameters of the ConstructionContext.SetTerminationCallback
type ConstructionContextMockSetTerminationCallbackParams struct {
	receiver    ExecutionContext
	getResultFn TerminationCallbackFunc
}

// Expect sets up expected params for ConstructionContext.SetTerminationCallback
func (mmSetTerminationCallback *mConstructionContextMockSetTerminationCallback) Expect(receiver ExecutionContext, getResultFn TerminationCallbackFunc) *mConstructionContextMockSetTerminationCallback {
	if mmSetTerminationCallback.mock.funcSetTerminationCallback != nil {
		mmSetTerminationCallback.mock.t.Fatalf("ConstructionContextMock.SetTerminationCallback mock is already set by Set")
	}

	if mmSetTerminationCallback.defaultExpectation == nil {
		mmSetTerminationCallback.defaultExpectation = &ConstructionContextMockSetTerminationCallbackExpectation{}
	}

	mmSetTerminationCallback.defaultExpectation.params = &ConstructionContextMockSetTerminationCallbackParams{receiver, getResultFn}
	for _, e := range mmSetTerminationCallback.expectations {
		if minimock.Equal(e.params, mmSetTerminationCallback.defaultExpectation.params) {
			mmSetTerminationCallback.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetTerminationCallback.defaultExpectation.params)
		}
	}

	return mmSetTerminationCallback
}

// Inspect accepts an inspector function that has same arguments as the ConstructionContext.SetTerminationCallback
func (mmSetTerminationCallback *mConstructionContextMockSetTerminationCallback) Inspect(f func(receiver ExecutionContext, getResultFn TerminationCallbackFunc)) *mConstructionContextMockSetTerminationCallback {
	if mmSetTerminationCallback.mock.inspectFuncSetTerminationCallback != nil {
		mmSetTerminationCallback.mock.t.Fatalf("Inspect function is already set for ConstructionContextMock.SetTerminationCallback")
	}

	mmSetTerminationCallback.mock.inspectFuncSetTerminationCallback = f

	return mmSetTerminationCallback
}

// Return sets up results that will be returned by ConstructionContext.SetTerminationCallback
func (mmSetTerminationCallback *mConstructionContextMockSetTerminationCallback) Return() *ConstructionContextMock {
	if mmSetTerminationCallback.mock.funcSetTerminationCallback != nil {
		mmSetTerminationCallback.mock.t.Fatalf("ConstructionContextMock.SetTerminationCallback mock is already set by Set")
	}

	if mmSetTerminationCallback.defaultExpectation == nil {
		mmSetTerminationCallback.defaultExpectation = &ConstructionContextMockSetTerminationCallbackExpectation{mock: mmSetTerminationCallback.mock}
	}

	return mmSetTerminationCallback.mock
}

//Set uses given function f to mock the ConstructionContext.SetTerminationCallback method
func (mmSetTerminationCallback *mConstructionContextMockSetTerminationCallback) Set(f func(receiver ExecutionContext, getResultFn TerminationCallbackFunc)) *ConstructionContextMock {
	if mmSetTerminationCallback.defaultExpectation != nil {
		mmSetTerminationCallback.mock.t.Fatalf("Default expectation is already set for the ConstructionContext.SetTerminationCallback method")
	}

	if len(mmSetTerminationCallback.expectations) > 0 {
		mmSetTerminationCallback.mock.t.Fatalf("Some expectations are already set for the ConstructionContext.SetTerminationCallback method")
	}

	mmSetTerminationCallback.mock.funcSetTerminationCallback = f
	return mmSetTerminationCallback.mock
}

// SetTerminationCallback implements ConstructionContext
func (mmSetTerminationCallback *ConstructionContextMock) SetTerminationCallback(receiver ExecutionContext, getResultFn TerminationCallbackFunc) {
	mm_atomic.AddUint64(&mmSetTerminationCallback.beforeSetTerminationCallbackCounter, 1)
	defer mm_atomic.AddUint64(&mmSetTerminationCallback.afterSetTerminationCallbackCounter, 1)

	if mmSetTerminationCallback.inspectFuncSetTerminationCallback != nil {
		mmSetTerminationCallback.inspectFuncSetTerminationCallback(receiver, getResultFn)
	}

	mm_params := &ConstructionContextMockSetTerminationCallbackParams{receiver, getResultFn}

	// Record call args
	mmSetTerminationCallback.SetTerminationCallbackMock.mutex.Lock()
	mmSetTerminationCallback.SetTerminationCallbackMock.callArgs = append(mmSetTerminationCallback.SetTerminationCallbackMock.callArgs, mm_params)
	mmSetTerminationCallback.SetTerminationCallbackMock.mutex.Unlock()

	for _, e := range mmSetTerminationCallback.SetTerminationCallbackMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetTerminationCallback.SetTerminationCallbackMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetTerminationCallback.SetTerminationCallbackMock.defaultExpectation.Counter, 1)
		mm_want := mmSetTerminationCallback.SetTerminationCallbackMock.defaultExpectation.params
		mm_got := ConstructionContextMockSetTerminationCallbackParams{receiver, getResultFn}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetTerminationCallback.t.Errorf("ConstructionContextMock.SetTerminationCallback got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetTerminationCallback.funcSetTerminationCallback != nil {
		mmSetTerminationCallback.funcSetTerminationCallback(receiver, getResultFn)
		return
	}
	mmSetTerminationCallback.t.Fatalf("Unexpected call to ConstructionContextMock.SetTerminationCallback. %v %v", receiver, getResultFn)

}

// SetTerminationCallbackAfterCounter returns a count of finished ConstructionContextMock.SetTerminationCallback invocations
func (mmSetTerminationCallback *ConstructionContextMock) SetTerminationCallbackAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTerminationCallback.afterSetTerminationCallbackCounter)
}

// SetTerminationCallbackBeforeCounter returns a count of ConstructionContextMock.SetTerminationCallback invocations
func (mmSetTerminationCallback *ConstructionContextMock) SetTerminationCallbackBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTerminationCallback.beforeSetTerminationCallbackCounter)
}

// Calls returns a list of arguments used in each call to ConstructionContextMock.SetTerminationCallback.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetTerminationCallback *mConstructionContextMockSetTerminationCallback) Calls() []*ConstructionContextMockSetTerminationCallbackParams {
	mmSetTerminationCallback.mutex.RLock()

	argCopy := make([]*ConstructionContextMockSetTerminationCallbackParams, len(mmSetTerminationCallback.callArgs))
	copy(argCopy, mmSetTerminationCallback.callArgs)

	mmSetTerminationCallback.mutex.RUnlock()

	return argCopy
}

// MinimockSetTerminationCallbackDone returns true if the count of the SetTerminationCallback invocations corresponds
// the number of defined expectations
func (m *ConstructionContextMock) MinimockSetTerminationCallbackDone() bool {
	for _, e := range m.SetTerminationCallbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTerminationCallbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTerminationCallbackCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTerminationCallback != nil && mm_atomic.LoadUint64(&m.afterSetTerminationCallbackCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetTerminationCallbackInspect logs each unmet expectation
func (m *ConstructionContextMock) MinimockSetTerminationCallbackInspect() {
	for _, e := range m.SetTerminationCallbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConstructionContextMock.SetTerminationCallback with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTerminationCallbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTerminationCallbackCounter) < 1 {
		if m.SetTerminationCallbackMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConstructionContextMock.SetTerminationCallback")
		} else {
			m.t.Errorf("Expected call to ConstructionContextMock.SetTerminationCallback with params: %#v", *m.SetTerminationCallbackMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTerminationCallback != nil && mm_atomic.LoadUint64(&m.afterSetTerminationCallbackCounter) < 1 {
		m.t.Error("Expected call to ConstructionContextMock.SetTerminationCallback")
	}
}

type mConstructionContextMockSetTracerID struct {
	mock               *ConstructionContextMock
	defaultExpectation *ConstructionContextMockSetTracerIDExpectation
	expectations       []*ConstructionContextMockSetTracerIDExpectation

	callArgs []*ConstructionContextMockSetTracerIDParams
	mutex    sync.RWMutex
}

// ConstructionContextMockSetTracerIDExpectation specifies expectation struct of the ConstructionContext.SetTracerID
type ConstructionContextMockSetTracerIDExpectation struct {
	mock   *ConstructionContextMock
	params *ConstructionContextMockSetTracerIDParams

	Counter uint64
}

// ConstructionContextMockSetTracerIDParams contains parameters of the ConstructionContext.SetTracerID
type ConstructionContextMockSetTracerIDParams struct {
	t1 TracerID
}

// Expect sets up expected params for ConstructionContext.SetTracerID
func (mmSetTracerID *mConstructionContextMockSetTracerID) Expect(t1 TracerID) *mConstructionContextMockSetTracerID {
	if mmSetTracerID.mock.funcSetTracerID != nil {
		mmSetTracerID.mock.t.Fatalf("ConstructionContextMock.SetTracerID mock is already set by Set")
	}

	if mmSetTracerID.defaultExpectation == nil {
		mmSetTracerID.defaultExpectation = &ConstructionContextMockSetTracerIDExpectation{}
	}

	mmSetTracerID.defaultExpectation.params = &ConstructionContextMockSetTracerIDParams{t1}
	for _, e := range mmSetTracerID.expectations {
		if minimock.Equal(e.params, mmSetTracerID.defaultExpectation.params) {
			mmSetTracerID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetTracerID.defaultExpectation.params)
		}
	}

	return mmSetTracerID
}

// Inspect accepts an inspector function that has same arguments as the ConstructionContext.SetTracerID
func (mmSetTracerID *mConstructionContextMockSetTracerID) Inspect(f func(t1 TracerID)) *mConstructionContextMockSetTracerID {
	if mmSetTracerID.mock.inspectFuncSetTracerID != nil {
		mmSetTracerID.mock.t.Fatalf("Inspect function is already set for ConstructionContextMock.SetTracerID")
	}

	mmSetTracerID.mock.inspectFuncSetTracerID = f

	return mmSetTracerID
}

// Return sets up results that will be returned by ConstructionContext.SetTracerID
func (mmSetTracerID *mConstructionContextMockSetTracerID) Return() *ConstructionContextMock {
	if mmSetTracerID.mock.funcSetTracerID != nil {
		mmSetTracerID.mock.t.Fatalf("ConstructionContextMock.SetTracerID mock is already set by Set")
	}

	if mmSetTracerID.defaultExpectation == nil {
		mmSetTracerID.defaultExpectation = &ConstructionContextMockSetTracerIDExpectation{mock: mmSetTracerID.mock}
	}

	return mmSetTracerID.mock
}

//Set uses given function f to mock the ConstructionContext.SetTracerID method
func (mmSetTracerID *mConstructionContextMockSetTracerID) Set(f func(t1 TracerID)) *ConstructionContextMock {
	if mmSetTracerID.defaultExpectation != nil {
		mmSetTracerID.mock.t.Fatalf("Default expectation is already set for the ConstructionContext.SetTracerID method")
	}

	if len(mmSetTracerID.expectations) > 0 {
		mmSetTracerID.mock.t.Fatalf("Some expectations are already set for the ConstructionContext.SetTracerID method")
	}

	mmSetTracerID.mock.funcSetTracerID = f
	return mmSetTracerID.mock
}

// SetTracerID implements ConstructionContext
func (mmSetTracerID *ConstructionContextMock) SetTracerID(t1 TracerID) {
	mm_atomic.AddUint64(&mmSetTracerID.beforeSetTracerIDCounter, 1)
	defer mm_atomic.AddUint64(&mmSetTracerID.afterSetTracerIDCounter, 1)

	if mmSetTracerID.inspectFuncSetTracerID != nil {
		mmSetTracerID.inspectFuncSetTracerID(t1)
	}

	mm_params := &ConstructionContextMockSetTracerIDParams{t1}

	// Record call args
	mmSetTracerID.SetTracerIDMock.mutex.Lock()
	mmSetTracerID.SetTracerIDMock.callArgs = append(mmSetTracerID.SetTracerIDMock.callArgs, mm_params)
	mmSetTracerID.SetTracerIDMock.mutex.Unlock()

	for _, e := range mmSetTracerID.SetTracerIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetTracerID.SetTracerIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetTracerID.SetTracerIDMock.defaultExpectation.Counter, 1)
		mm_want := mmSetTracerID.SetTracerIDMock.defaultExpectation.params
		mm_got := ConstructionContextMockSetTracerIDParams{t1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetTracerID.t.Errorf("ConstructionContextMock.SetTracerID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetTracerID.funcSetTracerID != nil {
		mmSetTracerID.funcSetTracerID(t1)
		return
	}
	mmSetTracerID.t.Fatalf("Unexpected call to ConstructionContextMock.SetTracerID. %v", t1)

}

// SetTracerIDAfterCounter returns a count of finished ConstructionContextMock.SetTracerID invocations
func (mmSetTracerID *ConstructionContextMock) SetTracerIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTracerID.afterSetTracerIDCounter)
}

// SetTracerIDBeforeCounter returns a count of ConstructionContextMock.SetTracerID invocations
func (mmSetTracerID *ConstructionContextMock) SetTracerIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTracerID.beforeSetTracerIDCounter)
}

// Calls returns a list of arguments used in each call to ConstructionContextMock.SetTracerID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetTracerID *mConstructionContextMockSetTracerID) Calls() []*ConstructionContextMockSetTracerIDParams {
	mmSetTracerID.mutex.RLock()

	argCopy := make([]*ConstructionContextMockSetTracerIDParams, len(mmSetTracerID.callArgs))
	copy(argCopy, mmSetTracerID.callArgs)

	mmSetTracerID.mutex.RUnlock()

	return argCopy
}

// MinimockSetTracerIDDone returns true if the count of the SetTracerID invocations corresponds
// the number of defined expectations
func (m *ConstructionContextMock) MinimockSetTracerIDDone() bool {
	for _, e := range m.SetTracerIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTracerIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTracerIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTracerID != nil && mm_atomic.LoadUint64(&m.afterSetTracerIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetTracerIDInspect logs each unmet expectation
func (m *ConstructionContextMock) MinimockSetTracerIDInspect() {
	for _, e := range m.SetTracerIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConstructionContextMock.SetTracerID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTracerIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTracerIDCounter) < 1 {
		if m.SetTracerIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConstructionContextMock.SetTracerID")
		} else {
			m.t.Errorf("Expected call to ConstructionContextMock.SetTracerID with params: %#v", *m.SetTracerIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTracerID != nil && mm_atomic.LoadUint64(&m.afterSetTracerIDCounter) < 1 {
		m.t.Error("Expected call to ConstructionContextMock.SetTracerID")
	}
}

type mConstructionContextMockSlotLink struct {
	mock               *ConstructionContextMock
	defaultExpectation *ConstructionContextMockSlotLinkExpectation
	expectations       []*ConstructionContextMockSlotLinkExpectation
}

// ConstructionContextMockSlotLinkExpectation specifies expectation struct of the ConstructionContext.SlotLink
type ConstructionContextMockSlotLinkExpectation struct {
	mock *ConstructionContextMock

	results *ConstructionContextMockSlotLinkResults
	Counter uint64
}

// ConstructionContextMockSlotLinkResults contains results of the ConstructionContext.SlotLink
type ConstructionContextMockSlotLinkResults struct {
	s1 SlotLink
}

// Expect sets up expected params for ConstructionContext.SlotLink
func (mmSlotLink *mConstructionContextMockSlotLink) Expect() *mConstructionContextMockSlotLink {
	if mmSlotLink.mock.funcSlotLink != nil {
		mmSlotLink.mock.t.Fatalf("ConstructionContextMock.SlotLink mock is already set by Set")
	}

	if mmSlotLink.defaultExpectation == nil {
		mmSlotLink.defaultExpectation = &ConstructionContextMockSlotLinkExpectation{}
	}

	return mmSlotLink
}

// Inspect accepts an inspector function that has same arguments as the ConstructionContext.SlotLink
func (mmSlotLink *mConstructionContextMockSlotLink) Inspect(f func()) *mConstructionContextMockSlotLink {
	if mmSlotLink.mock.inspectFuncSlotLink != nil {
		mmSlotLink.mock.t.Fatalf("Inspect function is already set for ConstructionContextMock.SlotLink")
	}

	mmSlotLink.mock.inspectFuncSlotLink = f

	return mmSlotLink
}

// Return sets up results that will be returned by ConstructionContext.SlotLink
func (mmSlotLink *mConstructionContextMockSlotLink) Return(s1 SlotLink) *ConstructionContextMock {
	if mmSlotLink.mock.funcSlotLink != nil {
		mmSlotLink.mock.t.Fatalf("ConstructionContextMock.SlotLink mock is already set by Set")
	}

	if mmSlotLink.defaultExpectation == nil {
		mmSlotLink.defaultExpectation = &ConstructionContextMockSlotLinkExpectation{mock: mmSlotLink.mock}
	}
	mmSlotLink.defaultExpectation.results = &ConstructionContextMockSlotLinkResults{s1}
	return mmSlotLink.mock
}

//Set uses given function f to mock the ConstructionContext.SlotLink method
func (mmSlotLink *mConstructionContextMockSlotLink) Set(f func() (s1 SlotLink)) *ConstructionContextMock {
	if mmSlotLink.defaultExpectation != nil {
		mmSlotLink.mock.t.Fatalf("Default expectation is already set for the ConstructionContext.SlotLink method")
	}

	if len(mmSlotLink.expectations) > 0 {
		mmSlotLink.mock.t.Fatalf("Some expectations are already set for the ConstructionContext.SlotLink method")
	}

	mmSlotLink.mock.funcSlotLink = f
	return mmSlotLink.mock
}

// SlotLink implements ConstructionContext
func (mmSlotLink *ConstructionContextMock) SlotLink() (s1 SlotLink) {
	mm_atomic.AddUint64(&mmSlotLink.beforeSlotLinkCounter, 1)
	defer mm_atomic.AddUint64(&mmSlotLink.afterSlotLinkCounter, 1)

	if mmSlotLink.inspectFuncSlotLink != nil {
		mmSlotLink.inspectFuncSlotLink()
	}

	if mmSlotLink.SlotLinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSlotLink.SlotLinkMock.defaultExpectation.Counter, 1)

		mm_results := mmSlotLink.SlotLinkMock.defaultExpectation.results
		if mm_results == nil {
			mmSlotLink.t.Fatal("No results are set for the ConstructionContextMock.SlotLink")
		}
		return (*mm_results).s1
	}
	if mmSlotLink.funcSlotLink != nil {
		return mmSlotLink.funcSlotLink()
	}
	mmSlotLink.t.Fatalf("Unexpected call to ConstructionContextMock.SlotLink.")
	return
}

// SlotLinkAfterCounter returns a count of finished ConstructionContextMock.SlotLink invocations
func (mmSlotLink *ConstructionContextMock) SlotLinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSlotLink.afterSlotLinkCounter)
}

// SlotLinkBeforeCounter returns a count of ConstructionContextMock.SlotLink invocations
func (mmSlotLink *ConstructionContextMock) SlotLinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSlotLink.beforeSlotLinkCounter)
}

// MinimockSlotLinkDone returns true if the count of the SlotLink invocations corresponds
// the number of defined expectations
func (m *ConstructionContextMock) MinimockSlotLinkDone() bool {
	for _, e := range m.SlotLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SlotLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSlotLinkCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSlotLink != nil && mm_atomic.LoadUint64(&m.afterSlotLinkCounter) < 1 {
		return false
	}
	return true
}

// MinimockSlotLinkInspect logs each unmet expectation
func (m *ConstructionContextMock) MinimockSlotLinkInspect() {
	for _, e := range m.SlotLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConstructionContextMock.SlotLink")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SlotLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSlotLinkCounter) < 1 {
		m.t.Error("Expected call to ConstructionContextMock.SlotLink")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSlotLink != nil && mm_atomic.LoadUint64(&m.afterSlotLinkCounter) < 1 {
		m.t.Error("Expected call to ConstructionContextMock.SlotLink")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ConstructionContextMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetContextInspect()

		m.MinimockOverrideDependencyInspect()

		m.MinimockParentLinkInspect()

		m.MinimockSetContextInspect()

		m.MinimockSetDefaultTerminationResultInspect()

		m.MinimockSetDependencyInheritanceModeInspect()

		m.MinimockSetLogTracingInspect()

		m.MinimockSetParentLinkInspect()

		m.MinimockSetTerminationCallbackInspect()

		m.MinimockSetTracerIDInspect()

		m.MinimockSlotLinkInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ConstructionContextMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ConstructionContextMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetContextDone() &&
		m.MinimockOverrideDependencyDone() &&
		m.MinimockParentLinkDone() &&
		m.MinimockSetContextDone() &&
		m.MinimockSetDefaultTerminationResultDone() &&
		m.MinimockSetDependencyInheritanceModeDone() &&
		m.MinimockSetLogTracingDone() &&
		m.MinimockSetParentLinkDone() &&
		m.MinimockSetTerminationCallbackDone() &&
		m.MinimockSetTracerIDDone() &&
		m.MinimockSlotLinkDone()
}
