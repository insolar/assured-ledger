package smachine

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// BargeInBuilderMock implements BargeInBuilder
type BargeInBuilderMock struct {
	t minimock.Tester

	funcWithError          func(e1 error) (b1 BargeIn)
	inspectFuncWithError   func(e1 error)
	afterWithErrorCounter  uint64
	beforeWithErrorCounter uint64
	WithErrorMock          mBargeInBuilderMockWithError

	funcWithJump          func(s1 StateFunc) (b1 BargeIn)
	inspectFuncWithJump   func(s1 StateFunc)
	afterWithJumpCounter  uint64
	beforeWithJumpCounter uint64
	WithJumpMock          mBargeInBuilderMockWithJump

	funcWithJumpExt          func(s1 SlotStep) (b1 BargeIn)
	inspectFuncWithJumpExt   func(s1 SlotStep)
	afterWithJumpExtCounter  uint64
	beforeWithJumpExtCounter uint64
	WithJumpExtMock          mBargeInBuilderMockWithJumpExt

	funcWithStop          func() (b1 BargeIn)
	inspectFuncWithStop   func()
	afterWithStopCounter  uint64
	beforeWithStopCounter uint64
	WithStopMock          mBargeInBuilderMockWithStop

	funcWithWakeUp          func() (b1 BargeIn)
	inspectFuncWithWakeUp   func()
	afterWithWakeUpCounter  uint64
	beforeWithWakeUpCounter uint64
	WithWakeUpMock          mBargeInBuilderMockWithWakeUp
}

// NewBargeInBuilderMock returns a mock for BargeInBuilder
func NewBargeInBuilderMock(t minimock.Tester) *BargeInBuilderMock {
	m := &BargeInBuilderMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.WithErrorMock = mBargeInBuilderMockWithError{mock: m}
	m.WithErrorMock.callArgs = []*BargeInBuilderMockWithErrorParams{}

	m.WithJumpMock = mBargeInBuilderMockWithJump{mock: m}
	m.WithJumpMock.callArgs = []*BargeInBuilderMockWithJumpParams{}

	m.WithJumpExtMock = mBargeInBuilderMockWithJumpExt{mock: m}
	m.WithJumpExtMock.callArgs = []*BargeInBuilderMockWithJumpExtParams{}

	m.WithStopMock = mBargeInBuilderMockWithStop{mock: m}

	m.WithWakeUpMock = mBargeInBuilderMockWithWakeUp{mock: m}

	return m
}

type mBargeInBuilderMockWithError struct {
	mock               *BargeInBuilderMock
	defaultExpectation *BargeInBuilderMockWithErrorExpectation
	expectations       []*BargeInBuilderMockWithErrorExpectation

	callArgs []*BargeInBuilderMockWithErrorParams
	mutex    sync.RWMutex
}

// BargeInBuilderMockWithErrorExpectation specifies expectation struct of the BargeInBuilder.WithError
type BargeInBuilderMockWithErrorExpectation struct {
	mock    *BargeInBuilderMock
	params  *BargeInBuilderMockWithErrorParams
	results *BargeInBuilderMockWithErrorResults
	Counter uint64
}

// BargeInBuilderMockWithErrorParams contains parameters of the BargeInBuilder.WithError
type BargeInBuilderMockWithErrorParams struct {
	e1 error
}

// BargeInBuilderMockWithErrorResults contains results of the BargeInBuilder.WithError
type BargeInBuilderMockWithErrorResults struct {
	b1 BargeIn
}

// Expect sets up expected params for BargeInBuilder.WithError
func (mmWithError *mBargeInBuilderMockWithError) Expect(e1 error) *mBargeInBuilderMockWithError {
	if mmWithError.mock.funcWithError != nil {
		mmWithError.mock.t.Fatalf("BargeInBuilderMock.WithError mock is already set by Set")
	}

	if mmWithError.defaultExpectation == nil {
		mmWithError.defaultExpectation = &BargeInBuilderMockWithErrorExpectation{}
	}

	mmWithError.defaultExpectation.params = &BargeInBuilderMockWithErrorParams{e1}
	for _, e := range mmWithError.expectations {
		if minimock.Equal(e.params, mmWithError.defaultExpectation.params) {
			mmWithError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithError.defaultExpectation.params)
		}
	}

	return mmWithError
}

// Inspect accepts an inspector function that has same arguments as the BargeInBuilder.WithError
func (mmWithError *mBargeInBuilderMockWithError) Inspect(f func(e1 error)) *mBargeInBuilderMockWithError {
	if mmWithError.mock.inspectFuncWithError != nil {
		mmWithError.mock.t.Fatalf("Inspect function is already set for BargeInBuilderMock.WithError")
	}

	mmWithError.mock.inspectFuncWithError = f

	return mmWithError
}

// Return sets up results that will be returned by BargeInBuilder.WithError
func (mmWithError *mBargeInBuilderMockWithError) Return(b1 BargeIn) *BargeInBuilderMock {
	if mmWithError.mock.funcWithError != nil {
		mmWithError.mock.t.Fatalf("BargeInBuilderMock.WithError mock is already set by Set")
	}

	if mmWithError.defaultExpectation == nil {
		mmWithError.defaultExpectation = &BargeInBuilderMockWithErrorExpectation{mock: mmWithError.mock}
	}
	mmWithError.defaultExpectation.results = &BargeInBuilderMockWithErrorResults{b1}
	return mmWithError.mock
}

//Set uses given function f to mock the BargeInBuilder.WithError method
func (mmWithError *mBargeInBuilderMockWithError) Set(f func(e1 error) (b1 BargeIn)) *BargeInBuilderMock {
	if mmWithError.defaultExpectation != nil {
		mmWithError.mock.t.Fatalf("Default expectation is already set for the BargeInBuilder.WithError method")
	}

	if len(mmWithError.expectations) > 0 {
		mmWithError.mock.t.Fatalf("Some expectations are already set for the BargeInBuilder.WithError method")
	}

	mmWithError.mock.funcWithError = f
	return mmWithError.mock
}

// When sets expectation for the BargeInBuilder.WithError which will trigger the result defined by the following
// Then helper
func (mmWithError *mBargeInBuilderMockWithError) When(e1 error) *BargeInBuilderMockWithErrorExpectation {
	if mmWithError.mock.funcWithError != nil {
		mmWithError.mock.t.Fatalf("BargeInBuilderMock.WithError mock is already set by Set")
	}

	expectation := &BargeInBuilderMockWithErrorExpectation{
		mock:   mmWithError.mock,
		params: &BargeInBuilderMockWithErrorParams{e1},
	}
	mmWithError.expectations = append(mmWithError.expectations, expectation)
	return expectation
}

// Then sets up BargeInBuilder.WithError return parameters for the expectation previously defined by the When method
func (e *BargeInBuilderMockWithErrorExpectation) Then(b1 BargeIn) *BargeInBuilderMock {
	e.results = &BargeInBuilderMockWithErrorResults{b1}
	return e.mock
}

// WithError implements BargeInBuilder
func (mmWithError *BargeInBuilderMock) WithError(e1 error) (b1 BargeIn) {
	mm_atomic.AddUint64(&mmWithError.beforeWithErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmWithError.afterWithErrorCounter, 1)

	if mmWithError.inspectFuncWithError != nil {
		mmWithError.inspectFuncWithError(e1)
	}

	mm_params := &BargeInBuilderMockWithErrorParams{e1}

	// Record call args
	mmWithError.WithErrorMock.mutex.Lock()
	mmWithError.WithErrorMock.callArgs = append(mmWithError.WithErrorMock.callArgs, mm_params)
	mmWithError.WithErrorMock.mutex.Unlock()

	for _, e := range mmWithError.WithErrorMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmWithError.WithErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithError.WithErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmWithError.WithErrorMock.defaultExpectation.params
		mm_got := BargeInBuilderMockWithErrorParams{e1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithError.t.Errorf("BargeInBuilderMock.WithError got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithError.WithErrorMock.defaultExpectation.results
		if mm_results == nil {
			mmWithError.t.Fatal("No results are set for the BargeInBuilderMock.WithError")
		}
		return (*mm_results).b1
	}
	if mmWithError.funcWithError != nil {
		return mmWithError.funcWithError(e1)
	}
	mmWithError.t.Fatalf("Unexpected call to BargeInBuilderMock.WithError. %v", e1)
	return
}

// WithErrorAfterCounter returns a count of finished BargeInBuilderMock.WithError invocations
func (mmWithError *BargeInBuilderMock) WithErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithError.afterWithErrorCounter)
}

// WithErrorBeforeCounter returns a count of BargeInBuilderMock.WithError invocations
func (mmWithError *BargeInBuilderMock) WithErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithError.beforeWithErrorCounter)
}

// Calls returns a list of arguments used in each call to BargeInBuilderMock.WithError.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithError *mBargeInBuilderMockWithError) Calls() []*BargeInBuilderMockWithErrorParams {
	mmWithError.mutex.RLock()

	argCopy := make([]*BargeInBuilderMockWithErrorParams, len(mmWithError.callArgs))
	copy(argCopy, mmWithError.callArgs)

	mmWithError.mutex.RUnlock()

	return argCopy
}

// MinimockWithErrorDone returns true if the count of the WithError invocations corresponds
// the number of defined expectations
func (m *BargeInBuilderMock) MinimockWithErrorDone() bool {
	for _, e := range m.WithErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithErrorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithError != nil && mm_atomic.LoadUint64(&m.afterWithErrorCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithErrorInspect logs each unmet expectation
func (m *BargeInBuilderMock) MinimockWithErrorInspect() {
	for _, e := range m.WithErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BargeInBuilderMock.WithError with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithErrorCounter) < 1 {
		if m.WithErrorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BargeInBuilderMock.WithError")
		} else {
			m.t.Errorf("Expected call to BargeInBuilderMock.WithError with params: %#v", *m.WithErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithError != nil && mm_atomic.LoadUint64(&m.afterWithErrorCounter) < 1 {
		m.t.Error("Expected call to BargeInBuilderMock.WithError")
	}
}

type mBargeInBuilderMockWithJump struct {
	mock               *BargeInBuilderMock
	defaultExpectation *BargeInBuilderMockWithJumpExpectation
	expectations       []*BargeInBuilderMockWithJumpExpectation

	callArgs []*BargeInBuilderMockWithJumpParams
	mutex    sync.RWMutex
}

// BargeInBuilderMockWithJumpExpectation specifies expectation struct of the BargeInBuilder.WithJump
type BargeInBuilderMockWithJumpExpectation struct {
	mock    *BargeInBuilderMock
	params  *BargeInBuilderMockWithJumpParams
	results *BargeInBuilderMockWithJumpResults
	Counter uint64
}

// BargeInBuilderMockWithJumpParams contains parameters of the BargeInBuilder.WithJump
type BargeInBuilderMockWithJumpParams struct {
	s1 StateFunc
}

// BargeInBuilderMockWithJumpResults contains results of the BargeInBuilder.WithJump
type BargeInBuilderMockWithJumpResults struct {
	b1 BargeIn
}

// Expect sets up expected params for BargeInBuilder.WithJump
func (mmWithJump *mBargeInBuilderMockWithJump) Expect(s1 StateFunc) *mBargeInBuilderMockWithJump {
	if mmWithJump.mock.funcWithJump != nil {
		mmWithJump.mock.t.Fatalf("BargeInBuilderMock.WithJump mock is already set by Set")
	}

	if mmWithJump.defaultExpectation == nil {
		mmWithJump.defaultExpectation = &BargeInBuilderMockWithJumpExpectation{}
	}

	mmWithJump.defaultExpectation.params = &BargeInBuilderMockWithJumpParams{s1}
	for _, e := range mmWithJump.expectations {
		if minimock.Equal(e.params, mmWithJump.defaultExpectation.params) {
			mmWithJump.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithJump.defaultExpectation.params)
		}
	}

	return mmWithJump
}

// Inspect accepts an inspector function that has same arguments as the BargeInBuilder.WithJump
func (mmWithJump *mBargeInBuilderMockWithJump) Inspect(f func(s1 StateFunc)) *mBargeInBuilderMockWithJump {
	if mmWithJump.mock.inspectFuncWithJump != nil {
		mmWithJump.mock.t.Fatalf("Inspect function is already set for BargeInBuilderMock.WithJump")
	}

	mmWithJump.mock.inspectFuncWithJump = f

	return mmWithJump
}

// Return sets up results that will be returned by BargeInBuilder.WithJump
func (mmWithJump *mBargeInBuilderMockWithJump) Return(b1 BargeIn) *BargeInBuilderMock {
	if mmWithJump.mock.funcWithJump != nil {
		mmWithJump.mock.t.Fatalf("BargeInBuilderMock.WithJump mock is already set by Set")
	}

	if mmWithJump.defaultExpectation == nil {
		mmWithJump.defaultExpectation = &BargeInBuilderMockWithJumpExpectation{mock: mmWithJump.mock}
	}
	mmWithJump.defaultExpectation.results = &BargeInBuilderMockWithJumpResults{b1}
	return mmWithJump.mock
}

//Set uses given function f to mock the BargeInBuilder.WithJump method
func (mmWithJump *mBargeInBuilderMockWithJump) Set(f func(s1 StateFunc) (b1 BargeIn)) *BargeInBuilderMock {
	if mmWithJump.defaultExpectation != nil {
		mmWithJump.mock.t.Fatalf("Default expectation is already set for the BargeInBuilder.WithJump method")
	}

	if len(mmWithJump.expectations) > 0 {
		mmWithJump.mock.t.Fatalf("Some expectations are already set for the BargeInBuilder.WithJump method")
	}

	mmWithJump.mock.funcWithJump = f
	return mmWithJump.mock
}

// When sets expectation for the BargeInBuilder.WithJump which will trigger the result defined by the following
// Then helper
func (mmWithJump *mBargeInBuilderMockWithJump) When(s1 StateFunc) *BargeInBuilderMockWithJumpExpectation {
	if mmWithJump.mock.funcWithJump != nil {
		mmWithJump.mock.t.Fatalf("BargeInBuilderMock.WithJump mock is already set by Set")
	}

	expectation := &BargeInBuilderMockWithJumpExpectation{
		mock:   mmWithJump.mock,
		params: &BargeInBuilderMockWithJumpParams{s1},
	}
	mmWithJump.expectations = append(mmWithJump.expectations, expectation)
	return expectation
}

// Then sets up BargeInBuilder.WithJump return parameters for the expectation previously defined by the When method
func (e *BargeInBuilderMockWithJumpExpectation) Then(b1 BargeIn) *BargeInBuilderMock {
	e.results = &BargeInBuilderMockWithJumpResults{b1}
	return e.mock
}

// WithJump implements BargeInBuilder
func (mmWithJump *BargeInBuilderMock) WithJump(s1 StateFunc) (b1 BargeIn) {
	mm_atomic.AddUint64(&mmWithJump.beforeWithJumpCounter, 1)
	defer mm_atomic.AddUint64(&mmWithJump.afterWithJumpCounter, 1)

	if mmWithJump.inspectFuncWithJump != nil {
		mmWithJump.inspectFuncWithJump(s1)
	}

	mm_params := &BargeInBuilderMockWithJumpParams{s1}

	// Record call args
	mmWithJump.WithJumpMock.mutex.Lock()
	mmWithJump.WithJumpMock.callArgs = append(mmWithJump.WithJumpMock.callArgs, mm_params)
	mmWithJump.WithJumpMock.mutex.Unlock()

	for _, e := range mmWithJump.WithJumpMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmWithJump.WithJumpMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithJump.WithJumpMock.defaultExpectation.Counter, 1)
		mm_want := mmWithJump.WithJumpMock.defaultExpectation.params
		mm_got := BargeInBuilderMockWithJumpParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithJump.t.Errorf("BargeInBuilderMock.WithJump got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithJump.WithJumpMock.defaultExpectation.results
		if mm_results == nil {
			mmWithJump.t.Fatal("No results are set for the BargeInBuilderMock.WithJump")
		}
		return (*mm_results).b1
	}
	if mmWithJump.funcWithJump != nil {
		return mmWithJump.funcWithJump(s1)
	}
	mmWithJump.t.Fatalf("Unexpected call to BargeInBuilderMock.WithJump. %v", s1)
	return
}

// WithJumpAfterCounter returns a count of finished BargeInBuilderMock.WithJump invocations
func (mmWithJump *BargeInBuilderMock) WithJumpAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithJump.afterWithJumpCounter)
}

// WithJumpBeforeCounter returns a count of BargeInBuilderMock.WithJump invocations
func (mmWithJump *BargeInBuilderMock) WithJumpBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithJump.beforeWithJumpCounter)
}

// Calls returns a list of arguments used in each call to BargeInBuilderMock.WithJump.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithJump *mBargeInBuilderMockWithJump) Calls() []*BargeInBuilderMockWithJumpParams {
	mmWithJump.mutex.RLock()

	argCopy := make([]*BargeInBuilderMockWithJumpParams, len(mmWithJump.callArgs))
	copy(argCopy, mmWithJump.callArgs)

	mmWithJump.mutex.RUnlock()

	return argCopy
}

// MinimockWithJumpDone returns true if the count of the WithJump invocations corresponds
// the number of defined expectations
func (m *BargeInBuilderMock) MinimockWithJumpDone() bool {
	for _, e := range m.WithJumpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithJumpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithJumpCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithJump != nil && mm_atomic.LoadUint64(&m.afterWithJumpCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithJumpInspect logs each unmet expectation
func (m *BargeInBuilderMock) MinimockWithJumpInspect() {
	for _, e := range m.WithJumpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BargeInBuilderMock.WithJump with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithJumpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithJumpCounter) < 1 {
		if m.WithJumpMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BargeInBuilderMock.WithJump")
		} else {
			m.t.Errorf("Expected call to BargeInBuilderMock.WithJump with params: %#v", *m.WithJumpMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithJump != nil && mm_atomic.LoadUint64(&m.afterWithJumpCounter) < 1 {
		m.t.Error("Expected call to BargeInBuilderMock.WithJump")
	}
}

type mBargeInBuilderMockWithJumpExt struct {
	mock               *BargeInBuilderMock
	defaultExpectation *BargeInBuilderMockWithJumpExtExpectation
	expectations       []*BargeInBuilderMockWithJumpExtExpectation

	callArgs []*BargeInBuilderMockWithJumpExtParams
	mutex    sync.RWMutex
}

// BargeInBuilderMockWithJumpExtExpectation specifies expectation struct of the BargeInBuilder.WithJumpExt
type BargeInBuilderMockWithJumpExtExpectation struct {
	mock    *BargeInBuilderMock
	params  *BargeInBuilderMockWithJumpExtParams
	results *BargeInBuilderMockWithJumpExtResults
	Counter uint64
}

// BargeInBuilderMockWithJumpExtParams contains parameters of the BargeInBuilder.WithJumpExt
type BargeInBuilderMockWithJumpExtParams struct {
	s1 SlotStep
}

// BargeInBuilderMockWithJumpExtResults contains results of the BargeInBuilder.WithJumpExt
type BargeInBuilderMockWithJumpExtResults struct {
	b1 BargeIn
}

// Expect sets up expected params for BargeInBuilder.WithJumpExt
func (mmWithJumpExt *mBargeInBuilderMockWithJumpExt) Expect(s1 SlotStep) *mBargeInBuilderMockWithJumpExt {
	if mmWithJumpExt.mock.funcWithJumpExt != nil {
		mmWithJumpExt.mock.t.Fatalf("BargeInBuilderMock.WithJumpExt mock is already set by Set")
	}

	if mmWithJumpExt.defaultExpectation == nil {
		mmWithJumpExt.defaultExpectation = &BargeInBuilderMockWithJumpExtExpectation{}
	}

	mmWithJumpExt.defaultExpectation.params = &BargeInBuilderMockWithJumpExtParams{s1}
	for _, e := range mmWithJumpExt.expectations {
		if minimock.Equal(e.params, mmWithJumpExt.defaultExpectation.params) {
			mmWithJumpExt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithJumpExt.defaultExpectation.params)
		}
	}

	return mmWithJumpExt
}

// Inspect accepts an inspector function that has same arguments as the BargeInBuilder.WithJumpExt
func (mmWithJumpExt *mBargeInBuilderMockWithJumpExt) Inspect(f func(s1 SlotStep)) *mBargeInBuilderMockWithJumpExt {
	if mmWithJumpExt.mock.inspectFuncWithJumpExt != nil {
		mmWithJumpExt.mock.t.Fatalf("Inspect function is already set for BargeInBuilderMock.WithJumpExt")
	}

	mmWithJumpExt.mock.inspectFuncWithJumpExt = f

	return mmWithJumpExt
}

// Return sets up results that will be returned by BargeInBuilder.WithJumpExt
func (mmWithJumpExt *mBargeInBuilderMockWithJumpExt) Return(b1 BargeIn) *BargeInBuilderMock {
	if mmWithJumpExt.mock.funcWithJumpExt != nil {
		mmWithJumpExt.mock.t.Fatalf("BargeInBuilderMock.WithJumpExt mock is already set by Set")
	}

	if mmWithJumpExt.defaultExpectation == nil {
		mmWithJumpExt.defaultExpectation = &BargeInBuilderMockWithJumpExtExpectation{mock: mmWithJumpExt.mock}
	}
	mmWithJumpExt.defaultExpectation.results = &BargeInBuilderMockWithJumpExtResults{b1}
	return mmWithJumpExt.mock
}

//Set uses given function f to mock the BargeInBuilder.WithJumpExt method
func (mmWithJumpExt *mBargeInBuilderMockWithJumpExt) Set(f func(s1 SlotStep) (b1 BargeIn)) *BargeInBuilderMock {
	if mmWithJumpExt.defaultExpectation != nil {
		mmWithJumpExt.mock.t.Fatalf("Default expectation is already set for the BargeInBuilder.WithJumpExt method")
	}

	if len(mmWithJumpExt.expectations) > 0 {
		mmWithJumpExt.mock.t.Fatalf("Some expectations are already set for the BargeInBuilder.WithJumpExt method")
	}

	mmWithJumpExt.mock.funcWithJumpExt = f
	return mmWithJumpExt.mock
}

// When sets expectation for the BargeInBuilder.WithJumpExt which will trigger the result defined by the following
// Then helper
func (mmWithJumpExt *mBargeInBuilderMockWithJumpExt) When(s1 SlotStep) *BargeInBuilderMockWithJumpExtExpectation {
	if mmWithJumpExt.mock.funcWithJumpExt != nil {
		mmWithJumpExt.mock.t.Fatalf("BargeInBuilderMock.WithJumpExt mock is already set by Set")
	}

	expectation := &BargeInBuilderMockWithJumpExtExpectation{
		mock:   mmWithJumpExt.mock,
		params: &BargeInBuilderMockWithJumpExtParams{s1},
	}
	mmWithJumpExt.expectations = append(mmWithJumpExt.expectations, expectation)
	return expectation
}

// Then sets up BargeInBuilder.WithJumpExt return parameters for the expectation previously defined by the When method
func (e *BargeInBuilderMockWithJumpExtExpectation) Then(b1 BargeIn) *BargeInBuilderMock {
	e.results = &BargeInBuilderMockWithJumpExtResults{b1}
	return e.mock
}

// WithJumpExt implements BargeInBuilder
func (mmWithJumpExt *BargeInBuilderMock) WithJumpExt(s1 SlotStep) (b1 BargeIn) {
	mm_atomic.AddUint64(&mmWithJumpExt.beforeWithJumpExtCounter, 1)
	defer mm_atomic.AddUint64(&mmWithJumpExt.afterWithJumpExtCounter, 1)

	if mmWithJumpExt.inspectFuncWithJumpExt != nil {
		mmWithJumpExt.inspectFuncWithJumpExt(s1)
	}

	mm_params := &BargeInBuilderMockWithJumpExtParams{s1}

	// Record call args
	mmWithJumpExt.WithJumpExtMock.mutex.Lock()
	mmWithJumpExt.WithJumpExtMock.callArgs = append(mmWithJumpExt.WithJumpExtMock.callArgs, mm_params)
	mmWithJumpExt.WithJumpExtMock.mutex.Unlock()

	for _, e := range mmWithJumpExt.WithJumpExtMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmWithJumpExt.WithJumpExtMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithJumpExt.WithJumpExtMock.defaultExpectation.Counter, 1)
		mm_want := mmWithJumpExt.WithJumpExtMock.defaultExpectation.params
		mm_got := BargeInBuilderMockWithJumpExtParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithJumpExt.t.Errorf("BargeInBuilderMock.WithJumpExt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithJumpExt.WithJumpExtMock.defaultExpectation.results
		if mm_results == nil {
			mmWithJumpExt.t.Fatal("No results are set for the BargeInBuilderMock.WithJumpExt")
		}
		return (*mm_results).b1
	}
	if mmWithJumpExt.funcWithJumpExt != nil {
		return mmWithJumpExt.funcWithJumpExt(s1)
	}
	mmWithJumpExt.t.Fatalf("Unexpected call to BargeInBuilderMock.WithJumpExt. %v", s1)
	return
}

// WithJumpExtAfterCounter returns a count of finished BargeInBuilderMock.WithJumpExt invocations
func (mmWithJumpExt *BargeInBuilderMock) WithJumpExtAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithJumpExt.afterWithJumpExtCounter)
}

// WithJumpExtBeforeCounter returns a count of BargeInBuilderMock.WithJumpExt invocations
func (mmWithJumpExt *BargeInBuilderMock) WithJumpExtBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithJumpExt.beforeWithJumpExtCounter)
}

// Calls returns a list of arguments used in each call to BargeInBuilderMock.WithJumpExt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithJumpExt *mBargeInBuilderMockWithJumpExt) Calls() []*BargeInBuilderMockWithJumpExtParams {
	mmWithJumpExt.mutex.RLock()

	argCopy := make([]*BargeInBuilderMockWithJumpExtParams, len(mmWithJumpExt.callArgs))
	copy(argCopy, mmWithJumpExt.callArgs)

	mmWithJumpExt.mutex.RUnlock()

	return argCopy
}

// MinimockWithJumpExtDone returns true if the count of the WithJumpExt invocations corresponds
// the number of defined expectations
func (m *BargeInBuilderMock) MinimockWithJumpExtDone() bool {
	for _, e := range m.WithJumpExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithJumpExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithJumpExtCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithJumpExt != nil && mm_atomic.LoadUint64(&m.afterWithJumpExtCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithJumpExtInspect logs each unmet expectation
func (m *BargeInBuilderMock) MinimockWithJumpExtInspect() {
	for _, e := range m.WithJumpExtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BargeInBuilderMock.WithJumpExt with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithJumpExtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithJumpExtCounter) < 1 {
		if m.WithJumpExtMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BargeInBuilderMock.WithJumpExt")
		} else {
			m.t.Errorf("Expected call to BargeInBuilderMock.WithJumpExt with params: %#v", *m.WithJumpExtMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithJumpExt != nil && mm_atomic.LoadUint64(&m.afterWithJumpExtCounter) < 1 {
		m.t.Error("Expected call to BargeInBuilderMock.WithJumpExt")
	}
}

type mBargeInBuilderMockWithStop struct {
	mock               *BargeInBuilderMock
	defaultExpectation *BargeInBuilderMockWithStopExpectation
	expectations       []*BargeInBuilderMockWithStopExpectation
}

// BargeInBuilderMockWithStopExpectation specifies expectation struct of the BargeInBuilder.WithStop
type BargeInBuilderMockWithStopExpectation struct {
	mock *BargeInBuilderMock

	results *BargeInBuilderMockWithStopResults
	Counter uint64
}

// BargeInBuilderMockWithStopResults contains results of the BargeInBuilder.WithStop
type BargeInBuilderMockWithStopResults struct {
	b1 BargeIn
}

// Expect sets up expected params for BargeInBuilder.WithStop
func (mmWithStop *mBargeInBuilderMockWithStop) Expect() *mBargeInBuilderMockWithStop {
	if mmWithStop.mock.funcWithStop != nil {
		mmWithStop.mock.t.Fatalf("BargeInBuilderMock.WithStop mock is already set by Set")
	}

	if mmWithStop.defaultExpectation == nil {
		mmWithStop.defaultExpectation = &BargeInBuilderMockWithStopExpectation{}
	}

	return mmWithStop
}

// Inspect accepts an inspector function that has same arguments as the BargeInBuilder.WithStop
func (mmWithStop *mBargeInBuilderMockWithStop) Inspect(f func()) *mBargeInBuilderMockWithStop {
	if mmWithStop.mock.inspectFuncWithStop != nil {
		mmWithStop.mock.t.Fatalf("Inspect function is already set for BargeInBuilderMock.WithStop")
	}

	mmWithStop.mock.inspectFuncWithStop = f

	return mmWithStop
}

// Return sets up results that will be returned by BargeInBuilder.WithStop
func (mmWithStop *mBargeInBuilderMockWithStop) Return(b1 BargeIn) *BargeInBuilderMock {
	if mmWithStop.mock.funcWithStop != nil {
		mmWithStop.mock.t.Fatalf("BargeInBuilderMock.WithStop mock is already set by Set")
	}

	if mmWithStop.defaultExpectation == nil {
		mmWithStop.defaultExpectation = &BargeInBuilderMockWithStopExpectation{mock: mmWithStop.mock}
	}
	mmWithStop.defaultExpectation.results = &BargeInBuilderMockWithStopResults{b1}
	return mmWithStop.mock
}

//Set uses given function f to mock the BargeInBuilder.WithStop method
func (mmWithStop *mBargeInBuilderMockWithStop) Set(f func() (b1 BargeIn)) *BargeInBuilderMock {
	if mmWithStop.defaultExpectation != nil {
		mmWithStop.mock.t.Fatalf("Default expectation is already set for the BargeInBuilder.WithStop method")
	}

	if len(mmWithStop.expectations) > 0 {
		mmWithStop.mock.t.Fatalf("Some expectations are already set for the BargeInBuilder.WithStop method")
	}

	mmWithStop.mock.funcWithStop = f
	return mmWithStop.mock
}

// WithStop implements BargeInBuilder
func (mmWithStop *BargeInBuilderMock) WithStop() (b1 BargeIn) {
	mm_atomic.AddUint64(&mmWithStop.beforeWithStopCounter, 1)
	defer mm_atomic.AddUint64(&mmWithStop.afterWithStopCounter, 1)

	if mmWithStop.inspectFuncWithStop != nil {
		mmWithStop.inspectFuncWithStop()
	}

	if mmWithStop.WithStopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithStop.WithStopMock.defaultExpectation.Counter, 1)

		mm_results := mmWithStop.WithStopMock.defaultExpectation.results
		if mm_results == nil {
			mmWithStop.t.Fatal("No results are set for the BargeInBuilderMock.WithStop")
		}
		return (*mm_results).b1
	}
	if mmWithStop.funcWithStop != nil {
		return mmWithStop.funcWithStop()
	}
	mmWithStop.t.Fatalf("Unexpected call to BargeInBuilderMock.WithStop.")
	return
}

// WithStopAfterCounter returns a count of finished BargeInBuilderMock.WithStop invocations
func (mmWithStop *BargeInBuilderMock) WithStopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithStop.afterWithStopCounter)
}

// WithStopBeforeCounter returns a count of BargeInBuilderMock.WithStop invocations
func (mmWithStop *BargeInBuilderMock) WithStopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithStop.beforeWithStopCounter)
}

// MinimockWithStopDone returns true if the count of the WithStop invocations corresponds
// the number of defined expectations
func (m *BargeInBuilderMock) MinimockWithStopDone() bool {
	for _, e := range m.WithStopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithStopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithStopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithStop != nil && mm_atomic.LoadUint64(&m.afterWithStopCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithStopInspect logs each unmet expectation
func (m *BargeInBuilderMock) MinimockWithStopInspect() {
	for _, e := range m.WithStopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to BargeInBuilderMock.WithStop")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithStopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithStopCounter) < 1 {
		m.t.Error("Expected call to BargeInBuilderMock.WithStop")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithStop != nil && mm_atomic.LoadUint64(&m.afterWithStopCounter) < 1 {
		m.t.Error("Expected call to BargeInBuilderMock.WithStop")
	}
}

type mBargeInBuilderMockWithWakeUp struct {
	mock               *BargeInBuilderMock
	defaultExpectation *BargeInBuilderMockWithWakeUpExpectation
	expectations       []*BargeInBuilderMockWithWakeUpExpectation
}

// BargeInBuilderMockWithWakeUpExpectation specifies expectation struct of the BargeInBuilder.WithWakeUp
type BargeInBuilderMockWithWakeUpExpectation struct {
	mock *BargeInBuilderMock

	results *BargeInBuilderMockWithWakeUpResults
	Counter uint64
}

// BargeInBuilderMockWithWakeUpResults contains results of the BargeInBuilder.WithWakeUp
type BargeInBuilderMockWithWakeUpResults struct {
	b1 BargeIn
}

// Expect sets up expected params for BargeInBuilder.WithWakeUp
func (mmWithWakeUp *mBargeInBuilderMockWithWakeUp) Expect() *mBargeInBuilderMockWithWakeUp {
	if mmWithWakeUp.mock.funcWithWakeUp != nil {
		mmWithWakeUp.mock.t.Fatalf("BargeInBuilderMock.WithWakeUp mock is already set by Set")
	}

	if mmWithWakeUp.defaultExpectation == nil {
		mmWithWakeUp.defaultExpectation = &BargeInBuilderMockWithWakeUpExpectation{}
	}

	return mmWithWakeUp
}

// Inspect accepts an inspector function that has same arguments as the BargeInBuilder.WithWakeUp
func (mmWithWakeUp *mBargeInBuilderMockWithWakeUp) Inspect(f func()) *mBargeInBuilderMockWithWakeUp {
	if mmWithWakeUp.mock.inspectFuncWithWakeUp != nil {
		mmWithWakeUp.mock.t.Fatalf("Inspect function is already set for BargeInBuilderMock.WithWakeUp")
	}

	mmWithWakeUp.mock.inspectFuncWithWakeUp = f

	return mmWithWakeUp
}

// Return sets up results that will be returned by BargeInBuilder.WithWakeUp
func (mmWithWakeUp *mBargeInBuilderMockWithWakeUp) Return(b1 BargeIn) *BargeInBuilderMock {
	if mmWithWakeUp.mock.funcWithWakeUp != nil {
		mmWithWakeUp.mock.t.Fatalf("BargeInBuilderMock.WithWakeUp mock is already set by Set")
	}

	if mmWithWakeUp.defaultExpectation == nil {
		mmWithWakeUp.defaultExpectation = &BargeInBuilderMockWithWakeUpExpectation{mock: mmWithWakeUp.mock}
	}
	mmWithWakeUp.defaultExpectation.results = &BargeInBuilderMockWithWakeUpResults{b1}
	return mmWithWakeUp.mock
}

//Set uses given function f to mock the BargeInBuilder.WithWakeUp method
func (mmWithWakeUp *mBargeInBuilderMockWithWakeUp) Set(f func() (b1 BargeIn)) *BargeInBuilderMock {
	if mmWithWakeUp.defaultExpectation != nil {
		mmWithWakeUp.mock.t.Fatalf("Default expectation is already set for the BargeInBuilder.WithWakeUp method")
	}

	if len(mmWithWakeUp.expectations) > 0 {
		mmWithWakeUp.mock.t.Fatalf("Some expectations are already set for the BargeInBuilder.WithWakeUp method")
	}

	mmWithWakeUp.mock.funcWithWakeUp = f
	return mmWithWakeUp.mock
}

// WithWakeUp implements BargeInBuilder
func (mmWithWakeUp *BargeInBuilderMock) WithWakeUp() (b1 BargeIn) {
	mm_atomic.AddUint64(&mmWithWakeUp.beforeWithWakeUpCounter, 1)
	defer mm_atomic.AddUint64(&mmWithWakeUp.afterWithWakeUpCounter, 1)

	if mmWithWakeUp.inspectFuncWithWakeUp != nil {
		mmWithWakeUp.inspectFuncWithWakeUp()
	}

	if mmWithWakeUp.WithWakeUpMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithWakeUp.WithWakeUpMock.defaultExpectation.Counter, 1)

		mm_results := mmWithWakeUp.WithWakeUpMock.defaultExpectation.results
		if mm_results == nil {
			mmWithWakeUp.t.Fatal("No results are set for the BargeInBuilderMock.WithWakeUp")
		}
		return (*mm_results).b1
	}
	if mmWithWakeUp.funcWithWakeUp != nil {
		return mmWithWakeUp.funcWithWakeUp()
	}
	mmWithWakeUp.t.Fatalf("Unexpected call to BargeInBuilderMock.WithWakeUp.")
	return
}

// WithWakeUpAfterCounter returns a count of finished BargeInBuilderMock.WithWakeUp invocations
func (mmWithWakeUp *BargeInBuilderMock) WithWakeUpAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithWakeUp.afterWithWakeUpCounter)
}

// WithWakeUpBeforeCounter returns a count of BargeInBuilderMock.WithWakeUp invocations
func (mmWithWakeUp *BargeInBuilderMock) WithWakeUpBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithWakeUp.beforeWithWakeUpCounter)
}

// MinimockWithWakeUpDone returns true if the count of the WithWakeUp invocations corresponds
// the number of defined expectations
func (m *BargeInBuilderMock) MinimockWithWakeUpDone() bool {
	for _, e := range m.WithWakeUpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithWakeUpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithWakeUpCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithWakeUp != nil && mm_atomic.LoadUint64(&m.afterWithWakeUpCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithWakeUpInspect logs each unmet expectation
func (m *BargeInBuilderMock) MinimockWithWakeUpInspect() {
	for _, e := range m.WithWakeUpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to BargeInBuilderMock.WithWakeUp")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithWakeUpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithWakeUpCounter) < 1 {
		m.t.Error("Expected call to BargeInBuilderMock.WithWakeUp")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithWakeUp != nil && mm_atomic.LoadUint64(&m.afterWithWakeUpCounter) < 1 {
		m.t.Error("Expected call to BargeInBuilderMock.WithWakeUp")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BargeInBuilderMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockWithErrorInspect()

		m.MinimockWithJumpInspect()

		m.MinimockWithJumpExtInspect()

		m.MinimockWithStopInspect()

		m.MinimockWithWakeUpInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BargeInBuilderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *BargeInBuilderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockWithErrorDone() &&
		m.MinimockWithJumpDone() &&
		m.MinimockWithJumpExtDone() &&
		m.MinimockWithStopDone() &&
		m.MinimockWithWakeUpDone()
}
