package proofs

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/vanilla/cryptkit"
	"github.com/insolar/assured-ledger/ledger-core/vanilla/longbits"
)

// GlobulaStateHashMock implements GlobulaStateHash
type GlobulaStateHashMock struct {
	t minimock.Tester

	funcAsByteString          func() (b1 longbits.ByteString)
	inspectFuncAsByteString   func()
	afterAsByteStringCounter  uint64
	beforeAsByteStringCounter uint64
	AsByteStringMock          mGlobulaStateHashMockAsByteString

	funcCopyTo          func(p []byte) (i1 int)
	inspectFuncCopyTo   func(p []byte)
	afterCopyToCounter  uint64
	beforeCopyToCounter uint64
	CopyToMock          mGlobulaStateHashMockCopyTo

	funcEquals          func(other cryptkit.DigestHolder) (b1 bool)
	inspectFuncEquals   func(other cryptkit.DigestHolder)
	afterEqualsCounter  uint64
	beforeEqualsCounter uint64
	EqualsMock          mGlobulaStateHashMockEquals

	funcFixedByteSize          func() (i1 int)
	inspectFuncFixedByteSize   func()
	afterFixedByteSizeCounter  uint64
	beforeFixedByteSizeCounter uint64
	FixedByteSizeMock          mGlobulaStateHashMockFixedByteSize

	funcFoldToUint64          func() (u1 uint64)
	inspectFuncFoldToUint64   func()
	afterFoldToUint64Counter  uint64
	beforeFoldToUint64Counter uint64
	FoldToUint64Mock          mGlobulaStateHashMockFoldToUint64

	funcGetDigestMethod          func() (d1 cryptkit.DigestMethod)
	inspectFuncGetDigestMethod   func()
	afterGetDigestMethodCounter  uint64
	beforeGetDigestMethodCounter uint64
	GetDigestMethodMock          mGlobulaStateHashMockGetDigestMethod

	funcSignWith          func(signer cryptkit.DigestSigner) (s1 cryptkit.SignedDigestHolder)
	inspectFuncSignWith   func(signer cryptkit.DigestSigner)
	afterSignWithCounter  uint64
	beforeSignWithCounter uint64
	SignWithMock          mGlobulaStateHashMockSignWith

	funcWriteTo          func(w io.Writer) (n int64, err error)
	inspectFuncWriteTo   func(w io.Writer)
	afterWriteToCounter  uint64
	beforeWriteToCounter uint64
	WriteToMock          mGlobulaStateHashMockWriteTo
}

// NewGlobulaStateHashMock returns a mock for GlobulaStateHash
func NewGlobulaStateHashMock(t minimock.Tester) *GlobulaStateHashMock {
	m := &GlobulaStateHashMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AsByteStringMock = mGlobulaStateHashMockAsByteString{mock: m}

	m.CopyToMock = mGlobulaStateHashMockCopyTo{mock: m}
	m.CopyToMock.callArgs = []*GlobulaStateHashMockCopyToParams{}

	m.EqualsMock = mGlobulaStateHashMockEquals{mock: m}
	m.EqualsMock.callArgs = []*GlobulaStateHashMockEqualsParams{}

	m.FixedByteSizeMock = mGlobulaStateHashMockFixedByteSize{mock: m}

	m.FoldToUint64Mock = mGlobulaStateHashMockFoldToUint64{mock: m}

	m.GetDigestMethodMock = mGlobulaStateHashMockGetDigestMethod{mock: m}

	m.SignWithMock = mGlobulaStateHashMockSignWith{mock: m}
	m.SignWithMock.callArgs = []*GlobulaStateHashMockSignWithParams{}

	m.WriteToMock = mGlobulaStateHashMockWriteTo{mock: m}
	m.WriteToMock.callArgs = []*GlobulaStateHashMockWriteToParams{}

	return m
}

type mGlobulaStateHashMockAsByteString struct {
	mock               *GlobulaStateHashMock
	defaultExpectation *GlobulaStateHashMockAsByteStringExpectation
	expectations       []*GlobulaStateHashMockAsByteStringExpectation
}

// GlobulaStateHashMockAsByteStringExpectation specifies expectation struct of the GlobulaStateHash.AsByteString
type GlobulaStateHashMockAsByteStringExpectation struct {
	mock *GlobulaStateHashMock

	results *GlobulaStateHashMockAsByteStringResults
	Counter uint64
}

// GlobulaStateHashMockAsByteStringResults contains results of the GlobulaStateHash.AsByteString
type GlobulaStateHashMockAsByteStringResults struct {
	b1 longbits.ByteString
}

// Expect sets up expected params for GlobulaStateHash.AsByteString
func (mmAsByteString *mGlobulaStateHashMockAsByteString) Expect() *mGlobulaStateHashMockAsByteString {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("GlobulaStateHashMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &GlobulaStateHashMockAsByteStringExpectation{}
	}

	return mmAsByteString
}

// Inspect accepts an inspector function that has same arguments as the GlobulaStateHash.AsByteString
func (mmAsByteString *mGlobulaStateHashMockAsByteString) Inspect(f func()) *mGlobulaStateHashMockAsByteString {
	if mmAsByteString.mock.inspectFuncAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("Inspect function is already set for GlobulaStateHashMock.AsByteString")
	}

	mmAsByteString.mock.inspectFuncAsByteString = f

	return mmAsByteString
}

// Return sets up results that will be returned by GlobulaStateHash.AsByteString
func (mmAsByteString *mGlobulaStateHashMockAsByteString) Return(b1 longbits.ByteString) *GlobulaStateHashMock {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("GlobulaStateHashMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &GlobulaStateHashMockAsByteStringExpectation{mock: mmAsByteString.mock}
	}
	mmAsByteString.defaultExpectation.results = &GlobulaStateHashMockAsByteStringResults{b1}
	return mmAsByteString.mock
}

//Set uses given function f to mock the GlobulaStateHash.AsByteString method
func (mmAsByteString *mGlobulaStateHashMockAsByteString) Set(f func() (b1 longbits.ByteString)) *GlobulaStateHashMock {
	if mmAsByteString.defaultExpectation != nil {
		mmAsByteString.mock.t.Fatalf("Default expectation is already set for the GlobulaStateHash.AsByteString method")
	}

	if len(mmAsByteString.expectations) > 0 {
		mmAsByteString.mock.t.Fatalf("Some expectations are already set for the GlobulaStateHash.AsByteString method")
	}

	mmAsByteString.mock.funcAsByteString = f
	return mmAsByteString.mock
}

// AsByteString implements GlobulaStateHash
func (mmAsByteString *GlobulaStateHashMock) AsByteString() (b1 longbits.ByteString) {
	mm_atomic.AddUint64(&mmAsByteString.beforeAsByteStringCounter, 1)
	defer mm_atomic.AddUint64(&mmAsByteString.afterAsByteStringCounter, 1)

	if mmAsByteString.inspectFuncAsByteString != nil {
		mmAsByteString.inspectFuncAsByteString()
	}

	if mmAsByteString.AsByteStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsByteString.AsByteStringMock.defaultExpectation.Counter, 1)

		mm_results := mmAsByteString.AsByteStringMock.defaultExpectation.results
		if mm_results == nil {
			mmAsByteString.t.Fatal("No results are set for the GlobulaStateHashMock.AsByteString")
		}
		return (*mm_results).b1
	}
	if mmAsByteString.funcAsByteString != nil {
		return mmAsByteString.funcAsByteString()
	}
	mmAsByteString.t.Fatalf("Unexpected call to GlobulaStateHashMock.AsByteString.")
	return
}

// AsByteStringAfterCounter returns a count of finished GlobulaStateHashMock.AsByteString invocations
func (mmAsByteString *GlobulaStateHashMock) AsByteStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.afterAsByteStringCounter)
}

// AsByteStringBeforeCounter returns a count of GlobulaStateHashMock.AsByteString invocations
func (mmAsByteString *GlobulaStateHashMock) AsByteStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.beforeAsByteStringCounter)
}

// MinimockAsByteStringDone returns true if the count of the AsByteString invocations corresponds
// the number of defined expectations
func (m *GlobulaStateHashMock) MinimockAsByteStringDone() bool {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsByteStringInspect logs each unmet expectation
func (m *GlobulaStateHashMock) MinimockAsByteStringInspect() {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GlobulaStateHashMock.AsByteString")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.AsByteString")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.AsByteString")
	}
}

type mGlobulaStateHashMockCopyTo struct {
	mock               *GlobulaStateHashMock
	defaultExpectation *GlobulaStateHashMockCopyToExpectation
	expectations       []*GlobulaStateHashMockCopyToExpectation

	callArgs []*GlobulaStateHashMockCopyToParams
	mutex    sync.RWMutex
}

// GlobulaStateHashMockCopyToExpectation specifies expectation struct of the GlobulaStateHash.CopyTo
type GlobulaStateHashMockCopyToExpectation struct {
	mock    *GlobulaStateHashMock
	params  *GlobulaStateHashMockCopyToParams
	results *GlobulaStateHashMockCopyToResults
	Counter uint64
}

// GlobulaStateHashMockCopyToParams contains parameters of the GlobulaStateHash.CopyTo
type GlobulaStateHashMockCopyToParams struct {
	p []byte
}

// GlobulaStateHashMockCopyToResults contains results of the GlobulaStateHash.CopyTo
type GlobulaStateHashMockCopyToResults struct {
	i1 int
}

// Expect sets up expected params for GlobulaStateHash.CopyTo
func (mmCopyTo *mGlobulaStateHashMockCopyTo) Expect(p []byte) *mGlobulaStateHashMockCopyTo {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("GlobulaStateHashMock.CopyTo mock is already set by Set")
	}

	if mmCopyTo.defaultExpectation == nil {
		mmCopyTo.defaultExpectation = &GlobulaStateHashMockCopyToExpectation{}
	}

	mmCopyTo.defaultExpectation.params = &GlobulaStateHashMockCopyToParams{p}
	for _, e := range mmCopyTo.expectations {
		if minimock.Equal(e.params, mmCopyTo.defaultExpectation.params) {
			mmCopyTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCopyTo.defaultExpectation.params)
		}
	}

	return mmCopyTo
}

// Inspect accepts an inspector function that has same arguments as the GlobulaStateHash.CopyTo
func (mmCopyTo *mGlobulaStateHashMockCopyTo) Inspect(f func(p []byte)) *mGlobulaStateHashMockCopyTo {
	if mmCopyTo.mock.inspectFuncCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("Inspect function is already set for GlobulaStateHashMock.CopyTo")
	}

	mmCopyTo.mock.inspectFuncCopyTo = f

	return mmCopyTo
}

// Return sets up results that will be returned by GlobulaStateHash.CopyTo
func (mmCopyTo *mGlobulaStateHashMockCopyTo) Return(i1 int) *GlobulaStateHashMock {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("GlobulaStateHashMock.CopyTo mock is already set by Set")
	}

	if mmCopyTo.defaultExpectation == nil {
		mmCopyTo.defaultExpectation = &GlobulaStateHashMockCopyToExpectation{mock: mmCopyTo.mock}
	}
	mmCopyTo.defaultExpectation.results = &GlobulaStateHashMockCopyToResults{i1}
	return mmCopyTo.mock
}

//Set uses given function f to mock the GlobulaStateHash.CopyTo method
func (mmCopyTo *mGlobulaStateHashMockCopyTo) Set(f func(p []byte) (i1 int)) *GlobulaStateHashMock {
	if mmCopyTo.defaultExpectation != nil {
		mmCopyTo.mock.t.Fatalf("Default expectation is already set for the GlobulaStateHash.CopyTo method")
	}

	if len(mmCopyTo.expectations) > 0 {
		mmCopyTo.mock.t.Fatalf("Some expectations are already set for the GlobulaStateHash.CopyTo method")
	}

	mmCopyTo.mock.funcCopyTo = f
	return mmCopyTo.mock
}

// When sets expectation for the GlobulaStateHash.CopyTo which will trigger the result defined by the following
// Then helper
func (mmCopyTo *mGlobulaStateHashMockCopyTo) When(p []byte) *GlobulaStateHashMockCopyToExpectation {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("GlobulaStateHashMock.CopyTo mock is already set by Set")
	}

	expectation := &GlobulaStateHashMockCopyToExpectation{
		mock:   mmCopyTo.mock,
		params: &GlobulaStateHashMockCopyToParams{p},
	}
	mmCopyTo.expectations = append(mmCopyTo.expectations, expectation)
	return expectation
}

// Then sets up GlobulaStateHash.CopyTo return parameters for the expectation previously defined by the When method
func (e *GlobulaStateHashMockCopyToExpectation) Then(i1 int) *GlobulaStateHashMock {
	e.results = &GlobulaStateHashMockCopyToResults{i1}
	return e.mock
}

// CopyTo implements GlobulaStateHash
func (mmCopyTo *GlobulaStateHashMock) CopyTo(p []byte) (i1 int) {
	mm_atomic.AddUint64(&mmCopyTo.beforeCopyToCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyTo.afterCopyToCounter, 1)

	if mmCopyTo.inspectFuncCopyTo != nil {
		mmCopyTo.inspectFuncCopyTo(p)
	}

	mm_params := &GlobulaStateHashMockCopyToParams{p}

	// Record call args
	mmCopyTo.CopyToMock.mutex.Lock()
	mmCopyTo.CopyToMock.callArgs = append(mmCopyTo.CopyToMock.callArgs, mm_params)
	mmCopyTo.CopyToMock.mutex.Unlock()

	for _, e := range mmCopyTo.CopyToMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1
		}
	}

	if mmCopyTo.CopyToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyTo.CopyToMock.defaultExpectation.Counter, 1)
		mm_want := mmCopyTo.CopyToMock.defaultExpectation.params
		mm_got := GlobulaStateHashMockCopyToParams{p}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCopyTo.t.Errorf("GlobulaStateHashMock.CopyTo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCopyTo.CopyToMock.defaultExpectation.results
		if mm_results == nil {
			mmCopyTo.t.Fatal("No results are set for the GlobulaStateHashMock.CopyTo")
		}
		return (*mm_results).i1
	}
	if mmCopyTo.funcCopyTo != nil {
		return mmCopyTo.funcCopyTo(p)
	}
	mmCopyTo.t.Fatalf("Unexpected call to GlobulaStateHashMock.CopyTo. %v", p)
	return
}

// CopyToAfterCounter returns a count of finished GlobulaStateHashMock.CopyTo invocations
func (mmCopyTo *GlobulaStateHashMock) CopyToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyTo.afterCopyToCounter)
}

// CopyToBeforeCounter returns a count of GlobulaStateHashMock.CopyTo invocations
func (mmCopyTo *GlobulaStateHashMock) CopyToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyTo.beforeCopyToCounter)
}

// Calls returns a list of arguments used in each call to GlobulaStateHashMock.CopyTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCopyTo *mGlobulaStateHashMockCopyTo) Calls() []*GlobulaStateHashMockCopyToParams {
	mmCopyTo.mutex.RLock()

	argCopy := make([]*GlobulaStateHashMockCopyToParams, len(mmCopyTo.callArgs))
	copy(argCopy, mmCopyTo.callArgs)

	mmCopyTo.mutex.RUnlock()

	return argCopy
}

// MinimockCopyToDone returns true if the count of the CopyTo invocations corresponds
// the number of defined expectations
func (m *GlobulaStateHashMock) MinimockCopyToDone() bool {
	for _, e := range m.CopyToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyTo != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyToInspect logs each unmet expectation
func (m *GlobulaStateHashMock) MinimockCopyToInspect() {
	for _, e := range m.CopyToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GlobulaStateHashMock.CopyTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		if m.CopyToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GlobulaStateHashMock.CopyTo")
		} else {
			m.t.Errorf("Expected call to GlobulaStateHashMock.CopyTo with params: %#v", *m.CopyToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyTo != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.CopyTo")
	}
}

type mGlobulaStateHashMockEquals struct {
	mock               *GlobulaStateHashMock
	defaultExpectation *GlobulaStateHashMockEqualsExpectation
	expectations       []*GlobulaStateHashMockEqualsExpectation

	callArgs []*GlobulaStateHashMockEqualsParams
	mutex    sync.RWMutex
}

// GlobulaStateHashMockEqualsExpectation specifies expectation struct of the GlobulaStateHash.Equals
type GlobulaStateHashMockEqualsExpectation struct {
	mock    *GlobulaStateHashMock
	params  *GlobulaStateHashMockEqualsParams
	results *GlobulaStateHashMockEqualsResults
	Counter uint64
}

// GlobulaStateHashMockEqualsParams contains parameters of the GlobulaStateHash.Equals
type GlobulaStateHashMockEqualsParams struct {
	other cryptkit.DigestHolder
}

// GlobulaStateHashMockEqualsResults contains results of the GlobulaStateHash.Equals
type GlobulaStateHashMockEqualsResults struct {
	b1 bool
}

// Expect sets up expected params for GlobulaStateHash.Equals
func (mmEquals *mGlobulaStateHashMockEquals) Expect(other cryptkit.DigestHolder) *mGlobulaStateHashMockEquals {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("GlobulaStateHashMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &GlobulaStateHashMockEqualsExpectation{}
	}

	mmEquals.defaultExpectation.params = &GlobulaStateHashMockEqualsParams{other}
	for _, e := range mmEquals.expectations {
		if minimock.Equal(e.params, mmEquals.defaultExpectation.params) {
			mmEquals.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEquals.defaultExpectation.params)
		}
	}

	return mmEquals
}

// Inspect accepts an inspector function that has same arguments as the GlobulaStateHash.Equals
func (mmEquals *mGlobulaStateHashMockEquals) Inspect(f func(other cryptkit.DigestHolder)) *mGlobulaStateHashMockEquals {
	if mmEquals.mock.inspectFuncEquals != nil {
		mmEquals.mock.t.Fatalf("Inspect function is already set for GlobulaStateHashMock.Equals")
	}

	mmEquals.mock.inspectFuncEquals = f

	return mmEquals
}

// Return sets up results that will be returned by GlobulaStateHash.Equals
func (mmEquals *mGlobulaStateHashMockEquals) Return(b1 bool) *GlobulaStateHashMock {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("GlobulaStateHashMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &GlobulaStateHashMockEqualsExpectation{mock: mmEquals.mock}
	}
	mmEquals.defaultExpectation.results = &GlobulaStateHashMockEqualsResults{b1}
	return mmEquals.mock
}

//Set uses given function f to mock the GlobulaStateHash.Equals method
func (mmEquals *mGlobulaStateHashMockEquals) Set(f func(other cryptkit.DigestHolder) (b1 bool)) *GlobulaStateHashMock {
	if mmEquals.defaultExpectation != nil {
		mmEquals.mock.t.Fatalf("Default expectation is already set for the GlobulaStateHash.Equals method")
	}

	if len(mmEquals.expectations) > 0 {
		mmEquals.mock.t.Fatalf("Some expectations are already set for the GlobulaStateHash.Equals method")
	}

	mmEquals.mock.funcEquals = f
	return mmEquals.mock
}

// When sets expectation for the GlobulaStateHash.Equals which will trigger the result defined by the following
// Then helper
func (mmEquals *mGlobulaStateHashMockEquals) When(other cryptkit.DigestHolder) *GlobulaStateHashMockEqualsExpectation {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("GlobulaStateHashMock.Equals mock is already set by Set")
	}

	expectation := &GlobulaStateHashMockEqualsExpectation{
		mock:   mmEquals.mock,
		params: &GlobulaStateHashMockEqualsParams{other},
	}
	mmEquals.expectations = append(mmEquals.expectations, expectation)
	return expectation
}

// Then sets up GlobulaStateHash.Equals return parameters for the expectation previously defined by the When method
func (e *GlobulaStateHashMockEqualsExpectation) Then(b1 bool) *GlobulaStateHashMock {
	e.results = &GlobulaStateHashMockEqualsResults{b1}
	return e.mock
}

// Equals implements GlobulaStateHash
func (mmEquals *GlobulaStateHashMock) Equals(other cryptkit.DigestHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmEquals.beforeEqualsCounter, 1)
	defer mm_atomic.AddUint64(&mmEquals.afterEqualsCounter, 1)

	if mmEquals.inspectFuncEquals != nil {
		mmEquals.inspectFuncEquals(other)
	}

	mm_params := &GlobulaStateHashMockEqualsParams{other}

	// Record call args
	mmEquals.EqualsMock.mutex.Lock()
	mmEquals.EqualsMock.callArgs = append(mmEquals.EqualsMock.callArgs, mm_params)
	mmEquals.EqualsMock.mutex.Unlock()

	for _, e := range mmEquals.EqualsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmEquals.EqualsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEquals.EqualsMock.defaultExpectation.Counter, 1)
		mm_want := mmEquals.EqualsMock.defaultExpectation.params
		mm_got := GlobulaStateHashMockEqualsParams{other}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEquals.t.Errorf("GlobulaStateHashMock.Equals got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEquals.EqualsMock.defaultExpectation.results
		if mm_results == nil {
			mmEquals.t.Fatal("No results are set for the GlobulaStateHashMock.Equals")
		}
		return (*mm_results).b1
	}
	if mmEquals.funcEquals != nil {
		return mmEquals.funcEquals(other)
	}
	mmEquals.t.Fatalf("Unexpected call to GlobulaStateHashMock.Equals. %v", other)
	return
}

// EqualsAfterCounter returns a count of finished GlobulaStateHashMock.Equals invocations
func (mmEquals *GlobulaStateHashMock) EqualsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.afterEqualsCounter)
}

// EqualsBeforeCounter returns a count of GlobulaStateHashMock.Equals invocations
func (mmEquals *GlobulaStateHashMock) EqualsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.beforeEqualsCounter)
}

// Calls returns a list of arguments used in each call to GlobulaStateHashMock.Equals.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEquals *mGlobulaStateHashMockEquals) Calls() []*GlobulaStateHashMockEqualsParams {
	mmEquals.mutex.RLock()

	argCopy := make([]*GlobulaStateHashMockEqualsParams, len(mmEquals.callArgs))
	copy(argCopy, mmEquals.callArgs)

	mmEquals.mutex.RUnlock()

	return argCopy
}

// MinimockEqualsDone returns true if the count of the Equals invocations corresponds
// the number of defined expectations
func (m *GlobulaStateHashMock) MinimockEqualsDone() bool {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	return true
}

// MinimockEqualsInspect logs each unmet expectation
func (m *GlobulaStateHashMock) MinimockEqualsInspect() {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GlobulaStateHashMock.Equals with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		if m.EqualsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GlobulaStateHashMock.Equals")
		} else {
			m.t.Errorf("Expected call to GlobulaStateHashMock.Equals with params: %#v", *m.EqualsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.Equals")
	}
}

type mGlobulaStateHashMockFixedByteSize struct {
	mock               *GlobulaStateHashMock
	defaultExpectation *GlobulaStateHashMockFixedByteSizeExpectation
	expectations       []*GlobulaStateHashMockFixedByteSizeExpectation
}

// GlobulaStateHashMockFixedByteSizeExpectation specifies expectation struct of the GlobulaStateHash.FixedByteSize
type GlobulaStateHashMockFixedByteSizeExpectation struct {
	mock *GlobulaStateHashMock

	results *GlobulaStateHashMockFixedByteSizeResults
	Counter uint64
}

// GlobulaStateHashMockFixedByteSizeResults contains results of the GlobulaStateHash.FixedByteSize
type GlobulaStateHashMockFixedByteSizeResults struct {
	i1 int
}

// Expect sets up expected params for GlobulaStateHash.FixedByteSize
func (mmFixedByteSize *mGlobulaStateHashMockFixedByteSize) Expect() *mGlobulaStateHashMockFixedByteSize {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("GlobulaStateHashMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &GlobulaStateHashMockFixedByteSizeExpectation{}
	}

	return mmFixedByteSize
}

// Inspect accepts an inspector function that has same arguments as the GlobulaStateHash.FixedByteSize
func (mmFixedByteSize *mGlobulaStateHashMockFixedByteSize) Inspect(f func()) *mGlobulaStateHashMockFixedByteSize {
	if mmFixedByteSize.mock.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("Inspect function is already set for GlobulaStateHashMock.FixedByteSize")
	}

	mmFixedByteSize.mock.inspectFuncFixedByteSize = f

	return mmFixedByteSize
}

// Return sets up results that will be returned by GlobulaStateHash.FixedByteSize
func (mmFixedByteSize *mGlobulaStateHashMockFixedByteSize) Return(i1 int) *GlobulaStateHashMock {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("GlobulaStateHashMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &GlobulaStateHashMockFixedByteSizeExpectation{mock: mmFixedByteSize.mock}
	}
	mmFixedByteSize.defaultExpectation.results = &GlobulaStateHashMockFixedByteSizeResults{i1}
	return mmFixedByteSize.mock
}

//Set uses given function f to mock the GlobulaStateHash.FixedByteSize method
func (mmFixedByteSize *mGlobulaStateHashMockFixedByteSize) Set(f func() (i1 int)) *GlobulaStateHashMock {
	if mmFixedByteSize.defaultExpectation != nil {
		mmFixedByteSize.mock.t.Fatalf("Default expectation is already set for the GlobulaStateHash.FixedByteSize method")
	}

	if len(mmFixedByteSize.expectations) > 0 {
		mmFixedByteSize.mock.t.Fatalf("Some expectations are already set for the GlobulaStateHash.FixedByteSize method")
	}

	mmFixedByteSize.mock.funcFixedByteSize = f
	return mmFixedByteSize.mock
}

// FixedByteSize implements GlobulaStateHash
func (mmFixedByteSize *GlobulaStateHashMock) FixedByteSize() (i1 int) {
	mm_atomic.AddUint64(&mmFixedByteSize.beforeFixedByteSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmFixedByteSize.afterFixedByteSizeCounter, 1)

	if mmFixedByteSize.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.inspectFuncFixedByteSize()
	}

	if mmFixedByteSize.FixedByteSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFixedByteSize.FixedByteSizeMock.defaultExpectation.Counter, 1)

		mm_results := mmFixedByteSize.FixedByteSizeMock.defaultExpectation.results
		if mm_results == nil {
			mmFixedByteSize.t.Fatal("No results are set for the GlobulaStateHashMock.FixedByteSize")
		}
		return (*mm_results).i1
	}
	if mmFixedByteSize.funcFixedByteSize != nil {
		return mmFixedByteSize.funcFixedByteSize()
	}
	mmFixedByteSize.t.Fatalf("Unexpected call to GlobulaStateHashMock.FixedByteSize.")
	return
}

// FixedByteSizeAfterCounter returns a count of finished GlobulaStateHashMock.FixedByteSize invocations
func (mmFixedByteSize *GlobulaStateHashMock) FixedByteSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.afterFixedByteSizeCounter)
}

// FixedByteSizeBeforeCounter returns a count of GlobulaStateHashMock.FixedByteSize invocations
func (mmFixedByteSize *GlobulaStateHashMock) FixedByteSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.beforeFixedByteSizeCounter)
}

// MinimockFixedByteSizeDone returns true if the count of the FixedByteSize invocations corresponds
// the number of defined expectations
func (m *GlobulaStateHashMock) MinimockFixedByteSizeDone() bool {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockFixedByteSizeInspect logs each unmet expectation
func (m *GlobulaStateHashMock) MinimockFixedByteSizeInspect() {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GlobulaStateHashMock.FixedByteSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.FixedByteSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.FixedByteSize")
	}
}

type mGlobulaStateHashMockFoldToUint64 struct {
	mock               *GlobulaStateHashMock
	defaultExpectation *GlobulaStateHashMockFoldToUint64Expectation
	expectations       []*GlobulaStateHashMockFoldToUint64Expectation
}

// GlobulaStateHashMockFoldToUint64Expectation specifies expectation struct of the GlobulaStateHash.FoldToUint64
type GlobulaStateHashMockFoldToUint64Expectation struct {
	mock *GlobulaStateHashMock

	results *GlobulaStateHashMockFoldToUint64Results
	Counter uint64
}

// GlobulaStateHashMockFoldToUint64Results contains results of the GlobulaStateHash.FoldToUint64
type GlobulaStateHashMockFoldToUint64Results struct {
	u1 uint64
}

// Expect sets up expected params for GlobulaStateHash.FoldToUint64
func (mmFoldToUint64 *mGlobulaStateHashMockFoldToUint64) Expect() *mGlobulaStateHashMockFoldToUint64 {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("GlobulaStateHashMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &GlobulaStateHashMockFoldToUint64Expectation{}
	}

	return mmFoldToUint64
}

// Inspect accepts an inspector function that has same arguments as the GlobulaStateHash.FoldToUint64
func (mmFoldToUint64 *mGlobulaStateHashMockFoldToUint64) Inspect(f func()) *mGlobulaStateHashMockFoldToUint64 {
	if mmFoldToUint64.mock.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("Inspect function is already set for GlobulaStateHashMock.FoldToUint64")
	}

	mmFoldToUint64.mock.inspectFuncFoldToUint64 = f

	return mmFoldToUint64
}

// Return sets up results that will be returned by GlobulaStateHash.FoldToUint64
func (mmFoldToUint64 *mGlobulaStateHashMockFoldToUint64) Return(u1 uint64) *GlobulaStateHashMock {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("GlobulaStateHashMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &GlobulaStateHashMockFoldToUint64Expectation{mock: mmFoldToUint64.mock}
	}
	mmFoldToUint64.defaultExpectation.results = &GlobulaStateHashMockFoldToUint64Results{u1}
	return mmFoldToUint64.mock
}

//Set uses given function f to mock the GlobulaStateHash.FoldToUint64 method
func (mmFoldToUint64 *mGlobulaStateHashMockFoldToUint64) Set(f func() (u1 uint64)) *GlobulaStateHashMock {
	if mmFoldToUint64.defaultExpectation != nil {
		mmFoldToUint64.mock.t.Fatalf("Default expectation is already set for the GlobulaStateHash.FoldToUint64 method")
	}

	if len(mmFoldToUint64.expectations) > 0 {
		mmFoldToUint64.mock.t.Fatalf("Some expectations are already set for the GlobulaStateHash.FoldToUint64 method")
	}

	mmFoldToUint64.mock.funcFoldToUint64 = f
	return mmFoldToUint64.mock
}

// FoldToUint64 implements GlobulaStateHash
func (mmFoldToUint64 *GlobulaStateHashMock) FoldToUint64() (u1 uint64) {
	mm_atomic.AddUint64(&mmFoldToUint64.beforeFoldToUint64Counter, 1)
	defer mm_atomic.AddUint64(&mmFoldToUint64.afterFoldToUint64Counter, 1)

	if mmFoldToUint64.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.inspectFuncFoldToUint64()
	}

	if mmFoldToUint64.FoldToUint64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFoldToUint64.FoldToUint64Mock.defaultExpectation.Counter, 1)

		mm_results := mmFoldToUint64.FoldToUint64Mock.defaultExpectation.results
		if mm_results == nil {
			mmFoldToUint64.t.Fatal("No results are set for the GlobulaStateHashMock.FoldToUint64")
		}
		return (*mm_results).u1
	}
	if mmFoldToUint64.funcFoldToUint64 != nil {
		return mmFoldToUint64.funcFoldToUint64()
	}
	mmFoldToUint64.t.Fatalf("Unexpected call to GlobulaStateHashMock.FoldToUint64.")
	return
}

// FoldToUint64AfterCounter returns a count of finished GlobulaStateHashMock.FoldToUint64 invocations
func (mmFoldToUint64 *GlobulaStateHashMock) FoldToUint64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.afterFoldToUint64Counter)
}

// FoldToUint64BeforeCounter returns a count of GlobulaStateHashMock.FoldToUint64 invocations
func (mmFoldToUint64 *GlobulaStateHashMock) FoldToUint64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.beforeFoldToUint64Counter)
}

// MinimockFoldToUint64Done returns true if the count of the FoldToUint64 invocations corresponds
// the number of defined expectations
func (m *GlobulaStateHashMock) MinimockFoldToUint64Done() bool {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	return true
}

// MinimockFoldToUint64Inspect logs each unmet expectation
func (m *GlobulaStateHashMock) MinimockFoldToUint64Inspect() {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GlobulaStateHashMock.FoldToUint64")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.FoldToUint64")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.FoldToUint64")
	}
}

type mGlobulaStateHashMockGetDigestMethod struct {
	mock               *GlobulaStateHashMock
	defaultExpectation *GlobulaStateHashMockGetDigestMethodExpectation
	expectations       []*GlobulaStateHashMockGetDigestMethodExpectation
}

// GlobulaStateHashMockGetDigestMethodExpectation specifies expectation struct of the GlobulaStateHash.GetDigestMethod
type GlobulaStateHashMockGetDigestMethodExpectation struct {
	mock *GlobulaStateHashMock

	results *GlobulaStateHashMockGetDigestMethodResults
	Counter uint64
}

// GlobulaStateHashMockGetDigestMethodResults contains results of the GlobulaStateHash.GetDigestMethod
type GlobulaStateHashMockGetDigestMethodResults struct {
	d1 cryptkit.DigestMethod
}

// Expect sets up expected params for GlobulaStateHash.GetDigestMethod
func (mmGetDigestMethod *mGlobulaStateHashMockGetDigestMethod) Expect() *mGlobulaStateHashMockGetDigestMethod {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("GlobulaStateHashMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &GlobulaStateHashMockGetDigestMethodExpectation{}
	}

	return mmGetDigestMethod
}

// Inspect accepts an inspector function that has same arguments as the GlobulaStateHash.GetDigestMethod
func (mmGetDigestMethod *mGlobulaStateHashMockGetDigestMethod) Inspect(f func()) *mGlobulaStateHashMockGetDigestMethod {
	if mmGetDigestMethod.mock.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("Inspect function is already set for GlobulaStateHashMock.GetDigestMethod")
	}

	mmGetDigestMethod.mock.inspectFuncGetDigestMethod = f

	return mmGetDigestMethod
}

// Return sets up results that will be returned by GlobulaStateHash.GetDigestMethod
func (mmGetDigestMethod *mGlobulaStateHashMockGetDigestMethod) Return(d1 cryptkit.DigestMethod) *GlobulaStateHashMock {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("GlobulaStateHashMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &GlobulaStateHashMockGetDigestMethodExpectation{mock: mmGetDigestMethod.mock}
	}
	mmGetDigestMethod.defaultExpectation.results = &GlobulaStateHashMockGetDigestMethodResults{d1}
	return mmGetDigestMethod.mock
}

//Set uses given function f to mock the GlobulaStateHash.GetDigestMethod method
func (mmGetDigestMethod *mGlobulaStateHashMockGetDigestMethod) Set(f func() (d1 cryptkit.DigestMethod)) *GlobulaStateHashMock {
	if mmGetDigestMethod.defaultExpectation != nil {
		mmGetDigestMethod.mock.t.Fatalf("Default expectation is already set for the GlobulaStateHash.GetDigestMethod method")
	}

	if len(mmGetDigestMethod.expectations) > 0 {
		mmGetDigestMethod.mock.t.Fatalf("Some expectations are already set for the GlobulaStateHash.GetDigestMethod method")
	}

	mmGetDigestMethod.mock.funcGetDigestMethod = f
	return mmGetDigestMethod.mock
}

// GetDigestMethod implements GlobulaStateHash
func (mmGetDigestMethod *GlobulaStateHashMock) GetDigestMethod() (d1 cryptkit.DigestMethod) {
	mm_atomic.AddUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestMethod.afterGetDigestMethodCounter, 1)

	if mmGetDigestMethod.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.inspectFuncGetDigestMethod()
	}

	if mmGetDigestMethod.GetDigestMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDigestMethod.t.Fatal("No results are set for the GlobulaStateHashMock.GetDigestMethod")
		}
		return (*mm_results).d1
	}
	if mmGetDigestMethod.funcGetDigestMethod != nil {
		return mmGetDigestMethod.funcGetDigestMethod()
	}
	mmGetDigestMethod.t.Fatalf("Unexpected call to GlobulaStateHashMock.GetDigestMethod.")
	return
}

// GetDigestMethodAfterCounter returns a count of finished GlobulaStateHashMock.GetDigestMethod invocations
func (mmGetDigestMethod *GlobulaStateHashMock) GetDigestMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.afterGetDigestMethodCounter)
}

// GetDigestMethodBeforeCounter returns a count of GlobulaStateHashMock.GetDigestMethod invocations
func (mmGetDigestMethod *GlobulaStateHashMock) GetDigestMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter)
}

// MinimockGetDigestMethodDone returns true if the count of the GetDigestMethod invocations corresponds
// the number of defined expectations
func (m *GlobulaStateHashMock) MinimockGetDigestMethodDone() bool {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestMethodInspect logs each unmet expectation
func (m *GlobulaStateHashMock) MinimockGetDigestMethodInspect() {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GlobulaStateHashMock.GetDigestMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.GetDigestMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.GetDigestMethod")
	}
}

type mGlobulaStateHashMockSignWith struct {
	mock               *GlobulaStateHashMock
	defaultExpectation *GlobulaStateHashMockSignWithExpectation
	expectations       []*GlobulaStateHashMockSignWithExpectation

	callArgs []*GlobulaStateHashMockSignWithParams
	mutex    sync.RWMutex
}

// GlobulaStateHashMockSignWithExpectation specifies expectation struct of the GlobulaStateHash.SignWith
type GlobulaStateHashMockSignWithExpectation struct {
	mock    *GlobulaStateHashMock
	params  *GlobulaStateHashMockSignWithParams
	results *GlobulaStateHashMockSignWithResults
	Counter uint64
}

// GlobulaStateHashMockSignWithParams contains parameters of the GlobulaStateHash.SignWith
type GlobulaStateHashMockSignWithParams struct {
	signer cryptkit.DigestSigner
}

// GlobulaStateHashMockSignWithResults contains results of the GlobulaStateHash.SignWith
type GlobulaStateHashMockSignWithResults struct {
	s1 cryptkit.SignedDigestHolder
}

// Expect sets up expected params for GlobulaStateHash.SignWith
func (mmSignWith *mGlobulaStateHashMockSignWith) Expect(signer cryptkit.DigestSigner) *mGlobulaStateHashMockSignWith {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("GlobulaStateHashMock.SignWith mock is already set by Set")
	}

	if mmSignWith.defaultExpectation == nil {
		mmSignWith.defaultExpectation = &GlobulaStateHashMockSignWithExpectation{}
	}

	mmSignWith.defaultExpectation.params = &GlobulaStateHashMockSignWithParams{signer}
	for _, e := range mmSignWith.expectations {
		if minimock.Equal(e.params, mmSignWith.defaultExpectation.params) {
			mmSignWith.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSignWith.defaultExpectation.params)
		}
	}

	return mmSignWith
}

// Inspect accepts an inspector function that has same arguments as the GlobulaStateHash.SignWith
func (mmSignWith *mGlobulaStateHashMockSignWith) Inspect(f func(signer cryptkit.DigestSigner)) *mGlobulaStateHashMockSignWith {
	if mmSignWith.mock.inspectFuncSignWith != nil {
		mmSignWith.mock.t.Fatalf("Inspect function is already set for GlobulaStateHashMock.SignWith")
	}

	mmSignWith.mock.inspectFuncSignWith = f

	return mmSignWith
}

// Return sets up results that will be returned by GlobulaStateHash.SignWith
func (mmSignWith *mGlobulaStateHashMockSignWith) Return(s1 cryptkit.SignedDigestHolder) *GlobulaStateHashMock {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("GlobulaStateHashMock.SignWith mock is already set by Set")
	}

	if mmSignWith.defaultExpectation == nil {
		mmSignWith.defaultExpectation = &GlobulaStateHashMockSignWithExpectation{mock: mmSignWith.mock}
	}
	mmSignWith.defaultExpectation.results = &GlobulaStateHashMockSignWithResults{s1}
	return mmSignWith.mock
}

//Set uses given function f to mock the GlobulaStateHash.SignWith method
func (mmSignWith *mGlobulaStateHashMockSignWith) Set(f func(signer cryptkit.DigestSigner) (s1 cryptkit.SignedDigestHolder)) *GlobulaStateHashMock {
	if mmSignWith.defaultExpectation != nil {
		mmSignWith.mock.t.Fatalf("Default expectation is already set for the GlobulaStateHash.SignWith method")
	}

	if len(mmSignWith.expectations) > 0 {
		mmSignWith.mock.t.Fatalf("Some expectations are already set for the GlobulaStateHash.SignWith method")
	}

	mmSignWith.mock.funcSignWith = f
	return mmSignWith.mock
}

// When sets expectation for the GlobulaStateHash.SignWith which will trigger the result defined by the following
// Then helper
func (mmSignWith *mGlobulaStateHashMockSignWith) When(signer cryptkit.DigestSigner) *GlobulaStateHashMockSignWithExpectation {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("GlobulaStateHashMock.SignWith mock is already set by Set")
	}

	expectation := &GlobulaStateHashMockSignWithExpectation{
		mock:   mmSignWith.mock,
		params: &GlobulaStateHashMockSignWithParams{signer},
	}
	mmSignWith.expectations = append(mmSignWith.expectations, expectation)
	return expectation
}

// Then sets up GlobulaStateHash.SignWith return parameters for the expectation previously defined by the When method
func (e *GlobulaStateHashMockSignWithExpectation) Then(s1 cryptkit.SignedDigestHolder) *GlobulaStateHashMock {
	e.results = &GlobulaStateHashMockSignWithResults{s1}
	return e.mock
}

// SignWith implements GlobulaStateHash
func (mmSignWith *GlobulaStateHashMock) SignWith(signer cryptkit.DigestSigner) (s1 cryptkit.SignedDigestHolder) {
	mm_atomic.AddUint64(&mmSignWith.beforeSignWithCounter, 1)
	defer mm_atomic.AddUint64(&mmSignWith.afterSignWithCounter, 1)

	if mmSignWith.inspectFuncSignWith != nil {
		mmSignWith.inspectFuncSignWith(signer)
	}

	mm_params := &GlobulaStateHashMockSignWithParams{signer}

	// Record call args
	mmSignWith.SignWithMock.mutex.Lock()
	mmSignWith.SignWithMock.callArgs = append(mmSignWith.SignWithMock.callArgs, mm_params)
	mmSignWith.SignWithMock.mutex.Unlock()

	for _, e := range mmSignWith.SignWithMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSignWith.SignWithMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSignWith.SignWithMock.defaultExpectation.Counter, 1)
		mm_want := mmSignWith.SignWithMock.defaultExpectation.params
		mm_got := GlobulaStateHashMockSignWithParams{signer}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSignWith.t.Errorf("GlobulaStateHashMock.SignWith got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSignWith.SignWithMock.defaultExpectation.results
		if mm_results == nil {
			mmSignWith.t.Fatal("No results are set for the GlobulaStateHashMock.SignWith")
		}
		return (*mm_results).s1
	}
	if mmSignWith.funcSignWith != nil {
		return mmSignWith.funcSignWith(signer)
	}
	mmSignWith.t.Fatalf("Unexpected call to GlobulaStateHashMock.SignWith. %v", signer)
	return
}

// SignWithAfterCounter returns a count of finished GlobulaStateHashMock.SignWith invocations
func (mmSignWith *GlobulaStateHashMock) SignWithAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignWith.afterSignWithCounter)
}

// SignWithBeforeCounter returns a count of GlobulaStateHashMock.SignWith invocations
func (mmSignWith *GlobulaStateHashMock) SignWithBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignWith.beforeSignWithCounter)
}

// Calls returns a list of arguments used in each call to GlobulaStateHashMock.SignWith.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSignWith *mGlobulaStateHashMockSignWith) Calls() []*GlobulaStateHashMockSignWithParams {
	mmSignWith.mutex.RLock()

	argCopy := make([]*GlobulaStateHashMockSignWithParams, len(mmSignWith.callArgs))
	copy(argCopy, mmSignWith.callArgs)

	mmSignWith.mutex.RUnlock()

	return argCopy
}

// MinimockSignWithDone returns true if the count of the SignWith invocations corresponds
// the number of defined expectations
func (m *GlobulaStateHashMock) MinimockSignWithDone() bool {
	for _, e := range m.SignWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignWith != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		return false
	}
	return true
}

// MinimockSignWithInspect logs each unmet expectation
func (m *GlobulaStateHashMock) MinimockSignWithInspect() {
	for _, e := range m.SignWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GlobulaStateHashMock.SignWith with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		if m.SignWithMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GlobulaStateHashMock.SignWith")
		} else {
			m.t.Errorf("Expected call to GlobulaStateHashMock.SignWith with params: %#v", *m.SignWithMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignWith != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.SignWith")
	}
}

type mGlobulaStateHashMockWriteTo struct {
	mock               *GlobulaStateHashMock
	defaultExpectation *GlobulaStateHashMockWriteToExpectation
	expectations       []*GlobulaStateHashMockWriteToExpectation

	callArgs []*GlobulaStateHashMockWriteToParams
	mutex    sync.RWMutex
}

// GlobulaStateHashMockWriteToExpectation specifies expectation struct of the GlobulaStateHash.WriteTo
type GlobulaStateHashMockWriteToExpectation struct {
	mock    *GlobulaStateHashMock
	params  *GlobulaStateHashMockWriteToParams
	results *GlobulaStateHashMockWriteToResults
	Counter uint64
}

// GlobulaStateHashMockWriteToParams contains parameters of the GlobulaStateHash.WriteTo
type GlobulaStateHashMockWriteToParams struct {
	w io.Writer
}

// GlobulaStateHashMockWriteToResults contains results of the GlobulaStateHash.WriteTo
type GlobulaStateHashMockWriteToResults struct {
	n   int64
	err error
}

// Expect sets up expected params for GlobulaStateHash.WriteTo
func (mmWriteTo *mGlobulaStateHashMockWriteTo) Expect(w io.Writer) *mGlobulaStateHashMockWriteTo {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("GlobulaStateHashMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &GlobulaStateHashMockWriteToExpectation{}
	}

	mmWriteTo.defaultExpectation.params = &GlobulaStateHashMockWriteToParams{w}
	for _, e := range mmWriteTo.expectations {
		if minimock.Equal(e.params, mmWriteTo.defaultExpectation.params) {
			mmWriteTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteTo.defaultExpectation.params)
		}
	}

	return mmWriteTo
}

// Inspect accepts an inspector function that has same arguments as the GlobulaStateHash.WriteTo
func (mmWriteTo *mGlobulaStateHashMockWriteTo) Inspect(f func(w io.Writer)) *mGlobulaStateHashMockWriteTo {
	if mmWriteTo.mock.inspectFuncWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("Inspect function is already set for GlobulaStateHashMock.WriteTo")
	}

	mmWriteTo.mock.inspectFuncWriteTo = f

	return mmWriteTo
}

// Return sets up results that will be returned by GlobulaStateHash.WriteTo
func (mmWriteTo *mGlobulaStateHashMockWriteTo) Return(n int64, err error) *GlobulaStateHashMock {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("GlobulaStateHashMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &GlobulaStateHashMockWriteToExpectation{mock: mmWriteTo.mock}
	}
	mmWriteTo.defaultExpectation.results = &GlobulaStateHashMockWriteToResults{n, err}
	return mmWriteTo.mock
}

//Set uses given function f to mock the GlobulaStateHash.WriteTo method
func (mmWriteTo *mGlobulaStateHashMockWriteTo) Set(f func(w io.Writer) (n int64, err error)) *GlobulaStateHashMock {
	if mmWriteTo.defaultExpectation != nil {
		mmWriteTo.mock.t.Fatalf("Default expectation is already set for the GlobulaStateHash.WriteTo method")
	}

	if len(mmWriteTo.expectations) > 0 {
		mmWriteTo.mock.t.Fatalf("Some expectations are already set for the GlobulaStateHash.WriteTo method")
	}

	mmWriteTo.mock.funcWriteTo = f
	return mmWriteTo.mock
}

// When sets expectation for the GlobulaStateHash.WriteTo which will trigger the result defined by the following
// Then helper
func (mmWriteTo *mGlobulaStateHashMockWriteTo) When(w io.Writer) *GlobulaStateHashMockWriteToExpectation {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("GlobulaStateHashMock.WriteTo mock is already set by Set")
	}

	expectation := &GlobulaStateHashMockWriteToExpectation{
		mock:   mmWriteTo.mock,
		params: &GlobulaStateHashMockWriteToParams{w},
	}
	mmWriteTo.expectations = append(mmWriteTo.expectations, expectation)
	return expectation
}

// Then sets up GlobulaStateHash.WriteTo return parameters for the expectation previously defined by the When method
func (e *GlobulaStateHashMockWriteToExpectation) Then(n int64, err error) *GlobulaStateHashMock {
	e.results = &GlobulaStateHashMockWriteToResults{n, err}
	return e.mock
}

// WriteTo implements GlobulaStateHash
func (mmWriteTo *GlobulaStateHashMock) WriteTo(w io.Writer) (n int64, err error) {
	mm_atomic.AddUint64(&mmWriteTo.beforeWriteToCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteTo.afterWriteToCounter, 1)

	if mmWriteTo.inspectFuncWriteTo != nil {
		mmWriteTo.inspectFuncWriteTo(w)
	}

	mm_params := &GlobulaStateHashMockWriteToParams{w}

	// Record call args
	mmWriteTo.WriteToMock.mutex.Lock()
	mmWriteTo.WriteToMock.callArgs = append(mmWriteTo.WriteToMock.callArgs, mm_params)
	mmWriteTo.WriteToMock.mutex.Unlock()

	for _, e := range mmWriteTo.WriteToMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWriteTo.WriteToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteTo.WriteToMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteTo.WriteToMock.defaultExpectation.params
		mm_got := GlobulaStateHashMockWriteToParams{w}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteTo.t.Errorf("GlobulaStateHashMock.WriteTo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWriteTo.WriteToMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteTo.t.Fatal("No results are set for the GlobulaStateHashMock.WriteTo")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmWriteTo.funcWriteTo != nil {
		return mmWriteTo.funcWriteTo(w)
	}
	mmWriteTo.t.Fatalf("Unexpected call to GlobulaStateHashMock.WriteTo. %v", w)
	return
}

// WriteToAfterCounter returns a count of finished GlobulaStateHashMock.WriteTo invocations
func (mmWriteTo *GlobulaStateHashMock) WriteToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.afterWriteToCounter)
}

// WriteToBeforeCounter returns a count of GlobulaStateHashMock.WriteTo invocations
func (mmWriteTo *GlobulaStateHashMock) WriteToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.beforeWriteToCounter)
}

// Calls returns a list of arguments used in each call to GlobulaStateHashMock.WriteTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteTo *mGlobulaStateHashMockWriteTo) Calls() []*GlobulaStateHashMockWriteToParams {
	mmWriteTo.mutex.RLock()

	argCopy := make([]*GlobulaStateHashMockWriteToParams, len(mmWriteTo.callArgs))
	copy(argCopy, mmWriteTo.callArgs)

	mmWriteTo.mutex.RUnlock()

	return argCopy
}

// MinimockWriteToDone returns true if the count of the WriteTo invocations corresponds
// the number of defined expectations
func (m *GlobulaStateHashMock) MinimockWriteToDone() bool {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteToInspect logs each unmet expectation
func (m *GlobulaStateHashMock) MinimockWriteToInspect() {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GlobulaStateHashMock.WriteTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		if m.WriteToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GlobulaStateHashMock.WriteTo")
		} else {
			m.t.Errorf("Expected call to GlobulaStateHashMock.WriteTo with params: %#v", *m.WriteToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.WriteTo")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *GlobulaStateHashMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAsByteStringInspect()

		m.MinimockCopyToInspect()

		m.MinimockEqualsInspect()

		m.MinimockFixedByteSizeInspect()

		m.MinimockFoldToUint64Inspect()

		m.MinimockGetDigestMethodInspect()

		m.MinimockSignWithInspect()

		m.MinimockWriteToInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *GlobulaStateHashMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *GlobulaStateHashMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAsByteStringDone() &&
		m.MinimockCopyToDone() &&
		m.MinimockEqualsDone() &&
		m.MinimockFixedByteSizeDone() &&
		m.MinimockFoldToUint64Done() &&
		m.MinimockGetDigestMethodDone() &&
		m.MinimockSignWithDone() &&
		m.MinimockWriteToDone()
}
