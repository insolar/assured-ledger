package proofs

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/vanilla/cryptkit"
	"github.com/insolar/assured-ledger/ledger-core/vanilla/longbits"
)

// NodeStateHashMock implements NodeStateHash
type NodeStateHashMock struct {
	t minimock.Tester

	funcAsByteString          func() (b1 longbits.ByteString)
	inspectFuncAsByteString   func()
	afterAsByteStringCounter  uint64
	beforeAsByteStringCounter uint64
	AsByteStringMock          mNodeStateHashMockAsByteString

	funcCopyTo          func(p []byte) (i1 int)
	inspectFuncCopyTo   func(p []byte)
	afterCopyToCounter  uint64
	beforeCopyToCounter uint64
	CopyToMock          mNodeStateHashMockCopyTo

	funcEquals          func(other cryptkit.DigestHolder) (b1 bool)
	inspectFuncEquals   func(other cryptkit.DigestHolder)
	afterEqualsCounter  uint64
	beforeEqualsCounter uint64
	EqualsMock          mNodeStateHashMockEquals

	funcFixedByteSize          func() (i1 int)
	inspectFuncFixedByteSize   func()
	afterFixedByteSizeCounter  uint64
	beforeFixedByteSizeCounter uint64
	FixedByteSizeMock          mNodeStateHashMockFixedByteSize

	funcFoldToUint64          func() (u1 uint64)
	inspectFuncFoldToUint64   func()
	afterFoldToUint64Counter  uint64
	beforeFoldToUint64Counter uint64
	FoldToUint64Mock          mNodeStateHashMockFoldToUint64

	funcGetDigestMethod          func() (d1 cryptkit.DigestMethod)
	inspectFuncGetDigestMethod   func()
	afterGetDigestMethodCounter  uint64
	beforeGetDigestMethodCounter uint64
	GetDigestMethodMock          mNodeStateHashMockGetDigestMethod

	funcSignWith          func(signer cryptkit.DigestSigner) (s1 cryptkit.SignedDigestHolder)
	inspectFuncSignWith   func(signer cryptkit.DigestSigner)
	afterSignWithCounter  uint64
	beforeSignWithCounter uint64
	SignWithMock          mNodeStateHashMockSignWith

	funcWriteTo          func(w io.Writer) (n int64, err error)
	inspectFuncWriteTo   func(w io.Writer)
	afterWriteToCounter  uint64
	beforeWriteToCounter uint64
	WriteToMock          mNodeStateHashMockWriteTo
}

// NewNodeStateHashMock returns a mock for NodeStateHash
func NewNodeStateHashMock(t minimock.Tester) *NodeStateHashMock {
	m := &NodeStateHashMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AsByteStringMock = mNodeStateHashMockAsByteString{mock: m}

	m.CopyToMock = mNodeStateHashMockCopyTo{mock: m}
	m.CopyToMock.callArgs = []*NodeStateHashMockCopyToParams{}

	m.EqualsMock = mNodeStateHashMockEquals{mock: m}
	m.EqualsMock.callArgs = []*NodeStateHashMockEqualsParams{}

	m.FixedByteSizeMock = mNodeStateHashMockFixedByteSize{mock: m}

	m.FoldToUint64Mock = mNodeStateHashMockFoldToUint64{mock: m}

	m.GetDigestMethodMock = mNodeStateHashMockGetDigestMethod{mock: m}

	m.SignWithMock = mNodeStateHashMockSignWith{mock: m}
	m.SignWithMock.callArgs = []*NodeStateHashMockSignWithParams{}

	m.WriteToMock = mNodeStateHashMockWriteTo{mock: m}
	m.WriteToMock.callArgs = []*NodeStateHashMockWriteToParams{}

	return m
}

type mNodeStateHashMockAsByteString struct {
	mock               *NodeStateHashMock
	defaultExpectation *NodeStateHashMockAsByteStringExpectation
	expectations       []*NodeStateHashMockAsByteStringExpectation
}

// NodeStateHashMockAsByteStringExpectation specifies expectation struct of the NodeStateHash.AsByteString
type NodeStateHashMockAsByteStringExpectation struct {
	mock *NodeStateHashMock

	results *NodeStateHashMockAsByteStringResults
	Counter uint64
}

// NodeStateHashMockAsByteStringResults contains results of the NodeStateHash.AsByteString
type NodeStateHashMockAsByteStringResults struct {
	b1 longbits.ByteString
}

// Expect sets up expected params for NodeStateHash.AsByteString
func (mmAsByteString *mNodeStateHashMockAsByteString) Expect() *mNodeStateHashMockAsByteString {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("NodeStateHashMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &NodeStateHashMockAsByteStringExpectation{}
	}

	return mmAsByteString
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHash.AsByteString
func (mmAsByteString *mNodeStateHashMockAsByteString) Inspect(f func()) *mNodeStateHashMockAsByteString {
	if mmAsByteString.mock.inspectFuncAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("Inspect function is already set for NodeStateHashMock.AsByteString")
	}

	mmAsByteString.mock.inspectFuncAsByteString = f

	return mmAsByteString
}

// Return sets up results that will be returned by NodeStateHash.AsByteString
func (mmAsByteString *mNodeStateHashMockAsByteString) Return(b1 longbits.ByteString) *NodeStateHashMock {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("NodeStateHashMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &NodeStateHashMockAsByteStringExpectation{mock: mmAsByteString.mock}
	}
	mmAsByteString.defaultExpectation.results = &NodeStateHashMockAsByteStringResults{b1}
	return mmAsByteString.mock
}

//Set uses given function f to mock the NodeStateHash.AsByteString method
func (mmAsByteString *mNodeStateHashMockAsByteString) Set(f func() (b1 longbits.ByteString)) *NodeStateHashMock {
	if mmAsByteString.defaultExpectation != nil {
		mmAsByteString.mock.t.Fatalf("Default expectation is already set for the NodeStateHash.AsByteString method")
	}

	if len(mmAsByteString.expectations) > 0 {
		mmAsByteString.mock.t.Fatalf("Some expectations are already set for the NodeStateHash.AsByteString method")
	}

	mmAsByteString.mock.funcAsByteString = f
	return mmAsByteString.mock
}

// AsByteString implements NodeStateHash
func (mmAsByteString *NodeStateHashMock) AsByteString() (b1 longbits.ByteString) {
	mm_atomic.AddUint64(&mmAsByteString.beforeAsByteStringCounter, 1)
	defer mm_atomic.AddUint64(&mmAsByteString.afterAsByteStringCounter, 1)

	if mmAsByteString.inspectFuncAsByteString != nil {
		mmAsByteString.inspectFuncAsByteString()
	}

	if mmAsByteString.AsByteStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsByteString.AsByteStringMock.defaultExpectation.Counter, 1)

		mm_results := mmAsByteString.AsByteStringMock.defaultExpectation.results
		if mm_results == nil {
			mmAsByteString.t.Fatal("No results are set for the NodeStateHashMock.AsByteString")
		}
		return (*mm_results).b1
	}
	if mmAsByteString.funcAsByteString != nil {
		return mmAsByteString.funcAsByteString()
	}
	mmAsByteString.t.Fatalf("Unexpected call to NodeStateHashMock.AsByteString.")
	return
}

// AsByteStringAfterCounter returns a count of finished NodeStateHashMock.AsByteString invocations
func (mmAsByteString *NodeStateHashMock) AsByteStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.afterAsByteStringCounter)
}

// AsByteStringBeforeCounter returns a count of NodeStateHashMock.AsByteString invocations
func (mmAsByteString *NodeStateHashMock) AsByteStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.beforeAsByteStringCounter)
}

// MinimockAsByteStringDone returns true if the count of the AsByteString invocations corresponds
// the number of defined expectations
func (m *NodeStateHashMock) MinimockAsByteStringDone() bool {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsByteStringInspect logs each unmet expectation
func (m *NodeStateHashMock) MinimockAsByteStringInspect() {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NodeStateHashMock.AsByteString")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.AsByteString")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.AsByteString")
	}
}

type mNodeStateHashMockCopyTo struct {
	mock               *NodeStateHashMock
	defaultExpectation *NodeStateHashMockCopyToExpectation
	expectations       []*NodeStateHashMockCopyToExpectation

	callArgs []*NodeStateHashMockCopyToParams
	mutex    sync.RWMutex
}

// NodeStateHashMockCopyToExpectation specifies expectation struct of the NodeStateHash.CopyTo
type NodeStateHashMockCopyToExpectation struct {
	mock    *NodeStateHashMock
	params  *NodeStateHashMockCopyToParams
	results *NodeStateHashMockCopyToResults
	Counter uint64
}

// NodeStateHashMockCopyToParams contains parameters of the NodeStateHash.CopyTo
type NodeStateHashMockCopyToParams struct {
	p []byte
}

// NodeStateHashMockCopyToResults contains results of the NodeStateHash.CopyTo
type NodeStateHashMockCopyToResults struct {
	i1 int
}

// Expect sets up expected params for NodeStateHash.CopyTo
func (mmCopyTo *mNodeStateHashMockCopyTo) Expect(p []byte) *mNodeStateHashMockCopyTo {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("NodeStateHashMock.CopyTo mock is already set by Set")
	}

	if mmCopyTo.defaultExpectation == nil {
		mmCopyTo.defaultExpectation = &NodeStateHashMockCopyToExpectation{}
	}

	mmCopyTo.defaultExpectation.params = &NodeStateHashMockCopyToParams{p}
	for _, e := range mmCopyTo.expectations {
		if minimock.Equal(e.params, mmCopyTo.defaultExpectation.params) {
			mmCopyTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCopyTo.defaultExpectation.params)
		}
	}

	return mmCopyTo
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHash.CopyTo
func (mmCopyTo *mNodeStateHashMockCopyTo) Inspect(f func(p []byte)) *mNodeStateHashMockCopyTo {
	if mmCopyTo.mock.inspectFuncCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("Inspect function is already set for NodeStateHashMock.CopyTo")
	}

	mmCopyTo.mock.inspectFuncCopyTo = f

	return mmCopyTo
}

// Return sets up results that will be returned by NodeStateHash.CopyTo
func (mmCopyTo *mNodeStateHashMockCopyTo) Return(i1 int) *NodeStateHashMock {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("NodeStateHashMock.CopyTo mock is already set by Set")
	}

	if mmCopyTo.defaultExpectation == nil {
		mmCopyTo.defaultExpectation = &NodeStateHashMockCopyToExpectation{mock: mmCopyTo.mock}
	}
	mmCopyTo.defaultExpectation.results = &NodeStateHashMockCopyToResults{i1}
	return mmCopyTo.mock
}

//Set uses given function f to mock the NodeStateHash.CopyTo method
func (mmCopyTo *mNodeStateHashMockCopyTo) Set(f func(p []byte) (i1 int)) *NodeStateHashMock {
	if mmCopyTo.defaultExpectation != nil {
		mmCopyTo.mock.t.Fatalf("Default expectation is already set for the NodeStateHash.CopyTo method")
	}

	if len(mmCopyTo.expectations) > 0 {
		mmCopyTo.mock.t.Fatalf("Some expectations are already set for the NodeStateHash.CopyTo method")
	}

	mmCopyTo.mock.funcCopyTo = f
	return mmCopyTo.mock
}

// When sets expectation for the NodeStateHash.CopyTo which will trigger the result defined by the following
// Then helper
func (mmCopyTo *mNodeStateHashMockCopyTo) When(p []byte) *NodeStateHashMockCopyToExpectation {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("NodeStateHashMock.CopyTo mock is already set by Set")
	}

	expectation := &NodeStateHashMockCopyToExpectation{
		mock:   mmCopyTo.mock,
		params: &NodeStateHashMockCopyToParams{p},
	}
	mmCopyTo.expectations = append(mmCopyTo.expectations, expectation)
	return expectation
}

// Then sets up NodeStateHash.CopyTo return parameters for the expectation previously defined by the When method
func (e *NodeStateHashMockCopyToExpectation) Then(i1 int) *NodeStateHashMock {
	e.results = &NodeStateHashMockCopyToResults{i1}
	return e.mock
}

// CopyTo implements NodeStateHash
func (mmCopyTo *NodeStateHashMock) CopyTo(p []byte) (i1 int) {
	mm_atomic.AddUint64(&mmCopyTo.beforeCopyToCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyTo.afterCopyToCounter, 1)

	if mmCopyTo.inspectFuncCopyTo != nil {
		mmCopyTo.inspectFuncCopyTo(p)
	}

	mm_params := &NodeStateHashMockCopyToParams{p}

	// Record call args
	mmCopyTo.CopyToMock.mutex.Lock()
	mmCopyTo.CopyToMock.callArgs = append(mmCopyTo.CopyToMock.callArgs, mm_params)
	mmCopyTo.CopyToMock.mutex.Unlock()

	for _, e := range mmCopyTo.CopyToMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1
		}
	}

	if mmCopyTo.CopyToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyTo.CopyToMock.defaultExpectation.Counter, 1)
		mm_want := mmCopyTo.CopyToMock.defaultExpectation.params
		mm_got := NodeStateHashMockCopyToParams{p}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCopyTo.t.Errorf("NodeStateHashMock.CopyTo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCopyTo.CopyToMock.defaultExpectation.results
		if mm_results == nil {
			mmCopyTo.t.Fatal("No results are set for the NodeStateHashMock.CopyTo")
		}
		return (*mm_results).i1
	}
	if mmCopyTo.funcCopyTo != nil {
		return mmCopyTo.funcCopyTo(p)
	}
	mmCopyTo.t.Fatalf("Unexpected call to NodeStateHashMock.CopyTo. %v", p)
	return
}

// CopyToAfterCounter returns a count of finished NodeStateHashMock.CopyTo invocations
func (mmCopyTo *NodeStateHashMock) CopyToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyTo.afterCopyToCounter)
}

// CopyToBeforeCounter returns a count of NodeStateHashMock.CopyTo invocations
func (mmCopyTo *NodeStateHashMock) CopyToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyTo.beforeCopyToCounter)
}

// Calls returns a list of arguments used in each call to NodeStateHashMock.CopyTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCopyTo *mNodeStateHashMockCopyTo) Calls() []*NodeStateHashMockCopyToParams {
	mmCopyTo.mutex.RLock()

	argCopy := make([]*NodeStateHashMockCopyToParams, len(mmCopyTo.callArgs))
	copy(argCopy, mmCopyTo.callArgs)

	mmCopyTo.mutex.RUnlock()

	return argCopy
}

// MinimockCopyToDone returns true if the count of the CopyTo invocations corresponds
// the number of defined expectations
func (m *NodeStateHashMock) MinimockCopyToDone() bool {
	for _, e := range m.CopyToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyTo != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyToInspect logs each unmet expectation
func (m *NodeStateHashMock) MinimockCopyToInspect() {
	for _, e := range m.CopyToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NodeStateHashMock.CopyTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		if m.CopyToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NodeStateHashMock.CopyTo")
		} else {
			m.t.Errorf("Expected call to NodeStateHashMock.CopyTo with params: %#v", *m.CopyToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyTo != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.CopyTo")
	}
}

type mNodeStateHashMockEquals struct {
	mock               *NodeStateHashMock
	defaultExpectation *NodeStateHashMockEqualsExpectation
	expectations       []*NodeStateHashMockEqualsExpectation

	callArgs []*NodeStateHashMockEqualsParams
	mutex    sync.RWMutex
}

// NodeStateHashMockEqualsExpectation specifies expectation struct of the NodeStateHash.Equals
type NodeStateHashMockEqualsExpectation struct {
	mock    *NodeStateHashMock
	params  *NodeStateHashMockEqualsParams
	results *NodeStateHashMockEqualsResults
	Counter uint64
}

// NodeStateHashMockEqualsParams contains parameters of the NodeStateHash.Equals
type NodeStateHashMockEqualsParams struct {
	other cryptkit.DigestHolder
}

// NodeStateHashMockEqualsResults contains results of the NodeStateHash.Equals
type NodeStateHashMockEqualsResults struct {
	b1 bool
}

// Expect sets up expected params for NodeStateHash.Equals
func (mmEquals *mNodeStateHashMockEquals) Expect(other cryptkit.DigestHolder) *mNodeStateHashMockEquals {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("NodeStateHashMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &NodeStateHashMockEqualsExpectation{}
	}

	mmEquals.defaultExpectation.params = &NodeStateHashMockEqualsParams{other}
	for _, e := range mmEquals.expectations {
		if minimock.Equal(e.params, mmEquals.defaultExpectation.params) {
			mmEquals.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEquals.defaultExpectation.params)
		}
	}

	return mmEquals
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHash.Equals
func (mmEquals *mNodeStateHashMockEquals) Inspect(f func(other cryptkit.DigestHolder)) *mNodeStateHashMockEquals {
	if mmEquals.mock.inspectFuncEquals != nil {
		mmEquals.mock.t.Fatalf("Inspect function is already set for NodeStateHashMock.Equals")
	}

	mmEquals.mock.inspectFuncEquals = f

	return mmEquals
}

// Return sets up results that will be returned by NodeStateHash.Equals
func (mmEquals *mNodeStateHashMockEquals) Return(b1 bool) *NodeStateHashMock {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("NodeStateHashMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &NodeStateHashMockEqualsExpectation{mock: mmEquals.mock}
	}
	mmEquals.defaultExpectation.results = &NodeStateHashMockEqualsResults{b1}
	return mmEquals.mock
}

//Set uses given function f to mock the NodeStateHash.Equals method
func (mmEquals *mNodeStateHashMockEquals) Set(f func(other cryptkit.DigestHolder) (b1 bool)) *NodeStateHashMock {
	if mmEquals.defaultExpectation != nil {
		mmEquals.mock.t.Fatalf("Default expectation is already set for the NodeStateHash.Equals method")
	}

	if len(mmEquals.expectations) > 0 {
		mmEquals.mock.t.Fatalf("Some expectations are already set for the NodeStateHash.Equals method")
	}

	mmEquals.mock.funcEquals = f
	return mmEquals.mock
}

// When sets expectation for the NodeStateHash.Equals which will trigger the result defined by the following
// Then helper
func (mmEquals *mNodeStateHashMockEquals) When(other cryptkit.DigestHolder) *NodeStateHashMockEqualsExpectation {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("NodeStateHashMock.Equals mock is already set by Set")
	}

	expectation := &NodeStateHashMockEqualsExpectation{
		mock:   mmEquals.mock,
		params: &NodeStateHashMockEqualsParams{other},
	}
	mmEquals.expectations = append(mmEquals.expectations, expectation)
	return expectation
}

// Then sets up NodeStateHash.Equals return parameters for the expectation previously defined by the When method
func (e *NodeStateHashMockEqualsExpectation) Then(b1 bool) *NodeStateHashMock {
	e.results = &NodeStateHashMockEqualsResults{b1}
	return e.mock
}

// Equals implements NodeStateHash
func (mmEquals *NodeStateHashMock) Equals(other cryptkit.DigestHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmEquals.beforeEqualsCounter, 1)
	defer mm_atomic.AddUint64(&mmEquals.afterEqualsCounter, 1)

	if mmEquals.inspectFuncEquals != nil {
		mmEquals.inspectFuncEquals(other)
	}

	mm_params := &NodeStateHashMockEqualsParams{other}

	// Record call args
	mmEquals.EqualsMock.mutex.Lock()
	mmEquals.EqualsMock.callArgs = append(mmEquals.EqualsMock.callArgs, mm_params)
	mmEquals.EqualsMock.mutex.Unlock()

	for _, e := range mmEquals.EqualsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmEquals.EqualsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEquals.EqualsMock.defaultExpectation.Counter, 1)
		mm_want := mmEquals.EqualsMock.defaultExpectation.params
		mm_got := NodeStateHashMockEqualsParams{other}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEquals.t.Errorf("NodeStateHashMock.Equals got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEquals.EqualsMock.defaultExpectation.results
		if mm_results == nil {
			mmEquals.t.Fatal("No results are set for the NodeStateHashMock.Equals")
		}
		return (*mm_results).b1
	}
	if mmEquals.funcEquals != nil {
		return mmEquals.funcEquals(other)
	}
	mmEquals.t.Fatalf("Unexpected call to NodeStateHashMock.Equals. %v", other)
	return
}

// EqualsAfterCounter returns a count of finished NodeStateHashMock.Equals invocations
func (mmEquals *NodeStateHashMock) EqualsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.afterEqualsCounter)
}

// EqualsBeforeCounter returns a count of NodeStateHashMock.Equals invocations
func (mmEquals *NodeStateHashMock) EqualsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.beforeEqualsCounter)
}

// Calls returns a list of arguments used in each call to NodeStateHashMock.Equals.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEquals *mNodeStateHashMockEquals) Calls() []*NodeStateHashMockEqualsParams {
	mmEquals.mutex.RLock()

	argCopy := make([]*NodeStateHashMockEqualsParams, len(mmEquals.callArgs))
	copy(argCopy, mmEquals.callArgs)

	mmEquals.mutex.RUnlock()

	return argCopy
}

// MinimockEqualsDone returns true if the count of the Equals invocations corresponds
// the number of defined expectations
func (m *NodeStateHashMock) MinimockEqualsDone() bool {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	return true
}

// MinimockEqualsInspect logs each unmet expectation
func (m *NodeStateHashMock) MinimockEqualsInspect() {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NodeStateHashMock.Equals with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		if m.EqualsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NodeStateHashMock.Equals")
		} else {
			m.t.Errorf("Expected call to NodeStateHashMock.Equals with params: %#v", *m.EqualsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.Equals")
	}
}

type mNodeStateHashMockFixedByteSize struct {
	mock               *NodeStateHashMock
	defaultExpectation *NodeStateHashMockFixedByteSizeExpectation
	expectations       []*NodeStateHashMockFixedByteSizeExpectation
}

// NodeStateHashMockFixedByteSizeExpectation specifies expectation struct of the NodeStateHash.FixedByteSize
type NodeStateHashMockFixedByteSizeExpectation struct {
	mock *NodeStateHashMock

	results *NodeStateHashMockFixedByteSizeResults
	Counter uint64
}

// NodeStateHashMockFixedByteSizeResults contains results of the NodeStateHash.FixedByteSize
type NodeStateHashMockFixedByteSizeResults struct {
	i1 int
}

// Expect sets up expected params for NodeStateHash.FixedByteSize
func (mmFixedByteSize *mNodeStateHashMockFixedByteSize) Expect() *mNodeStateHashMockFixedByteSize {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("NodeStateHashMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &NodeStateHashMockFixedByteSizeExpectation{}
	}

	return mmFixedByteSize
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHash.FixedByteSize
func (mmFixedByteSize *mNodeStateHashMockFixedByteSize) Inspect(f func()) *mNodeStateHashMockFixedByteSize {
	if mmFixedByteSize.mock.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("Inspect function is already set for NodeStateHashMock.FixedByteSize")
	}

	mmFixedByteSize.mock.inspectFuncFixedByteSize = f

	return mmFixedByteSize
}

// Return sets up results that will be returned by NodeStateHash.FixedByteSize
func (mmFixedByteSize *mNodeStateHashMockFixedByteSize) Return(i1 int) *NodeStateHashMock {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("NodeStateHashMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &NodeStateHashMockFixedByteSizeExpectation{mock: mmFixedByteSize.mock}
	}
	mmFixedByteSize.defaultExpectation.results = &NodeStateHashMockFixedByteSizeResults{i1}
	return mmFixedByteSize.mock
}

//Set uses given function f to mock the NodeStateHash.FixedByteSize method
func (mmFixedByteSize *mNodeStateHashMockFixedByteSize) Set(f func() (i1 int)) *NodeStateHashMock {
	if mmFixedByteSize.defaultExpectation != nil {
		mmFixedByteSize.mock.t.Fatalf("Default expectation is already set for the NodeStateHash.FixedByteSize method")
	}

	if len(mmFixedByteSize.expectations) > 0 {
		mmFixedByteSize.mock.t.Fatalf("Some expectations are already set for the NodeStateHash.FixedByteSize method")
	}

	mmFixedByteSize.mock.funcFixedByteSize = f
	return mmFixedByteSize.mock
}

// FixedByteSize implements NodeStateHash
func (mmFixedByteSize *NodeStateHashMock) FixedByteSize() (i1 int) {
	mm_atomic.AddUint64(&mmFixedByteSize.beforeFixedByteSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmFixedByteSize.afterFixedByteSizeCounter, 1)

	if mmFixedByteSize.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.inspectFuncFixedByteSize()
	}

	if mmFixedByteSize.FixedByteSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFixedByteSize.FixedByteSizeMock.defaultExpectation.Counter, 1)

		mm_results := mmFixedByteSize.FixedByteSizeMock.defaultExpectation.results
		if mm_results == nil {
			mmFixedByteSize.t.Fatal("No results are set for the NodeStateHashMock.FixedByteSize")
		}
		return (*mm_results).i1
	}
	if mmFixedByteSize.funcFixedByteSize != nil {
		return mmFixedByteSize.funcFixedByteSize()
	}
	mmFixedByteSize.t.Fatalf("Unexpected call to NodeStateHashMock.FixedByteSize.")
	return
}

// FixedByteSizeAfterCounter returns a count of finished NodeStateHashMock.FixedByteSize invocations
func (mmFixedByteSize *NodeStateHashMock) FixedByteSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.afterFixedByteSizeCounter)
}

// FixedByteSizeBeforeCounter returns a count of NodeStateHashMock.FixedByteSize invocations
func (mmFixedByteSize *NodeStateHashMock) FixedByteSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.beforeFixedByteSizeCounter)
}

// MinimockFixedByteSizeDone returns true if the count of the FixedByteSize invocations corresponds
// the number of defined expectations
func (m *NodeStateHashMock) MinimockFixedByteSizeDone() bool {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockFixedByteSizeInspect logs each unmet expectation
func (m *NodeStateHashMock) MinimockFixedByteSizeInspect() {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NodeStateHashMock.FixedByteSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.FixedByteSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.FixedByteSize")
	}
}

type mNodeStateHashMockFoldToUint64 struct {
	mock               *NodeStateHashMock
	defaultExpectation *NodeStateHashMockFoldToUint64Expectation
	expectations       []*NodeStateHashMockFoldToUint64Expectation
}

// NodeStateHashMockFoldToUint64Expectation specifies expectation struct of the NodeStateHash.FoldToUint64
type NodeStateHashMockFoldToUint64Expectation struct {
	mock *NodeStateHashMock

	results *NodeStateHashMockFoldToUint64Results
	Counter uint64
}

// NodeStateHashMockFoldToUint64Results contains results of the NodeStateHash.FoldToUint64
type NodeStateHashMockFoldToUint64Results struct {
	u1 uint64
}

// Expect sets up expected params for NodeStateHash.FoldToUint64
func (mmFoldToUint64 *mNodeStateHashMockFoldToUint64) Expect() *mNodeStateHashMockFoldToUint64 {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("NodeStateHashMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &NodeStateHashMockFoldToUint64Expectation{}
	}

	return mmFoldToUint64
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHash.FoldToUint64
func (mmFoldToUint64 *mNodeStateHashMockFoldToUint64) Inspect(f func()) *mNodeStateHashMockFoldToUint64 {
	if mmFoldToUint64.mock.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("Inspect function is already set for NodeStateHashMock.FoldToUint64")
	}

	mmFoldToUint64.mock.inspectFuncFoldToUint64 = f

	return mmFoldToUint64
}

// Return sets up results that will be returned by NodeStateHash.FoldToUint64
func (mmFoldToUint64 *mNodeStateHashMockFoldToUint64) Return(u1 uint64) *NodeStateHashMock {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("NodeStateHashMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &NodeStateHashMockFoldToUint64Expectation{mock: mmFoldToUint64.mock}
	}
	mmFoldToUint64.defaultExpectation.results = &NodeStateHashMockFoldToUint64Results{u1}
	return mmFoldToUint64.mock
}

//Set uses given function f to mock the NodeStateHash.FoldToUint64 method
func (mmFoldToUint64 *mNodeStateHashMockFoldToUint64) Set(f func() (u1 uint64)) *NodeStateHashMock {
	if mmFoldToUint64.defaultExpectation != nil {
		mmFoldToUint64.mock.t.Fatalf("Default expectation is already set for the NodeStateHash.FoldToUint64 method")
	}

	if len(mmFoldToUint64.expectations) > 0 {
		mmFoldToUint64.mock.t.Fatalf("Some expectations are already set for the NodeStateHash.FoldToUint64 method")
	}

	mmFoldToUint64.mock.funcFoldToUint64 = f
	return mmFoldToUint64.mock
}

// FoldToUint64 implements NodeStateHash
func (mmFoldToUint64 *NodeStateHashMock) FoldToUint64() (u1 uint64) {
	mm_atomic.AddUint64(&mmFoldToUint64.beforeFoldToUint64Counter, 1)
	defer mm_atomic.AddUint64(&mmFoldToUint64.afterFoldToUint64Counter, 1)

	if mmFoldToUint64.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.inspectFuncFoldToUint64()
	}

	if mmFoldToUint64.FoldToUint64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFoldToUint64.FoldToUint64Mock.defaultExpectation.Counter, 1)

		mm_results := mmFoldToUint64.FoldToUint64Mock.defaultExpectation.results
		if mm_results == nil {
			mmFoldToUint64.t.Fatal("No results are set for the NodeStateHashMock.FoldToUint64")
		}
		return (*mm_results).u1
	}
	if mmFoldToUint64.funcFoldToUint64 != nil {
		return mmFoldToUint64.funcFoldToUint64()
	}
	mmFoldToUint64.t.Fatalf("Unexpected call to NodeStateHashMock.FoldToUint64.")
	return
}

// FoldToUint64AfterCounter returns a count of finished NodeStateHashMock.FoldToUint64 invocations
func (mmFoldToUint64 *NodeStateHashMock) FoldToUint64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.afterFoldToUint64Counter)
}

// FoldToUint64BeforeCounter returns a count of NodeStateHashMock.FoldToUint64 invocations
func (mmFoldToUint64 *NodeStateHashMock) FoldToUint64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.beforeFoldToUint64Counter)
}

// MinimockFoldToUint64Done returns true if the count of the FoldToUint64 invocations corresponds
// the number of defined expectations
func (m *NodeStateHashMock) MinimockFoldToUint64Done() bool {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	return true
}

// MinimockFoldToUint64Inspect logs each unmet expectation
func (m *NodeStateHashMock) MinimockFoldToUint64Inspect() {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NodeStateHashMock.FoldToUint64")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.FoldToUint64")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.FoldToUint64")
	}
}

type mNodeStateHashMockGetDigestMethod struct {
	mock               *NodeStateHashMock
	defaultExpectation *NodeStateHashMockGetDigestMethodExpectation
	expectations       []*NodeStateHashMockGetDigestMethodExpectation
}

// NodeStateHashMockGetDigestMethodExpectation specifies expectation struct of the NodeStateHash.GetDigestMethod
type NodeStateHashMockGetDigestMethodExpectation struct {
	mock *NodeStateHashMock

	results *NodeStateHashMockGetDigestMethodResults
	Counter uint64
}

// NodeStateHashMockGetDigestMethodResults contains results of the NodeStateHash.GetDigestMethod
type NodeStateHashMockGetDigestMethodResults struct {
	d1 cryptkit.DigestMethod
}

// Expect sets up expected params for NodeStateHash.GetDigestMethod
func (mmGetDigestMethod *mNodeStateHashMockGetDigestMethod) Expect() *mNodeStateHashMockGetDigestMethod {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("NodeStateHashMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &NodeStateHashMockGetDigestMethodExpectation{}
	}

	return mmGetDigestMethod
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHash.GetDigestMethod
func (mmGetDigestMethod *mNodeStateHashMockGetDigestMethod) Inspect(f func()) *mNodeStateHashMockGetDigestMethod {
	if mmGetDigestMethod.mock.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("Inspect function is already set for NodeStateHashMock.GetDigestMethod")
	}

	mmGetDigestMethod.mock.inspectFuncGetDigestMethod = f

	return mmGetDigestMethod
}

// Return sets up results that will be returned by NodeStateHash.GetDigestMethod
func (mmGetDigestMethod *mNodeStateHashMockGetDigestMethod) Return(d1 cryptkit.DigestMethod) *NodeStateHashMock {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("NodeStateHashMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &NodeStateHashMockGetDigestMethodExpectation{mock: mmGetDigestMethod.mock}
	}
	mmGetDigestMethod.defaultExpectation.results = &NodeStateHashMockGetDigestMethodResults{d1}
	return mmGetDigestMethod.mock
}

//Set uses given function f to mock the NodeStateHash.GetDigestMethod method
func (mmGetDigestMethod *mNodeStateHashMockGetDigestMethod) Set(f func() (d1 cryptkit.DigestMethod)) *NodeStateHashMock {
	if mmGetDigestMethod.defaultExpectation != nil {
		mmGetDigestMethod.mock.t.Fatalf("Default expectation is already set for the NodeStateHash.GetDigestMethod method")
	}

	if len(mmGetDigestMethod.expectations) > 0 {
		mmGetDigestMethod.mock.t.Fatalf("Some expectations are already set for the NodeStateHash.GetDigestMethod method")
	}

	mmGetDigestMethod.mock.funcGetDigestMethod = f
	return mmGetDigestMethod.mock
}

// GetDigestMethod implements NodeStateHash
func (mmGetDigestMethod *NodeStateHashMock) GetDigestMethod() (d1 cryptkit.DigestMethod) {
	mm_atomic.AddUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestMethod.afterGetDigestMethodCounter, 1)

	if mmGetDigestMethod.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.inspectFuncGetDigestMethod()
	}

	if mmGetDigestMethod.GetDigestMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDigestMethod.t.Fatal("No results are set for the NodeStateHashMock.GetDigestMethod")
		}
		return (*mm_results).d1
	}
	if mmGetDigestMethod.funcGetDigestMethod != nil {
		return mmGetDigestMethod.funcGetDigestMethod()
	}
	mmGetDigestMethod.t.Fatalf("Unexpected call to NodeStateHashMock.GetDigestMethod.")
	return
}

// GetDigestMethodAfterCounter returns a count of finished NodeStateHashMock.GetDigestMethod invocations
func (mmGetDigestMethod *NodeStateHashMock) GetDigestMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.afterGetDigestMethodCounter)
}

// GetDigestMethodBeforeCounter returns a count of NodeStateHashMock.GetDigestMethod invocations
func (mmGetDigestMethod *NodeStateHashMock) GetDigestMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter)
}

// MinimockGetDigestMethodDone returns true if the count of the GetDigestMethod invocations corresponds
// the number of defined expectations
func (m *NodeStateHashMock) MinimockGetDigestMethodDone() bool {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestMethodInspect logs each unmet expectation
func (m *NodeStateHashMock) MinimockGetDigestMethodInspect() {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NodeStateHashMock.GetDigestMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.GetDigestMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.GetDigestMethod")
	}
}

type mNodeStateHashMockSignWith struct {
	mock               *NodeStateHashMock
	defaultExpectation *NodeStateHashMockSignWithExpectation
	expectations       []*NodeStateHashMockSignWithExpectation

	callArgs []*NodeStateHashMockSignWithParams
	mutex    sync.RWMutex
}

// NodeStateHashMockSignWithExpectation specifies expectation struct of the NodeStateHash.SignWith
type NodeStateHashMockSignWithExpectation struct {
	mock    *NodeStateHashMock
	params  *NodeStateHashMockSignWithParams
	results *NodeStateHashMockSignWithResults
	Counter uint64
}

// NodeStateHashMockSignWithParams contains parameters of the NodeStateHash.SignWith
type NodeStateHashMockSignWithParams struct {
	signer cryptkit.DigestSigner
}

// NodeStateHashMockSignWithResults contains results of the NodeStateHash.SignWith
type NodeStateHashMockSignWithResults struct {
	s1 cryptkit.SignedDigestHolder
}

// Expect sets up expected params for NodeStateHash.SignWith
func (mmSignWith *mNodeStateHashMockSignWith) Expect(signer cryptkit.DigestSigner) *mNodeStateHashMockSignWith {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("NodeStateHashMock.SignWith mock is already set by Set")
	}

	if mmSignWith.defaultExpectation == nil {
		mmSignWith.defaultExpectation = &NodeStateHashMockSignWithExpectation{}
	}

	mmSignWith.defaultExpectation.params = &NodeStateHashMockSignWithParams{signer}
	for _, e := range mmSignWith.expectations {
		if minimock.Equal(e.params, mmSignWith.defaultExpectation.params) {
			mmSignWith.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSignWith.defaultExpectation.params)
		}
	}

	return mmSignWith
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHash.SignWith
func (mmSignWith *mNodeStateHashMockSignWith) Inspect(f func(signer cryptkit.DigestSigner)) *mNodeStateHashMockSignWith {
	if mmSignWith.mock.inspectFuncSignWith != nil {
		mmSignWith.mock.t.Fatalf("Inspect function is already set for NodeStateHashMock.SignWith")
	}

	mmSignWith.mock.inspectFuncSignWith = f

	return mmSignWith
}

// Return sets up results that will be returned by NodeStateHash.SignWith
func (mmSignWith *mNodeStateHashMockSignWith) Return(s1 cryptkit.SignedDigestHolder) *NodeStateHashMock {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("NodeStateHashMock.SignWith mock is already set by Set")
	}

	if mmSignWith.defaultExpectation == nil {
		mmSignWith.defaultExpectation = &NodeStateHashMockSignWithExpectation{mock: mmSignWith.mock}
	}
	mmSignWith.defaultExpectation.results = &NodeStateHashMockSignWithResults{s1}
	return mmSignWith.mock
}

//Set uses given function f to mock the NodeStateHash.SignWith method
func (mmSignWith *mNodeStateHashMockSignWith) Set(f func(signer cryptkit.DigestSigner) (s1 cryptkit.SignedDigestHolder)) *NodeStateHashMock {
	if mmSignWith.defaultExpectation != nil {
		mmSignWith.mock.t.Fatalf("Default expectation is already set for the NodeStateHash.SignWith method")
	}

	if len(mmSignWith.expectations) > 0 {
		mmSignWith.mock.t.Fatalf("Some expectations are already set for the NodeStateHash.SignWith method")
	}

	mmSignWith.mock.funcSignWith = f
	return mmSignWith.mock
}

// When sets expectation for the NodeStateHash.SignWith which will trigger the result defined by the following
// Then helper
func (mmSignWith *mNodeStateHashMockSignWith) When(signer cryptkit.DigestSigner) *NodeStateHashMockSignWithExpectation {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("NodeStateHashMock.SignWith mock is already set by Set")
	}

	expectation := &NodeStateHashMockSignWithExpectation{
		mock:   mmSignWith.mock,
		params: &NodeStateHashMockSignWithParams{signer},
	}
	mmSignWith.expectations = append(mmSignWith.expectations, expectation)
	return expectation
}

// Then sets up NodeStateHash.SignWith return parameters for the expectation previously defined by the When method
func (e *NodeStateHashMockSignWithExpectation) Then(s1 cryptkit.SignedDigestHolder) *NodeStateHashMock {
	e.results = &NodeStateHashMockSignWithResults{s1}
	return e.mock
}

// SignWith implements NodeStateHash
func (mmSignWith *NodeStateHashMock) SignWith(signer cryptkit.DigestSigner) (s1 cryptkit.SignedDigestHolder) {
	mm_atomic.AddUint64(&mmSignWith.beforeSignWithCounter, 1)
	defer mm_atomic.AddUint64(&mmSignWith.afterSignWithCounter, 1)

	if mmSignWith.inspectFuncSignWith != nil {
		mmSignWith.inspectFuncSignWith(signer)
	}

	mm_params := &NodeStateHashMockSignWithParams{signer}

	// Record call args
	mmSignWith.SignWithMock.mutex.Lock()
	mmSignWith.SignWithMock.callArgs = append(mmSignWith.SignWithMock.callArgs, mm_params)
	mmSignWith.SignWithMock.mutex.Unlock()

	for _, e := range mmSignWith.SignWithMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSignWith.SignWithMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSignWith.SignWithMock.defaultExpectation.Counter, 1)
		mm_want := mmSignWith.SignWithMock.defaultExpectation.params
		mm_got := NodeStateHashMockSignWithParams{signer}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSignWith.t.Errorf("NodeStateHashMock.SignWith got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSignWith.SignWithMock.defaultExpectation.results
		if mm_results == nil {
			mmSignWith.t.Fatal("No results are set for the NodeStateHashMock.SignWith")
		}
		return (*mm_results).s1
	}
	if mmSignWith.funcSignWith != nil {
		return mmSignWith.funcSignWith(signer)
	}
	mmSignWith.t.Fatalf("Unexpected call to NodeStateHashMock.SignWith. %v", signer)
	return
}

// SignWithAfterCounter returns a count of finished NodeStateHashMock.SignWith invocations
func (mmSignWith *NodeStateHashMock) SignWithAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignWith.afterSignWithCounter)
}

// SignWithBeforeCounter returns a count of NodeStateHashMock.SignWith invocations
func (mmSignWith *NodeStateHashMock) SignWithBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignWith.beforeSignWithCounter)
}

// Calls returns a list of arguments used in each call to NodeStateHashMock.SignWith.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSignWith *mNodeStateHashMockSignWith) Calls() []*NodeStateHashMockSignWithParams {
	mmSignWith.mutex.RLock()

	argCopy := make([]*NodeStateHashMockSignWithParams, len(mmSignWith.callArgs))
	copy(argCopy, mmSignWith.callArgs)

	mmSignWith.mutex.RUnlock()

	return argCopy
}

// MinimockSignWithDone returns true if the count of the SignWith invocations corresponds
// the number of defined expectations
func (m *NodeStateHashMock) MinimockSignWithDone() bool {
	for _, e := range m.SignWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignWith != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		return false
	}
	return true
}

// MinimockSignWithInspect logs each unmet expectation
func (m *NodeStateHashMock) MinimockSignWithInspect() {
	for _, e := range m.SignWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NodeStateHashMock.SignWith with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		if m.SignWithMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NodeStateHashMock.SignWith")
		} else {
			m.t.Errorf("Expected call to NodeStateHashMock.SignWith with params: %#v", *m.SignWithMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignWith != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.SignWith")
	}
}

type mNodeStateHashMockWriteTo struct {
	mock               *NodeStateHashMock
	defaultExpectation *NodeStateHashMockWriteToExpectation
	expectations       []*NodeStateHashMockWriteToExpectation

	callArgs []*NodeStateHashMockWriteToParams
	mutex    sync.RWMutex
}

// NodeStateHashMockWriteToExpectation specifies expectation struct of the NodeStateHash.WriteTo
type NodeStateHashMockWriteToExpectation struct {
	mock    *NodeStateHashMock
	params  *NodeStateHashMockWriteToParams
	results *NodeStateHashMockWriteToResults
	Counter uint64
}

// NodeStateHashMockWriteToParams contains parameters of the NodeStateHash.WriteTo
type NodeStateHashMockWriteToParams struct {
	w io.Writer
}

// NodeStateHashMockWriteToResults contains results of the NodeStateHash.WriteTo
type NodeStateHashMockWriteToResults struct {
	n   int64
	err error
}

// Expect sets up expected params for NodeStateHash.WriteTo
func (mmWriteTo *mNodeStateHashMockWriteTo) Expect(w io.Writer) *mNodeStateHashMockWriteTo {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("NodeStateHashMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &NodeStateHashMockWriteToExpectation{}
	}

	mmWriteTo.defaultExpectation.params = &NodeStateHashMockWriteToParams{w}
	for _, e := range mmWriteTo.expectations {
		if minimock.Equal(e.params, mmWriteTo.defaultExpectation.params) {
			mmWriteTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteTo.defaultExpectation.params)
		}
	}

	return mmWriteTo
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHash.WriteTo
func (mmWriteTo *mNodeStateHashMockWriteTo) Inspect(f func(w io.Writer)) *mNodeStateHashMockWriteTo {
	if mmWriteTo.mock.inspectFuncWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("Inspect function is already set for NodeStateHashMock.WriteTo")
	}

	mmWriteTo.mock.inspectFuncWriteTo = f

	return mmWriteTo
}

// Return sets up results that will be returned by NodeStateHash.WriteTo
func (mmWriteTo *mNodeStateHashMockWriteTo) Return(n int64, err error) *NodeStateHashMock {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("NodeStateHashMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &NodeStateHashMockWriteToExpectation{mock: mmWriteTo.mock}
	}
	mmWriteTo.defaultExpectation.results = &NodeStateHashMockWriteToResults{n, err}
	return mmWriteTo.mock
}

//Set uses given function f to mock the NodeStateHash.WriteTo method
func (mmWriteTo *mNodeStateHashMockWriteTo) Set(f func(w io.Writer) (n int64, err error)) *NodeStateHashMock {
	if mmWriteTo.defaultExpectation != nil {
		mmWriteTo.mock.t.Fatalf("Default expectation is already set for the NodeStateHash.WriteTo method")
	}

	if len(mmWriteTo.expectations) > 0 {
		mmWriteTo.mock.t.Fatalf("Some expectations are already set for the NodeStateHash.WriteTo method")
	}

	mmWriteTo.mock.funcWriteTo = f
	return mmWriteTo.mock
}

// When sets expectation for the NodeStateHash.WriteTo which will trigger the result defined by the following
// Then helper
func (mmWriteTo *mNodeStateHashMockWriteTo) When(w io.Writer) *NodeStateHashMockWriteToExpectation {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("NodeStateHashMock.WriteTo mock is already set by Set")
	}

	expectation := &NodeStateHashMockWriteToExpectation{
		mock:   mmWriteTo.mock,
		params: &NodeStateHashMockWriteToParams{w},
	}
	mmWriteTo.expectations = append(mmWriteTo.expectations, expectation)
	return expectation
}

// Then sets up NodeStateHash.WriteTo return parameters for the expectation previously defined by the When method
func (e *NodeStateHashMockWriteToExpectation) Then(n int64, err error) *NodeStateHashMock {
	e.results = &NodeStateHashMockWriteToResults{n, err}
	return e.mock
}

// WriteTo implements NodeStateHash
func (mmWriteTo *NodeStateHashMock) WriteTo(w io.Writer) (n int64, err error) {
	mm_atomic.AddUint64(&mmWriteTo.beforeWriteToCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteTo.afterWriteToCounter, 1)

	if mmWriteTo.inspectFuncWriteTo != nil {
		mmWriteTo.inspectFuncWriteTo(w)
	}

	mm_params := &NodeStateHashMockWriteToParams{w}

	// Record call args
	mmWriteTo.WriteToMock.mutex.Lock()
	mmWriteTo.WriteToMock.callArgs = append(mmWriteTo.WriteToMock.callArgs, mm_params)
	mmWriteTo.WriteToMock.mutex.Unlock()

	for _, e := range mmWriteTo.WriteToMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWriteTo.WriteToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteTo.WriteToMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteTo.WriteToMock.defaultExpectation.params
		mm_got := NodeStateHashMockWriteToParams{w}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteTo.t.Errorf("NodeStateHashMock.WriteTo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWriteTo.WriteToMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteTo.t.Fatal("No results are set for the NodeStateHashMock.WriteTo")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmWriteTo.funcWriteTo != nil {
		return mmWriteTo.funcWriteTo(w)
	}
	mmWriteTo.t.Fatalf("Unexpected call to NodeStateHashMock.WriteTo. %v", w)
	return
}

// WriteToAfterCounter returns a count of finished NodeStateHashMock.WriteTo invocations
func (mmWriteTo *NodeStateHashMock) WriteToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.afterWriteToCounter)
}

// WriteToBeforeCounter returns a count of NodeStateHashMock.WriteTo invocations
func (mmWriteTo *NodeStateHashMock) WriteToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.beforeWriteToCounter)
}

// Calls returns a list of arguments used in each call to NodeStateHashMock.WriteTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteTo *mNodeStateHashMockWriteTo) Calls() []*NodeStateHashMockWriteToParams {
	mmWriteTo.mutex.RLock()

	argCopy := make([]*NodeStateHashMockWriteToParams, len(mmWriteTo.callArgs))
	copy(argCopy, mmWriteTo.callArgs)

	mmWriteTo.mutex.RUnlock()

	return argCopy
}

// MinimockWriteToDone returns true if the count of the WriteTo invocations corresponds
// the number of defined expectations
func (m *NodeStateHashMock) MinimockWriteToDone() bool {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteToInspect logs each unmet expectation
func (m *NodeStateHashMock) MinimockWriteToInspect() {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NodeStateHashMock.WriteTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		if m.WriteToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NodeStateHashMock.WriteTo")
		} else {
			m.t.Errorf("Expected call to NodeStateHashMock.WriteTo with params: %#v", *m.WriteToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.WriteTo")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *NodeStateHashMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAsByteStringInspect()

		m.MinimockCopyToInspect()

		m.MinimockEqualsInspect()

		m.MinimockFixedByteSizeInspect()

		m.MinimockFoldToUint64Inspect()

		m.MinimockGetDigestMethodInspect()

		m.MinimockSignWithInspect()

		m.MinimockWriteToInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *NodeStateHashMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *NodeStateHashMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAsByteStringDone() &&
		m.MinimockCopyToDone() &&
		m.MinimockEqualsDone() &&
		m.MinimockFixedByteSizeDone() &&
		m.MinimockFoldToUint64Done() &&
		m.MinimockGetDigestMethodDone() &&
		m.MinimockSignWithDone() &&
		m.MinimockWriteToDone()
}
