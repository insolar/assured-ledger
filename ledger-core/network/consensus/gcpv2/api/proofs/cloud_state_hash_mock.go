package proofs

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/vanilla/cryptkit"
	"github.com/insolar/assured-ledger/ledger-core/vanilla/longbits"
)

// CloudStateHashMock implements CloudStateHash
type CloudStateHashMock struct {
	t minimock.Tester

	funcAsByteString          func() (b1 longbits.ByteString)
	inspectFuncAsByteString   func()
	afterAsByteStringCounter  uint64
	beforeAsByteStringCounter uint64
	AsByteStringMock          mCloudStateHashMockAsByteString

	funcCopyTo          func(p []byte) (i1 int)
	inspectFuncCopyTo   func(p []byte)
	afterCopyToCounter  uint64
	beforeCopyToCounter uint64
	CopyToMock          mCloudStateHashMockCopyTo

	funcEquals          func(other cryptkit.DigestHolder) (b1 bool)
	inspectFuncEquals   func(other cryptkit.DigestHolder)
	afterEqualsCounter  uint64
	beforeEqualsCounter uint64
	EqualsMock          mCloudStateHashMockEquals

	funcFixedByteSize          func() (i1 int)
	inspectFuncFixedByteSize   func()
	afterFixedByteSizeCounter  uint64
	beforeFixedByteSizeCounter uint64
	FixedByteSizeMock          mCloudStateHashMockFixedByteSize

	funcFoldToUint64          func() (u1 uint64)
	inspectFuncFoldToUint64   func()
	afterFoldToUint64Counter  uint64
	beforeFoldToUint64Counter uint64
	FoldToUint64Mock          mCloudStateHashMockFoldToUint64

	funcGetDigestMethod          func() (d1 cryptkit.DigestMethod)
	inspectFuncGetDigestMethod   func()
	afterGetDigestMethodCounter  uint64
	beforeGetDigestMethodCounter uint64
	GetDigestMethodMock          mCloudStateHashMockGetDigestMethod

	funcSignWith          func(signer cryptkit.DigestSigner) (s1 cryptkit.SignedDigestHolder)
	inspectFuncSignWith   func(signer cryptkit.DigestSigner)
	afterSignWithCounter  uint64
	beforeSignWithCounter uint64
	SignWithMock          mCloudStateHashMockSignWith

	funcWriteTo          func(w io.Writer) (n int64, err error)
	inspectFuncWriteTo   func(w io.Writer)
	afterWriteToCounter  uint64
	beforeWriteToCounter uint64
	WriteToMock          mCloudStateHashMockWriteTo
}

// NewCloudStateHashMock returns a mock for CloudStateHash
func NewCloudStateHashMock(t minimock.Tester) *CloudStateHashMock {
	m := &CloudStateHashMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AsByteStringMock = mCloudStateHashMockAsByteString{mock: m}

	m.CopyToMock = mCloudStateHashMockCopyTo{mock: m}
	m.CopyToMock.callArgs = []*CloudStateHashMockCopyToParams{}

	m.EqualsMock = mCloudStateHashMockEquals{mock: m}
	m.EqualsMock.callArgs = []*CloudStateHashMockEqualsParams{}

	m.FixedByteSizeMock = mCloudStateHashMockFixedByteSize{mock: m}

	m.FoldToUint64Mock = mCloudStateHashMockFoldToUint64{mock: m}

	m.GetDigestMethodMock = mCloudStateHashMockGetDigestMethod{mock: m}

	m.SignWithMock = mCloudStateHashMockSignWith{mock: m}
	m.SignWithMock.callArgs = []*CloudStateHashMockSignWithParams{}

	m.WriteToMock = mCloudStateHashMockWriteTo{mock: m}
	m.WriteToMock.callArgs = []*CloudStateHashMockWriteToParams{}

	return m
}

type mCloudStateHashMockAsByteString struct {
	mock               *CloudStateHashMock
	defaultExpectation *CloudStateHashMockAsByteStringExpectation
	expectations       []*CloudStateHashMockAsByteStringExpectation
}

// CloudStateHashMockAsByteStringExpectation specifies expectation struct of the CloudStateHash.AsByteString
type CloudStateHashMockAsByteStringExpectation struct {
	mock *CloudStateHashMock

	results *CloudStateHashMockAsByteStringResults
	Counter uint64
}

// CloudStateHashMockAsByteStringResults contains results of the CloudStateHash.AsByteString
type CloudStateHashMockAsByteStringResults struct {
	b1 longbits.ByteString
}

// Expect sets up expected params for CloudStateHash.AsByteString
func (mmAsByteString *mCloudStateHashMockAsByteString) Expect() *mCloudStateHashMockAsByteString {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("CloudStateHashMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &CloudStateHashMockAsByteStringExpectation{}
	}

	return mmAsByteString
}

// Inspect accepts an inspector function that has same arguments as the CloudStateHash.AsByteString
func (mmAsByteString *mCloudStateHashMockAsByteString) Inspect(f func()) *mCloudStateHashMockAsByteString {
	if mmAsByteString.mock.inspectFuncAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("Inspect function is already set for CloudStateHashMock.AsByteString")
	}

	mmAsByteString.mock.inspectFuncAsByteString = f

	return mmAsByteString
}

// Return sets up results that will be returned by CloudStateHash.AsByteString
func (mmAsByteString *mCloudStateHashMockAsByteString) Return(b1 longbits.ByteString) *CloudStateHashMock {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("CloudStateHashMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &CloudStateHashMockAsByteStringExpectation{mock: mmAsByteString.mock}
	}
	mmAsByteString.defaultExpectation.results = &CloudStateHashMockAsByteStringResults{b1}
	return mmAsByteString.mock
}

//Set uses given function f to mock the CloudStateHash.AsByteString method
func (mmAsByteString *mCloudStateHashMockAsByteString) Set(f func() (b1 longbits.ByteString)) *CloudStateHashMock {
	if mmAsByteString.defaultExpectation != nil {
		mmAsByteString.mock.t.Fatalf("Default expectation is already set for the CloudStateHash.AsByteString method")
	}

	if len(mmAsByteString.expectations) > 0 {
		mmAsByteString.mock.t.Fatalf("Some expectations are already set for the CloudStateHash.AsByteString method")
	}

	mmAsByteString.mock.funcAsByteString = f
	return mmAsByteString.mock
}

// AsByteString implements CloudStateHash
func (mmAsByteString *CloudStateHashMock) AsByteString() (b1 longbits.ByteString) {
	mm_atomic.AddUint64(&mmAsByteString.beforeAsByteStringCounter, 1)
	defer mm_atomic.AddUint64(&mmAsByteString.afterAsByteStringCounter, 1)

	if mmAsByteString.inspectFuncAsByteString != nil {
		mmAsByteString.inspectFuncAsByteString()
	}

	if mmAsByteString.AsByteStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsByteString.AsByteStringMock.defaultExpectation.Counter, 1)

		mm_results := mmAsByteString.AsByteStringMock.defaultExpectation.results
		if mm_results == nil {
			mmAsByteString.t.Fatal("No results are set for the CloudStateHashMock.AsByteString")
		}
		return (*mm_results).b1
	}
	if mmAsByteString.funcAsByteString != nil {
		return mmAsByteString.funcAsByteString()
	}
	mmAsByteString.t.Fatalf("Unexpected call to CloudStateHashMock.AsByteString.")
	return
}

// AsByteStringAfterCounter returns a count of finished CloudStateHashMock.AsByteString invocations
func (mmAsByteString *CloudStateHashMock) AsByteStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.afterAsByteStringCounter)
}

// AsByteStringBeforeCounter returns a count of CloudStateHashMock.AsByteString invocations
func (mmAsByteString *CloudStateHashMock) AsByteStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.beforeAsByteStringCounter)
}

// MinimockAsByteStringDone returns true if the count of the AsByteString invocations corresponds
// the number of defined expectations
func (m *CloudStateHashMock) MinimockAsByteStringDone() bool {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsByteStringInspect logs each unmet expectation
func (m *CloudStateHashMock) MinimockAsByteStringInspect() {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CloudStateHashMock.AsByteString")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.AsByteString")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.AsByteString")
	}
}

type mCloudStateHashMockCopyTo struct {
	mock               *CloudStateHashMock
	defaultExpectation *CloudStateHashMockCopyToExpectation
	expectations       []*CloudStateHashMockCopyToExpectation

	callArgs []*CloudStateHashMockCopyToParams
	mutex    sync.RWMutex
}

// CloudStateHashMockCopyToExpectation specifies expectation struct of the CloudStateHash.CopyTo
type CloudStateHashMockCopyToExpectation struct {
	mock    *CloudStateHashMock
	params  *CloudStateHashMockCopyToParams
	results *CloudStateHashMockCopyToResults
	Counter uint64
}

// CloudStateHashMockCopyToParams contains parameters of the CloudStateHash.CopyTo
type CloudStateHashMockCopyToParams struct {
	p []byte
}

// CloudStateHashMockCopyToResults contains results of the CloudStateHash.CopyTo
type CloudStateHashMockCopyToResults struct {
	i1 int
}

// Expect sets up expected params for CloudStateHash.CopyTo
func (mmCopyTo *mCloudStateHashMockCopyTo) Expect(p []byte) *mCloudStateHashMockCopyTo {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("CloudStateHashMock.CopyTo mock is already set by Set")
	}

	if mmCopyTo.defaultExpectation == nil {
		mmCopyTo.defaultExpectation = &CloudStateHashMockCopyToExpectation{}
	}

	mmCopyTo.defaultExpectation.params = &CloudStateHashMockCopyToParams{p}
	for _, e := range mmCopyTo.expectations {
		if minimock.Equal(e.params, mmCopyTo.defaultExpectation.params) {
			mmCopyTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCopyTo.defaultExpectation.params)
		}
	}

	return mmCopyTo
}

// Inspect accepts an inspector function that has same arguments as the CloudStateHash.CopyTo
func (mmCopyTo *mCloudStateHashMockCopyTo) Inspect(f func(p []byte)) *mCloudStateHashMockCopyTo {
	if mmCopyTo.mock.inspectFuncCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("Inspect function is already set for CloudStateHashMock.CopyTo")
	}

	mmCopyTo.mock.inspectFuncCopyTo = f

	return mmCopyTo
}

// Return sets up results that will be returned by CloudStateHash.CopyTo
func (mmCopyTo *mCloudStateHashMockCopyTo) Return(i1 int) *CloudStateHashMock {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("CloudStateHashMock.CopyTo mock is already set by Set")
	}

	if mmCopyTo.defaultExpectation == nil {
		mmCopyTo.defaultExpectation = &CloudStateHashMockCopyToExpectation{mock: mmCopyTo.mock}
	}
	mmCopyTo.defaultExpectation.results = &CloudStateHashMockCopyToResults{i1}
	return mmCopyTo.mock
}

//Set uses given function f to mock the CloudStateHash.CopyTo method
func (mmCopyTo *mCloudStateHashMockCopyTo) Set(f func(p []byte) (i1 int)) *CloudStateHashMock {
	if mmCopyTo.defaultExpectation != nil {
		mmCopyTo.mock.t.Fatalf("Default expectation is already set for the CloudStateHash.CopyTo method")
	}

	if len(mmCopyTo.expectations) > 0 {
		mmCopyTo.mock.t.Fatalf("Some expectations are already set for the CloudStateHash.CopyTo method")
	}

	mmCopyTo.mock.funcCopyTo = f
	return mmCopyTo.mock
}

// When sets expectation for the CloudStateHash.CopyTo which will trigger the result defined by the following
// Then helper
func (mmCopyTo *mCloudStateHashMockCopyTo) When(p []byte) *CloudStateHashMockCopyToExpectation {
	if mmCopyTo.mock.funcCopyTo != nil {
		mmCopyTo.mock.t.Fatalf("CloudStateHashMock.CopyTo mock is already set by Set")
	}

	expectation := &CloudStateHashMockCopyToExpectation{
		mock:   mmCopyTo.mock,
		params: &CloudStateHashMockCopyToParams{p},
	}
	mmCopyTo.expectations = append(mmCopyTo.expectations, expectation)
	return expectation
}

// Then sets up CloudStateHash.CopyTo return parameters for the expectation previously defined by the When method
func (e *CloudStateHashMockCopyToExpectation) Then(i1 int) *CloudStateHashMock {
	e.results = &CloudStateHashMockCopyToResults{i1}
	return e.mock
}

// CopyTo implements CloudStateHash
func (mmCopyTo *CloudStateHashMock) CopyTo(p []byte) (i1 int) {
	mm_atomic.AddUint64(&mmCopyTo.beforeCopyToCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyTo.afterCopyToCounter, 1)

	if mmCopyTo.inspectFuncCopyTo != nil {
		mmCopyTo.inspectFuncCopyTo(p)
	}

	mm_params := &CloudStateHashMockCopyToParams{p}

	// Record call args
	mmCopyTo.CopyToMock.mutex.Lock()
	mmCopyTo.CopyToMock.callArgs = append(mmCopyTo.CopyToMock.callArgs, mm_params)
	mmCopyTo.CopyToMock.mutex.Unlock()

	for _, e := range mmCopyTo.CopyToMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1
		}
	}

	if mmCopyTo.CopyToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyTo.CopyToMock.defaultExpectation.Counter, 1)
		mm_want := mmCopyTo.CopyToMock.defaultExpectation.params
		mm_got := CloudStateHashMockCopyToParams{p}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCopyTo.t.Errorf("CloudStateHashMock.CopyTo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCopyTo.CopyToMock.defaultExpectation.results
		if mm_results == nil {
			mmCopyTo.t.Fatal("No results are set for the CloudStateHashMock.CopyTo")
		}
		return (*mm_results).i1
	}
	if mmCopyTo.funcCopyTo != nil {
		return mmCopyTo.funcCopyTo(p)
	}
	mmCopyTo.t.Fatalf("Unexpected call to CloudStateHashMock.CopyTo. %v", p)
	return
}

// CopyToAfterCounter returns a count of finished CloudStateHashMock.CopyTo invocations
func (mmCopyTo *CloudStateHashMock) CopyToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyTo.afterCopyToCounter)
}

// CopyToBeforeCounter returns a count of CloudStateHashMock.CopyTo invocations
func (mmCopyTo *CloudStateHashMock) CopyToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyTo.beforeCopyToCounter)
}

// Calls returns a list of arguments used in each call to CloudStateHashMock.CopyTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCopyTo *mCloudStateHashMockCopyTo) Calls() []*CloudStateHashMockCopyToParams {
	mmCopyTo.mutex.RLock()

	argCopy := make([]*CloudStateHashMockCopyToParams, len(mmCopyTo.callArgs))
	copy(argCopy, mmCopyTo.callArgs)

	mmCopyTo.mutex.RUnlock()

	return argCopy
}

// MinimockCopyToDone returns true if the count of the CopyTo invocations corresponds
// the number of defined expectations
func (m *CloudStateHashMock) MinimockCopyToDone() bool {
	for _, e := range m.CopyToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyTo != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyToInspect logs each unmet expectation
func (m *CloudStateHashMock) MinimockCopyToInspect() {
	for _, e := range m.CopyToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CloudStateHashMock.CopyTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		if m.CopyToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CloudStateHashMock.CopyTo")
		} else {
			m.t.Errorf("Expected call to CloudStateHashMock.CopyTo with params: %#v", *m.CopyToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyTo != nil && mm_atomic.LoadUint64(&m.afterCopyToCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.CopyTo")
	}
}

type mCloudStateHashMockEquals struct {
	mock               *CloudStateHashMock
	defaultExpectation *CloudStateHashMockEqualsExpectation
	expectations       []*CloudStateHashMockEqualsExpectation

	callArgs []*CloudStateHashMockEqualsParams
	mutex    sync.RWMutex
}

// CloudStateHashMockEqualsExpectation specifies expectation struct of the CloudStateHash.Equals
type CloudStateHashMockEqualsExpectation struct {
	mock    *CloudStateHashMock
	params  *CloudStateHashMockEqualsParams
	results *CloudStateHashMockEqualsResults
	Counter uint64
}

// CloudStateHashMockEqualsParams contains parameters of the CloudStateHash.Equals
type CloudStateHashMockEqualsParams struct {
	other cryptkit.DigestHolder
}

// CloudStateHashMockEqualsResults contains results of the CloudStateHash.Equals
type CloudStateHashMockEqualsResults struct {
	b1 bool
}

// Expect sets up expected params for CloudStateHash.Equals
func (mmEquals *mCloudStateHashMockEquals) Expect(other cryptkit.DigestHolder) *mCloudStateHashMockEquals {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("CloudStateHashMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &CloudStateHashMockEqualsExpectation{}
	}

	mmEquals.defaultExpectation.params = &CloudStateHashMockEqualsParams{other}
	for _, e := range mmEquals.expectations {
		if minimock.Equal(e.params, mmEquals.defaultExpectation.params) {
			mmEquals.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEquals.defaultExpectation.params)
		}
	}

	return mmEquals
}

// Inspect accepts an inspector function that has same arguments as the CloudStateHash.Equals
func (mmEquals *mCloudStateHashMockEquals) Inspect(f func(other cryptkit.DigestHolder)) *mCloudStateHashMockEquals {
	if mmEquals.mock.inspectFuncEquals != nil {
		mmEquals.mock.t.Fatalf("Inspect function is already set for CloudStateHashMock.Equals")
	}

	mmEquals.mock.inspectFuncEquals = f

	return mmEquals
}

// Return sets up results that will be returned by CloudStateHash.Equals
func (mmEquals *mCloudStateHashMockEquals) Return(b1 bool) *CloudStateHashMock {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("CloudStateHashMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &CloudStateHashMockEqualsExpectation{mock: mmEquals.mock}
	}
	mmEquals.defaultExpectation.results = &CloudStateHashMockEqualsResults{b1}
	return mmEquals.mock
}

//Set uses given function f to mock the CloudStateHash.Equals method
func (mmEquals *mCloudStateHashMockEquals) Set(f func(other cryptkit.DigestHolder) (b1 bool)) *CloudStateHashMock {
	if mmEquals.defaultExpectation != nil {
		mmEquals.mock.t.Fatalf("Default expectation is already set for the CloudStateHash.Equals method")
	}

	if len(mmEquals.expectations) > 0 {
		mmEquals.mock.t.Fatalf("Some expectations are already set for the CloudStateHash.Equals method")
	}

	mmEquals.mock.funcEquals = f
	return mmEquals.mock
}

// When sets expectation for the CloudStateHash.Equals which will trigger the result defined by the following
// Then helper
func (mmEquals *mCloudStateHashMockEquals) When(other cryptkit.DigestHolder) *CloudStateHashMockEqualsExpectation {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("CloudStateHashMock.Equals mock is already set by Set")
	}

	expectation := &CloudStateHashMockEqualsExpectation{
		mock:   mmEquals.mock,
		params: &CloudStateHashMockEqualsParams{other},
	}
	mmEquals.expectations = append(mmEquals.expectations, expectation)
	return expectation
}

// Then sets up CloudStateHash.Equals return parameters for the expectation previously defined by the When method
func (e *CloudStateHashMockEqualsExpectation) Then(b1 bool) *CloudStateHashMock {
	e.results = &CloudStateHashMockEqualsResults{b1}
	return e.mock
}

// Equals implements CloudStateHash
func (mmEquals *CloudStateHashMock) Equals(other cryptkit.DigestHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmEquals.beforeEqualsCounter, 1)
	defer mm_atomic.AddUint64(&mmEquals.afterEqualsCounter, 1)

	if mmEquals.inspectFuncEquals != nil {
		mmEquals.inspectFuncEquals(other)
	}

	mm_params := &CloudStateHashMockEqualsParams{other}

	// Record call args
	mmEquals.EqualsMock.mutex.Lock()
	mmEquals.EqualsMock.callArgs = append(mmEquals.EqualsMock.callArgs, mm_params)
	mmEquals.EqualsMock.mutex.Unlock()

	for _, e := range mmEquals.EqualsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmEquals.EqualsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEquals.EqualsMock.defaultExpectation.Counter, 1)
		mm_want := mmEquals.EqualsMock.defaultExpectation.params
		mm_got := CloudStateHashMockEqualsParams{other}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEquals.t.Errorf("CloudStateHashMock.Equals got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEquals.EqualsMock.defaultExpectation.results
		if mm_results == nil {
			mmEquals.t.Fatal("No results are set for the CloudStateHashMock.Equals")
		}
		return (*mm_results).b1
	}
	if mmEquals.funcEquals != nil {
		return mmEquals.funcEquals(other)
	}
	mmEquals.t.Fatalf("Unexpected call to CloudStateHashMock.Equals. %v", other)
	return
}

// EqualsAfterCounter returns a count of finished CloudStateHashMock.Equals invocations
func (mmEquals *CloudStateHashMock) EqualsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.afterEqualsCounter)
}

// EqualsBeforeCounter returns a count of CloudStateHashMock.Equals invocations
func (mmEquals *CloudStateHashMock) EqualsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.beforeEqualsCounter)
}

// Calls returns a list of arguments used in each call to CloudStateHashMock.Equals.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEquals *mCloudStateHashMockEquals) Calls() []*CloudStateHashMockEqualsParams {
	mmEquals.mutex.RLock()

	argCopy := make([]*CloudStateHashMockEqualsParams, len(mmEquals.callArgs))
	copy(argCopy, mmEquals.callArgs)

	mmEquals.mutex.RUnlock()

	return argCopy
}

// MinimockEqualsDone returns true if the count of the Equals invocations corresponds
// the number of defined expectations
func (m *CloudStateHashMock) MinimockEqualsDone() bool {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	return true
}

// MinimockEqualsInspect logs each unmet expectation
func (m *CloudStateHashMock) MinimockEqualsInspect() {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CloudStateHashMock.Equals with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		if m.EqualsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CloudStateHashMock.Equals")
		} else {
			m.t.Errorf("Expected call to CloudStateHashMock.Equals with params: %#v", *m.EqualsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.Equals")
	}
}

type mCloudStateHashMockFixedByteSize struct {
	mock               *CloudStateHashMock
	defaultExpectation *CloudStateHashMockFixedByteSizeExpectation
	expectations       []*CloudStateHashMockFixedByteSizeExpectation
}

// CloudStateHashMockFixedByteSizeExpectation specifies expectation struct of the CloudStateHash.FixedByteSize
type CloudStateHashMockFixedByteSizeExpectation struct {
	mock *CloudStateHashMock

	results *CloudStateHashMockFixedByteSizeResults
	Counter uint64
}

// CloudStateHashMockFixedByteSizeResults contains results of the CloudStateHash.FixedByteSize
type CloudStateHashMockFixedByteSizeResults struct {
	i1 int
}

// Expect sets up expected params for CloudStateHash.FixedByteSize
func (mmFixedByteSize *mCloudStateHashMockFixedByteSize) Expect() *mCloudStateHashMockFixedByteSize {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("CloudStateHashMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &CloudStateHashMockFixedByteSizeExpectation{}
	}

	return mmFixedByteSize
}

// Inspect accepts an inspector function that has same arguments as the CloudStateHash.FixedByteSize
func (mmFixedByteSize *mCloudStateHashMockFixedByteSize) Inspect(f func()) *mCloudStateHashMockFixedByteSize {
	if mmFixedByteSize.mock.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("Inspect function is already set for CloudStateHashMock.FixedByteSize")
	}

	mmFixedByteSize.mock.inspectFuncFixedByteSize = f

	return mmFixedByteSize
}

// Return sets up results that will be returned by CloudStateHash.FixedByteSize
func (mmFixedByteSize *mCloudStateHashMockFixedByteSize) Return(i1 int) *CloudStateHashMock {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("CloudStateHashMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &CloudStateHashMockFixedByteSizeExpectation{mock: mmFixedByteSize.mock}
	}
	mmFixedByteSize.defaultExpectation.results = &CloudStateHashMockFixedByteSizeResults{i1}
	return mmFixedByteSize.mock
}

//Set uses given function f to mock the CloudStateHash.FixedByteSize method
func (mmFixedByteSize *mCloudStateHashMockFixedByteSize) Set(f func() (i1 int)) *CloudStateHashMock {
	if mmFixedByteSize.defaultExpectation != nil {
		mmFixedByteSize.mock.t.Fatalf("Default expectation is already set for the CloudStateHash.FixedByteSize method")
	}

	if len(mmFixedByteSize.expectations) > 0 {
		mmFixedByteSize.mock.t.Fatalf("Some expectations are already set for the CloudStateHash.FixedByteSize method")
	}

	mmFixedByteSize.mock.funcFixedByteSize = f
	return mmFixedByteSize.mock
}

// FixedByteSize implements CloudStateHash
func (mmFixedByteSize *CloudStateHashMock) FixedByteSize() (i1 int) {
	mm_atomic.AddUint64(&mmFixedByteSize.beforeFixedByteSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmFixedByteSize.afterFixedByteSizeCounter, 1)

	if mmFixedByteSize.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.inspectFuncFixedByteSize()
	}

	if mmFixedByteSize.FixedByteSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFixedByteSize.FixedByteSizeMock.defaultExpectation.Counter, 1)

		mm_results := mmFixedByteSize.FixedByteSizeMock.defaultExpectation.results
		if mm_results == nil {
			mmFixedByteSize.t.Fatal("No results are set for the CloudStateHashMock.FixedByteSize")
		}
		return (*mm_results).i1
	}
	if mmFixedByteSize.funcFixedByteSize != nil {
		return mmFixedByteSize.funcFixedByteSize()
	}
	mmFixedByteSize.t.Fatalf("Unexpected call to CloudStateHashMock.FixedByteSize.")
	return
}

// FixedByteSizeAfterCounter returns a count of finished CloudStateHashMock.FixedByteSize invocations
func (mmFixedByteSize *CloudStateHashMock) FixedByteSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.afterFixedByteSizeCounter)
}

// FixedByteSizeBeforeCounter returns a count of CloudStateHashMock.FixedByteSize invocations
func (mmFixedByteSize *CloudStateHashMock) FixedByteSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.beforeFixedByteSizeCounter)
}

// MinimockFixedByteSizeDone returns true if the count of the FixedByteSize invocations corresponds
// the number of defined expectations
func (m *CloudStateHashMock) MinimockFixedByteSizeDone() bool {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockFixedByteSizeInspect logs each unmet expectation
func (m *CloudStateHashMock) MinimockFixedByteSizeInspect() {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CloudStateHashMock.FixedByteSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.FixedByteSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.FixedByteSize")
	}
}

type mCloudStateHashMockFoldToUint64 struct {
	mock               *CloudStateHashMock
	defaultExpectation *CloudStateHashMockFoldToUint64Expectation
	expectations       []*CloudStateHashMockFoldToUint64Expectation
}

// CloudStateHashMockFoldToUint64Expectation specifies expectation struct of the CloudStateHash.FoldToUint64
type CloudStateHashMockFoldToUint64Expectation struct {
	mock *CloudStateHashMock

	results *CloudStateHashMockFoldToUint64Results
	Counter uint64
}

// CloudStateHashMockFoldToUint64Results contains results of the CloudStateHash.FoldToUint64
type CloudStateHashMockFoldToUint64Results struct {
	u1 uint64
}

// Expect sets up expected params for CloudStateHash.FoldToUint64
func (mmFoldToUint64 *mCloudStateHashMockFoldToUint64) Expect() *mCloudStateHashMockFoldToUint64 {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("CloudStateHashMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &CloudStateHashMockFoldToUint64Expectation{}
	}

	return mmFoldToUint64
}

// Inspect accepts an inspector function that has same arguments as the CloudStateHash.FoldToUint64
func (mmFoldToUint64 *mCloudStateHashMockFoldToUint64) Inspect(f func()) *mCloudStateHashMockFoldToUint64 {
	if mmFoldToUint64.mock.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("Inspect function is already set for CloudStateHashMock.FoldToUint64")
	}

	mmFoldToUint64.mock.inspectFuncFoldToUint64 = f

	return mmFoldToUint64
}

// Return sets up results that will be returned by CloudStateHash.FoldToUint64
func (mmFoldToUint64 *mCloudStateHashMockFoldToUint64) Return(u1 uint64) *CloudStateHashMock {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("CloudStateHashMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &CloudStateHashMockFoldToUint64Expectation{mock: mmFoldToUint64.mock}
	}
	mmFoldToUint64.defaultExpectation.results = &CloudStateHashMockFoldToUint64Results{u1}
	return mmFoldToUint64.mock
}

//Set uses given function f to mock the CloudStateHash.FoldToUint64 method
func (mmFoldToUint64 *mCloudStateHashMockFoldToUint64) Set(f func() (u1 uint64)) *CloudStateHashMock {
	if mmFoldToUint64.defaultExpectation != nil {
		mmFoldToUint64.mock.t.Fatalf("Default expectation is already set for the CloudStateHash.FoldToUint64 method")
	}

	if len(mmFoldToUint64.expectations) > 0 {
		mmFoldToUint64.mock.t.Fatalf("Some expectations are already set for the CloudStateHash.FoldToUint64 method")
	}

	mmFoldToUint64.mock.funcFoldToUint64 = f
	return mmFoldToUint64.mock
}

// FoldToUint64 implements CloudStateHash
func (mmFoldToUint64 *CloudStateHashMock) FoldToUint64() (u1 uint64) {
	mm_atomic.AddUint64(&mmFoldToUint64.beforeFoldToUint64Counter, 1)
	defer mm_atomic.AddUint64(&mmFoldToUint64.afterFoldToUint64Counter, 1)

	if mmFoldToUint64.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.inspectFuncFoldToUint64()
	}

	if mmFoldToUint64.FoldToUint64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFoldToUint64.FoldToUint64Mock.defaultExpectation.Counter, 1)

		mm_results := mmFoldToUint64.FoldToUint64Mock.defaultExpectation.results
		if mm_results == nil {
			mmFoldToUint64.t.Fatal("No results are set for the CloudStateHashMock.FoldToUint64")
		}
		return (*mm_results).u1
	}
	if mmFoldToUint64.funcFoldToUint64 != nil {
		return mmFoldToUint64.funcFoldToUint64()
	}
	mmFoldToUint64.t.Fatalf("Unexpected call to CloudStateHashMock.FoldToUint64.")
	return
}

// FoldToUint64AfterCounter returns a count of finished CloudStateHashMock.FoldToUint64 invocations
func (mmFoldToUint64 *CloudStateHashMock) FoldToUint64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.afterFoldToUint64Counter)
}

// FoldToUint64BeforeCounter returns a count of CloudStateHashMock.FoldToUint64 invocations
func (mmFoldToUint64 *CloudStateHashMock) FoldToUint64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.beforeFoldToUint64Counter)
}

// MinimockFoldToUint64Done returns true if the count of the FoldToUint64 invocations corresponds
// the number of defined expectations
func (m *CloudStateHashMock) MinimockFoldToUint64Done() bool {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	return true
}

// MinimockFoldToUint64Inspect logs each unmet expectation
func (m *CloudStateHashMock) MinimockFoldToUint64Inspect() {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CloudStateHashMock.FoldToUint64")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.FoldToUint64")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.FoldToUint64")
	}
}

type mCloudStateHashMockGetDigestMethod struct {
	mock               *CloudStateHashMock
	defaultExpectation *CloudStateHashMockGetDigestMethodExpectation
	expectations       []*CloudStateHashMockGetDigestMethodExpectation
}

// CloudStateHashMockGetDigestMethodExpectation specifies expectation struct of the CloudStateHash.GetDigestMethod
type CloudStateHashMockGetDigestMethodExpectation struct {
	mock *CloudStateHashMock

	results *CloudStateHashMockGetDigestMethodResults
	Counter uint64
}

// CloudStateHashMockGetDigestMethodResults contains results of the CloudStateHash.GetDigestMethod
type CloudStateHashMockGetDigestMethodResults struct {
	d1 cryptkit.DigestMethod
}

// Expect sets up expected params for CloudStateHash.GetDigestMethod
func (mmGetDigestMethod *mCloudStateHashMockGetDigestMethod) Expect() *mCloudStateHashMockGetDigestMethod {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("CloudStateHashMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &CloudStateHashMockGetDigestMethodExpectation{}
	}

	return mmGetDigestMethod
}

// Inspect accepts an inspector function that has same arguments as the CloudStateHash.GetDigestMethod
func (mmGetDigestMethod *mCloudStateHashMockGetDigestMethod) Inspect(f func()) *mCloudStateHashMockGetDigestMethod {
	if mmGetDigestMethod.mock.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("Inspect function is already set for CloudStateHashMock.GetDigestMethod")
	}

	mmGetDigestMethod.mock.inspectFuncGetDigestMethod = f

	return mmGetDigestMethod
}

// Return sets up results that will be returned by CloudStateHash.GetDigestMethod
func (mmGetDigestMethod *mCloudStateHashMockGetDigestMethod) Return(d1 cryptkit.DigestMethod) *CloudStateHashMock {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("CloudStateHashMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &CloudStateHashMockGetDigestMethodExpectation{mock: mmGetDigestMethod.mock}
	}
	mmGetDigestMethod.defaultExpectation.results = &CloudStateHashMockGetDigestMethodResults{d1}
	return mmGetDigestMethod.mock
}

//Set uses given function f to mock the CloudStateHash.GetDigestMethod method
func (mmGetDigestMethod *mCloudStateHashMockGetDigestMethod) Set(f func() (d1 cryptkit.DigestMethod)) *CloudStateHashMock {
	if mmGetDigestMethod.defaultExpectation != nil {
		mmGetDigestMethod.mock.t.Fatalf("Default expectation is already set for the CloudStateHash.GetDigestMethod method")
	}

	if len(mmGetDigestMethod.expectations) > 0 {
		mmGetDigestMethod.mock.t.Fatalf("Some expectations are already set for the CloudStateHash.GetDigestMethod method")
	}

	mmGetDigestMethod.mock.funcGetDigestMethod = f
	return mmGetDigestMethod.mock
}

// GetDigestMethod implements CloudStateHash
func (mmGetDigestMethod *CloudStateHashMock) GetDigestMethod() (d1 cryptkit.DigestMethod) {
	mm_atomic.AddUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestMethod.afterGetDigestMethodCounter, 1)

	if mmGetDigestMethod.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.inspectFuncGetDigestMethod()
	}

	if mmGetDigestMethod.GetDigestMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDigestMethod.t.Fatal("No results are set for the CloudStateHashMock.GetDigestMethod")
		}
		return (*mm_results).d1
	}
	if mmGetDigestMethod.funcGetDigestMethod != nil {
		return mmGetDigestMethod.funcGetDigestMethod()
	}
	mmGetDigestMethod.t.Fatalf("Unexpected call to CloudStateHashMock.GetDigestMethod.")
	return
}

// GetDigestMethodAfterCounter returns a count of finished CloudStateHashMock.GetDigestMethod invocations
func (mmGetDigestMethod *CloudStateHashMock) GetDigestMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.afterGetDigestMethodCounter)
}

// GetDigestMethodBeforeCounter returns a count of CloudStateHashMock.GetDigestMethod invocations
func (mmGetDigestMethod *CloudStateHashMock) GetDigestMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter)
}

// MinimockGetDigestMethodDone returns true if the count of the GetDigestMethod invocations corresponds
// the number of defined expectations
func (m *CloudStateHashMock) MinimockGetDigestMethodDone() bool {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestMethodInspect logs each unmet expectation
func (m *CloudStateHashMock) MinimockGetDigestMethodInspect() {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CloudStateHashMock.GetDigestMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.GetDigestMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.GetDigestMethod")
	}
}

type mCloudStateHashMockSignWith struct {
	mock               *CloudStateHashMock
	defaultExpectation *CloudStateHashMockSignWithExpectation
	expectations       []*CloudStateHashMockSignWithExpectation

	callArgs []*CloudStateHashMockSignWithParams
	mutex    sync.RWMutex
}

// CloudStateHashMockSignWithExpectation specifies expectation struct of the CloudStateHash.SignWith
type CloudStateHashMockSignWithExpectation struct {
	mock    *CloudStateHashMock
	params  *CloudStateHashMockSignWithParams
	results *CloudStateHashMockSignWithResults
	Counter uint64
}

// CloudStateHashMockSignWithParams contains parameters of the CloudStateHash.SignWith
type CloudStateHashMockSignWithParams struct {
	signer cryptkit.DigestSigner
}

// CloudStateHashMockSignWithResults contains results of the CloudStateHash.SignWith
type CloudStateHashMockSignWithResults struct {
	s1 cryptkit.SignedDigestHolder
}

// Expect sets up expected params for CloudStateHash.SignWith
func (mmSignWith *mCloudStateHashMockSignWith) Expect(signer cryptkit.DigestSigner) *mCloudStateHashMockSignWith {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("CloudStateHashMock.SignWith mock is already set by Set")
	}

	if mmSignWith.defaultExpectation == nil {
		mmSignWith.defaultExpectation = &CloudStateHashMockSignWithExpectation{}
	}

	mmSignWith.defaultExpectation.params = &CloudStateHashMockSignWithParams{signer}
	for _, e := range mmSignWith.expectations {
		if minimock.Equal(e.params, mmSignWith.defaultExpectation.params) {
			mmSignWith.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSignWith.defaultExpectation.params)
		}
	}

	return mmSignWith
}

// Inspect accepts an inspector function that has same arguments as the CloudStateHash.SignWith
func (mmSignWith *mCloudStateHashMockSignWith) Inspect(f func(signer cryptkit.DigestSigner)) *mCloudStateHashMockSignWith {
	if mmSignWith.mock.inspectFuncSignWith != nil {
		mmSignWith.mock.t.Fatalf("Inspect function is already set for CloudStateHashMock.SignWith")
	}

	mmSignWith.mock.inspectFuncSignWith = f

	return mmSignWith
}

// Return sets up results that will be returned by CloudStateHash.SignWith
func (mmSignWith *mCloudStateHashMockSignWith) Return(s1 cryptkit.SignedDigestHolder) *CloudStateHashMock {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("CloudStateHashMock.SignWith mock is already set by Set")
	}

	if mmSignWith.defaultExpectation == nil {
		mmSignWith.defaultExpectation = &CloudStateHashMockSignWithExpectation{mock: mmSignWith.mock}
	}
	mmSignWith.defaultExpectation.results = &CloudStateHashMockSignWithResults{s1}
	return mmSignWith.mock
}

//Set uses given function f to mock the CloudStateHash.SignWith method
func (mmSignWith *mCloudStateHashMockSignWith) Set(f func(signer cryptkit.DigestSigner) (s1 cryptkit.SignedDigestHolder)) *CloudStateHashMock {
	if mmSignWith.defaultExpectation != nil {
		mmSignWith.mock.t.Fatalf("Default expectation is already set for the CloudStateHash.SignWith method")
	}

	if len(mmSignWith.expectations) > 0 {
		mmSignWith.mock.t.Fatalf("Some expectations are already set for the CloudStateHash.SignWith method")
	}

	mmSignWith.mock.funcSignWith = f
	return mmSignWith.mock
}

// When sets expectation for the CloudStateHash.SignWith which will trigger the result defined by the following
// Then helper
func (mmSignWith *mCloudStateHashMockSignWith) When(signer cryptkit.DigestSigner) *CloudStateHashMockSignWithExpectation {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("CloudStateHashMock.SignWith mock is already set by Set")
	}

	expectation := &CloudStateHashMockSignWithExpectation{
		mock:   mmSignWith.mock,
		params: &CloudStateHashMockSignWithParams{signer},
	}
	mmSignWith.expectations = append(mmSignWith.expectations, expectation)
	return expectation
}

// Then sets up CloudStateHash.SignWith return parameters for the expectation previously defined by the When method
func (e *CloudStateHashMockSignWithExpectation) Then(s1 cryptkit.SignedDigestHolder) *CloudStateHashMock {
	e.results = &CloudStateHashMockSignWithResults{s1}
	return e.mock
}

// SignWith implements CloudStateHash
func (mmSignWith *CloudStateHashMock) SignWith(signer cryptkit.DigestSigner) (s1 cryptkit.SignedDigestHolder) {
	mm_atomic.AddUint64(&mmSignWith.beforeSignWithCounter, 1)
	defer mm_atomic.AddUint64(&mmSignWith.afterSignWithCounter, 1)

	if mmSignWith.inspectFuncSignWith != nil {
		mmSignWith.inspectFuncSignWith(signer)
	}

	mm_params := &CloudStateHashMockSignWithParams{signer}

	// Record call args
	mmSignWith.SignWithMock.mutex.Lock()
	mmSignWith.SignWithMock.callArgs = append(mmSignWith.SignWithMock.callArgs, mm_params)
	mmSignWith.SignWithMock.mutex.Unlock()

	for _, e := range mmSignWith.SignWithMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSignWith.SignWithMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSignWith.SignWithMock.defaultExpectation.Counter, 1)
		mm_want := mmSignWith.SignWithMock.defaultExpectation.params
		mm_got := CloudStateHashMockSignWithParams{signer}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSignWith.t.Errorf("CloudStateHashMock.SignWith got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSignWith.SignWithMock.defaultExpectation.results
		if mm_results == nil {
			mmSignWith.t.Fatal("No results are set for the CloudStateHashMock.SignWith")
		}
		return (*mm_results).s1
	}
	if mmSignWith.funcSignWith != nil {
		return mmSignWith.funcSignWith(signer)
	}
	mmSignWith.t.Fatalf("Unexpected call to CloudStateHashMock.SignWith. %v", signer)
	return
}

// SignWithAfterCounter returns a count of finished CloudStateHashMock.SignWith invocations
func (mmSignWith *CloudStateHashMock) SignWithAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignWith.afterSignWithCounter)
}

// SignWithBeforeCounter returns a count of CloudStateHashMock.SignWith invocations
func (mmSignWith *CloudStateHashMock) SignWithBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignWith.beforeSignWithCounter)
}

// Calls returns a list of arguments used in each call to CloudStateHashMock.SignWith.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSignWith *mCloudStateHashMockSignWith) Calls() []*CloudStateHashMockSignWithParams {
	mmSignWith.mutex.RLock()

	argCopy := make([]*CloudStateHashMockSignWithParams, len(mmSignWith.callArgs))
	copy(argCopy, mmSignWith.callArgs)

	mmSignWith.mutex.RUnlock()

	return argCopy
}

// MinimockSignWithDone returns true if the count of the SignWith invocations corresponds
// the number of defined expectations
func (m *CloudStateHashMock) MinimockSignWithDone() bool {
	for _, e := range m.SignWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignWith != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		return false
	}
	return true
}

// MinimockSignWithInspect logs each unmet expectation
func (m *CloudStateHashMock) MinimockSignWithInspect() {
	for _, e := range m.SignWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CloudStateHashMock.SignWith with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		if m.SignWithMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CloudStateHashMock.SignWith")
		} else {
			m.t.Errorf("Expected call to CloudStateHashMock.SignWith with params: %#v", *m.SignWithMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignWith != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.SignWith")
	}
}

type mCloudStateHashMockWriteTo struct {
	mock               *CloudStateHashMock
	defaultExpectation *CloudStateHashMockWriteToExpectation
	expectations       []*CloudStateHashMockWriteToExpectation

	callArgs []*CloudStateHashMockWriteToParams
	mutex    sync.RWMutex
}

// CloudStateHashMockWriteToExpectation specifies expectation struct of the CloudStateHash.WriteTo
type CloudStateHashMockWriteToExpectation struct {
	mock    *CloudStateHashMock
	params  *CloudStateHashMockWriteToParams
	results *CloudStateHashMockWriteToResults
	Counter uint64
}

// CloudStateHashMockWriteToParams contains parameters of the CloudStateHash.WriteTo
type CloudStateHashMockWriteToParams struct {
	w io.Writer
}

// CloudStateHashMockWriteToResults contains results of the CloudStateHash.WriteTo
type CloudStateHashMockWriteToResults struct {
	n   int64
	err error
}

// Expect sets up expected params for CloudStateHash.WriteTo
func (mmWriteTo *mCloudStateHashMockWriteTo) Expect(w io.Writer) *mCloudStateHashMockWriteTo {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("CloudStateHashMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &CloudStateHashMockWriteToExpectation{}
	}

	mmWriteTo.defaultExpectation.params = &CloudStateHashMockWriteToParams{w}
	for _, e := range mmWriteTo.expectations {
		if minimock.Equal(e.params, mmWriteTo.defaultExpectation.params) {
			mmWriteTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteTo.defaultExpectation.params)
		}
	}

	return mmWriteTo
}

// Inspect accepts an inspector function that has same arguments as the CloudStateHash.WriteTo
func (mmWriteTo *mCloudStateHashMockWriteTo) Inspect(f func(w io.Writer)) *mCloudStateHashMockWriteTo {
	if mmWriteTo.mock.inspectFuncWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("Inspect function is already set for CloudStateHashMock.WriteTo")
	}

	mmWriteTo.mock.inspectFuncWriteTo = f

	return mmWriteTo
}

// Return sets up results that will be returned by CloudStateHash.WriteTo
func (mmWriteTo *mCloudStateHashMockWriteTo) Return(n int64, err error) *CloudStateHashMock {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("CloudStateHashMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &CloudStateHashMockWriteToExpectation{mock: mmWriteTo.mock}
	}
	mmWriteTo.defaultExpectation.results = &CloudStateHashMockWriteToResults{n, err}
	return mmWriteTo.mock
}

//Set uses given function f to mock the CloudStateHash.WriteTo method
func (mmWriteTo *mCloudStateHashMockWriteTo) Set(f func(w io.Writer) (n int64, err error)) *CloudStateHashMock {
	if mmWriteTo.defaultExpectation != nil {
		mmWriteTo.mock.t.Fatalf("Default expectation is already set for the CloudStateHash.WriteTo method")
	}

	if len(mmWriteTo.expectations) > 0 {
		mmWriteTo.mock.t.Fatalf("Some expectations are already set for the CloudStateHash.WriteTo method")
	}

	mmWriteTo.mock.funcWriteTo = f
	return mmWriteTo.mock
}

// When sets expectation for the CloudStateHash.WriteTo which will trigger the result defined by the following
// Then helper
func (mmWriteTo *mCloudStateHashMockWriteTo) When(w io.Writer) *CloudStateHashMockWriteToExpectation {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("CloudStateHashMock.WriteTo mock is already set by Set")
	}

	expectation := &CloudStateHashMockWriteToExpectation{
		mock:   mmWriteTo.mock,
		params: &CloudStateHashMockWriteToParams{w},
	}
	mmWriteTo.expectations = append(mmWriteTo.expectations, expectation)
	return expectation
}

// Then sets up CloudStateHash.WriteTo return parameters for the expectation previously defined by the When method
func (e *CloudStateHashMockWriteToExpectation) Then(n int64, err error) *CloudStateHashMock {
	e.results = &CloudStateHashMockWriteToResults{n, err}
	return e.mock
}

// WriteTo implements CloudStateHash
func (mmWriteTo *CloudStateHashMock) WriteTo(w io.Writer) (n int64, err error) {
	mm_atomic.AddUint64(&mmWriteTo.beforeWriteToCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteTo.afterWriteToCounter, 1)

	if mmWriteTo.inspectFuncWriteTo != nil {
		mmWriteTo.inspectFuncWriteTo(w)
	}

	mm_params := &CloudStateHashMockWriteToParams{w}

	// Record call args
	mmWriteTo.WriteToMock.mutex.Lock()
	mmWriteTo.WriteToMock.callArgs = append(mmWriteTo.WriteToMock.callArgs, mm_params)
	mmWriteTo.WriteToMock.mutex.Unlock()

	for _, e := range mmWriteTo.WriteToMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWriteTo.WriteToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteTo.WriteToMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteTo.WriteToMock.defaultExpectation.params
		mm_got := CloudStateHashMockWriteToParams{w}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteTo.t.Errorf("CloudStateHashMock.WriteTo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWriteTo.WriteToMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteTo.t.Fatal("No results are set for the CloudStateHashMock.WriteTo")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmWriteTo.funcWriteTo != nil {
		return mmWriteTo.funcWriteTo(w)
	}
	mmWriteTo.t.Fatalf("Unexpected call to CloudStateHashMock.WriteTo. %v", w)
	return
}

// WriteToAfterCounter returns a count of finished CloudStateHashMock.WriteTo invocations
func (mmWriteTo *CloudStateHashMock) WriteToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.afterWriteToCounter)
}

// WriteToBeforeCounter returns a count of CloudStateHashMock.WriteTo invocations
func (mmWriteTo *CloudStateHashMock) WriteToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.beforeWriteToCounter)
}

// Calls returns a list of arguments used in each call to CloudStateHashMock.WriteTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteTo *mCloudStateHashMockWriteTo) Calls() []*CloudStateHashMockWriteToParams {
	mmWriteTo.mutex.RLock()

	argCopy := make([]*CloudStateHashMockWriteToParams, len(mmWriteTo.callArgs))
	copy(argCopy, mmWriteTo.callArgs)

	mmWriteTo.mutex.RUnlock()

	return argCopy
}

// MinimockWriteToDone returns true if the count of the WriteTo invocations corresponds
// the number of defined expectations
func (m *CloudStateHashMock) MinimockWriteToDone() bool {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteToInspect logs each unmet expectation
func (m *CloudStateHashMock) MinimockWriteToInspect() {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CloudStateHashMock.WriteTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		if m.WriteToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CloudStateHashMock.WriteTo")
		} else {
			m.t.Errorf("Expected call to CloudStateHashMock.WriteTo with params: %#v", *m.WriteToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.WriteTo")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CloudStateHashMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAsByteStringInspect()

		m.MinimockCopyToInspect()

		m.MinimockEqualsInspect()

		m.MinimockFixedByteSizeInspect()

		m.MinimockFoldToUint64Inspect()

		m.MinimockGetDigestMethodInspect()

		m.MinimockSignWithInspect()

		m.MinimockWriteToInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CloudStateHashMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CloudStateHashMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAsByteStringDone() &&
		m.MinimockCopyToDone() &&
		m.MinimockEqualsDone() &&
		m.MinimockFixedByteSizeDone() &&
		m.MinimockFoldToUint64Done() &&
		m.MinimockGetDigestMethodDone() &&
		m.MinimockSignWithDone() &&
		m.MinimockWriteToDone()
}
