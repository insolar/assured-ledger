package census

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/insolar/node"
	"github.com/insolar/assured-ledger/ledger-core/network/consensus/gcpv2/api/member"
	"github.com/insolar/assured-ledger/ledger-core/network/consensus/gcpv2/api/profiles"
)

// RolePopulationMock implements RolePopulation
type RolePopulationMock struct {
	t minimock.Tester

	funcGetAssignmentByCount          func(metric uint64, excludeID node.ShortNodeID) (assigned profiles.ActiveNode, excluded profiles.ActiveNode)
	inspectFuncGetAssignmentByCount   func(metric uint64, excludeID node.ShortNodeID)
	afterGetAssignmentByCountCounter  uint64
	beforeGetAssignmentByCountCounter uint64
	GetAssignmentByCountMock          mRolePopulationMockGetAssignmentByCount

	funcGetAssignmentByPower          func(metric uint64, excludeID node.ShortNodeID) (assigned profiles.ActiveNode, excluded profiles.ActiveNode)
	inspectFuncGetAssignmentByPower   func(metric uint64, excludeID node.ShortNodeID)
	afterGetAssignmentByPowerCounter  uint64
	beforeGetAssignmentByPowerCounter uint64
	GetAssignmentByPowerMock          mRolePopulationMockGetAssignmentByPower

	funcGetIdleCount          func() (i1 int)
	inspectFuncGetIdleCount   func()
	afterGetIdleCountCounter  uint64
	beforeGetIdleCountCounter uint64
	GetIdleCountMock          mRolePopulationMockGetIdleCount

	funcGetPrimaryRole          func() (p1 member.PrimaryRole)
	inspectFuncGetPrimaryRole   func()
	afterGetPrimaryRoleCounter  uint64
	beforeGetPrimaryRoleCounter uint64
	GetPrimaryRoleMock          mRolePopulationMockGetPrimaryRole

	funcGetProfiles          func() (aa1 []profiles.ActiveNode)
	inspectFuncGetProfiles   func()
	afterGetProfilesCounter  uint64
	beforeGetProfilesCounter uint64
	GetProfilesMock          mRolePopulationMockGetProfiles

	funcGetWorkingCount          func() (i1 int)
	inspectFuncGetWorkingCount   func()
	afterGetWorkingCountCounter  uint64
	beforeGetWorkingCountCounter uint64
	GetWorkingCountMock          mRolePopulationMockGetWorkingCount

	funcGetWorkingPower          func() (u1 uint32)
	inspectFuncGetWorkingPower   func()
	afterGetWorkingPowerCounter  uint64
	beforeGetWorkingPowerCounter uint64
	GetWorkingPowerMock          mRolePopulationMockGetWorkingPower

	funcIsValid          func() (b1 bool)
	inspectFuncIsValid   func()
	afterIsValidCounter  uint64
	beforeIsValidCounter uint64
	IsValidMock          mRolePopulationMockIsValid
}

// NewRolePopulationMock returns a mock for RolePopulation
func NewRolePopulationMock(t minimock.Tester) *RolePopulationMock {
	m := &RolePopulationMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetAssignmentByCountMock = mRolePopulationMockGetAssignmentByCount{mock: m}
	m.GetAssignmentByCountMock.callArgs = []*RolePopulationMockGetAssignmentByCountParams{}

	m.GetAssignmentByPowerMock = mRolePopulationMockGetAssignmentByPower{mock: m}
	m.GetAssignmentByPowerMock.callArgs = []*RolePopulationMockGetAssignmentByPowerParams{}

	m.GetIdleCountMock = mRolePopulationMockGetIdleCount{mock: m}

	m.GetPrimaryRoleMock = mRolePopulationMockGetPrimaryRole{mock: m}

	m.GetProfilesMock = mRolePopulationMockGetProfiles{mock: m}

	m.GetWorkingCountMock = mRolePopulationMockGetWorkingCount{mock: m}

	m.GetWorkingPowerMock = mRolePopulationMockGetWorkingPower{mock: m}

	m.IsValidMock = mRolePopulationMockIsValid{mock: m}

	return m
}

type mRolePopulationMockGetAssignmentByCount struct {
	mock               *RolePopulationMock
	defaultExpectation *RolePopulationMockGetAssignmentByCountExpectation
	expectations       []*RolePopulationMockGetAssignmentByCountExpectation

	callArgs []*RolePopulationMockGetAssignmentByCountParams
	mutex    sync.RWMutex
}

// RolePopulationMockGetAssignmentByCountExpectation specifies expectation struct of the RolePopulation.GetAssignmentByCount
type RolePopulationMockGetAssignmentByCountExpectation struct {
	mock    *RolePopulationMock
	params  *RolePopulationMockGetAssignmentByCountParams
	results *RolePopulationMockGetAssignmentByCountResults
	Counter uint64
}

// RolePopulationMockGetAssignmentByCountParams contains parameters of the RolePopulation.GetAssignmentByCount
type RolePopulationMockGetAssignmentByCountParams struct {
	metric    uint64
	excludeID node.ShortNodeID
}

// RolePopulationMockGetAssignmentByCountResults contains results of the RolePopulation.GetAssignmentByCount
type RolePopulationMockGetAssignmentByCountResults struct {
	assigned profiles.ActiveNode
	excluded profiles.ActiveNode
}

// Expect sets up expected params for RolePopulation.GetAssignmentByCount
func (mmGetAssignmentByCount *mRolePopulationMockGetAssignmentByCount) Expect(metric uint64, excludeID node.ShortNodeID) *mRolePopulationMockGetAssignmentByCount {
	if mmGetAssignmentByCount.mock.funcGetAssignmentByCount != nil {
		mmGetAssignmentByCount.mock.t.Fatalf("RolePopulationMock.GetAssignmentByCount mock is already set by Set")
	}

	if mmGetAssignmentByCount.defaultExpectation == nil {
		mmGetAssignmentByCount.defaultExpectation = &RolePopulationMockGetAssignmentByCountExpectation{}
	}

	mmGetAssignmentByCount.defaultExpectation.params = &RolePopulationMockGetAssignmentByCountParams{metric, excludeID}
	for _, e := range mmGetAssignmentByCount.expectations {
		if minimock.Equal(e.params, mmGetAssignmentByCount.defaultExpectation.params) {
			mmGetAssignmentByCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAssignmentByCount.defaultExpectation.params)
		}
	}

	return mmGetAssignmentByCount
}

// Inspect accepts an inspector function that has same arguments as the RolePopulation.GetAssignmentByCount
func (mmGetAssignmentByCount *mRolePopulationMockGetAssignmentByCount) Inspect(f func(metric uint64, excludeID node.ShortNodeID)) *mRolePopulationMockGetAssignmentByCount {
	if mmGetAssignmentByCount.mock.inspectFuncGetAssignmentByCount != nil {
		mmGetAssignmentByCount.mock.t.Fatalf("Inspect function is already set for RolePopulationMock.GetAssignmentByCount")
	}

	mmGetAssignmentByCount.mock.inspectFuncGetAssignmentByCount = f

	return mmGetAssignmentByCount
}

// Return sets up results that will be returned by RolePopulation.GetAssignmentByCount
func (mmGetAssignmentByCount *mRolePopulationMockGetAssignmentByCount) Return(assigned profiles.ActiveNode, excluded profiles.ActiveNode) *RolePopulationMock {
	if mmGetAssignmentByCount.mock.funcGetAssignmentByCount != nil {
		mmGetAssignmentByCount.mock.t.Fatalf("RolePopulationMock.GetAssignmentByCount mock is already set by Set")
	}

	if mmGetAssignmentByCount.defaultExpectation == nil {
		mmGetAssignmentByCount.defaultExpectation = &RolePopulationMockGetAssignmentByCountExpectation{mock: mmGetAssignmentByCount.mock}
	}
	mmGetAssignmentByCount.defaultExpectation.results = &RolePopulationMockGetAssignmentByCountResults{assigned, excluded}
	return mmGetAssignmentByCount.mock
}

//Set uses given function f to mock the RolePopulation.GetAssignmentByCount method
func (mmGetAssignmentByCount *mRolePopulationMockGetAssignmentByCount) Set(f func(metric uint64, excludeID node.ShortNodeID) (assigned profiles.ActiveNode, excluded profiles.ActiveNode)) *RolePopulationMock {
	if mmGetAssignmentByCount.defaultExpectation != nil {
		mmGetAssignmentByCount.mock.t.Fatalf("Default expectation is already set for the RolePopulation.GetAssignmentByCount method")
	}

	if len(mmGetAssignmentByCount.expectations) > 0 {
		mmGetAssignmentByCount.mock.t.Fatalf("Some expectations are already set for the RolePopulation.GetAssignmentByCount method")
	}

	mmGetAssignmentByCount.mock.funcGetAssignmentByCount = f
	return mmGetAssignmentByCount.mock
}

// When sets expectation for the RolePopulation.GetAssignmentByCount which will trigger the result defined by the following
// Then helper
func (mmGetAssignmentByCount *mRolePopulationMockGetAssignmentByCount) When(metric uint64, excludeID node.ShortNodeID) *RolePopulationMockGetAssignmentByCountExpectation {
	if mmGetAssignmentByCount.mock.funcGetAssignmentByCount != nil {
		mmGetAssignmentByCount.mock.t.Fatalf("RolePopulationMock.GetAssignmentByCount mock is already set by Set")
	}

	expectation := &RolePopulationMockGetAssignmentByCountExpectation{
		mock:   mmGetAssignmentByCount.mock,
		params: &RolePopulationMockGetAssignmentByCountParams{metric, excludeID},
	}
	mmGetAssignmentByCount.expectations = append(mmGetAssignmentByCount.expectations, expectation)
	return expectation
}

// Then sets up RolePopulation.GetAssignmentByCount return parameters for the expectation previously defined by the When method
func (e *RolePopulationMockGetAssignmentByCountExpectation) Then(assigned profiles.ActiveNode, excluded profiles.ActiveNode) *RolePopulationMock {
	e.results = &RolePopulationMockGetAssignmentByCountResults{assigned, excluded}
	return e.mock
}

// GetAssignmentByCount implements RolePopulation
func (mmGetAssignmentByCount *RolePopulationMock) GetAssignmentByCount(metric uint64, excludeID node.ShortNodeID) (assigned profiles.ActiveNode, excluded profiles.ActiveNode) {
	mm_atomic.AddUint64(&mmGetAssignmentByCount.beforeGetAssignmentByCountCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAssignmentByCount.afterGetAssignmentByCountCounter, 1)

	if mmGetAssignmentByCount.inspectFuncGetAssignmentByCount != nil {
		mmGetAssignmentByCount.inspectFuncGetAssignmentByCount(metric, excludeID)
	}

	mm_params := &RolePopulationMockGetAssignmentByCountParams{metric, excludeID}

	// Record call args
	mmGetAssignmentByCount.GetAssignmentByCountMock.mutex.Lock()
	mmGetAssignmentByCount.GetAssignmentByCountMock.callArgs = append(mmGetAssignmentByCount.GetAssignmentByCountMock.callArgs, mm_params)
	mmGetAssignmentByCount.GetAssignmentByCountMock.mutex.Unlock()

	for _, e := range mmGetAssignmentByCount.GetAssignmentByCountMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.assigned, e.results.excluded
		}
	}

	if mmGetAssignmentByCount.GetAssignmentByCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAssignmentByCount.GetAssignmentByCountMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAssignmentByCount.GetAssignmentByCountMock.defaultExpectation.params
		mm_got := RolePopulationMockGetAssignmentByCountParams{metric, excludeID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAssignmentByCount.t.Errorf("RolePopulationMock.GetAssignmentByCount got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAssignmentByCount.GetAssignmentByCountMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAssignmentByCount.t.Fatal("No results are set for the RolePopulationMock.GetAssignmentByCount")
		}
		return (*mm_results).assigned, (*mm_results).excluded
	}
	if mmGetAssignmentByCount.funcGetAssignmentByCount != nil {
		return mmGetAssignmentByCount.funcGetAssignmentByCount(metric, excludeID)
	}
	mmGetAssignmentByCount.t.Fatalf("Unexpected call to RolePopulationMock.GetAssignmentByCount. %v %v", metric, excludeID)
	return
}

// GetAssignmentByCountAfterCounter returns a count of finished RolePopulationMock.GetAssignmentByCount invocations
func (mmGetAssignmentByCount *RolePopulationMock) GetAssignmentByCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAssignmentByCount.afterGetAssignmentByCountCounter)
}

// GetAssignmentByCountBeforeCounter returns a count of RolePopulationMock.GetAssignmentByCount invocations
func (mmGetAssignmentByCount *RolePopulationMock) GetAssignmentByCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAssignmentByCount.beforeGetAssignmentByCountCounter)
}

// Calls returns a list of arguments used in each call to RolePopulationMock.GetAssignmentByCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAssignmentByCount *mRolePopulationMockGetAssignmentByCount) Calls() []*RolePopulationMockGetAssignmentByCountParams {
	mmGetAssignmentByCount.mutex.RLock()

	argCopy := make([]*RolePopulationMockGetAssignmentByCountParams, len(mmGetAssignmentByCount.callArgs))
	copy(argCopy, mmGetAssignmentByCount.callArgs)

	mmGetAssignmentByCount.mutex.RUnlock()

	return argCopy
}

// MinimockGetAssignmentByCountDone returns true if the count of the GetAssignmentByCount invocations corresponds
// the number of defined expectations
func (m *RolePopulationMock) MinimockGetAssignmentByCountDone() bool {
	for _, e := range m.GetAssignmentByCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAssignmentByCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAssignmentByCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAssignmentByCount != nil && mm_atomic.LoadUint64(&m.afterGetAssignmentByCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAssignmentByCountInspect logs each unmet expectation
func (m *RolePopulationMock) MinimockGetAssignmentByCountInspect() {
	for _, e := range m.GetAssignmentByCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RolePopulationMock.GetAssignmentByCount with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAssignmentByCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAssignmentByCountCounter) < 1 {
		if m.GetAssignmentByCountMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RolePopulationMock.GetAssignmentByCount")
		} else {
			m.t.Errorf("Expected call to RolePopulationMock.GetAssignmentByCount with params: %#v", *m.GetAssignmentByCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAssignmentByCount != nil && mm_atomic.LoadUint64(&m.afterGetAssignmentByCountCounter) < 1 {
		m.t.Error("Expected call to RolePopulationMock.GetAssignmentByCount")
	}
}

type mRolePopulationMockGetAssignmentByPower struct {
	mock               *RolePopulationMock
	defaultExpectation *RolePopulationMockGetAssignmentByPowerExpectation
	expectations       []*RolePopulationMockGetAssignmentByPowerExpectation

	callArgs []*RolePopulationMockGetAssignmentByPowerParams
	mutex    sync.RWMutex
}

// RolePopulationMockGetAssignmentByPowerExpectation specifies expectation struct of the RolePopulation.GetAssignmentByPower
type RolePopulationMockGetAssignmentByPowerExpectation struct {
	mock    *RolePopulationMock
	params  *RolePopulationMockGetAssignmentByPowerParams
	results *RolePopulationMockGetAssignmentByPowerResults
	Counter uint64
}

// RolePopulationMockGetAssignmentByPowerParams contains parameters of the RolePopulation.GetAssignmentByPower
type RolePopulationMockGetAssignmentByPowerParams struct {
	metric    uint64
	excludeID node.ShortNodeID
}

// RolePopulationMockGetAssignmentByPowerResults contains results of the RolePopulation.GetAssignmentByPower
type RolePopulationMockGetAssignmentByPowerResults struct {
	assigned profiles.ActiveNode
	excluded profiles.ActiveNode
}

// Expect sets up expected params for RolePopulation.GetAssignmentByPower
func (mmGetAssignmentByPower *mRolePopulationMockGetAssignmentByPower) Expect(metric uint64, excludeID node.ShortNodeID) *mRolePopulationMockGetAssignmentByPower {
	if mmGetAssignmentByPower.mock.funcGetAssignmentByPower != nil {
		mmGetAssignmentByPower.mock.t.Fatalf("RolePopulationMock.GetAssignmentByPower mock is already set by Set")
	}

	if mmGetAssignmentByPower.defaultExpectation == nil {
		mmGetAssignmentByPower.defaultExpectation = &RolePopulationMockGetAssignmentByPowerExpectation{}
	}

	mmGetAssignmentByPower.defaultExpectation.params = &RolePopulationMockGetAssignmentByPowerParams{metric, excludeID}
	for _, e := range mmGetAssignmentByPower.expectations {
		if minimock.Equal(e.params, mmGetAssignmentByPower.defaultExpectation.params) {
			mmGetAssignmentByPower.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAssignmentByPower.defaultExpectation.params)
		}
	}

	return mmGetAssignmentByPower
}

// Inspect accepts an inspector function that has same arguments as the RolePopulation.GetAssignmentByPower
func (mmGetAssignmentByPower *mRolePopulationMockGetAssignmentByPower) Inspect(f func(metric uint64, excludeID node.ShortNodeID)) *mRolePopulationMockGetAssignmentByPower {
	if mmGetAssignmentByPower.mock.inspectFuncGetAssignmentByPower != nil {
		mmGetAssignmentByPower.mock.t.Fatalf("Inspect function is already set for RolePopulationMock.GetAssignmentByPower")
	}

	mmGetAssignmentByPower.mock.inspectFuncGetAssignmentByPower = f

	return mmGetAssignmentByPower
}

// Return sets up results that will be returned by RolePopulation.GetAssignmentByPower
func (mmGetAssignmentByPower *mRolePopulationMockGetAssignmentByPower) Return(assigned profiles.ActiveNode, excluded profiles.ActiveNode) *RolePopulationMock {
	if mmGetAssignmentByPower.mock.funcGetAssignmentByPower != nil {
		mmGetAssignmentByPower.mock.t.Fatalf("RolePopulationMock.GetAssignmentByPower mock is already set by Set")
	}

	if mmGetAssignmentByPower.defaultExpectation == nil {
		mmGetAssignmentByPower.defaultExpectation = &RolePopulationMockGetAssignmentByPowerExpectation{mock: mmGetAssignmentByPower.mock}
	}
	mmGetAssignmentByPower.defaultExpectation.results = &RolePopulationMockGetAssignmentByPowerResults{assigned, excluded}
	return mmGetAssignmentByPower.mock
}

//Set uses given function f to mock the RolePopulation.GetAssignmentByPower method
func (mmGetAssignmentByPower *mRolePopulationMockGetAssignmentByPower) Set(f func(metric uint64, excludeID node.ShortNodeID) (assigned profiles.ActiveNode, excluded profiles.ActiveNode)) *RolePopulationMock {
	if mmGetAssignmentByPower.defaultExpectation != nil {
		mmGetAssignmentByPower.mock.t.Fatalf("Default expectation is already set for the RolePopulation.GetAssignmentByPower method")
	}

	if len(mmGetAssignmentByPower.expectations) > 0 {
		mmGetAssignmentByPower.mock.t.Fatalf("Some expectations are already set for the RolePopulation.GetAssignmentByPower method")
	}

	mmGetAssignmentByPower.mock.funcGetAssignmentByPower = f
	return mmGetAssignmentByPower.mock
}

// When sets expectation for the RolePopulation.GetAssignmentByPower which will trigger the result defined by the following
// Then helper
func (mmGetAssignmentByPower *mRolePopulationMockGetAssignmentByPower) When(metric uint64, excludeID node.ShortNodeID) *RolePopulationMockGetAssignmentByPowerExpectation {
	if mmGetAssignmentByPower.mock.funcGetAssignmentByPower != nil {
		mmGetAssignmentByPower.mock.t.Fatalf("RolePopulationMock.GetAssignmentByPower mock is already set by Set")
	}

	expectation := &RolePopulationMockGetAssignmentByPowerExpectation{
		mock:   mmGetAssignmentByPower.mock,
		params: &RolePopulationMockGetAssignmentByPowerParams{metric, excludeID},
	}
	mmGetAssignmentByPower.expectations = append(mmGetAssignmentByPower.expectations, expectation)
	return expectation
}

// Then sets up RolePopulation.GetAssignmentByPower return parameters for the expectation previously defined by the When method
func (e *RolePopulationMockGetAssignmentByPowerExpectation) Then(assigned profiles.ActiveNode, excluded profiles.ActiveNode) *RolePopulationMock {
	e.results = &RolePopulationMockGetAssignmentByPowerResults{assigned, excluded}
	return e.mock
}

// GetAssignmentByPower implements RolePopulation
func (mmGetAssignmentByPower *RolePopulationMock) GetAssignmentByPower(metric uint64, excludeID node.ShortNodeID) (assigned profiles.ActiveNode, excluded profiles.ActiveNode) {
	mm_atomic.AddUint64(&mmGetAssignmentByPower.beforeGetAssignmentByPowerCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAssignmentByPower.afterGetAssignmentByPowerCounter, 1)

	if mmGetAssignmentByPower.inspectFuncGetAssignmentByPower != nil {
		mmGetAssignmentByPower.inspectFuncGetAssignmentByPower(metric, excludeID)
	}

	mm_params := &RolePopulationMockGetAssignmentByPowerParams{metric, excludeID}

	// Record call args
	mmGetAssignmentByPower.GetAssignmentByPowerMock.mutex.Lock()
	mmGetAssignmentByPower.GetAssignmentByPowerMock.callArgs = append(mmGetAssignmentByPower.GetAssignmentByPowerMock.callArgs, mm_params)
	mmGetAssignmentByPower.GetAssignmentByPowerMock.mutex.Unlock()

	for _, e := range mmGetAssignmentByPower.GetAssignmentByPowerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.assigned, e.results.excluded
		}
	}

	if mmGetAssignmentByPower.GetAssignmentByPowerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAssignmentByPower.GetAssignmentByPowerMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAssignmentByPower.GetAssignmentByPowerMock.defaultExpectation.params
		mm_got := RolePopulationMockGetAssignmentByPowerParams{metric, excludeID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAssignmentByPower.t.Errorf("RolePopulationMock.GetAssignmentByPower got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAssignmentByPower.GetAssignmentByPowerMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAssignmentByPower.t.Fatal("No results are set for the RolePopulationMock.GetAssignmentByPower")
		}
		return (*mm_results).assigned, (*mm_results).excluded
	}
	if mmGetAssignmentByPower.funcGetAssignmentByPower != nil {
		return mmGetAssignmentByPower.funcGetAssignmentByPower(metric, excludeID)
	}
	mmGetAssignmentByPower.t.Fatalf("Unexpected call to RolePopulationMock.GetAssignmentByPower. %v %v", metric, excludeID)
	return
}

// GetAssignmentByPowerAfterCounter returns a count of finished RolePopulationMock.GetAssignmentByPower invocations
func (mmGetAssignmentByPower *RolePopulationMock) GetAssignmentByPowerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAssignmentByPower.afterGetAssignmentByPowerCounter)
}

// GetAssignmentByPowerBeforeCounter returns a count of RolePopulationMock.GetAssignmentByPower invocations
func (mmGetAssignmentByPower *RolePopulationMock) GetAssignmentByPowerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAssignmentByPower.beforeGetAssignmentByPowerCounter)
}

// Calls returns a list of arguments used in each call to RolePopulationMock.GetAssignmentByPower.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAssignmentByPower *mRolePopulationMockGetAssignmentByPower) Calls() []*RolePopulationMockGetAssignmentByPowerParams {
	mmGetAssignmentByPower.mutex.RLock()

	argCopy := make([]*RolePopulationMockGetAssignmentByPowerParams, len(mmGetAssignmentByPower.callArgs))
	copy(argCopy, mmGetAssignmentByPower.callArgs)

	mmGetAssignmentByPower.mutex.RUnlock()

	return argCopy
}

// MinimockGetAssignmentByPowerDone returns true if the count of the GetAssignmentByPower invocations corresponds
// the number of defined expectations
func (m *RolePopulationMock) MinimockGetAssignmentByPowerDone() bool {
	for _, e := range m.GetAssignmentByPowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAssignmentByPowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAssignmentByPowerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAssignmentByPower != nil && mm_atomic.LoadUint64(&m.afterGetAssignmentByPowerCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAssignmentByPowerInspect logs each unmet expectation
func (m *RolePopulationMock) MinimockGetAssignmentByPowerInspect() {
	for _, e := range m.GetAssignmentByPowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RolePopulationMock.GetAssignmentByPower with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAssignmentByPowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAssignmentByPowerCounter) < 1 {
		if m.GetAssignmentByPowerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RolePopulationMock.GetAssignmentByPower")
		} else {
			m.t.Errorf("Expected call to RolePopulationMock.GetAssignmentByPower with params: %#v", *m.GetAssignmentByPowerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAssignmentByPower != nil && mm_atomic.LoadUint64(&m.afterGetAssignmentByPowerCounter) < 1 {
		m.t.Error("Expected call to RolePopulationMock.GetAssignmentByPower")
	}
}

type mRolePopulationMockGetIdleCount struct {
	mock               *RolePopulationMock
	defaultExpectation *RolePopulationMockGetIdleCountExpectation
	expectations       []*RolePopulationMockGetIdleCountExpectation
}

// RolePopulationMockGetIdleCountExpectation specifies expectation struct of the RolePopulation.GetIdleCount
type RolePopulationMockGetIdleCountExpectation struct {
	mock *RolePopulationMock

	results *RolePopulationMockGetIdleCountResults
	Counter uint64
}

// RolePopulationMockGetIdleCountResults contains results of the RolePopulation.GetIdleCount
type RolePopulationMockGetIdleCountResults struct {
	i1 int
}

// Expect sets up expected params for RolePopulation.GetIdleCount
func (mmGetIdleCount *mRolePopulationMockGetIdleCount) Expect() *mRolePopulationMockGetIdleCount {
	if mmGetIdleCount.mock.funcGetIdleCount != nil {
		mmGetIdleCount.mock.t.Fatalf("RolePopulationMock.GetIdleCount mock is already set by Set")
	}

	if mmGetIdleCount.defaultExpectation == nil {
		mmGetIdleCount.defaultExpectation = &RolePopulationMockGetIdleCountExpectation{}
	}

	return mmGetIdleCount
}

// Inspect accepts an inspector function that has same arguments as the RolePopulation.GetIdleCount
func (mmGetIdleCount *mRolePopulationMockGetIdleCount) Inspect(f func()) *mRolePopulationMockGetIdleCount {
	if mmGetIdleCount.mock.inspectFuncGetIdleCount != nil {
		mmGetIdleCount.mock.t.Fatalf("Inspect function is already set for RolePopulationMock.GetIdleCount")
	}

	mmGetIdleCount.mock.inspectFuncGetIdleCount = f

	return mmGetIdleCount
}

// Return sets up results that will be returned by RolePopulation.GetIdleCount
func (mmGetIdleCount *mRolePopulationMockGetIdleCount) Return(i1 int) *RolePopulationMock {
	if mmGetIdleCount.mock.funcGetIdleCount != nil {
		mmGetIdleCount.mock.t.Fatalf("RolePopulationMock.GetIdleCount mock is already set by Set")
	}

	if mmGetIdleCount.defaultExpectation == nil {
		mmGetIdleCount.defaultExpectation = &RolePopulationMockGetIdleCountExpectation{mock: mmGetIdleCount.mock}
	}
	mmGetIdleCount.defaultExpectation.results = &RolePopulationMockGetIdleCountResults{i1}
	return mmGetIdleCount.mock
}

//Set uses given function f to mock the RolePopulation.GetIdleCount method
func (mmGetIdleCount *mRolePopulationMockGetIdleCount) Set(f func() (i1 int)) *RolePopulationMock {
	if mmGetIdleCount.defaultExpectation != nil {
		mmGetIdleCount.mock.t.Fatalf("Default expectation is already set for the RolePopulation.GetIdleCount method")
	}

	if len(mmGetIdleCount.expectations) > 0 {
		mmGetIdleCount.mock.t.Fatalf("Some expectations are already set for the RolePopulation.GetIdleCount method")
	}

	mmGetIdleCount.mock.funcGetIdleCount = f
	return mmGetIdleCount.mock
}

// GetIdleCount implements RolePopulation
func (mmGetIdleCount *RolePopulationMock) GetIdleCount() (i1 int) {
	mm_atomic.AddUint64(&mmGetIdleCount.beforeGetIdleCountCounter, 1)
	defer mm_atomic.AddUint64(&mmGetIdleCount.afterGetIdleCountCounter, 1)

	if mmGetIdleCount.inspectFuncGetIdleCount != nil {
		mmGetIdleCount.inspectFuncGetIdleCount()
	}

	if mmGetIdleCount.GetIdleCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetIdleCount.GetIdleCountMock.defaultExpectation.Counter, 1)

		mm_results := mmGetIdleCount.GetIdleCountMock.defaultExpectation.results
		if mm_results == nil {
			mmGetIdleCount.t.Fatal("No results are set for the RolePopulationMock.GetIdleCount")
		}
		return (*mm_results).i1
	}
	if mmGetIdleCount.funcGetIdleCount != nil {
		return mmGetIdleCount.funcGetIdleCount()
	}
	mmGetIdleCount.t.Fatalf("Unexpected call to RolePopulationMock.GetIdleCount.")
	return
}

// GetIdleCountAfterCounter returns a count of finished RolePopulationMock.GetIdleCount invocations
func (mmGetIdleCount *RolePopulationMock) GetIdleCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIdleCount.afterGetIdleCountCounter)
}

// GetIdleCountBeforeCounter returns a count of RolePopulationMock.GetIdleCount invocations
func (mmGetIdleCount *RolePopulationMock) GetIdleCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIdleCount.beforeGetIdleCountCounter)
}

// MinimockGetIdleCountDone returns true if the count of the GetIdleCount invocations corresponds
// the number of defined expectations
func (m *RolePopulationMock) MinimockGetIdleCountDone() bool {
	for _, e := range m.GetIdleCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetIdleCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetIdleCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetIdleCount != nil && mm_atomic.LoadUint64(&m.afterGetIdleCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetIdleCountInspect logs each unmet expectation
func (m *RolePopulationMock) MinimockGetIdleCountInspect() {
	for _, e := range m.GetIdleCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RolePopulationMock.GetIdleCount")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetIdleCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetIdleCountCounter) < 1 {
		m.t.Error("Expected call to RolePopulationMock.GetIdleCount")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetIdleCount != nil && mm_atomic.LoadUint64(&m.afterGetIdleCountCounter) < 1 {
		m.t.Error("Expected call to RolePopulationMock.GetIdleCount")
	}
}

type mRolePopulationMockGetPrimaryRole struct {
	mock               *RolePopulationMock
	defaultExpectation *RolePopulationMockGetPrimaryRoleExpectation
	expectations       []*RolePopulationMockGetPrimaryRoleExpectation
}

// RolePopulationMockGetPrimaryRoleExpectation specifies expectation struct of the RolePopulation.GetPrimaryRole
type RolePopulationMockGetPrimaryRoleExpectation struct {
	mock *RolePopulationMock

	results *RolePopulationMockGetPrimaryRoleResults
	Counter uint64
}

// RolePopulationMockGetPrimaryRoleResults contains results of the RolePopulation.GetPrimaryRole
type RolePopulationMockGetPrimaryRoleResults struct {
	p1 member.PrimaryRole
}

// Expect sets up expected params for RolePopulation.GetPrimaryRole
func (mmGetPrimaryRole *mRolePopulationMockGetPrimaryRole) Expect() *mRolePopulationMockGetPrimaryRole {
	if mmGetPrimaryRole.mock.funcGetPrimaryRole != nil {
		mmGetPrimaryRole.mock.t.Fatalf("RolePopulationMock.GetPrimaryRole mock is already set by Set")
	}

	if mmGetPrimaryRole.defaultExpectation == nil {
		mmGetPrimaryRole.defaultExpectation = &RolePopulationMockGetPrimaryRoleExpectation{}
	}

	return mmGetPrimaryRole
}

// Inspect accepts an inspector function that has same arguments as the RolePopulation.GetPrimaryRole
func (mmGetPrimaryRole *mRolePopulationMockGetPrimaryRole) Inspect(f func()) *mRolePopulationMockGetPrimaryRole {
	if mmGetPrimaryRole.mock.inspectFuncGetPrimaryRole != nil {
		mmGetPrimaryRole.mock.t.Fatalf("Inspect function is already set for RolePopulationMock.GetPrimaryRole")
	}

	mmGetPrimaryRole.mock.inspectFuncGetPrimaryRole = f

	return mmGetPrimaryRole
}

// Return sets up results that will be returned by RolePopulation.GetPrimaryRole
func (mmGetPrimaryRole *mRolePopulationMockGetPrimaryRole) Return(p1 member.PrimaryRole) *RolePopulationMock {
	if mmGetPrimaryRole.mock.funcGetPrimaryRole != nil {
		mmGetPrimaryRole.mock.t.Fatalf("RolePopulationMock.GetPrimaryRole mock is already set by Set")
	}

	if mmGetPrimaryRole.defaultExpectation == nil {
		mmGetPrimaryRole.defaultExpectation = &RolePopulationMockGetPrimaryRoleExpectation{mock: mmGetPrimaryRole.mock}
	}
	mmGetPrimaryRole.defaultExpectation.results = &RolePopulationMockGetPrimaryRoleResults{p1}
	return mmGetPrimaryRole.mock
}

//Set uses given function f to mock the RolePopulation.GetPrimaryRole method
func (mmGetPrimaryRole *mRolePopulationMockGetPrimaryRole) Set(f func() (p1 member.PrimaryRole)) *RolePopulationMock {
	if mmGetPrimaryRole.defaultExpectation != nil {
		mmGetPrimaryRole.mock.t.Fatalf("Default expectation is already set for the RolePopulation.GetPrimaryRole method")
	}

	if len(mmGetPrimaryRole.expectations) > 0 {
		mmGetPrimaryRole.mock.t.Fatalf("Some expectations are already set for the RolePopulation.GetPrimaryRole method")
	}

	mmGetPrimaryRole.mock.funcGetPrimaryRole = f
	return mmGetPrimaryRole.mock
}

// GetPrimaryRole implements RolePopulation
func (mmGetPrimaryRole *RolePopulationMock) GetPrimaryRole() (p1 member.PrimaryRole) {
	mm_atomic.AddUint64(&mmGetPrimaryRole.beforeGetPrimaryRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPrimaryRole.afterGetPrimaryRoleCounter, 1)

	if mmGetPrimaryRole.inspectFuncGetPrimaryRole != nil {
		mmGetPrimaryRole.inspectFuncGetPrimaryRole()
	}

	if mmGetPrimaryRole.GetPrimaryRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPrimaryRole.GetPrimaryRoleMock.defaultExpectation.Counter, 1)

		mm_results := mmGetPrimaryRole.GetPrimaryRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPrimaryRole.t.Fatal("No results are set for the RolePopulationMock.GetPrimaryRole")
		}
		return (*mm_results).p1
	}
	if mmGetPrimaryRole.funcGetPrimaryRole != nil {
		return mmGetPrimaryRole.funcGetPrimaryRole()
	}
	mmGetPrimaryRole.t.Fatalf("Unexpected call to RolePopulationMock.GetPrimaryRole.")
	return
}

// GetPrimaryRoleAfterCounter returns a count of finished RolePopulationMock.GetPrimaryRole invocations
func (mmGetPrimaryRole *RolePopulationMock) GetPrimaryRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPrimaryRole.afterGetPrimaryRoleCounter)
}

// GetPrimaryRoleBeforeCounter returns a count of RolePopulationMock.GetPrimaryRole invocations
func (mmGetPrimaryRole *RolePopulationMock) GetPrimaryRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPrimaryRole.beforeGetPrimaryRoleCounter)
}

// MinimockGetPrimaryRoleDone returns true if the count of the GetPrimaryRole invocations corresponds
// the number of defined expectations
func (m *RolePopulationMock) MinimockGetPrimaryRoleDone() bool {
	for _, e := range m.GetPrimaryRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPrimaryRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPrimaryRoleCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPrimaryRole != nil && mm_atomic.LoadUint64(&m.afterGetPrimaryRoleCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPrimaryRoleInspect logs each unmet expectation
func (m *RolePopulationMock) MinimockGetPrimaryRoleInspect() {
	for _, e := range m.GetPrimaryRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RolePopulationMock.GetPrimaryRole")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPrimaryRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPrimaryRoleCounter) < 1 {
		m.t.Error("Expected call to RolePopulationMock.GetPrimaryRole")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPrimaryRole != nil && mm_atomic.LoadUint64(&m.afterGetPrimaryRoleCounter) < 1 {
		m.t.Error("Expected call to RolePopulationMock.GetPrimaryRole")
	}
}

type mRolePopulationMockGetProfiles struct {
	mock               *RolePopulationMock
	defaultExpectation *RolePopulationMockGetProfilesExpectation
	expectations       []*RolePopulationMockGetProfilesExpectation
}

// RolePopulationMockGetProfilesExpectation specifies expectation struct of the RolePopulation.GetProfiles
type RolePopulationMockGetProfilesExpectation struct {
	mock *RolePopulationMock

	results *RolePopulationMockGetProfilesResults
	Counter uint64
}

// RolePopulationMockGetProfilesResults contains results of the RolePopulation.GetProfiles
type RolePopulationMockGetProfilesResults struct {
	aa1 []profiles.ActiveNode
}

// Expect sets up expected params for RolePopulation.GetProfiles
func (mmGetProfiles *mRolePopulationMockGetProfiles) Expect() *mRolePopulationMockGetProfiles {
	if mmGetProfiles.mock.funcGetProfiles != nil {
		mmGetProfiles.mock.t.Fatalf("RolePopulationMock.GetProfiles mock is already set by Set")
	}

	if mmGetProfiles.defaultExpectation == nil {
		mmGetProfiles.defaultExpectation = &RolePopulationMockGetProfilesExpectation{}
	}

	return mmGetProfiles
}

// Inspect accepts an inspector function that has same arguments as the RolePopulation.GetProfiles
func (mmGetProfiles *mRolePopulationMockGetProfiles) Inspect(f func()) *mRolePopulationMockGetProfiles {
	if mmGetProfiles.mock.inspectFuncGetProfiles != nil {
		mmGetProfiles.mock.t.Fatalf("Inspect function is already set for RolePopulationMock.GetProfiles")
	}

	mmGetProfiles.mock.inspectFuncGetProfiles = f

	return mmGetProfiles
}

// Return sets up results that will be returned by RolePopulation.GetProfiles
func (mmGetProfiles *mRolePopulationMockGetProfiles) Return(aa1 []profiles.ActiveNode) *RolePopulationMock {
	if mmGetProfiles.mock.funcGetProfiles != nil {
		mmGetProfiles.mock.t.Fatalf("RolePopulationMock.GetProfiles mock is already set by Set")
	}

	if mmGetProfiles.defaultExpectation == nil {
		mmGetProfiles.defaultExpectation = &RolePopulationMockGetProfilesExpectation{mock: mmGetProfiles.mock}
	}
	mmGetProfiles.defaultExpectation.results = &RolePopulationMockGetProfilesResults{aa1}
	return mmGetProfiles.mock
}

//Set uses given function f to mock the RolePopulation.GetProfiles method
func (mmGetProfiles *mRolePopulationMockGetProfiles) Set(f func() (aa1 []profiles.ActiveNode)) *RolePopulationMock {
	if mmGetProfiles.defaultExpectation != nil {
		mmGetProfiles.mock.t.Fatalf("Default expectation is already set for the RolePopulation.GetProfiles method")
	}

	if len(mmGetProfiles.expectations) > 0 {
		mmGetProfiles.mock.t.Fatalf("Some expectations are already set for the RolePopulation.GetProfiles method")
	}

	mmGetProfiles.mock.funcGetProfiles = f
	return mmGetProfiles.mock
}

// GetProfiles implements RolePopulation
func (mmGetProfiles *RolePopulationMock) GetProfiles() (aa1 []profiles.ActiveNode) {
	mm_atomic.AddUint64(&mmGetProfiles.beforeGetProfilesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetProfiles.afterGetProfilesCounter, 1)

	if mmGetProfiles.inspectFuncGetProfiles != nil {
		mmGetProfiles.inspectFuncGetProfiles()
	}

	if mmGetProfiles.GetProfilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetProfiles.GetProfilesMock.defaultExpectation.Counter, 1)

		mm_results := mmGetProfiles.GetProfilesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetProfiles.t.Fatal("No results are set for the RolePopulationMock.GetProfiles")
		}
		return (*mm_results).aa1
	}
	if mmGetProfiles.funcGetProfiles != nil {
		return mmGetProfiles.funcGetProfiles()
	}
	mmGetProfiles.t.Fatalf("Unexpected call to RolePopulationMock.GetProfiles.")
	return
}

// GetProfilesAfterCounter returns a count of finished RolePopulationMock.GetProfiles invocations
func (mmGetProfiles *RolePopulationMock) GetProfilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProfiles.afterGetProfilesCounter)
}

// GetProfilesBeforeCounter returns a count of RolePopulationMock.GetProfiles invocations
func (mmGetProfiles *RolePopulationMock) GetProfilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProfiles.beforeGetProfilesCounter)
}

// MinimockGetProfilesDone returns true if the count of the GetProfiles invocations corresponds
// the number of defined expectations
func (m *RolePopulationMock) MinimockGetProfilesDone() bool {
	for _, e := range m.GetProfilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProfilesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProfilesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProfiles != nil && mm_atomic.LoadUint64(&m.afterGetProfilesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetProfilesInspect logs each unmet expectation
func (m *RolePopulationMock) MinimockGetProfilesInspect() {
	for _, e := range m.GetProfilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RolePopulationMock.GetProfiles")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProfilesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProfilesCounter) < 1 {
		m.t.Error("Expected call to RolePopulationMock.GetProfiles")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProfiles != nil && mm_atomic.LoadUint64(&m.afterGetProfilesCounter) < 1 {
		m.t.Error("Expected call to RolePopulationMock.GetProfiles")
	}
}

type mRolePopulationMockGetWorkingCount struct {
	mock               *RolePopulationMock
	defaultExpectation *RolePopulationMockGetWorkingCountExpectation
	expectations       []*RolePopulationMockGetWorkingCountExpectation
}

// RolePopulationMockGetWorkingCountExpectation specifies expectation struct of the RolePopulation.GetWorkingCount
type RolePopulationMockGetWorkingCountExpectation struct {
	mock *RolePopulationMock

	results *RolePopulationMockGetWorkingCountResults
	Counter uint64
}

// RolePopulationMockGetWorkingCountResults contains results of the RolePopulation.GetWorkingCount
type RolePopulationMockGetWorkingCountResults struct {
	i1 int
}

// Expect sets up expected params for RolePopulation.GetWorkingCount
func (mmGetWorkingCount *mRolePopulationMockGetWorkingCount) Expect() *mRolePopulationMockGetWorkingCount {
	if mmGetWorkingCount.mock.funcGetWorkingCount != nil {
		mmGetWorkingCount.mock.t.Fatalf("RolePopulationMock.GetWorkingCount mock is already set by Set")
	}

	if mmGetWorkingCount.defaultExpectation == nil {
		mmGetWorkingCount.defaultExpectation = &RolePopulationMockGetWorkingCountExpectation{}
	}

	return mmGetWorkingCount
}

// Inspect accepts an inspector function that has same arguments as the RolePopulation.GetWorkingCount
func (mmGetWorkingCount *mRolePopulationMockGetWorkingCount) Inspect(f func()) *mRolePopulationMockGetWorkingCount {
	if mmGetWorkingCount.mock.inspectFuncGetWorkingCount != nil {
		mmGetWorkingCount.mock.t.Fatalf("Inspect function is already set for RolePopulationMock.GetWorkingCount")
	}

	mmGetWorkingCount.mock.inspectFuncGetWorkingCount = f

	return mmGetWorkingCount
}

// Return sets up results that will be returned by RolePopulation.GetWorkingCount
func (mmGetWorkingCount *mRolePopulationMockGetWorkingCount) Return(i1 int) *RolePopulationMock {
	if mmGetWorkingCount.mock.funcGetWorkingCount != nil {
		mmGetWorkingCount.mock.t.Fatalf("RolePopulationMock.GetWorkingCount mock is already set by Set")
	}

	if mmGetWorkingCount.defaultExpectation == nil {
		mmGetWorkingCount.defaultExpectation = &RolePopulationMockGetWorkingCountExpectation{mock: mmGetWorkingCount.mock}
	}
	mmGetWorkingCount.defaultExpectation.results = &RolePopulationMockGetWorkingCountResults{i1}
	return mmGetWorkingCount.mock
}

//Set uses given function f to mock the RolePopulation.GetWorkingCount method
func (mmGetWorkingCount *mRolePopulationMockGetWorkingCount) Set(f func() (i1 int)) *RolePopulationMock {
	if mmGetWorkingCount.defaultExpectation != nil {
		mmGetWorkingCount.mock.t.Fatalf("Default expectation is already set for the RolePopulation.GetWorkingCount method")
	}

	if len(mmGetWorkingCount.expectations) > 0 {
		mmGetWorkingCount.mock.t.Fatalf("Some expectations are already set for the RolePopulation.GetWorkingCount method")
	}

	mmGetWorkingCount.mock.funcGetWorkingCount = f
	return mmGetWorkingCount.mock
}

// GetWorkingCount implements RolePopulation
func (mmGetWorkingCount *RolePopulationMock) GetWorkingCount() (i1 int) {
	mm_atomic.AddUint64(&mmGetWorkingCount.beforeGetWorkingCountCounter, 1)
	defer mm_atomic.AddUint64(&mmGetWorkingCount.afterGetWorkingCountCounter, 1)

	if mmGetWorkingCount.inspectFuncGetWorkingCount != nil {
		mmGetWorkingCount.inspectFuncGetWorkingCount()
	}

	if mmGetWorkingCount.GetWorkingCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetWorkingCount.GetWorkingCountMock.defaultExpectation.Counter, 1)

		mm_results := mmGetWorkingCount.GetWorkingCountMock.defaultExpectation.results
		if mm_results == nil {
			mmGetWorkingCount.t.Fatal("No results are set for the RolePopulationMock.GetWorkingCount")
		}
		return (*mm_results).i1
	}
	if mmGetWorkingCount.funcGetWorkingCount != nil {
		return mmGetWorkingCount.funcGetWorkingCount()
	}
	mmGetWorkingCount.t.Fatalf("Unexpected call to RolePopulationMock.GetWorkingCount.")
	return
}

// GetWorkingCountAfterCounter returns a count of finished RolePopulationMock.GetWorkingCount invocations
func (mmGetWorkingCount *RolePopulationMock) GetWorkingCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWorkingCount.afterGetWorkingCountCounter)
}

// GetWorkingCountBeforeCounter returns a count of RolePopulationMock.GetWorkingCount invocations
func (mmGetWorkingCount *RolePopulationMock) GetWorkingCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWorkingCount.beforeGetWorkingCountCounter)
}

// MinimockGetWorkingCountDone returns true if the count of the GetWorkingCount invocations corresponds
// the number of defined expectations
func (m *RolePopulationMock) MinimockGetWorkingCountDone() bool {
	for _, e := range m.GetWorkingCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWorkingCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWorkingCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWorkingCount != nil && mm_atomic.LoadUint64(&m.afterGetWorkingCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetWorkingCountInspect logs each unmet expectation
func (m *RolePopulationMock) MinimockGetWorkingCountInspect() {
	for _, e := range m.GetWorkingCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RolePopulationMock.GetWorkingCount")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWorkingCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWorkingCountCounter) < 1 {
		m.t.Error("Expected call to RolePopulationMock.GetWorkingCount")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWorkingCount != nil && mm_atomic.LoadUint64(&m.afterGetWorkingCountCounter) < 1 {
		m.t.Error("Expected call to RolePopulationMock.GetWorkingCount")
	}
}

type mRolePopulationMockGetWorkingPower struct {
	mock               *RolePopulationMock
	defaultExpectation *RolePopulationMockGetWorkingPowerExpectation
	expectations       []*RolePopulationMockGetWorkingPowerExpectation
}

// RolePopulationMockGetWorkingPowerExpectation specifies expectation struct of the RolePopulation.GetWorkingPower
type RolePopulationMockGetWorkingPowerExpectation struct {
	mock *RolePopulationMock

	results *RolePopulationMockGetWorkingPowerResults
	Counter uint64
}

// RolePopulationMockGetWorkingPowerResults contains results of the RolePopulation.GetWorkingPower
type RolePopulationMockGetWorkingPowerResults struct {
	u1 uint32
}

// Expect sets up expected params for RolePopulation.GetWorkingPower
func (mmGetWorkingPower *mRolePopulationMockGetWorkingPower) Expect() *mRolePopulationMockGetWorkingPower {
	if mmGetWorkingPower.mock.funcGetWorkingPower != nil {
		mmGetWorkingPower.mock.t.Fatalf("RolePopulationMock.GetWorkingPower mock is already set by Set")
	}

	if mmGetWorkingPower.defaultExpectation == nil {
		mmGetWorkingPower.defaultExpectation = &RolePopulationMockGetWorkingPowerExpectation{}
	}

	return mmGetWorkingPower
}

// Inspect accepts an inspector function that has same arguments as the RolePopulation.GetWorkingPower
func (mmGetWorkingPower *mRolePopulationMockGetWorkingPower) Inspect(f func()) *mRolePopulationMockGetWorkingPower {
	if mmGetWorkingPower.mock.inspectFuncGetWorkingPower != nil {
		mmGetWorkingPower.mock.t.Fatalf("Inspect function is already set for RolePopulationMock.GetWorkingPower")
	}

	mmGetWorkingPower.mock.inspectFuncGetWorkingPower = f

	return mmGetWorkingPower
}

// Return sets up results that will be returned by RolePopulation.GetWorkingPower
func (mmGetWorkingPower *mRolePopulationMockGetWorkingPower) Return(u1 uint32) *RolePopulationMock {
	if mmGetWorkingPower.mock.funcGetWorkingPower != nil {
		mmGetWorkingPower.mock.t.Fatalf("RolePopulationMock.GetWorkingPower mock is already set by Set")
	}

	if mmGetWorkingPower.defaultExpectation == nil {
		mmGetWorkingPower.defaultExpectation = &RolePopulationMockGetWorkingPowerExpectation{mock: mmGetWorkingPower.mock}
	}
	mmGetWorkingPower.defaultExpectation.results = &RolePopulationMockGetWorkingPowerResults{u1}
	return mmGetWorkingPower.mock
}

//Set uses given function f to mock the RolePopulation.GetWorkingPower method
func (mmGetWorkingPower *mRolePopulationMockGetWorkingPower) Set(f func() (u1 uint32)) *RolePopulationMock {
	if mmGetWorkingPower.defaultExpectation != nil {
		mmGetWorkingPower.mock.t.Fatalf("Default expectation is already set for the RolePopulation.GetWorkingPower method")
	}

	if len(mmGetWorkingPower.expectations) > 0 {
		mmGetWorkingPower.mock.t.Fatalf("Some expectations are already set for the RolePopulation.GetWorkingPower method")
	}

	mmGetWorkingPower.mock.funcGetWorkingPower = f
	return mmGetWorkingPower.mock
}

// GetWorkingPower implements RolePopulation
func (mmGetWorkingPower *RolePopulationMock) GetWorkingPower() (u1 uint32) {
	mm_atomic.AddUint64(&mmGetWorkingPower.beforeGetWorkingPowerCounter, 1)
	defer mm_atomic.AddUint64(&mmGetWorkingPower.afterGetWorkingPowerCounter, 1)

	if mmGetWorkingPower.inspectFuncGetWorkingPower != nil {
		mmGetWorkingPower.inspectFuncGetWorkingPower()
	}

	if mmGetWorkingPower.GetWorkingPowerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetWorkingPower.GetWorkingPowerMock.defaultExpectation.Counter, 1)

		mm_results := mmGetWorkingPower.GetWorkingPowerMock.defaultExpectation.results
		if mm_results == nil {
			mmGetWorkingPower.t.Fatal("No results are set for the RolePopulationMock.GetWorkingPower")
		}
		return (*mm_results).u1
	}
	if mmGetWorkingPower.funcGetWorkingPower != nil {
		return mmGetWorkingPower.funcGetWorkingPower()
	}
	mmGetWorkingPower.t.Fatalf("Unexpected call to RolePopulationMock.GetWorkingPower.")
	return
}

// GetWorkingPowerAfterCounter returns a count of finished RolePopulationMock.GetWorkingPower invocations
func (mmGetWorkingPower *RolePopulationMock) GetWorkingPowerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWorkingPower.afterGetWorkingPowerCounter)
}

// GetWorkingPowerBeforeCounter returns a count of RolePopulationMock.GetWorkingPower invocations
func (mmGetWorkingPower *RolePopulationMock) GetWorkingPowerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWorkingPower.beforeGetWorkingPowerCounter)
}

// MinimockGetWorkingPowerDone returns true if the count of the GetWorkingPower invocations corresponds
// the number of defined expectations
func (m *RolePopulationMock) MinimockGetWorkingPowerDone() bool {
	for _, e := range m.GetWorkingPowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWorkingPowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWorkingPowerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWorkingPower != nil && mm_atomic.LoadUint64(&m.afterGetWorkingPowerCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetWorkingPowerInspect logs each unmet expectation
func (m *RolePopulationMock) MinimockGetWorkingPowerInspect() {
	for _, e := range m.GetWorkingPowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RolePopulationMock.GetWorkingPower")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWorkingPowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWorkingPowerCounter) < 1 {
		m.t.Error("Expected call to RolePopulationMock.GetWorkingPower")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWorkingPower != nil && mm_atomic.LoadUint64(&m.afterGetWorkingPowerCounter) < 1 {
		m.t.Error("Expected call to RolePopulationMock.GetWorkingPower")
	}
}

type mRolePopulationMockIsValid struct {
	mock               *RolePopulationMock
	defaultExpectation *RolePopulationMockIsValidExpectation
	expectations       []*RolePopulationMockIsValidExpectation
}

// RolePopulationMockIsValidExpectation specifies expectation struct of the RolePopulation.IsValid
type RolePopulationMockIsValidExpectation struct {
	mock *RolePopulationMock

	results *RolePopulationMockIsValidResults
	Counter uint64
}

// RolePopulationMockIsValidResults contains results of the RolePopulation.IsValid
type RolePopulationMockIsValidResults struct {
	b1 bool
}

// Expect sets up expected params for RolePopulation.IsValid
func (mmIsValid *mRolePopulationMockIsValid) Expect() *mRolePopulationMockIsValid {
	if mmIsValid.mock.funcIsValid != nil {
		mmIsValid.mock.t.Fatalf("RolePopulationMock.IsValid mock is already set by Set")
	}

	if mmIsValid.defaultExpectation == nil {
		mmIsValid.defaultExpectation = &RolePopulationMockIsValidExpectation{}
	}

	return mmIsValid
}

// Inspect accepts an inspector function that has same arguments as the RolePopulation.IsValid
func (mmIsValid *mRolePopulationMockIsValid) Inspect(f func()) *mRolePopulationMockIsValid {
	if mmIsValid.mock.inspectFuncIsValid != nil {
		mmIsValid.mock.t.Fatalf("Inspect function is already set for RolePopulationMock.IsValid")
	}

	mmIsValid.mock.inspectFuncIsValid = f

	return mmIsValid
}

// Return sets up results that will be returned by RolePopulation.IsValid
func (mmIsValid *mRolePopulationMockIsValid) Return(b1 bool) *RolePopulationMock {
	if mmIsValid.mock.funcIsValid != nil {
		mmIsValid.mock.t.Fatalf("RolePopulationMock.IsValid mock is already set by Set")
	}

	if mmIsValid.defaultExpectation == nil {
		mmIsValid.defaultExpectation = &RolePopulationMockIsValidExpectation{mock: mmIsValid.mock}
	}
	mmIsValid.defaultExpectation.results = &RolePopulationMockIsValidResults{b1}
	return mmIsValid.mock
}

//Set uses given function f to mock the RolePopulation.IsValid method
func (mmIsValid *mRolePopulationMockIsValid) Set(f func() (b1 bool)) *RolePopulationMock {
	if mmIsValid.defaultExpectation != nil {
		mmIsValid.mock.t.Fatalf("Default expectation is already set for the RolePopulation.IsValid method")
	}

	if len(mmIsValid.expectations) > 0 {
		mmIsValid.mock.t.Fatalf("Some expectations are already set for the RolePopulation.IsValid method")
	}

	mmIsValid.mock.funcIsValid = f
	return mmIsValid.mock
}

// IsValid implements RolePopulation
func (mmIsValid *RolePopulationMock) IsValid() (b1 bool) {
	mm_atomic.AddUint64(&mmIsValid.beforeIsValidCounter, 1)
	defer mm_atomic.AddUint64(&mmIsValid.afterIsValidCounter, 1)

	if mmIsValid.inspectFuncIsValid != nil {
		mmIsValid.inspectFuncIsValid()
	}

	if mmIsValid.IsValidMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsValid.IsValidMock.defaultExpectation.Counter, 1)

		mm_results := mmIsValid.IsValidMock.defaultExpectation.results
		if mm_results == nil {
			mmIsValid.t.Fatal("No results are set for the RolePopulationMock.IsValid")
		}
		return (*mm_results).b1
	}
	if mmIsValid.funcIsValid != nil {
		return mmIsValid.funcIsValid()
	}
	mmIsValid.t.Fatalf("Unexpected call to RolePopulationMock.IsValid.")
	return
}

// IsValidAfterCounter returns a count of finished RolePopulationMock.IsValid invocations
func (mmIsValid *RolePopulationMock) IsValidAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsValid.afterIsValidCounter)
}

// IsValidBeforeCounter returns a count of RolePopulationMock.IsValid invocations
func (mmIsValid *RolePopulationMock) IsValidBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsValid.beforeIsValidCounter)
}

// MinimockIsValidDone returns true if the count of the IsValid invocations corresponds
// the number of defined expectations
func (m *RolePopulationMock) MinimockIsValidDone() bool {
	for _, e := range m.IsValidMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsValidMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsValidCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsValid != nil && mm_atomic.LoadUint64(&m.afterIsValidCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsValidInspect logs each unmet expectation
func (m *RolePopulationMock) MinimockIsValidInspect() {
	for _, e := range m.IsValidMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RolePopulationMock.IsValid")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsValidMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsValidCounter) < 1 {
		m.t.Error("Expected call to RolePopulationMock.IsValid")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsValid != nil && mm_atomic.LoadUint64(&m.afterIsValidCounter) < 1 {
		m.t.Error("Expected call to RolePopulationMock.IsValid")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RolePopulationMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetAssignmentByCountInspect()

		m.MinimockGetAssignmentByPowerInspect()

		m.MinimockGetIdleCountInspect()

		m.MinimockGetPrimaryRoleInspect()

		m.MinimockGetProfilesInspect()

		m.MinimockGetWorkingCountInspect()

		m.MinimockGetWorkingPowerInspect()

		m.MinimockIsValidInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RolePopulationMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RolePopulationMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetAssignmentByCountDone() &&
		m.MinimockGetAssignmentByPowerDone() &&
		m.MinimockGetIdleCountDone() &&
		m.MinimockGetPrimaryRoleDone() &&
		m.MinimockGetProfilesDone() &&
		m.MinimockGetWorkingCountDone() &&
		m.MinimockGetWorkingPowerDone() &&
		m.MinimockIsValidDone()
}
