// Copyright 2020 Insolar Network Ltd.
// All rights reserved.
// This material is licensed under the Insolar License version 1.0,
// available at https://github.com/insolar/assured-ledger/blob/master/LICENSE.md.

package recordchecker

import (
	"reflect"
	"time"

	"github.com/gojuno/minimock/v3"

	"github.com/insolar/assured-ledger/ledger-core/pulse"
	"github.com/insolar/assured-ledger/ledger-core/reference"
	"github.com/insolar/assured-ledger/ledger-core/rms"
	"github.com/insolar/assured-ledger/ledger-core/rms/rmsbox"
	"github.com/insolar/assured-ledger/ledger-core/vanilla/throw"
)

type Constraint func(actualMsg rms.LRegisterRequest) error
type ResponseProducer func(message rms.LRegisterRequest)

type Checker interface {
	// Add new chainItem of expected messages
	NewChainFromReference(objectRef rms.Reference) Chain
	NewChainFromRLifeline(msg rms.LRegisterRequest, responseProducer ResponseProducer, constraints ...Constraint) Chain

	GetReadView() ReadViewChainList
}

type ReadViewChainList interface {
	// Mocker describes common interface for all mocks generated by minimock
	minimock.Mocker

	IsFinished() bool
	GetObjectByReference(objectRef reference.Global) ChainChecker
	GetObjectByRLifeline(p pulse.Number, msg rms.LRegisterRequest) ChainChecker
}

type Chain interface {
	AddMessage(msg rms.LRegisterRequest, responseProducer ResponseProducer, constraints ...Constraint) Chain
	GetReadView() ChainChecker
	// GetReference returns reference that can be accessed only AFTER we've obtained message
	GetReference() rmsbox.ReferenceProvider
}

type ChainChecker interface {
	Feed(msg rms.LRegisterRequest) (ChainChecker, error)
	GetResponseProvider() ResponseProducer
	GetConstraints() []Constraint
	IsFinished() bool
}

func NewChecker(t minimock.Tester) Checker {
	m := &checker{
		t: t,
	}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}
	return m
}

// implementation

var _ Checker = &checker{}
var _ ReadViewChainList = &checker{}

type checker struct {
	t      minimock.Tester
	chains []*chain
}

func (c *checker) GetReadView() ReadViewChainList {
	return c
}

func (c *checker) MinimockFinish() {
	if !c.IsFinished() {
		c.t.FailNow()
	}
}

func (c *checker) MinimockWait(timeout time.Duration) {
	timeoutCh := time.After(timeout)
	for {
		if c.IsFinished() {
			return
		}
		select {
		case <-timeoutCh:
			c.MinimockFinish()
			return
		case <-time.After(10 * time.Millisecond):
		}
	}
}

func (c *checker) NewChainFromReference(objectRef rms.Reference) Chain {
	newChain := &chain{
		objectRef: objectRef.GetValue(),
	}
	c.chains = append(c.chains, newChain)
	return newChain
}

func (c *checker) NewChainFromRLifeline(msg rms.LRegisterRequest, responseProducer ResponseProducer, constraints ...Constraint) Chain {
	ch := newChainItem(msg, responseProducer, constraints...)
	iCh := &chain{
		objectRef: msg.AnticipatedRef.GetValue(),
		root:      ch,
	}
	c.chains = append(c.chains, iCh)
	return ch
}

func (c *checker) IsFinished() bool {
	for _, chain := range c.chains {
		if !chain.isFinished() {
			return false
		}
	}
	return true
}

func (c *checker) GetObjectByReference(objectRef reference.Global) ChainChecker {
	for _, iChain := range c.chains {
		if iChain.objectRef.Equal(&objectRef) {
			return iChain.GetReadView()
		}
	}
	return nil
}

func (c *checker) GetObjectByRLifeline(p pulse.Number, msg rms.LRegisterRequest) ChainChecker {
	// TODO: calculate objRef from pulse and payload
	recordWithRefs, ok := RecordFromLRegisterRequest(msg).(withRefs)
	if !ok {
		return nil
	}
	rootRef := recordWithRefs.GetRootRef()
	if !rootRef.IsEmpty() {
		return c.GetObjectByReference(rootRef.GetValue())
	}
	return c.GetObjectByReference(msg.AnticipatedRef.GetValue())
}

var _ Chain = &chain{}

type chain struct {
	objectRef reference.Global
	root      *chainItem
}

func (c *chain) AddMessage(msg rms.LRegisterRequest, responseProducer ResponseProducer, constraints ...Constraint) Chain {
	if c.root != nil {
		panic(throw.IllegalState())
	}
	c.root = newChainItem(msg, responseProducer, constraints...)
	return c.root
}

func (c *chain) GetReadView() ChainChecker {
	if c.root != nil {
		return c.root
	}
	return nil
}

func (c *chain) isFinished() bool {
	if c.root == nil {
		panic(throw.IllegalState())
	}
	return isChainFinished(c.root)
}

func isChainFinished(root *chainItem) bool {
	if !root.IsFinished() {
		return false
	}
	for _, node := range root.nodes {
		if !isChainFinished(node) {
			return false
		}
	}
	return true
}

func (c *chain) GetReference() rmsbox.ReferenceProvider {
	if c.root == nil {
		panic(throw.IllegalState())
	}
	return c.root.GetReference()
}

var _ Chain = &chainItem{}
var _ ChainChecker = &chainItem{}

type chainItem struct {
	anticipatedMessage rms.LRegisterRequest
	constraints        []Constraint
	responseProducer   ResponseProducer
	nodes              []*chainItem
	parent             *chainItem
	receivedMessage    rms.LRegisterRequest
}

func newChainItem(msg rms.LRegisterRequest, responseProducer ResponseProducer, constraints ...Constraint) *chainItem {
	return &chainItem{
		anticipatedMessage: msg,
		constraints:        constraints,
		responseProducer:   responseProducer,
		nodes:              make([]*chainItem, 0),
	}
}

func (c *chainItem) AddMessage(msg rms.LRegisterRequest, responseProducer ResponseProducer, constraints ...Constraint) Chain {
	child := newChainItem(msg, responseProducer, constraints...)
	child.parent = c
	c.nodes = append(c.nodes, child)
	return child
}

func (c *chainItem) GetReadView() ChainChecker {
	return c
}

func (c *chainItem) Feed(msg rms.LRegisterRequest) (ChainChecker, error) {
	return c.findItem(msg, nil)
}

func (c *chainItem) findItem(msg rms.LRegisterRequest, skipItem *chainItem) (ChainChecker, error) {
	if !c.IsFinished() {
		if err := c.checkRefs(msg); err != nil {
			return nil, err
		}
		c.receivedMessage = msg
		return c, nil
	}
	for _, node := range c.nodes {
		if node == skipItem {
			continue
		}
		if node.IsFinished() {
			if founded, err := node.findItem(msg, node); err == nil {
				return founded, nil
			}
		}
		if node.checkRefs(msg) == nil {
			node.receivedMessage = msg
			return node, nil
		}
	}
	if c.parent != nil {
		return c.parent.findItem(msg, c)
	}
	return nil, throw.IllegalValue()
}

func (c *chainItem) checkRefs(msg rms.LRegisterRequest) error {
	msgRecord := RecordFromLRegisterRequest(msg)
	anticipatedRecord := RecordFromLRegisterRequest(c.anticipatedMessage)
	if reflect.TypeOf(msgRecord) != reflect.TypeOf(anticipatedRecord) {
		return throw.E("type mismatch")
	}
	if c.parent != nil {
		wr, ok := msgRecord.(withRefs)
		if !ok {
			return throw.IllegalValue()
		}
		prevRef := wr.GetPrevRef()
		parentRef := c.parent.receivedMessage.AnticipatedRef
		if !prevRef.Equal(&parentRef) {
			return throw.E("order mismatch")
		}
	}
	return nil
}

func (c *chainItem) GetResponseProvider() ResponseProducer {
	return c.responseProducer
}

func (c *chainItem) GetConstraints() []Constraint {
	return c.constraints
}

func (c *chainItem) IsFinished() bool {
	return !c.receivedMessage.AnticipatedRef.IsEmpty()
}

func (c *chainItem) GetReference() rmsbox.ReferenceProvider {
	if !c.IsFinished() {
		panic(throw.IllegalState())
	}
	return &chainItemReferenceProvider{ref: c.receivedMessage.AnticipatedRef.GetValue()}
}

type chainItemReferenceProvider struct {
	ref reference.Global
}

func (c *chainItemReferenceProvider) GetReference() reference.Global {
	return c.ref
}
func (c *chainItemReferenceProvider) TryPullReference() reference.Global {
	return c.ref
}

type withRefs interface {
	GetPrevRef() rms.Reference
	GetRootRef() rms.Reference
}
