// Copyright 2020 Insolar Network Ltd.
// All rights reserved.
// This material is licensed under the Insolar License version 1.0,
// available at https://github.com/insolar/assured-ledger/blob/master/LICENSE.md.

package recordchecker

import (
	"reflect"
	"time"

	"github.com/gojuno/minimock/v3"

	"github.com/insolar/assured-ledger/ledger-core/pulse"
	"github.com/insolar/assured-ledger/ledger-core/reference"
	"github.com/insolar/assured-ledger/ledger-core/rms"
	"github.com/insolar/assured-ledger/ledger-core/rms/rmsbox"
	"github.com/insolar/assured-ledger/ledger-core/vanilla/throw"
)

type CheckMessageFunc func(actualMsg rms.LRegisterRequest) error
type ProduceResponseFunc func(message rms.LRegisterRequest)

type Builder interface {
	// Add new chainItem of expected messages
	CreateChainFromReference(objectRef rms.Reference) ChainBuilder
	CreateChainFromRLifeline(msg rms.LRegisterRequest, responseProducer ProduceResponseFunc, checkFuncs ...CheckMessageFunc) ChainBuilder

	GetChainValidatorList() ChainValidatorList
}

type ChainValidatorList interface {
	// Mocker describes common interface for all mocks generated by minimock
	minimock.Mocker

	IsFinished() bool
	GetChainValidatorByReference(objectRef reference.Global) ChainValidator
	GetChainValidatorByRLifeline(p pulse.Number, msg rms.LRegisterRequest) ChainValidator
}

type ChainBuilder interface {
	AddMessage(msg rms.LRegisterRequest, responseProducer ProduceResponseFunc, constraints ...CheckMessageFunc) ChainBuilder
	GetValidator() ChainValidator
	// GetReference returns reference that can be accessed only AFTER we've obtained message
	GetReference() rmsbox.ReferenceProvider
}

type ChainValidator interface {
	Feed(msg rms.LRegisterRequest) (ChainValidator, error)
	GetProduceResponseFunc() ProduceResponseFunc
	GetCheckMessageFuncs() []CheckMessageFunc
	IsFinished() bool
}

func NewChecker(t minimock.Tester) Builder {
	m := &checker{
		t: t,
	}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}
	return m
}

// implementation

var _ Builder = &checker{}
var _ ChainValidatorList = &checker{}

type checker struct {
	t      minimock.Tester
	chains []*chain
}

func (c *checker) GetChainValidatorList() ChainValidatorList {
	return c
}

func (c *checker) MinimockFinish() {
	if !c.IsFinished() {
		c.t.FailNow()
	}
}

func (c *checker) MinimockWait(timeout time.Duration) {
	timeoutCh := time.After(timeout)
	for {
		if c.IsFinished() {
			return
		}
		select {
		case <-timeoutCh:
			c.MinimockFinish()
			return
		case <-time.After(10 * time.Millisecond):
		}
	}
}

func (c *checker) CreateChainFromReference(objectRef rms.Reference) ChainBuilder {
	newChain := &chain{
		objectRef: objectRef.GetValue(),
	}
	c.chains = append(c.chains, newChain)
	return newChain
}

func (c *checker) CreateChainFromRLifeline(msg rms.LRegisterRequest, responseProducer ProduceResponseFunc, constraints ...CheckMessageFunc) ChainBuilder {
	ch := newChainItem(msg, responseProducer, constraints...)
	iCh := &chain{
		objectRef: msg.AnticipatedRef.GetValue(),
		root:      ch,
	}
	c.chains = append(c.chains, iCh)
	return ch
}

func (c *checker) IsFinished() bool {
	for _, chain := range c.chains {
		if !chain.isFinished() {
			return false
		}
	}
	return true
}

func (c *checker) GetChainValidatorByReference(objectRef reference.Global) ChainValidator {
	for _, iChain := range c.chains {
		if iChain.objectRef.Equal(&objectRef) {
			return iChain.GetValidator()
		}
	}
	return nil
}

func (c *checker) GetChainValidatorByRLifeline(p pulse.Number, msg rms.LRegisterRequest) ChainValidator {
	// TODO: calculate objRef from pulse and payload
	recordWithRefs, ok := RecordFromLRegisterRequest(msg).(withRefs)
	if !ok {
		return nil
	}
	rootRef := recordWithRefs.GetRootRef()
	if !rootRef.IsEmpty() {
		return c.GetChainValidatorByReference(rootRef.GetValue())
	}
	return c.GetChainValidatorByReference(msg.AnticipatedRef.GetValue())
}

var _ ChainBuilder = &chain{}

type chain struct {
	objectRef reference.Global
	root      *chainItem
}

func (c *chain) AddMessage(msg rms.LRegisterRequest, responseProducer ProduceResponseFunc, constraints ...CheckMessageFunc) ChainBuilder {
	if c.root != nil {
		panic(throw.IllegalState())
	}
	c.root = newChainItem(msg, responseProducer, constraints...)
	return c.root
}

func (c *chain) GetValidator() ChainValidator {
	if c.root != nil {
		return c.root
	}
	return nil
}

func (c *chain) isFinished() bool {
	if c.root == nil {
		panic(throw.IllegalState())
	}
	return isChainFinished(c.root)
}

func isChainFinished(root *chainItem) bool {
	if !root.IsFinished() {
		return false
	}
	for _, node := range root.nodes {
		if !isChainFinished(node) {
			return false
		}
	}
	return true
}

func (c *chain) GetReference() rmsbox.ReferenceProvider {
	if c.root == nil {
		panic(throw.IllegalState())
	}
	return c.root.GetReference()
}

var _ ChainBuilder = &chainItem{}
var _ ChainValidator = &chainItem{}

type chainItem struct {
	anticipatedMessage rms.LRegisterRequest
	constraints        []CheckMessageFunc
	responseProducer   ProduceResponseFunc
	nodes              []*chainItem
	parent             *chainItem
	receivedMessage    rms.LRegisterRequest
}

func newChainItem(msg rms.LRegisterRequest, responseProducer ProduceResponseFunc, constraints ...CheckMessageFunc) *chainItem {
	return &chainItem{
		anticipatedMessage: msg,
		constraints:        constraints,
		responseProducer:   responseProducer,
		nodes:              make([]*chainItem, 0),
	}
}

func (c *chainItem) AddMessage(msg rms.LRegisterRequest, responseProducer ProduceResponseFunc, constraints ...CheckMessageFunc) ChainBuilder {
	child := newChainItem(msg, responseProducer, constraints...)
	child.parent = c
	c.nodes = append(c.nodes, child)
	return child
}

func (c *chainItem) GetValidator() ChainValidator {
	return c
}

func (c *chainItem) Feed(msg rms.LRegisterRequest) (ChainValidator, error) {
	return c.findItem(msg, nil)
}

func (c *chainItem) findItem(msg rms.LRegisterRequest, skipItem *chainItem) (ChainValidator, error) {
	if !c.IsFinished() {
		if err := c.checkRefs(msg); err != nil {
			return nil, err
		}
		c.receivedMessage = msg
		return c, nil
	}
	for _, node := range c.nodes {
		if node == skipItem {
			continue
		}
		if node.IsFinished() {
			if founded, err := node.findItem(msg, node); err == nil {
				return founded, nil
			}
		}
		if node.checkRefs(msg) == nil {
			node.receivedMessage = msg
			return node, nil
		}
	}
	if c.parent != nil {
		return c.parent.findItem(msg, c)
	}
	return nil, throw.IllegalValue()
}

func (c *chainItem) checkRefs(msg rms.LRegisterRequest) error {
	msgRecord := RecordFromLRegisterRequest(msg)
	anticipatedRecord := RecordFromLRegisterRequest(c.anticipatedMessage)
	if reflect.TypeOf(msgRecord) != reflect.TypeOf(anticipatedRecord) {
		return throw.E("type mismatch")
	}
	if c.parent != nil {
		wr, ok := msgRecord.(withRefs)
		if !ok {
			return throw.IllegalValue()
		}
		prevRef := wr.GetPrevRef()
		parentRef := c.parent.receivedMessage.AnticipatedRef
		if !prevRef.Equal(&parentRef) {
			return throw.E("order mismatch")
		}
	}
	return nil
}

func (c *chainItem) GetProduceResponseFunc() ProduceResponseFunc {
	return c.responseProducer
}

func (c *chainItem) GetCheckMessageFuncs() []CheckMessageFunc {
	return c.constraints
}

func (c *chainItem) IsFinished() bool {
	return !c.receivedMessage.AnticipatedRef.IsEmpty()
}

func (c *chainItem) GetReference() rmsbox.ReferenceProvider {
	if !c.IsFinished() {
		panic(throw.IllegalState())
	}
	return &chainItemReferenceProvider{ref: c.receivedMessage.AnticipatedRef.GetValue()}
}

type chainItemReferenceProvider struct {
	ref reference.Global
}

func (c *chainItemReferenceProvider) GetReference() reference.Global {
	return c.ref
}
func (c *chainItemReferenceProvider) TryPullReference() reference.Global {
	return c.ref
}

type withRefs interface {
	GetPrevRef() rms.Reference
	GetRootRef() rms.Reference
}
