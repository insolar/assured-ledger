// Copyright 2020 Insolar Network Ltd.
// All rights reserved.
// This material is licensed under the Insolar License version 1.0,
// available at https://github.com/insolar/assured-ledger/blob/master/LICENSE.md.

package recordchecker

import (
	"reflect"
	"time"

	"github.com/gojuno/minimock/v3"

	"github.com/insolar/assured-ledger/ledger-core/rms"
	"github.com/insolar/assured-ledger/ledger-core/vanilla/throw"
)

type LMNMessageChecker interface {
	// Add new chain of expected messages
	NewChain(objectRef rms.Reference) LMNChain
	// Process received from VE message
	ProcessMessage(msg rms.LRegisterRequest) error
	// Mocker describes common interface for all mocks generated by minimock
	MinimockFinish()
	MinimockWait(time.Duration)
}

type lmnMessageChecker struct {
	t      minimock.Tester
	chains []LMNChain
}

func NewLMNMessageChecker(t minimock.Tester) LMNMessageChecker {
	m := &lmnMessageChecker{
		t:      t,
		chains: make([]LMNChain, 0),
	}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}
	return m
}

func (c *lmnMessageChecker) NewChain(objectRef rms.Reference) LMNChain {
	newChain := NewLMNChain(objectRef)
	c.chains = append(c.chains, newChain)
	return newChain
}

func (c *lmnMessageChecker) ProcessMessage(msg rms.LRegisterRequest) error {
	for _, chain := range c.chains {
		if message := chain.FindMessage(msg); message != nil {
			message.ProduceResponse(msg)
			return nil
		}
	}
	return throw.E("Unknown message recv")
}

func (c *lmnMessageChecker) isAllProcessed() bool {
	done := true
	for _, chain := range c.chains {
		if !chain.IsAllProcessed() {
			c.t.Errorf("Message in chain %v was not received fully", chain)
			done = false
		}
	}
	return done
}

func (c *lmnMessageChecker) MinimockFinish() {
	if !c.isAllProcessed() {
		c.t.FailNow()
	}
}

func (c *lmnMessageChecker) MinimockWait(timeout time.Duration) {
	timeoutCh := time.After(timeout)
	for {
		if c.isAllProcessed() {
			return
		}
		select {
		case <-timeoutCh:
			c.MinimockFinish()
			return
		case <-time.After(10 * time.Millisecond):
		}
	}
}

type LMNChain interface {
	AddRootMessage(msg rms.BasicRecord, callback LMNResponseProducer, constraints ...LMNMsgConstraint) LMNMessage
	FindMessage(msg rms.LRegisterRequest) LMNMessage
	IsAllProcessed() bool
}

type lmnChain struct {
	objectRef rms.Reference
	root      LMNMessage
}

func NewLMNChain(objectRef rms.Reference) LMNChain {
	return &lmnChain{
		objectRef: objectRef,
	}
}

func (c *lmnChain) AddRootMessage(record rms.BasicRecord, callback LMNResponseProducer, constraints ...LMNMsgConstraint) LMNMessage {
	if c.root != nil {
		panic(throw.IllegalState())
	}
	c.root = NewLMNMessage(record, callback, constraints...)
	return c.root
}

func (c *lmnChain) FindMessage(msg rms.LRegisterRequest) LMNMessage {
	if c.root != nil {
		actualRecord, ok := RecordFromLRegisterRequest(msg).(withRefs)
		if !ok {
			panic(throw.IllegalValue())
		}
		objRef := actualRecord.GetRootRef()
		if objRef.Equal(&c.objectRef) || (!c.root.IsProcessed() && objRef.IsZero()) {
			return c.root.FindMessage(msg)
		}
	}
	return nil
}

func (c *lmnChain) IsAllProcessed() bool {
	if c.root == nil {
		return true
	}
	return c.root.IsAllProcessed()
}

type LMNMessage interface {
	AddChild(msg rms.BasicRecord, resultProducer LMNResponseProducer, constraints ...LMNMsgConstraint) LMNMessage
	FindMessage(msg rms.LRegisterRequest) LMNMessage
	ProduceResponse(msg rms.LRegisterRequest)
	Reference() rms.Reference
	IsProcessed() bool
	IsAllProcessed() bool
}

type lmnMessage struct {
	record           rms.BasicRecord
	ref              rms.Reference
	constraints      []LMNMsgConstraint
	responseProducer LMNResponseProducer
	nodes            []LMNMessage
	parent           LMNMessage
	processed        bool
}

func NewLMNMessage(record rms.BasicRecord, responseProducer LMNResponseProducer, constraints ...LMNMsgConstraint) *lmnMessage {
	return &lmnMessage{
		record:           record,
		constraints:      constraints,
		responseProducer: responseProducer,
		nodes:            make([]LMNMessage, 0),
	}
}

func (c *lmnMessage) AddChild(msg rms.BasicRecord, responseProducer LMNResponseProducer, constraints ...LMNMsgConstraint) LMNMessage {
	newMsg := NewLMNMessage(msg, responseProducer, constraints...)
	newMsg.parent = c
	c.nodes = append(c.nodes, newMsg)
	return newMsg
}

func (c *lmnMessage) checkConstraints(actualMsg rms.LRegisterRequest) error {
	actualRecord := RecordFromLRegisterRequest(actualMsg)
	if reflect.TypeOf(actualRecord) != reflect.TypeOf(c.record) {
		return throw.E("type mismatch")
	}
	if c.parent != nil {
		wr, ok := actualRecord.(withRefs)
		if !ok {
			return throw.IllegalValue()
		}
		prevRef := wr.GetPrevRef()
		parentRef := c.parent.Reference()
		if !prevRef.Equal(&parentRef) {
			return throw.E("order mismatch")
		}
	}
	for _, constraint := range c.constraints {
		if err := constraint(actualMsg); err != nil {
			return err
		}
	}
	c.processed = true
	c.ref = actualMsg.AnticipatedRef
	return nil
}

func (c *lmnMessage) ProduceResponse(msg rms.LRegisterRequest) {
	if c.responseProducer != nil {
		c.responseProducer(msg)
	}
}

func (c *lmnMessage) FindMessage(msg rms.LRegisterRequest) LMNMessage {
	if !c.processed && c.checkConstraints(msg) == nil {
		return c
	}
	for _, node := range c.nodes {
		if foundedNode := node.FindMessage(msg); foundedNode != nil {
			return foundedNode
		}
	}
	return nil
}

func (c *lmnMessage) IsAllProcessed() bool {
	if !c.processed {
		return false
	}
	for _, node := range c.nodes {
		if !node.IsAllProcessed() {
			return false
		}
	}
	return true
}

func (c *lmnMessage) Reference() rms.Reference {
	return c.ref
}

func (c *lmnMessage) IsProcessed() bool {
	return c.processed
}

type LMNMsgConstraint func(actualMsg rms.LRegisterRequest) error
type LMNResponseProducer func(message rms.LRegisterRequest)

type withRefs interface {
	GetPrevRef() rms.Reference
	GetRootRef() rms.Reference
}
