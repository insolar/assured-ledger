package network

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"crypto"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/insolar/node"
	"github.com/insolar/assured-ledger/ledger-core/network/consensus/gcpv2/api/member"
	"github.com/insolar/assured-ledger/ledger-core/network/consensus/gcpv2/api/profiles"
	"github.com/insolar/assured-ledger/ledger-core/vanilla/cryptkit"
)

// NetworkNodeMock implements nodeinfo.NetworkNode
type NetworkNodeMock struct {
	t minimock.Tester

	funcGetDeclaredPower          func() (p1 member.Power)
	inspectFuncGetDeclaredPower   func()
	afterGetDeclaredPowerCounter  uint64
	beforeGetDeclaredPowerCounter uint64
	GetDeclaredPowerMock          mNetworkNodeMockGetDeclaredPower

	funcGetNodeID          func() (s1 node.ShortNodeID)
	inspectFuncGetNodeID   func()
	afterGetNodeIDCounter  uint64
	beforeGetNodeIDCounter uint64
	GetNodeIDMock          mNetworkNodeMockGetNodeID

	funcGetSignature          func() (s1 cryptkit.SignedDigestHolder)
	inspectFuncGetSignature   func()
	afterGetSignatureCounter  uint64
	beforeGetSignatureCounter uint64
	GetSignatureMock          mNetworkNodeMockGetSignature

	funcGetStatic          func() (s1 profiles.StaticProfile)
	inspectFuncGetStatic   func()
	afterGetStaticCounter  uint64
	beforeGetStaticCounter uint64
	GetStaticMock          mNetworkNodeMockGetStatic

	funcIsJoiner          func() (b1 bool)
	inspectFuncIsJoiner   func()
	afterIsJoinerCounter  uint64
	beforeIsJoinerCounter uint64
	IsJoinerMock          mNetworkNodeMockIsJoiner

	funcIsPowered          func() (b1 bool)
	inspectFuncIsPowered   func()
	afterIsPoweredCounter  uint64
	beforeIsPoweredCounter uint64
	IsPoweredMock          mNetworkNodeMockIsPowered

	funcPublicKey          func() (p1 crypto.PublicKey)
	inspectFuncPublicKey   func()
	afterPublicKeyCounter  uint64
	beforePublicKeyCounter uint64
	PublicKeyMock          mNetworkNodeMockPublicKey
}

// NewNetworkNodeMock returns a mock for nodeinfo.NetworkNode
func NewNetworkNodeMock(t minimock.Tester) *NetworkNodeMock {
	m := &NetworkNodeMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetDeclaredPowerMock = mNetworkNodeMockGetDeclaredPower{mock: m}

	m.GetNodeIDMock = mNetworkNodeMockGetNodeID{mock: m}

	m.GetSignatureMock = mNetworkNodeMockGetSignature{mock: m}

	m.GetStaticMock = mNetworkNodeMockGetStatic{mock: m}

	m.IsJoinerMock = mNetworkNodeMockIsJoiner{mock: m}

	m.IsPoweredMock = mNetworkNodeMockIsPowered{mock: m}

	m.PublicKeyMock = mNetworkNodeMockPublicKey{mock: m}

	return m
}

type mNetworkNodeMockGetDeclaredPower struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockGetDeclaredPowerExpectation
	expectations       []*NetworkNodeMockGetDeclaredPowerExpectation
}

// NetworkNodeMockGetDeclaredPowerExpectation specifies expectation struct of the NetworkNode.GetDeclaredPower
type NetworkNodeMockGetDeclaredPowerExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockGetDeclaredPowerResults
	Counter uint64
}

// NetworkNodeMockGetDeclaredPowerResults contains results of the NetworkNode.GetDeclaredPower
type NetworkNodeMockGetDeclaredPowerResults struct {
	p1 member.Power
}

// Expect sets up expected params for NetworkNode.GetDeclaredPower
func (mmGetDeclaredPower *mNetworkNodeMockGetDeclaredPower) Expect() *mNetworkNodeMockGetDeclaredPower {
	if mmGetDeclaredPower.mock.funcGetDeclaredPower != nil {
		mmGetDeclaredPower.mock.t.Fatalf("NetworkNodeMock.GetDeclaredPower mock is already set by Set")
	}

	if mmGetDeclaredPower.defaultExpectation == nil {
		mmGetDeclaredPower.defaultExpectation = &NetworkNodeMockGetDeclaredPowerExpectation{}
	}

	return mmGetDeclaredPower
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.GetDeclaredPower
func (mmGetDeclaredPower *mNetworkNodeMockGetDeclaredPower) Inspect(f func()) *mNetworkNodeMockGetDeclaredPower {
	if mmGetDeclaredPower.mock.inspectFuncGetDeclaredPower != nil {
		mmGetDeclaredPower.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.GetDeclaredPower")
	}

	mmGetDeclaredPower.mock.inspectFuncGetDeclaredPower = f

	return mmGetDeclaredPower
}

// Return sets up results that will be returned by NetworkNode.GetDeclaredPower
func (mmGetDeclaredPower *mNetworkNodeMockGetDeclaredPower) Return(p1 member.Power) *NetworkNodeMock {
	if mmGetDeclaredPower.mock.funcGetDeclaredPower != nil {
		mmGetDeclaredPower.mock.t.Fatalf("NetworkNodeMock.GetDeclaredPower mock is already set by Set")
	}

	if mmGetDeclaredPower.defaultExpectation == nil {
		mmGetDeclaredPower.defaultExpectation = &NetworkNodeMockGetDeclaredPowerExpectation{mock: mmGetDeclaredPower.mock}
	}
	mmGetDeclaredPower.defaultExpectation.results = &NetworkNodeMockGetDeclaredPowerResults{p1}
	return mmGetDeclaredPower.mock
}

//Set uses given function f to mock the NetworkNode.GetDeclaredPower method
func (mmGetDeclaredPower *mNetworkNodeMockGetDeclaredPower) Set(f func() (p1 member.Power)) *NetworkNodeMock {
	if mmGetDeclaredPower.defaultExpectation != nil {
		mmGetDeclaredPower.mock.t.Fatalf("Default expectation is already set for the NetworkNode.GetDeclaredPower method")
	}

	if len(mmGetDeclaredPower.expectations) > 0 {
		mmGetDeclaredPower.mock.t.Fatalf("Some expectations are already set for the NetworkNode.GetDeclaredPower method")
	}

	mmGetDeclaredPower.mock.funcGetDeclaredPower = f
	return mmGetDeclaredPower.mock
}

// GetDeclaredPower implements nodeinfo.NetworkNode
func (mmGetDeclaredPower *NetworkNodeMock) GetDeclaredPower() (p1 member.Power) {
	mm_atomic.AddUint64(&mmGetDeclaredPower.beforeGetDeclaredPowerCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDeclaredPower.afterGetDeclaredPowerCounter, 1)

	if mmGetDeclaredPower.inspectFuncGetDeclaredPower != nil {
		mmGetDeclaredPower.inspectFuncGetDeclaredPower()
	}

	if mmGetDeclaredPower.GetDeclaredPowerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDeclaredPower.GetDeclaredPowerMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDeclaredPower.GetDeclaredPowerMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDeclaredPower.t.Fatal("No results are set for the NetworkNodeMock.GetDeclaredPower")
		}
		return (*mm_results).p1
	}
	if mmGetDeclaredPower.funcGetDeclaredPower != nil {
		return mmGetDeclaredPower.funcGetDeclaredPower()
	}
	mmGetDeclaredPower.t.Fatalf("Unexpected call to NetworkNodeMock.GetDeclaredPower.")
	return
}

// GetDeclaredPowerAfterCounter returns a count of finished NetworkNodeMock.GetDeclaredPower invocations
func (mmGetDeclaredPower *NetworkNodeMock) GetDeclaredPowerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDeclaredPower.afterGetDeclaredPowerCounter)
}

// GetDeclaredPowerBeforeCounter returns a count of NetworkNodeMock.GetDeclaredPower invocations
func (mmGetDeclaredPower *NetworkNodeMock) GetDeclaredPowerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDeclaredPower.beforeGetDeclaredPowerCounter)
}

// MinimockGetDeclaredPowerDone returns true if the count of the GetDeclaredPower invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockGetDeclaredPowerDone() bool {
	for _, e := range m.GetDeclaredPowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDeclaredPowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDeclaredPowerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDeclaredPower != nil && mm_atomic.LoadUint64(&m.afterGetDeclaredPowerCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDeclaredPowerInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockGetDeclaredPowerInspect() {
	for _, e := range m.GetDeclaredPowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.GetDeclaredPower")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDeclaredPowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDeclaredPowerCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetDeclaredPower")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDeclaredPower != nil && mm_atomic.LoadUint64(&m.afterGetDeclaredPowerCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetDeclaredPower")
	}
}

type mNetworkNodeMockGetNodeID struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockGetNodeIDExpectation
	expectations       []*NetworkNodeMockGetNodeIDExpectation
}

// NetworkNodeMockGetNodeIDExpectation specifies expectation struct of the NetworkNode.GetNodeID
type NetworkNodeMockGetNodeIDExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockGetNodeIDResults
	Counter uint64
}

// NetworkNodeMockGetNodeIDResults contains results of the NetworkNode.GetNodeID
type NetworkNodeMockGetNodeIDResults struct {
	s1 node.ShortNodeID
}

// Expect sets up expected params for NetworkNode.GetNodeID
func (mmGetNodeID *mNetworkNodeMockGetNodeID) Expect() *mNetworkNodeMockGetNodeID {
	if mmGetNodeID.mock.funcGetNodeID != nil {
		mmGetNodeID.mock.t.Fatalf("NetworkNodeMock.GetNodeID mock is already set by Set")
	}

	if mmGetNodeID.defaultExpectation == nil {
		mmGetNodeID.defaultExpectation = &NetworkNodeMockGetNodeIDExpectation{}
	}

	return mmGetNodeID
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.GetNodeID
func (mmGetNodeID *mNetworkNodeMockGetNodeID) Inspect(f func()) *mNetworkNodeMockGetNodeID {
	if mmGetNodeID.mock.inspectFuncGetNodeID != nil {
		mmGetNodeID.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.GetNodeID")
	}

	mmGetNodeID.mock.inspectFuncGetNodeID = f

	return mmGetNodeID
}

// Return sets up results that will be returned by NetworkNode.GetNodeID
func (mmGetNodeID *mNetworkNodeMockGetNodeID) Return(s1 node.ShortNodeID) *NetworkNodeMock {
	if mmGetNodeID.mock.funcGetNodeID != nil {
		mmGetNodeID.mock.t.Fatalf("NetworkNodeMock.GetNodeID mock is already set by Set")
	}

	if mmGetNodeID.defaultExpectation == nil {
		mmGetNodeID.defaultExpectation = &NetworkNodeMockGetNodeIDExpectation{mock: mmGetNodeID.mock}
	}
	mmGetNodeID.defaultExpectation.results = &NetworkNodeMockGetNodeIDResults{s1}
	return mmGetNodeID.mock
}

//Set uses given function f to mock the NetworkNode.GetNodeID method
func (mmGetNodeID *mNetworkNodeMockGetNodeID) Set(f func() (s1 node.ShortNodeID)) *NetworkNodeMock {
	if mmGetNodeID.defaultExpectation != nil {
		mmGetNodeID.mock.t.Fatalf("Default expectation is already set for the NetworkNode.GetNodeID method")
	}

	if len(mmGetNodeID.expectations) > 0 {
		mmGetNodeID.mock.t.Fatalf("Some expectations are already set for the NetworkNode.GetNodeID method")
	}

	mmGetNodeID.mock.funcGetNodeID = f
	return mmGetNodeID.mock
}

// GetNodeID implements nodeinfo.NetworkNode
func (mmGetNodeID *NetworkNodeMock) GetNodeID() (s1 node.ShortNodeID) {
	mm_atomic.AddUint64(&mmGetNodeID.beforeGetNodeIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNodeID.afterGetNodeIDCounter, 1)

	if mmGetNodeID.inspectFuncGetNodeID != nil {
		mmGetNodeID.inspectFuncGetNodeID()
	}

	if mmGetNodeID.GetNodeIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNodeID.GetNodeIDMock.defaultExpectation.Counter, 1)

		mm_results := mmGetNodeID.GetNodeIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNodeID.t.Fatal("No results are set for the NetworkNodeMock.GetNodeID")
		}
		return (*mm_results).s1
	}
	if mmGetNodeID.funcGetNodeID != nil {
		return mmGetNodeID.funcGetNodeID()
	}
	mmGetNodeID.t.Fatalf("Unexpected call to NetworkNodeMock.GetNodeID.")
	return
}

// GetNodeIDAfterCounter returns a count of finished NetworkNodeMock.GetNodeID invocations
func (mmGetNodeID *NetworkNodeMock) GetNodeIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNodeID.afterGetNodeIDCounter)
}

// GetNodeIDBeforeCounter returns a count of NetworkNodeMock.GetNodeID invocations
func (mmGetNodeID *NetworkNodeMock) GetNodeIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNodeID.beforeGetNodeIDCounter)
}

// MinimockGetNodeIDDone returns true if the count of the GetNodeID invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockGetNodeIDDone() bool {
	for _, e := range m.GetNodeIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNodeIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNodeID != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetNodeIDInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockGetNodeIDInspect() {
	for _, e := range m.GetNodeIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.GetNodeID")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNodeIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetNodeID")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNodeID != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetNodeID")
	}
}

type mNetworkNodeMockGetSignature struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockGetSignatureExpectation
	expectations       []*NetworkNodeMockGetSignatureExpectation
}

// NetworkNodeMockGetSignatureExpectation specifies expectation struct of the NetworkNode.GetSignature
type NetworkNodeMockGetSignatureExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockGetSignatureResults
	Counter uint64
}

// NetworkNodeMockGetSignatureResults contains results of the NetworkNode.GetSignature
type NetworkNodeMockGetSignatureResults struct {
	s1 cryptkit.SignedDigestHolder
}

// Expect sets up expected params for NetworkNode.GetSignature
func (mmGetSignature *mNetworkNodeMockGetSignature) Expect() *mNetworkNodeMockGetSignature {
	if mmGetSignature.mock.funcGetSignature != nil {
		mmGetSignature.mock.t.Fatalf("NetworkNodeMock.GetSignature mock is already set by Set")
	}

	if mmGetSignature.defaultExpectation == nil {
		mmGetSignature.defaultExpectation = &NetworkNodeMockGetSignatureExpectation{}
	}

	return mmGetSignature
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.GetSignature
func (mmGetSignature *mNetworkNodeMockGetSignature) Inspect(f func()) *mNetworkNodeMockGetSignature {
	if mmGetSignature.mock.inspectFuncGetSignature != nil {
		mmGetSignature.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.GetSignature")
	}

	mmGetSignature.mock.inspectFuncGetSignature = f

	return mmGetSignature
}

// Return sets up results that will be returned by NetworkNode.GetSignature
func (mmGetSignature *mNetworkNodeMockGetSignature) Return(s1 cryptkit.SignedDigestHolder) *NetworkNodeMock {
	if mmGetSignature.mock.funcGetSignature != nil {
		mmGetSignature.mock.t.Fatalf("NetworkNodeMock.GetSignature mock is already set by Set")
	}

	if mmGetSignature.defaultExpectation == nil {
		mmGetSignature.defaultExpectation = &NetworkNodeMockGetSignatureExpectation{mock: mmGetSignature.mock}
	}
	mmGetSignature.defaultExpectation.results = &NetworkNodeMockGetSignatureResults{s1}
	return mmGetSignature.mock
}

//Set uses given function f to mock the NetworkNode.GetSignature method
func (mmGetSignature *mNetworkNodeMockGetSignature) Set(f func() (s1 cryptkit.SignedDigestHolder)) *NetworkNodeMock {
	if mmGetSignature.defaultExpectation != nil {
		mmGetSignature.mock.t.Fatalf("Default expectation is already set for the NetworkNode.GetSignature method")
	}

	if len(mmGetSignature.expectations) > 0 {
		mmGetSignature.mock.t.Fatalf("Some expectations are already set for the NetworkNode.GetSignature method")
	}

	mmGetSignature.mock.funcGetSignature = f
	return mmGetSignature.mock
}

// GetSignature implements nodeinfo.NetworkNode
func (mmGetSignature *NetworkNodeMock) GetSignature() (s1 cryptkit.SignedDigestHolder) {
	mm_atomic.AddUint64(&mmGetSignature.beforeGetSignatureCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSignature.afterGetSignatureCounter, 1)

	if mmGetSignature.inspectFuncGetSignature != nil {
		mmGetSignature.inspectFuncGetSignature()
	}

	if mmGetSignature.GetSignatureMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSignature.GetSignatureMock.defaultExpectation.Counter, 1)

		mm_results := mmGetSignature.GetSignatureMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSignature.t.Fatal("No results are set for the NetworkNodeMock.GetSignature")
		}
		return (*mm_results).s1
	}
	if mmGetSignature.funcGetSignature != nil {
		return mmGetSignature.funcGetSignature()
	}
	mmGetSignature.t.Fatalf("Unexpected call to NetworkNodeMock.GetSignature.")
	return
}

// GetSignatureAfterCounter returns a count of finished NetworkNodeMock.GetSignature invocations
func (mmGetSignature *NetworkNodeMock) GetSignatureAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignature.afterGetSignatureCounter)
}

// GetSignatureBeforeCounter returns a count of NetworkNodeMock.GetSignature invocations
func (mmGetSignature *NetworkNodeMock) GetSignatureBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignature.beforeGetSignatureCounter)
}

// MinimockGetSignatureDone returns true if the count of the GetSignature invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockGetSignatureDone() bool {
	for _, e := range m.GetSignatureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignature != nil && mm_atomic.LoadUint64(&m.afterGetSignatureCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSignatureInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockGetSignatureInspect() {
	for _, e := range m.GetSignatureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.GetSignature")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetSignature")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignature != nil && mm_atomic.LoadUint64(&m.afterGetSignatureCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetSignature")
	}
}

type mNetworkNodeMockGetStatic struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockGetStaticExpectation
	expectations       []*NetworkNodeMockGetStaticExpectation
}

// NetworkNodeMockGetStaticExpectation specifies expectation struct of the NetworkNode.GetStatic
type NetworkNodeMockGetStaticExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockGetStaticResults
	Counter uint64
}

// NetworkNodeMockGetStaticResults contains results of the NetworkNode.GetStatic
type NetworkNodeMockGetStaticResults struct {
	s1 profiles.StaticProfile
}

// Expect sets up expected params for NetworkNode.GetStatic
func (mmGetStatic *mNetworkNodeMockGetStatic) Expect() *mNetworkNodeMockGetStatic {
	if mmGetStatic.mock.funcGetStatic != nil {
		mmGetStatic.mock.t.Fatalf("NetworkNodeMock.GetStatic mock is already set by Set")
	}

	if mmGetStatic.defaultExpectation == nil {
		mmGetStatic.defaultExpectation = &NetworkNodeMockGetStaticExpectation{}
	}

	return mmGetStatic
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.GetStatic
func (mmGetStatic *mNetworkNodeMockGetStatic) Inspect(f func()) *mNetworkNodeMockGetStatic {
	if mmGetStatic.mock.inspectFuncGetStatic != nil {
		mmGetStatic.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.GetStatic")
	}

	mmGetStatic.mock.inspectFuncGetStatic = f

	return mmGetStatic
}

// Return sets up results that will be returned by NetworkNode.GetStatic
func (mmGetStatic *mNetworkNodeMockGetStatic) Return(s1 profiles.StaticProfile) *NetworkNodeMock {
	if mmGetStatic.mock.funcGetStatic != nil {
		mmGetStatic.mock.t.Fatalf("NetworkNodeMock.GetStatic mock is already set by Set")
	}

	if mmGetStatic.defaultExpectation == nil {
		mmGetStatic.defaultExpectation = &NetworkNodeMockGetStaticExpectation{mock: mmGetStatic.mock}
	}
	mmGetStatic.defaultExpectation.results = &NetworkNodeMockGetStaticResults{s1}
	return mmGetStatic.mock
}

//Set uses given function f to mock the NetworkNode.GetStatic method
func (mmGetStatic *mNetworkNodeMockGetStatic) Set(f func() (s1 profiles.StaticProfile)) *NetworkNodeMock {
	if mmGetStatic.defaultExpectation != nil {
		mmGetStatic.mock.t.Fatalf("Default expectation is already set for the NetworkNode.GetStatic method")
	}

	if len(mmGetStatic.expectations) > 0 {
		mmGetStatic.mock.t.Fatalf("Some expectations are already set for the NetworkNode.GetStatic method")
	}

	mmGetStatic.mock.funcGetStatic = f
	return mmGetStatic.mock
}

// GetStatic implements nodeinfo.NetworkNode
func (mmGetStatic *NetworkNodeMock) GetStatic() (s1 profiles.StaticProfile) {
	mm_atomic.AddUint64(&mmGetStatic.beforeGetStaticCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStatic.afterGetStaticCounter, 1)

	if mmGetStatic.inspectFuncGetStatic != nil {
		mmGetStatic.inspectFuncGetStatic()
	}

	if mmGetStatic.GetStaticMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStatic.GetStaticMock.defaultExpectation.Counter, 1)

		mm_results := mmGetStatic.GetStaticMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStatic.t.Fatal("No results are set for the NetworkNodeMock.GetStatic")
		}
		return (*mm_results).s1
	}
	if mmGetStatic.funcGetStatic != nil {
		return mmGetStatic.funcGetStatic()
	}
	mmGetStatic.t.Fatalf("Unexpected call to NetworkNodeMock.GetStatic.")
	return
}

// GetStaticAfterCounter returns a count of finished NetworkNodeMock.GetStatic invocations
func (mmGetStatic *NetworkNodeMock) GetStaticAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStatic.afterGetStaticCounter)
}

// GetStaticBeforeCounter returns a count of NetworkNodeMock.GetStatic invocations
func (mmGetStatic *NetworkNodeMock) GetStaticBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStatic.beforeGetStaticCounter)
}

// MinimockGetStaticDone returns true if the count of the GetStatic invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockGetStaticDone() bool {
	for _, e := range m.GetStaticMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStaticMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStatic != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetStaticInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockGetStaticInspect() {
	for _, e := range m.GetStaticMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.GetStatic")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStaticMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetStatic")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStatic != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetStatic")
	}
}

type mNetworkNodeMockIsJoiner struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockIsJoinerExpectation
	expectations       []*NetworkNodeMockIsJoinerExpectation
}

// NetworkNodeMockIsJoinerExpectation specifies expectation struct of the NetworkNode.IsJoiner
type NetworkNodeMockIsJoinerExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockIsJoinerResults
	Counter uint64
}

// NetworkNodeMockIsJoinerResults contains results of the NetworkNode.IsJoiner
type NetworkNodeMockIsJoinerResults struct {
	b1 bool
}

// Expect sets up expected params for NetworkNode.IsJoiner
func (mmIsJoiner *mNetworkNodeMockIsJoiner) Expect() *mNetworkNodeMockIsJoiner {
	if mmIsJoiner.mock.funcIsJoiner != nil {
		mmIsJoiner.mock.t.Fatalf("NetworkNodeMock.IsJoiner mock is already set by Set")
	}

	if mmIsJoiner.defaultExpectation == nil {
		mmIsJoiner.defaultExpectation = &NetworkNodeMockIsJoinerExpectation{}
	}

	return mmIsJoiner
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.IsJoiner
func (mmIsJoiner *mNetworkNodeMockIsJoiner) Inspect(f func()) *mNetworkNodeMockIsJoiner {
	if mmIsJoiner.mock.inspectFuncIsJoiner != nil {
		mmIsJoiner.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.IsJoiner")
	}

	mmIsJoiner.mock.inspectFuncIsJoiner = f

	return mmIsJoiner
}

// Return sets up results that will be returned by NetworkNode.IsJoiner
func (mmIsJoiner *mNetworkNodeMockIsJoiner) Return(b1 bool) *NetworkNodeMock {
	if mmIsJoiner.mock.funcIsJoiner != nil {
		mmIsJoiner.mock.t.Fatalf("NetworkNodeMock.IsJoiner mock is already set by Set")
	}

	if mmIsJoiner.defaultExpectation == nil {
		mmIsJoiner.defaultExpectation = &NetworkNodeMockIsJoinerExpectation{mock: mmIsJoiner.mock}
	}
	mmIsJoiner.defaultExpectation.results = &NetworkNodeMockIsJoinerResults{b1}
	return mmIsJoiner.mock
}

//Set uses given function f to mock the NetworkNode.IsJoiner method
func (mmIsJoiner *mNetworkNodeMockIsJoiner) Set(f func() (b1 bool)) *NetworkNodeMock {
	if mmIsJoiner.defaultExpectation != nil {
		mmIsJoiner.mock.t.Fatalf("Default expectation is already set for the NetworkNode.IsJoiner method")
	}

	if len(mmIsJoiner.expectations) > 0 {
		mmIsJoiner.mock.t.Fatalf("Some expectations are already set for the NetworkNode.IsJoiner method")
	}

	mmIsJoiner.mock.funcIsJoiner = f
	return mmIsJoiner.mock
}

// IsJoiner implements nodeinfo.NetworkNode
func (mmIsJoiner *NetworkNodeMock) IsJoiner() (b1 bool) {
	mm_atomic.AddUint64(&mmIsJoiner.beforeIsJoinerCounter, 1)
	defer mm_atomic.AddUint64(&mmIsJoiner.afterIsJoinerCounter, 1)

	if mmIsJoiner.inspectFuncIsJoiner != nil {
		mmIsJoiner.inspectFuncIsJoiner()
	}

	if mmIsJoiner.IsJoinerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsJoiner.IsJoinerMock.defaultExpectation.Counter, 1)

		mm_results := mmIsJoiner.IsJoinerMock.defaultExpectation.results
		if mm_results == nil {
			mmIsJoiner.t.Fatal("No results are set for the NetworkNodeMock.IsJoiner")
		}
		return (*mm_results).b1
	}
	if mmIsJoiner.funcIsJoiner != nil {
		return mmIsJoiner.funcIsJoiner()
	}
	mmIsJoiner.t.Fatalf("Unexpected call to NetworkNodeMock.IsJoiner.")
	return
}

// IsJoinerAfterCounter returns a count of finished NetworkNodeMock.IsJoiner invocations
func (mmIsJoiner *NetworkNodeMock) IsJoinerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsJoiner.afterIsJoinerCounter)
}

// IsJoinerBeforeCounter returns a count of NetworkNodeMock.IsJoiner invocations
func (mmIsJoiner *NetworkNodeMock) IsJoinerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsJoiner.beforeIsJoinerCounter)
}

// MinimockIsJoinerDone returns true if the count of the IsJoiner invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockIsJoinerDone() bool {
	for _, e := range m.IsJoinerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsJoinerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsJoiner != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsJoinerInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockIsJoinerInspect() {
	for _, e := range m.IsJoinerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.IsJoiner")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsJoinerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.IsJoiner")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsJoiner != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.IsJoiner")
	}
}

type mNetworkNodeMockIsPowered struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockIsPoweredExpectation
	expectations       []*NetworkNodeMockIsPoweredExpectation
}

// NetworkNodeMockIsPoweredExpectation specifies expectation struct of the NetworkNode.IsPowered
type NetworkNodeMockIsPoweredExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockIsPoweredResults
	Counter uint64
}

// NetworkNodeMockIsPoweredResults contains results of the NetworkNode.IsPowered
type NetworkNodeMockIsPoweredResults struct {
	b1 bool
}

// Expect sets up expected params for NetworkNode.IsPowered
func (mmIsPowered *mNetworkNodeMockIsPowered) Expect() *mNetworkNodeMockIsPowered {
	if mmIsPowered.mock.funcIsPowered != nil {
		mmIsPowered.mock.t.Fatalf("NetworkNodeMock.IsPowered mock is already set by Set")
	}

	if mmIsPowered.defaultExpectation == nil {
		mmIsPowered.defaultExpectation = &NetworkNodeMockIsPoweredExpectation{}
	}

	return mmIsPowered
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.IsPowered
func (mmIsPowered *mNetworkNodeMockIsPowered) Inspect(f func()) *mNetworkNodeMockIsPowered {
	if mmIsPowered.mock.inspectFuncIsPowered != nil {
		mmIsPowered.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.IsPowered")
	}

	mmIsPowered.mock.inspectFuncIsPowered = f

	return mmIsPowered
}

// Return sets up results that will be returned by NetworkNode.IsPowered
func (mmIsPowered *mNetworkNodeMockIsPowered) Return(b1 bool) *NetworkNodeMock {
	if mmIsPowered.mock.funcIsPowered != nil {
		mmIsPowered.mock.t.Fatalf("NetworkNodeMock.IsPowered mock is already set by Set")
	}

	if mmIsPowered.defaultExpectation == nil {
		mmIsPowered.defaultExpectation = &NetworkNodeMockIsPoweredExpectation{mock: mmIsPowered.mock}
	}
	mmIsPowered.defaultExpectation.results = &NetworkNodeMockIsPoweredResults{b1}
	return mmIsPowered.mock
}

//Set uses given function f to mock the NetworkNode.IsPowered method
func (mmIsPowered *mNetworkNodeMockIsPowered) Set(f func() (b1 bool)) *NetworkNodeMock {
	if mmIsPowered.defaultExpectation != nil {
		mmIsPowered.mock.t.Fatalf("Default expectation is already set for the NetworkNode.IsPowered method")
	}

	if len(mmIsPowered.expectations) > 0 {
		mmIsPowered.mock.t.Fatalf("Some expectations are already set for the NetworkNode.IsPowered method")
	}

	mmIsPowered.mock.funcIsPowered = f
	return mmIsPowered.mock
}

// IsPowered implements nodeinfo.NetworkNode
func (mmIsPowered *NetworkNodeMock) IsPowered() (b1 bool) {
	mm_atomic.AddUint64(&mmIsPowered.beforeIsPoweredCounter, 1)
	defer mm_atomic.AddUint64(&mmIsPowered.afterIsPoweredCounter, 1)

	if mmIsPowered.inspectFuncIsPowered != nil {
		mmIsPowered.inspectFuncIsPowered()
	}

	if mmIsPowered.IsPoweredMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsPowered.IsPoweredMock.defaultExpectation.Counter, 1)

		mm_results := mmIsPowered.IsPoweredMock.defaultExpectation.results
		if mm_results == nil {
			mmIsPowered.t.Fatal("No results are set for the NetworkNodeMock.IsPowered")
		}
		return (*mm_results).b1
	}
	if mmIsPowered.funcIsPowered != nil {
		return mmIsPowered.funcIsPowered()
	}
	mmIsPowered.t.Fatalf("Unexpected call to NetworkNodeMock.IsPowered.")
	return
}

// IsPoweredAfterCounter returns a count of finished NetworkNodeMock.IsPowered invocations
func (mmIsPowered *NetworkNodeMock) IsPoweredAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsPowered.afterIsPoweredCounter)
}

// IsPoweredBeforeCounter returns a count of NetworkNodeMock.IsPowered invocations
func (mmIsPowered *NetworkNodeMock) IsPoweredBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsPowered.beforeIsPoweredCounter)
}

// MinimockIsPoweredDone returns true if the count of the IsPowered invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockIsPoweredDone() bool {
	for _, e := range m.IsPoweredMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsPoweredMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsPoweredCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsPowered != nil && mm_atomic.LoadUint64(&m.afterIsPoweredCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsPoweredInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockIsPoweredInspect() {
	for _, e := range m.IsPoweredMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.IsPowered")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsPoweredMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsPoweredCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.IsPowered")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsPowered != nil && mm_atomic.LoadUint64(&m.afterIsPoweredCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.IsPowered")
	}
}

type mNetworkNodeMockPublicKey struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockPublicKeyExpectation
	expectations       []*NetworkNodeMockPublicKeyExpectation
}

// NetworkNodeMockPublicKeyExpectation specifies expectation struct of the NetworkNode.PublicKey
type NetworkNodeMockPublicKeyExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockPublicKeyResults
	Counter uint64
}

// NetworkNodeMockPublicKeyResults contains results of the NetworkNode.PublicKey
type NetworkNodeMockPublicKeyResults struct {
	p1 crypto.PublicKey
}

// Expect sets up expected params for NetworkNode.PublicKey
func (mmPublicKey *mNetworkNodeMockPublicKey) Expect() *mNetworkNodeMockPublicKey {
	if mmPublicKey.mock.funcPublicKey != nil {
		mmPublicKey.mock.t.Fatalf("NetworkNodeMock.PublicKey mock is already set by Set")
	}

	if mmPublicKey.defaultExpectation == nil {
		mmPublicKey.defaultExpectation = &NetworkNodeMockPublicKeyExpectation{}
	}

	return mmPublicKey
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.PublicKey
func (mmPublicKey *mNetworkNodeMockPublicKey) Inspect(f func()) *mNetworkNodeMockPublicKey {
	if mmPublicKey.mock.inspectFuncPublicKey != nil {
		mmPublicKey.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.PublicKey")
	}

	mmPublicKey.mock.inspectFuncPublicKey = f

	return mmPublicKey
}

// Return sets up results that will be returned by NetworkNode.PublicKey
func (mmPublicKey *mNetworkNodeMockPublicKey) Return(p1 crypto.PublicKey) *NetworkNodeMock {
	if mmPublicKey.mock.funcPublicKey != nil {
		mmPublicKey.mock.t.Fatalf("NetworkNodeMock.PublicKey mock is already set by Set")
	}

	if mmPublicKey.defaultExpectation == nil {
		mmPublicKey.defaultExpectation = &NetworkNodeMockPublicKeyExpectation{mock: mmPublicKey.mock}
	}
	mmPublicKey.defaultExpectation.results = &NetworkNodeMockPublicKeyResults{p1}
	return mmPublicKey.mock
}

//Set uses given function f to mock the NetworkNode.PublicKey method
func (mmPublicKey *mNetworkNodeMockPublicKey) Set(f func() (p1 crypto.PublicKey)) *NetworkNodeMock {
	if mmPublicKey.defaultExpectation != nil {
		mmPublicKey.mock.t.Fatalf("Default expectation is already set for the NetworkNode.PublicKey method")
	}

	if len(mmPublicKey.expectations) > 0 {
		mmPublicKey.mock.t.Fatalf("Some expectations are already set for the NetworkNode.PublicKey method")
	}

	mmPublicKey.mock.funcPublicKey = f
	return mmPublicKey.mock
}

// PublicKey implements nodeinfo.NetworkNode
func (mmPublicKey *NetworkNodeMock) PublicKey() (p1 crypto.PublicKey) {
	mm_atomic.AddUint64(&mmPublicKey.beforePublicKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmPublicKey.afterPublicKeyCounter, 1)

	if mmPublicKey.inspectFuncPublicKey != nil {
		mmPublicKey.inspectFuncPublicKey()
	}

	if mmPublicKey.PublicKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublicKey.PublicKeyMock.defaultExpectation.Counter, 1)

		mm_results := mmPublicKey.PublicKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmPublicKey.t.Fatal("No results are set for the NetworkNodeMock.PublicKey")
		}
		return (*mm_results).p1
	}
	if mmPublicKey.funcPublicKey != nil {
		return mmPublicKey.funcPublicKey()
	}
	mmPublicKey.t.Fatalf("Unexpected call to NetworkNodeMock.PublicKey.")
	return
}

// PublicKeyAfterCounter returns a count of finished NetworkNodeMock.PublicKey invocations
func (mmPublicKey *NetworkNodeMock) PublicKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublicKey.afterPublicKeyCounter)
}

// PublicKeyBeforeCounter returns a count of NetworkNodeMock.PublicKey invocations
func (mmPublicKey *NetworkNodeMock) PublicKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublicKey.beforePublicKeyCounter)
}

// MinimockPublicKeyDone returns true if the count of the PublicKey invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockPublicKeyDone() bool {
	for _, e := range m.PublicKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublicKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublicKeyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublicKey != nil && mm_atomic.LoadUint64(&m.afterPublicKeyCounter) < 1 {
		return false
	}
	return true
}

// MinimockPublicKeyInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockPublicKeyInspect() {
	for _, e := range m.PublicKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.PublicKey")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublicKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublicKeyCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.PublicKey")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublicKey != nil && mm_atomic.LoadUint64(&m.afterPublicKeyCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.PublicKey")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *NetworkNodeMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetDeclaredPowerInspect()

		m.MinimockGetNodeIDInspect()

		m.MinimockGetSignatureInspect()

		m.MinimockGetStaticInspect()

		m.MinimockIsJoinerInspect()

		m.MinimockIsPoweredInspect()

		m.MinimockPublicKeyInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *NetworkNodeMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *NetworkNodeMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetDeclaredPowerDone() &&
		m.MinimockGetNodeIDDone() &&
		m.MinimockGetSignatureDone() &&
		m.MinimockGetStaticDone() &&
		m.MinimockIsJoinerDone() &&
		m.MinimockIsPoweredDone() &&
		m.MinimockPublicKeyDone()
}
