package network

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"crypto"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/insolar/node"
	"github.com/insolar/assured-ledger/ledger-core/network/consensus/gcpv2/api/member"
	"github.com/insolar/assured-ledger/ledger-core/network/consensus/gcpv2/api/profiles"
	"github.com/insolar/assured-ledger/ledger-core/reference"
	"github.com/insolar/assured-ledger/ledger-core/vanilla/cryptkit"
)

// NetworkNodeMock implements nodeinfo.NetworkNode
type NetworkNodeMock struct {
	t minimock.Tester

	funcAddress          func() (s1 string)
	inspectFuncAddress   func()
	afterAddressCounter  uint64
	beforeAddressCounter uint64
	AddressMock          mNetworkNodeMockAddress

	funcGetNodeID          func() (s1 node.ShortNodeID)
	inspectFuncGetNodeID   func()
	afterGetNodeIDCounter  uint64
	beforeGetNodeIDCounter uint64
	GetNodeIDMock          mNetworkNodeMockGetNodeID

	funcGetPower          func() (p1 member.Power)
	inspectFuncGetPower   func()
	afterGetPowerCounter  uint64
	beforeGetPowerCounter uint64
	GetPowerMock          mNetworkNodeMockGetPower

	funcGetPrimaryRole          func() (p1 member.PrimaryRole)
	inspectFuncGetPrimaryRole   func()
	afterGetPrimaryRoleCounter  uint64
	beforeGetPrimaryRoleCounter uint64
	GetPrimaryRoleMock          mNetworkNodeMockGetPrimaryRole

	funcGetReference          func() (g1 reference.Global)
	inspectFuncGetReference   func()
	afterGetReferenceCounter  uint64
	beforeGetReferenceCounter uint64
	GetReferenceMock          mNetworkNodeMockGetReference

	funcGetSignature          func() (s1 cryptkit.SignedDigestHolder)
	inspectFuncGetSignature   func()
	afterGetSignatureCounter  uint64
	beforeGetSignatureCounter uint64
	GetSignatureMock          mNetworkNodeMockGetSignature

	funcGetStatic          func() (s1 profiles.StaticProfile)
	inspectFuncGetStatic   func()
	afterGetStaticCounter  uint64
	beforeGetStaticCounter uint64
	GetStaticMock          mNetworkNodeMockGetStatic

	funcIsJoiner          func() (b1 bool)
	inspectFuncIsJoiner   func()
	afterIsJoinerCounter  uint64
	beforeIsJoinerCounter uint64
	IsJoinerMock          mNetworkNodeMockIsJoiner

	funcIsPowered          func() (b1 bool)
	inspectFuncIsPowered   func()
	afterIsPoweredCounter  uint64
	beforeIsPoweredCounter uint64
	IsPoweredMock          mNetworkNodeMockIsPowered

	funcPublicKey          func() (p1 crypto.PublicKey)
	inspectFuncPublicKey   func()
	afterPublicKeyCounter  uint64
	beforePublicKeyCounter uint64
	PublicKeyMock          mNetworkNodeMockPublicKey
}

// NewNetworkNodeMock returns a mock for nodeinfo.NetworkNode
func NewNetworkNodeMock(t minimock.Tester) *NetworkNodeMock {
	m := &NetworkNodeMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddressMock = mNetworkNodeMockAddress{mock: m}

	m.GetNodeIDMock = mNetworkNodeMockGetNodeID{mock: m}

	m.GetPowerMock = mNetworkNodeMockGetPower{mock: m}

	m.GetPrimaryRoleMock = mNetworkNodeMockGetPrimaryRole{mock: m}

	m.GetReferenceMock = mNetworkNodeMockGetReference{mock: m}

	m.GetSignatureMock = mNetworkNodeMockGetSignature{mock: m}

	m.GetStaticMock = mNetworkNodeMockGetStatic{mock: m}

	m.IsJoinerMock = mNetworkNodeMockIsJoiner{mock: m}

	m.IsPoweredMock = mNetworkNodeMockIsPowered{mock: m}

	m.PublicKeyMock = mNetworkNodeMockPublicKey{mock: m}

	return m
}

type mNetworkNodeMockAddress struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockAddressExpectation
	expectations       []*NetworkNodeMockAddressExpectation
}

// NetworkNodeMockAddressExpectation specifies expectation struct of the NetworkNode.Address
type NetworkNodeMockAddressExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockAddressResults
	Counter uint64
}

// NetworkNodeMockAddressResults contains results of the NetworkNode.Address
type NetworkNodeMockAddressResults struct {
	s1 string
}

// Expect sets up expected params for NetworkNode.Address
func (mmAddress *mNetworkNodeMockAddress) Expect() *mNetworkNodeMockAddress {
	if mmAddress.mock.funcAddress != nil {
		mmAddress.mock.t.Fatalf("NetworkNodeMock.Address mock is already set by Set")
	}

	if mmAddress.defaultExpectation == nil {
		mmAddress.defaultExpectation = &NetworkNodeMockAddressExpectation{}
	}

	return mmAddress
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.Address
func (mmAddress *mNetworkNodeMockAddress) Inspect(f func()) *mNetworkNodeMockAddress {
	if mmAddress.mock.inspectFuncAddress != nil {
		mmAddress.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.Address")
	}

	mmAddress.mock.inspectFuncAddress = f

	return mmAddress
}

// Return sets up results that will be returned by NetworkNode.Address
func (mmAddress *mNetworkNodeMockAddress) Return(s1 string) *NetworkNodeMock {
	if mmAddress.mock.funcAddress != nil {
		mmAddress.mock.t.Fatalf("NetworkNodeMock.Address mock is already set by Set")
	}

	if mmAddress.defaultExpectation == nil {
		mmAddress.defaultExpectation = &NetworkNodeMockAddressExpectation{mock: mmAddress.mock}
	}
	mmAddress.defaultExpectation.results = &NetworkNodeMockAddressResults{s1}
	return mmAddress.mock
}

//Set uses given function f to mock the NetworkNode.Address method
func (mmAddress *mNetworkNodeMockAddress) Set(f func() (s1 string)) *NetworkNodeMock {
	if mmAddress.defaultExpectation != nil {
		mmAddress.mock.t.Fatalf("Default expectation is already set for the NetworkNode.Address method")
	}

	if len(mmAddress.expectations) > 0 {
		mmAddress.mock.t.Fatalf("Some expectations are already set for the NetworkNode.Address method")
	}

	mmAddress.mock.funcAddress = f
	return mmAddress.mock
}

// Address implements nodeinfo.NetworkNode
func (mmAddress *NetworkNodeMock) Address() (s1 string) {
	mm_atomic.AddUint64(&mmAddress.beforeAddressCounter, 1)
	defer mm_atomic.AddUint64(&mmAddress.afterAddressCounter, 1)

	if mmAddress.inspectFuncAddress != nil {
		mmAddress.inspectFuncAddress()
	}

	if mmAddress.AddressMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddress.AddressMock.defaultExpectation.Counter, 1)

		mm_results := mmAddress.AddressMock.defaultExpectation.results
		if mm_results == nil {
			mmAddress.t.Fatal("No results are set for the NetworkNodeMock.Address")
		}
		return (*mm_results).s1
	}
	if mmAddress.funcAddress != nil {
		return mmAddress.funcAddress()
	}
	mmAddress.t.Fatalf("Unexpected call to NetworkNodeMock.Address.")
	return
}

// AddressAfterCounter returns a count of finished NetworkNodeMock.Address invocations
func (mmAddress *NetworkNodeMock) AddressAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddress.afterAddressCounter)
}

// AddressBeforeCounter returns a count of NetworkNodeMock.Address invocations
func (mmAddress *NetworkNodeMock) AddressBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddress.beforeAddressCounter)
}

// MinimockAddressDone returns true if the count of the Address invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockAddressDone() bool {
	for _, e := range m.AddressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddressMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddressCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddress != nil && mm_atomic.LoadUint64(&m.afterAddressCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddressInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockAddressInspect() {
	for _, e := range m.AddressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.Address")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddressMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddressCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.Address")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddress != nil && mm_atomic.LoadUint64(&m.afterAddressCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.Address")
	}
}

type mNetworkNodeMockGetNodeID struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockGetNodeIDExpectation
	expectations       []*NetworkNodeMockGetNodeIDExpectation
}

// NetworkNodeMockGetNodeIDExpectation specifies expectation struct of the NetworkNode.GetNodeID
type NetworkNodeMockGetNodeIDExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockGetNodeIDResults
	Counter uint64
}

// NetworkNodeMockGetNodeIDResults contains results of the NetworkNode.GetNodeID
type NetworkNodeMockGetNodeIDResults struct {
	s1 node.ShortNodeID
}

// Expect sets up expected params for NetworkNode.GetNodeID
func (mmGetNodeID *mNetworkNodeMockGetNodeID) Expect() *mNetworkNodeMockGetNodeID {
	if mmGetNodeID.mock.funcGetNodeID != nil {
		mmGetNodeID.mock.t.Fatalf("NetworkNodeMock.GetNodeID mock is already set by Set")
	}

	if mmGetNodeID.defaultExpectation == nil {
		mmGetNodeID.defaultExpectation = &NetworkNodeMockGetNodeIDExpectation{}
	}

	return mmGetNodeID
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.GetNodeID
func (mmGetNodeID *mNetworkNodeMockGetNodeID) Inspect(f func()) *mNetworkNodeMockGetNodeID {
	if mmGetNodeID.mock.inspectFuncGetNodeID != nil {
		mmGetNodeID.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.GetNodeID")
	}

	mmGetNodeID.mock.inspectFuncGetNodeID = f

	return mmGetNodeID
}

// Return sets up results that will be returned by NetworkNode.GetNodeID
func (mmGetNodeID *mNetworkNodeMockGetNodeID) Return(s1 node.ShortNodeID) *NetworkNodeMock {
	if mmGetNodeID.mock.funcGetNodeID != nil {
		mmGetNodeID.mock.t.Fatalf("NetworkNodeMock.GetNodeID mock is already set by Set")
	}

	if mmGetNodeID.defaultExpectation == nil {
		mmGetNodeID.defaultExpectation = &NetworkNodeMockGetNodeIDExpectation{mock: mmGetNodeID.mock}
	}
	mmGetNodeID.defaultExpectation.results = &NetworkNodeMockGetNodeIDResults{s1}
	return mmGetNodeID.mock
}

//Set uses given function f to mock the NetworkNode.GetNodeID method
func (mmGetNodeID *mNetworkNodeMockGetNodeID) Set(f func() (s1 node.ShortNodeID)) *NetworkNodeMock {
	if mmGetNodeID.defaultExpectation != nil {
		mmGetNodeID.mock.t.Fatalf("Default expectation is already set for the NetworkNode.GetNodeID method")
	}

	if len(mmGetNodeID.expectations) > 0 {
		mmGetNodeID.mock.t.Fatalf("Some expectations are already set for the NetworkNode.GetNodeID method")
	}

	mmGetNodeID.mock.funcGetNodeID = f
	return mmGetNodeID.mock
}

// GetNodeID implements nodeinfo.NetworkNode
func (mmGetNodeID *NetworkNodeMock) GetNodeID() (s1 node.ShortNodeID) {
	mm_atomic.AddUint64(&mmGetNodeID.beforeGetNodeIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNodeID.afterGetNodeIDCounter, 1)

	if mmGetNodeID.inspectFuncGetNodeID != nil {
		mmGetNodeID.inspectFuncGetNodeID()
	}

	if mmGetNodeID.GetNodeIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNodeID.GetNodeIDMock.defaultExpectation.Counter, 1)

		mm_results := mmGetNodeID.GetNodeIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNodeID.t.Fatal("No results are set for the NetworkNodeMock.GetNodeID")
		}
		return (*mm_results).s1
	}
	if mmGetNodeID.funcGetNodeID != nil {
		return mmGetNodeID.funcGetNodeID()
	}
	mmGetNodeID.t.Fatalf("Unexpected call to NetworkNodeMock.GetNodeID.")
	return
}

// GetNodeIDAfterCounter returns a count of finished NetworkNodeMock.GetNodeID invocations
func (mmGetNodeID *NetworkNodeMock) GetNodeIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNodeID.afterGetNodeIDCounter)
}

// GetNodeIDBeforeCounter returns a count of NetworkNodeMock.GetNodeID invocations
func (mmGetNodeID *NetworkNodeMock) GetNodeIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNodeID.beforeGetNodeIDCounter)
}

// MinimockGetNodeIDDone returns true if the count of the GetNodeID invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockGetNodeIDDone() bool {
	for _, e := range m.GetNodeIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNodeIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNodeID != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetNodeIDInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockGetNodeIDInspect() {
	for _, e := range m.GetNodeIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.GetNodeID")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNodeIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetNodeID")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNodeID != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetNodeID")
	}
}

type mNetworkNodeMockGetPower struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockGetPowerExpectation
	expectations       []*NetworkNodeMockGetPowerExpectation
}

// NetworkNodeMockGetPowerExpectation specifies expectation struct of the NetworkNode.GetPower
type NetworkNodeMockGetPowerExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockGetPowerResults
	Counter uint64
}

// NetworkNodeMockGetPowerResults contains results of the NetworkNode.GetPower
type NetworkNodeMockGetPowerResults struct {
	p1 member.Power
}

// Expect sets up expected params for NetworkNode.GetPower
func (mmGetPower *mNetworkNodeMockGetPower) Expect() *mNetworkNodeMockGetPower {
	if mmGetPower.mock.funcGetPower != nil {
		mmGetPower.mock.t.Fatalf("NetworkNodeMock.GetPower mock is already set by Set")
	}

	if mmGetPower.defaultExpectation == nil {
		mmGetPower.defaultExpectation = &NetworkNodeMockGetPowerExpectation{}
	}

	return mmGetPower
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.GetPower
func (mmGetPower *mNetworkNodeMockGetPower) Inspect(f func()) *mNetworkNodeMockGetPower {
	if mmGetPower.mock.inspectFuncGetPower != nil {
		mmGetPower.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.GetPower")
	}

	mmGetPower.mock.inspectFuncGetPower = f

	return mmGetPower
}

// Return sets up results that will be returned by NetworkNode.GetPower
func (mmGetPower *mNetworkNodeMockGetPower) Return(p1 member.Power) *NetworkNodeMock {
	if mmGetPower.mock.funcGetPower != nil {
		mmGetPower.mock.t.Fatalf("NetworkNodeMock.GetPower mock is already set by Set")
	}

	if mmGetPower.defaultExpectation == nil {
		mmGetPower.defaultExpectation = &NetworkNodeMockGetPowerExpectation{mock: mmGetPower.mock}
	}
	mmGetPower.defaultExpectation.results = &NetworkNodeMockGetPowerResults{p1}
	return mmGetPower.mock
}

//Set uses given function f to mock the NetworkNode.GetPower method
func (mmGetPower *mNetworkNodeMockGetPower) Set(f func() (p1 member.Power)) *NetworkNodeMock {
	if mmGetPower.defaultExpectation != nil {
		mmGetPower.mock.t.Fatalf("Default expectation is already set for the NetworkNode.GetPower method")
	}

	if len(mmGetPower.expectations) > 0 {
		mmGetPower.mock.t.Fatalf("Some expectations are already set for the NetworkNode.GetPower method")
	}

	mmGetPower.mock.funcGetPower = f
	return mmGetPower.mock
}

// GetPower implements nodeinfo.NetworkNode
func (mmGetPower *NetworkNodeMock) GetPower() (p1 member.Power) {
	mm_atomic.AddUint64(&mmGetPower.beforeGetPowerCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPower.afterGetPowerCounter, 1)

	if mmGetPower.inspectFuncGetPower != nil {
		mmGetPower.inspectFuncGetPower()
	}

	if mmGetPower.GetPowerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPower.GetPowerMock.defaultExpectation.Counter, 1)

		mm_results := mmGetPower.GetPowerMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPower.t.Fatal("No results are set for the NetworkNodeMock.GetPower")
		}
		return (*mm_results).p1
	}
	if mmGetPower.funcGetPower != nil {
		return mmGetPower.funcGetPower()
	}
	mmGetPower.t.Fatalf("Unexpected call to NetworkNodeMock.GetPower.")
	return
}

// GetPowerAfterCounter returns a count of finished NetworkNodeMock.GetPower invocations
func (mmGetPower *NetworkNodeMock) GetPowerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPower.afterGetPowerCounter)
}

// GetPowerBeforeCounter returns a count of NetworkNodeMock.GetPower invocations
func (mmGetPower *NetworkNodeMock) GetPowerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPower.beforeGetPowerCounter)
}

// MinimockGetPowerDone returns true if the count of the GetPower invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockGetPowerDone() bool {
	for _, e := range m.GetPowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPowerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPower != nil && mm_atomic.LoadUint64(&m.afterGetPowerCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPowerInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockGetPowerInspect() {
	for _, e := range m.GetPowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.GetPower")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPowerCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetPower")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPower != nil && mm_atomic.LoadUint64(&m.afterGetPowerCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetPower")
	}
}

type mNetworkNodeMockGetPrimaryRole struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockGetPrimaryRoleExpectation
	expectations       []*NetworkNodeMockGetPrimaryRoleExpectation
}

// NetworkNodeMockGetPrimaryRoleExpectation specifies expectation struct of the NetworkNode.GetPrimaryRole
type NetworkNodeMockGetPrimaryRoleExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockGetPrimaryRoleResults
	Counter uint64
}

// NetworkNodeMockGetPrimaryRoleResults contains results of the NetworkNode.GetPrimaryRole
type NetworkNodeMockGetPrimaryRoleResults struct {
	p1 member.PrimaryRole
}

// Expect sets up expected params for NetworkNode.GetPrimaryRole
func (mmGetPrimaryRole *mNetworkNodeMockGetPrimaryRole) Expect() *mNetworkNodeMockGetPrimaryRole {
	if mmGetPrimaryRole.mock.funcGetPrimaryRole != nil {
		mmGetPrimaryRole.mock.t.Fatalf("NetworkNodeMock.GetPrimaryRole mock is already set by Set")
	}

	if mmGetPrimaryRole.defaultExpectation == nil {
		mmGetPrimaryRole.defaultExpectation = &NetworkNodeMockGetPrimaryRoleExpectation{}
	}

	return mmGetPrimaryRole
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.GetPrimaryRole
func (mmGetPrimaryRole *mNetworkNodeMockGetPrimaryRole) Inspect(f func()) *mNetworkNodeMockGetPrimaryRole {
	if mmGetPrimaryRole.mock.inspectFuncGetPrimaryRole != nil {
		mmGetPrimaryRole.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.GetPrimaryRole")
	}

	mmGetPrimaryRole.mock.inspectFuncGetPrimaryRole = f

	return mmGetPrimaryRole
}

// Return sets up results that will be returned by NetworkNode.GetPrimaryRole
func (mmGetPrimaryRole *mNetworkNodeMockGetPrimaryRole) Return(p1 member.PrimaryRole) *NetworkNodeMock {
	if mmGetPrimaryRole.mock.funcGetPrimaryRole != nil {
		mmGetPrimaryRole.mock.t.Fatalf("NetworkNodeMock.GetPrimaryRole mock is already set by Set")
	}

	if mmGetPrimaryRole.defaultExpectation == nil {
		mmGetPrimaryRole.defaultExpectation = &NetworkNodeMockGetPrimaryRoleExpectation{mock: mmGetPrimaryRole.mock}
	}
	mmGetPrimaryRole.defaultExpectation.results = &NetworkNodeMockGetPrimaryRoleResults{p1}
	return mmGetPrimaryRole.mock
}

//Set uses given function f to mock the NetworkNode.GetPrimaryRole method
func (mmGetPrimaryRole *mNetworkNodeMockGetPrimaryRole) Set(f func() (p1 member.PrimaryRole)) *NetworkNodeMock {
	if mmGetPrimaryRole.defaultExpectation != nil {
		mmGetPrimaryRole.mock.t.Fatalf("Default expectation is already set for the NetworkNode.GetPrimaryRole method")
	}

	if len(mmGetPrimaryRole.expectations) > 0 {
		mmGetPrimaryRole.mock.t.Fatalf("Some expectations are already set for the NetworkNode.GetPrimaryRole method")
	}

	mmGetPrimaryRole.mock.funcGetPrimaryRole = f
	return mmGetPrimaryRole.mock
}

// GetPrimaryRole implements nodeinfo.NetworkNode
func (mmGetPrimaryRole *NetworkNodeMock) GetPrimaryRole() (p1 member.PrimaryRole) {
	mm_atomic.AddUint64(&mmGetPrimaryRole.beforeGetPrimaryRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPrimaryRole.afterGetPrimaryRoleCounter, 1)

	if mmGetPrimaryRole.inspectFuncGetPrimaryRole != nil {
		mmGetPrimaryRole.inspectFuncGetPrimaryRole()
	}

	if mmGetPrimaryRole.GetPrimaryRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPrimaryRole.GetPrimaryRoleMock.defaultExpectation.Counter, 1)

		mm_results := mmGetPrimaryRole.GetPrimaryRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPrimaryRole.t.Fatal("No results are set for the NetworkNodeMock.GetPrimaryRole")
		}
		return (*mm_results).p1
	}
	if mmGetPrimaryRole.funcGetPrimaryRole != nil {
		return mmGetPrimaryRole.funcGetPrimaryRole()
	}
	mmGetPrimaryRole.t.Fatalf("Unexpected call to NetworkNodeMock.GetPrimaryRole.")
	return
}

// GetPrimaryRoleAfterCounter returns a count of finished NetworkNodeMock.GetPrimaryRole invocations
func (mmGetPrimaryRole *NetworkNodeMock) GetPrimaryRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPrimaryRole.afterGetPrimaryRoleCounter)
}

// GetPrimaryRoleBeforeCounter returns a count of NetworkNodeMock.GetPrimaryRole invocations
func (mmGetPrimaryRole *NetworkNodeMock) GetPrimaryRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPrimaryRole.beforeGetPrimaryRoleCounter)
}

// MinimockGetPrimaryRoleDone returns true if the count of the GetPrimaryRole invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockGetPrimaryRoleDone() bool {
	for _, e := range m.GetPrimaryRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPrimaryRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPrimaryRoleCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPrimaryRole != nil && mm_atomic.LoadUint64(&m.afterGetPrimaryRoleCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPrimaryRoleInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockGetPrimaryRoleInspect() {
	for _, e := range m.GetPrimaryRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.GetPrimaryRole")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPrimaryRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPrimaryRoleCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetPrimaryRole")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPrimaryRole != nil && mm_atomic.LoadUint64(&m.afterGetPrimaryRoleCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetPrimaryRole")
	}
}

type mNetworkNodeMockGetReference struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockGetReferenceExpectation
	expectations       []*NetworkNodeMockGetReferenceExpectation
}

// NetworkNodeMockGetReferenceExpectation specifies expectation struct of the NetworkNode.GetReference
type NetworkNodeMockGetReferenceExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockGetReferenceResults
	Counter uint64
}

// NetworkNodeMockGetReferenceResults contains results of the NetworkNode.GetReference
type NetworkNodeMockGetReferenceResults struct {
	g1 reference.Global
}

// Expect sets up expected params for NetworkNode.GetReference
func (mmGetReference *mNetworkNodeMockGetReference) Expect() *mNetworkNodeMockGetReference {
	if mmGetReference.mock.funcGetReference != nil {
		mmGetReference.mock.t.Fatalf("NetworkNodeMock.GetReference mock is already set by Set")
	}

	if mmGetReference.defaultExpectation == nil {
		mmGetReference.defaultExpectation = &NetworkNodeMockGetReferenceExpectation{}
	}

	return mmGetReference
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.GetReference
func (mmGetReference *mNetworkNodeMockGetReference) Inspect(f func()) *mNetworkNodeMockGetReference {
	if mmGetReference.mock.inspectFuncGetReference != nil {
		mmGetReference.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.GetReference")
	}

	mmGetReference.mock.inspectFuncGetReference = f

	return mmGetReference
}

// Return sets up results that will be returned by NetworkNode.GetReference
func (mmGetReference *mNetworkNodeMockGetReference) Return(g1 reference.Global) *NetworkNodeMock {
	if mmGetReference.mock.funcGetReference != nil {
		mmGetReference.mock.t.Fatalf("NetworkNodeMock.GetReference mock is already set by Set")
	}

	if mmGetReference.defaultExpectation == nil {
		mmGetReference.defaultExpectation = &NetworkNodeMockGetReferenceExpectation{mock: mmGetReference.mock}
	}
	mmGetReference.defaultExpectation.results = &NetworkNodeMockGetReferenceResults{g1}
	return mmGetReference.mock
}

//Set uses given function f to mock the NetworkNode.GetReference method
func (mmGetReference *mNetworkNodeMockGetReference) Set(f func() (g1 reference.Global)) *NetworkNodeMock {
	if mmGetReference.defaultExpectation != nil {
		mmGetReference.mock.t.Fatalf("Default expectation is already set for the NetworkNode.GetReference method")
	}

	if len(mmGetReference.expectations) > 0 {
		mmGetReference.mock.t.Fatalf("Some expectations are already set for the NetworkNode.GetReference method")
	}

	mmGetReference.mock.funcGetReference = f
	return mmGetReference.mock
}

// GetReference implements nodeinfo.NetworkNode
func (mmGetReference *NetworkNodeMock) GetReference() (g1 reference.Global) {
	mm_atomic.AddUint64(&mmGetReference.beforeGetReferenceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReference.afterGetReferenceCounter, 1)

	if mmGetReference.inspectFuncGetReference != nil {
		mmGetReference.inspectFuncGetReference()
	}

	if mmGetReference.GetReferenceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReference.GetReferenceMock.defaultExpectation.Counter, 1)

		mm_results := mmGetReference.GetReferenceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReference.t.Fatal("No results are set for the NetworkNodeMock.GetReference")
		}
		return (*mm_results).g1
	}
	if mmGetReference.funcGetReference != nil {
		return mmGetReference.funcGetReference()
	}
	mmGetReference.t.Fatalf("Unexpected call to NetworkNodeMock.GetReference.")
	return
}

// GetReferenceAfterCounter returns a count of finished NetworkNodeMock.GetReference invocations
func (mmGetReference *NetworkNodeMock) GetReferenceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReference.afterGetReferenceCounter)
}

// GetReferenceBeforeCounter returns a count of NetworkNodeMock.GetReference invocations
func (mmGetReference *NetworkNodeMock) GetReferenceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReference.beforeGetReferenceCounter)
}

// MinimockGetReferenceDone returns true if the count of the GetReference invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockGetReferenceDone() bool {
	for _, e := range m.GetReferenceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetReferenceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetReferenceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReference != nil && mm_atomic.LoadUint64(&m.afterGetReferenceCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetReferenceInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockGetReferenceInspect() {
	for _, e := range m.GetReferenceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.GetReference")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetReferenceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetReferenceCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetReference")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReference != nil && mm_atomic.LoadUint64(&m.afterGetReferenceCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetReference")
	}
}

type mNetworkNodeMockGetSignature struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockGetSignatureExpectation
	expectations       []*NetworkNodeMockGetSignatureExpectation
}

// NetworkNodeMockGetSignatureExpectation specifies expectation struct of the NetworkNode.GetSignature
type NetworkNodeMockGetSignatureExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockGetSignatureResults
	Counter uint64
}

// NetworkNodeMockGetSignatureResults contains results of the NetworkNode.GetSignature
type NetworkNodeMockGetSignatureResults struct {
	s1 cryptkit.SignedDigestHolder
}

// Expect sets up expected params for NetworkNode.GetSignature
func (mmGetSignature *mNetworkNodeMockGetSignature) Expect() *mNetworkNodeMockGetSignature {
	if mmGetSignature.mock.funcGetSignature != nil {
		mmGetSignature.mock.t.Fatalf("NetworkNodeMock.GetSignature mock is already set by Set")
	}

	if mmGetSignature.defaultExpectation == nil {
		mmGetSignature.defaultExpectation = &NetworkNodeMockGetSignatureExpectation{}
	}

	return mmGetSignature
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.GetSignature
func (mmGetSignature *mNetworkNodeMockGetSignature) Inspect(f func()) *mNetworkNodeMockGetSignature {
	if mmGetSignature.mock.inspectFuncGetSignature != nil {
		mmGetSignature.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.GetSignature")
	}

	mmGetSignature.mock.inspectFuncGetSignature = f

	return mmGetSignature
}

// Return sets up results that will be returned by NetworkNode.GetSignature
func (mmGetSignature *mNetworkNodeMockGetSignature) Return(s1 cryptkit.SignedDigestHolder) *NetworkNodeMock {
	if mmGetSignature.mock.funcGetSignature != nil {
		mmGetSignature.mock.t.Fatalf("NetworkNodeMock.GetSignature mock is already set by Set")
	}

	if mmGetSignature.defaultExpectation == nil {
		mmGetSignature.defaultExpectation = &NetworkNodeMockGetSignatureExpectation{mock: mmGetSignature.mock}
	}
	mmGetSignature.defaultExpectation.results = &NetworkNodeMockGetSignatureResults{s1}
	return mmGetSignature.mock
}

//Set uses given function f to mock the NetworkNode.GetSignature method
func (mmGetSignature *mNetworkNodeMockGetSignature) Set(f func() (s1 cryptkit.SignedDigestHolder)) *NetworkNodeMock {
	if mmGetSignature.defaultExpectation != nil {
		mmGetSignature.mock.t.Fatalf("Default expectation is already set for the NetworkNode.GetSignature method")
	}

	if len(mmGetSignature.expectations) > 0 {
		mmGetSignature.mock.t.Fatalf("Some expectations are already set for the NetworkNode.GetSignature method")
	}

	mmGetSignature.mock.funcGetSignature = f
	return mmGetSignature.mock
}

// GetSignature implements nodeinfo.NetworkNode
func (mmGetSignature *NetworkNodeMock) GetSignature() (s1 cryptkit.SignedDigestHolder) {
	mm_atomic.AddUint64(&mmGetSignature.beforeGetSignatureCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSignature.afterGetSignatureCounter, 1)

	if mmGetSignature.inspectFuncGetSignature != nil {
		mmGetSignature.inspectFuncGetSignature()
	}

	if mmGetSignature.GetSignatureMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSignature.GetSignatureMock.defaultExpectation.Counter, 1)

		mm_results := mmGetSignature.GetSignatureMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSignature.t.Fatal("No results are set for the NetworkNodeMock.GetSignature")
		}
		return (*mm_results).s1
	}
	if mmGetSignature.funcGetSignature != nil {
		return mmGetSignature.funcGetSignature()
	}
	mmGetSignature.t.Fatalf("Unexpected call to NetworkNodeMock.GetSignature.")
	return
}

// GetSignatureAfterCounter returns a count of finished NetworkNodeMock.GetSignature invocations
func (mmGetSignature *NetworkNodeMock) GetSignatureAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignature.afterGetSignatureCounter)
}

// GetSignatureBeforeCounter returns a count of NetworkNodeMock.GetSignature invocations
func (mmGetSignature *NetworkNodeMock) GetSignatureBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignature.beforeGetSignatureCounter)
}

// MinimockGetSignatureDone returns true if the count of the GetSignature invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockGetSignatureDone() bool {
	for _, e := range m.GetSignatureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignature != nil && mm_atomic.LoadUint64(&m.afterGetSignatureCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSignatureInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockGetSignatureInspect() {
	for _, e := range m.GetSignatureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.GetSignature")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetSignature")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignature != nil && mm_atomic.LoadUint64(&m.afterGetSignatureCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetSignature")
	}
}

type mNetworkNodeMockGetStatic struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockGetStaticExpectation
	expectations       []*NetworkNodeMockGetStaticExpectation
}

// NetworkNodeMockGetStaticExpectation specifies expectation struct of the NetworkNode.GetStatic
type NetworkNodeMockGetStaticExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockGetStaticResults
	Counter uint64
}

// NetworkNodeMockGetStaticResults contains results of the NetworkNode.GetStatic
type NetworkNodeMockGetStaticResults struct {
	s1 profiles.StaticProfile
}

// Expect sets up expected params for NetworkNode.GetStatic
func (mmGetStatic *mNetworkNodeMockGetStatic) Expect() *mNetworkNodeMockGetStatic {
	if mmGetStatic.mock.funcGetStatic != nil {
		mmGetStatic.mock.t.Fatalf("NetworkNodeMock.GetStatic mock is already set by Set")
	}

	if mmGetStatic.defaultExpectation == nil {
		mmGetStatic.defaultExpectation = &NetworkNodeMockGetStaticExpectation{}
	}

	return mmGetStatic
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.GetStatic
func (mmGetStatic *mNetworkNodeMockGetStatic) Inspect(f func()) *mNetworkNodeMockGetStatic {
	if mmGetStatic.mock.inspectFuncGetStatic != nil {
		mmGetStatic.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.GetStatic")
	}

	mmGetStatic.mock.inspectFuncGetStatic = f

	return mmGetStatic
}

// Return sets up results that will be returned by NetworkNode.GetStatic
func (mmGetStatic *mNetworkNodeMockGetStatic) Return(s1 profiles.StaticProfile) *NetworkNodeMock {
	if mmGetStatic.mock.funcGetStatic != nil {
		mmGetStatic.mock.t.Fatalf("NetworkNodeMock.GetStatic mock is already set by Set")
	}

	if mmGetStatic.defaultExpectation == nil {
		mmGetStatic.defaultExpectation = &NetworkNodeMockGetStaticExpectation{mock: mmGetStatic.mock}
	}
	mmGetStatic.defaultExpectation.results = &NetworkNodeMockGetStaticResults{s1}
	return mmGetStatic.mock
}

//Set uses given function f to mock the NetworkNode.GetStatic method
func (mmGetStatic *mNetworkNodeMockGetStatic) Set(f func() (s1 profiles.StaticProfile)) *NetworkNodeMock {
	if mmGetStatic.defaultExpectation != nil {
		mmGetStatic.mock.t.Fatalf("Default expectation is already set for the NetworkNode.GetStatic method")
	}

	if len(mmGetStatic.expectations) > 0 {
		mmGetStatic.mock.t.Fatalf("Some expectations are already set for the NetworkNode.GetStatic method")
	}

	mmGetStatic.mock.funcGetStatic = f
	return mmGetStatic.mock
}

// GetStatic implements nodeinfo.NetworkNode
func (mmGetStatic *NetworkNodeMock) GetStatic() (s1 profiles.StaticProfile) {
	mm_atomic.AddUint64(&mmGetStatic.beforeGetStaticCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStatic.afterGetStaticCounter, 1)

	if mmGetStatic.inspectFuncGetStatic != nil {
		mmGetStatic.inspectFuncGetStatic()
	}

	if mmGetStatic.GetStaticMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStatic.GetStaticMock.defaultExpectation.Counter, 1)

		mm_results := mmGetStatic.GetStaticMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStatic.t.Fatal("No results are set for the NetworkNodeMock.GetStatic")
		}
		return (*mm_results).s1
	}
	if mmGetStatic.funcGetStatic != nil {
		return mmGetStatic.funcGetStatic()
	}
	mmGetStatic.t.Fatalf("Unexpected call to NetworkNodeMock.GetStatic.")
	return
}

// GetStaticAfterCounter returns a count of finished NetworkNodeMock.GetStatic invocations
func (mmGetStatic *NetworkNodeMock) GetStaticAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStatic.afterGetStaticCounter)
}

// GetStaticBeforeCounter returns a count of NetworkNodeMock.GetStatic invocations
func (mmGetStatic *NetworkNodeMock) GetStaticBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStatic.beforeGetStaticCounter)
}

// MinimockGetStaticDone returns true if the count of the GetStatic invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockGetStaticDone() bool {
	for _, e := range m.GetStaticMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStaticMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStatic != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetStaticInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockGetStaticInspect() {
	for _, e := range m.GetStaticMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.GetStatic")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStaticMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetStatic")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStatic != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetStatic")
	}
}

type mNetworkNodeMockIsJoiner struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockIsJoinerExpectation
	expectations       []*NetworkNodeMockIsJoinerExpectation
}

// NetworkNodeMockIsJoinerExpectation specifies expectation struct of the NetworkNode.IsJoiner
type NetworkNodeMockIsJoinerExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockIsJoinerResults
	Counter uint64
}

// NetworkNodeMockIsJoinerResults contains results of the NetworkNode.IsJoiner
type NetworkNodeMockIsJoinerResults struct {
	b1 bool
}

// Expect sets up expected params for NetworkNode.IsJoiner
func (mmIsJoiner *mNetworkNodeMockIsJoiner) Expect() *mNetworkNodeMockIsJoiner {
	if mmIsJoiner.mock.funcIsJoiner != nil {
		mmIsJoiner.mock.t.Fatalf("NetworkNodeMock.IsJoiner mock is already set by Set")
	}

	if mmIsJoiner.defaultExpectation == nil {
		mmIsJoiner.defaultExpectation = &NetworkNodeMockIsJoinerExpectation{}
	}

	return mmIsJoiner
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.IsJoiner
func (mmIsJoiner *mNetworkNodeMockIsJoiner) Inspect(f func()) *mNetworkNodeMockIsJoiner {
	if mmIsJoiner.mock.inspectFuncIsJoiner != nil {
		mmIsJoiner.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.IsJoiner")
	}

	mmIsJoiner.mock.inspectFuncIsJoiner = f

	return mmIsJoiner
}

// Return sets up results that will be returned by NetworkNode.IsJoiner
func (mmIsJoiner *mNetworkNodeMockIsJoiner) Return(b1 bool) *NetworkNodeMock {
	if mmIsJoiner.mock.funcIsJoiner != nil {
		mmIsJoiner.mock.t.Fatalf("NetworkNodeMock.IsJoiner mock is already set by Set")
	}

	if mmIsJoiner.defaultExpectation == nil {
		mmIsJoiner.defaultExpectation = &NetworkNodeMockIsJoinerExpectation{mock: mmIsJoiner.mock}
	}
	mmIsJoiner.defaultExpectation.results = &NetworkNodeMockIsJoinerResults{b1}
	return mmIsJoiner.mock
}

//Set uses given function f to mock the NetworkNode.IsJoiner method
func (mmIsJoiner *mNetworkNodeMockIsJoiner) Set(f func() (b1 bool)) *NetworkNodeMock {
	if mmIsJoiner.defaultExpectation != nil {
		mmIsJoiner.mock.t.Fatalf("Default expectation is already set for the NetworkNode.IsJoiner method")
	}

	if len(mmIsJoiner.expectations) > 0 {
		mmIsJoiner.mock.t.Fatalf("Some expectations are already set for the NetworkNode.IsJoiner method")
	}

	mmIsJoiner.mock.funcIsJoiner = f
	return mmIsJoiner.mock
}

// IsJoiner implements nodeinfo.NetworkNode
func (mmIsJoiner *NetworkNodeMock) IsJoiner() (b1 bool) {
	mm_atomic.AddUint64(&mmIsJoiner.beforeIsJoinerCounter, 1)
	defer mm_atomic.AddUint64(&mmIsJoiner.afterIsJoinerCounter, 1)

	if mmIsJoiner.inspectFuncIsJoiner != nil {
		mmIsJoiner.inspectFuncIsJoiner()
	}

	if mmIsJoiner.IsJoinerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsJoiner.IsJoinerMock.defaultExpectation.Counter, 1)

		mm_results := mmIsJoiner.IsJoinerMock.defaultExpectation.results
		if mm_results == nil {
			mmIsJoiner.t.Fatal("No results are set for the NetworkNodeMock.IsJoiner")
		}
		return (*mm_results).b1
	}
	if mmIsJoiner.funcIsJoiner != nil {
		return mmIsJoiner.funcIsJoiner()
	}
	mmIsJoiner.t.Fatalf("Unexpected call to NetworkNodeMock.IsJoiner.")
	return
}

// IsJoinerAfterCounter returns a count of finished NetworkNodeMock.IsJoiner invocations
func (mmIsJoiner *NetworkNodeMock) IsJoinerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsJoiner.afterIsJoinerCounter)
}

// IsJoinerBeforeCounter returns a count of NetworkNodeMock.IsJoiner invocations
func (mmIsJoiner *NetworkNodeMock) IsJoinerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsJoiner.beforeIsJoinerCounter)
}

// MinimockIsJoinerDone returns true if the count of the IsJoiner invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockIsJoinerDone() bool {
	for _, e := range m.IsJoinerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsJoinerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsJoiner != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsJoinerInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockIsJoinerInspect() {
	for _, e := range m.IsJoinerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.IsJoiner")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsJoinerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.IsJoiner")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsJoiner != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.IsJoiner")
	}
}

type mNetworkNodeMockIsPowered struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockIsPoweredExpectation
	expectations       []*NetworkNodeMockIsPoweredExpectation
}

// NetworkNodeMockIsPoweredExpectation specifies expectation struct of the NetworkNode.IsPowered
type NetworkNodeMockIsPoweredExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockIsPoweredResults
	Counter uint64
}

// NetworkNodeMockIsPoweredResults contains results of the NetworkNode.IsPowered
type NetworkNodeMockIsPoweredResults struct {
	b1 bool
}

// Expect sets up expected params for NetworkNode.IsPowered
func (mmIsPowered *mNetworkNodeMockIsPowered) Expect() *mNetworkNodeMockIsPowered {
	if mmIsPowered.mock.funcIsPowered != nil {
		mmIsPowered.mock.t.Fatalf("NetworkNodeMock.IsPowered mock is already set by Set")
	}

	if mmIsPowered.defaultExpectation == nil {
		mmIsPowered.defaultExpectation = &NetworkNodeMockIsPoweredExpectation{}
	}

	return mmIsPowered
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.IsPowered
func (mmIsPowered *mNetworkNodeMockIsPowered) Inspect(f func()) *mNetworkNodeMockIsPowered {
	if mmIsPowered.mock.inspectFuncIsPowered != nil {
		mmIsPowered.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.IsPowered")
	}

	mmIsPowered.mock.inspectFuncIsPowered = f

	return mmIsPowered
}

// Return sets up results that will be returned by NetworkNode.IsPowered
func (mmIsPowered *mNetworkNodeMockIsPowered) Return(b1 bool) *NetworkNodeMock {
	if mmIsPowered.mock.funcIsPowered != nil {
		mmIsPowered.mock.t.Fatalf("NetworkNodeMock.IsPowered mock is already set by Set")
	}

	if mmIsPowered.defaultExpectation == nil {
		mmIsPowered.defaultExpectation = &NetworkNodeMockIsPoweredExpectation{mock: mmIsPowered.mock}
	}
	mmIsPowered.defaultExpectation.results = &NetworkNodeMockIsPoweredResults{b1}
	return mmIsPowered.mock
}

//Set uses given function f to mock the NetworkNode.IsPowered method
func (mmIsPowered *mNetworkNodeMockIsPowered) Set(f func() (b1 bool)) *NetworkNodeMock {
	if mmIsPowered.defaultExpectation != nil {
		mmIsPowered.mock.t.Fatalf("Default expectation is already set for the NetworkNode.IsPowered method")
	}

	if len(mmIsPowered.expectations) > 0 {
		mmIsPowered.mock.t.Fatalf("Some expectations are already set for the NetworkNode.IsPowered method")
	}

	mmIsPowered.mock.funcIsPowered = f
	return mmIsPowered.mock
}

// IsPowered implements nodeinfo.NetworkNode
func (mmIsPowered *NetworkNodeMock) IsPowered() (b1 bool) {
	mm_atomic.AddUint64(&mmIsPowered.beforeIsPoweredCounter, 1)
	defer mm_atomic.AddUint64(&mmIsPowered.afterIsPoweredCounter, 1)

	if mmIsPowered.inspectFuncIsPowered != nil {
		mmIsPowered.inspectFuncIsPowered()
	}

	if mmIsPowered.IsPoweredMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsPowered.IsPoweredMock.defaultExpectation.Counter, 1)

		mm_results := mmIsPowered.IsPoweredMock.defaultExpectation.results
		if mm_results == nil {
			mmIsPowered.t.Fatal("No results are set for the NetworkNodeMock.IsPowered")
		}
		return (*mm_results).b1
	}
	if mmIsPowered.funcIsPowered != nil {
		return mmIsPowered.funcIsPowered()
	}
	mmIsPowered.t.Fatalf("Unexpected call to NetworkNodeMock.IsPowered.")
	return
}

// IsPoweredAfterCounter returns a count of finished NetworkNodeMock.IsPowered invocations
func (mmIsPowered *NetworkNodeMock) IsPoweredAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsPowered.afterIsPoweredCounter)
}

// IsPoweredBeforeCounter returns a count of NetworkNodeMock.IsPowered invocations
func (mmIsPowered *NetworkNodeMock) IsPoweredBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsPowered.beforeIsPoweredCounter)
}

// MinimockIsPoweredDone returns true if the count of the IsPowered invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockIsPoweredDone() bool {
	for _, e := range m.IsPoweredMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsPoweredMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsPoweredCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsPowered != nil && mm_atomic.LoadUint64(&m.afterIsPoweredCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsPoweredInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockIsPoweredInspect() {
	for _, e := range m.IsPoweredMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.IsPowered")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsPoweredMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsPoweredCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.IsPowered")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsPowered != nil && mm_atomic.LoadUint64(&m.afterIsPoweredCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.IsPowered")
	}
}

type mNetworkNodeMockPublicKey struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockPublicKeyExpectation
	expectations       []*NetworkNodeMockPublicKeyExpectation
}

// NetworkNodeMockPublicKeyExpectation specifies expectation struct of the NetworkNode.PublicKey
type NetworkNodeMockPublicKeyExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockPublicKeyResults
	Counter uint64
}

// NetworkNodeMockPublicKeyResults contains results of the NetworkNode.PublicKey
type NetworkNodeMockPublicKeyResults struct {
	p1 crypto.PublicKey
}

// Expect sets up expected params for NetworkNode.PublicKey
func (mmPublicKey *mNetworkNodeMockPublicKey) Expect() *mNetworkNodeMockPublicKey {
	if mmPublicKey.mock.funcPublicKey != nil {
		mmPublicKey.mock.t.Fatalf("NetworkNodeMock.PublicKey mock is already set by Set")
	}

	if mmPublicKey.defaultExpectation == nil {
		mmPublicKey.defaultExpectation = &NetworkNodeMockPublicKeyExpectation{}
	}

	return mmPublicKey
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.PublicKey
func (mmPublicKey *mNetworkNodeMockPublicKey) Inspect(f func()) *mNetworkNodeMockPublicKey {
	if mmPublicKey.mock.inspectFuncPublicKey != nil {
		mmPublicKey.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.PublicKey")
	}

	mmPublicKey.mock.inspectFuncPublicKey = f

	return mmPublicKey
}

// Return sets up results that will be returned by NetworkNode.PublicKey
func (mmPublicKey *mNetworkNodeMockPublicKey) Return(p1 crypto.PublicKey) *NetworkNodeMock {
	if mmPublicKey.mock.funcPublicKey != nil {
		mmPublicKey.mock.t.Fatalf("NetworkNodeMock.PublicKey mock is already set by Set")
	}

	if mmPublicKey.defaultExpectation == nil {
		mmPublicKey.defaultExpectation = &NetworkNodeMockPublicKeyExpectation{mock: mmPublicKey.mock}
	}
	mmPublicKey.defaultExpectation.results = &NetworkNodeMockPublicKeyResults{p1}
	return mmPublicKey.mock
}

//Set uses given function f to mock the NetworkNode.PublicKey method
func (mmPublicKey *mNetworkNodeMockPublicKey) Set(f func() (p1 crypto.PublicKey)) *NetworkNodeMock {
	if mmPublicKey.defaultExpectation != nil {
		mmPublicKey.mock.t.Fatalf("Default expectation is already set for the NetworkNode.PublicKey method")
	}

	if len(mmPublicKey.expectations) > 0 {
		mmPublicKey.mock.t.Fatalf("Some expectations are already set for the NetworkNode.PublicKey method")
	}

	mmPublicKey.mock.funcPublicKey = f
	return mmPublicKey.mock
}

// PublicKey implements nodeinfo.NetworkNode
func (mmPublicKey *NetworkNodeMock) PublicKey() (p1 crypto.PublicKey) {
	mm_atomic.AddUint64(&mmPublicKey.beforePublicKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmPublicKey.afterPublicKeyCounter, 1)

	if mmPublicKey.inspectFuncPublicKey != nil {
		mmPublicKey.inspectFuncPublicKey()
	}

	if mmPublicKey.PublicKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublicKey.PublicKeyMock.defaultExpectation.Counter, 1)

		mm_results := mmPublicKey.PublicKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmPublicKey.t.Fatal("No results are set for the NetworkNodeMock.PublicKey")
		}
		return (*mm_results).p1
	}
	if mmPublicKey.funcPublicKey != nil {
		return mmPublicKey.funcPublicKey()
	}
	mmPublicKey.t.Fatalf("Unexpected call to NetworkNodeMock.PublicKey.")
	return
}

// PublicKeyAfterCounter returns a count of finished NetworkNodeMock.PublicKey invocations
func (mmPublicKey *NetworkNodeMock) PublicKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublicKey.afterPublicKeyCounter)
}

// PublicKeyBeforeCounter returns a count of NetworkNodeMock.PublicKey invocations
func (mmPublicKey *NetworkNodeMock) PublicKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublicKey.beforePublicKeyCounter)
}

// MinimockPublicKeyDone returns true if the count of the PublicKey invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockPublicKeyDone() bool {
	for _, e := range m.PublicKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublicKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublicKeyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublicKey != nil && mm_atomic.LoadUint64(&m.afterPublicKeyCounter) < 1 {
		return false
	}
	return true
}

// MinimockPublicKeyInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockPublicKeyInspect() {
	for _, e := range m.PublicKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.PublicKey")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublicKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublicKeyCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.PublicKey")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublicKey != nil && mm_atomic.LoadUint64(&m.afterPublicKeyCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.PublicKey")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *NetworkNodeMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddressInspect()

		m.MinimockGetNodeIDInspect()

		m.MinimockGetPowerInspect()

		m.MinimockGetPrimaryRoleInspect()

		m.MinimockGetReferenceInspect()

		m.MinimockGetSignatureInspect()

		m.MinimockGetStaticInspect()

		m.MinimockIsJoinerInspect()

		m.MinimockIsPoweredInspect()

		m.MinimockPublicKeyInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *NetworkNodeMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *NetworkNodeMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddressDone() &&
		m.MinimockGetNodeIDDone() &&
		m.MinimockGetPowerDone() &&
		m.MinimockGetPrimaryRoleDone() &&
		m.MinimockGetReferenceDone() &&
		m.MinimockGetSignatureDone() &&
		m.MinimockGetStaticDone() &&
		m.MinimockIsJoinerDone() &&
		m.MinimockIsPoweredDone() &&
		m.MinimockPublicKeyDone()
}
