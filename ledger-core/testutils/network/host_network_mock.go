package network

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_network "github.com/insolar/assured-ledger/ledger-core/network"
	"github.com/insolar/assured-ledger/ledger-core/network/hostnetwork/packet/types"
	"github.com/insolar/assured-ledger/ledger-core/network/nds/uniproto"
	"github.com/insolar/assured-ledger/ledger-core/network/nwapi"
)

// HostNetworkMock implements network.HostNetwork
type HostNetworkMock struct {
	t minimock.Tester

	funcBuildResponse          func(ctx context.Context, request mm_network.Packet, responseData interface{}) (p1 mm_network.Packet)
	inspectFuncBuildResponse   func(ctx context.Context, request mm_network.Packet, responseData interface{})
	afterBuildResponseCounter  uint64
	beforeBuildResponseCounter uint64
	BuildResponseMock          mHostNetworkMockBuildResponse

	funcReceiveLargePacket          func(rp *uniproto.ReceivedPacket, preRead []byte, r io.LimitedReader) (err error)
	inspectFuncReceiveLargePacket   func(rp *uniproto.ReceivedPacket, preRead []byte, r io.LimitedReader)
	afterReceiveLargePacketCounter  uint64
	beforeReceiveLargePacketCounter uint64
	ReceiveLargePacketMock          mHostNetworkMockReceiveLargePacket

	funcReceiveSmallPacket          func(rp *uniproto.ReceivedPacket, b []byte)
	inspectFuncReceiveSmallPacket   func(rp *uniproto.ReceivedPacket, b []byte)
	afterReceiveSmallPacketCounter  uint64
	beforeReceiveSmallPacketCounter uint64
	ReceiveSmallPacketMock          mHostNetworkMockReceiveSmallPacket

	funcRegisterRequestHandler          func(t types.PacketType, handler mm_network.RequestHandler)
	inspectFuncRegisterRequestHandler   func(t types.PacketType, handler mm_network.RequestHandler)
	afterRegisterRequestHandlerCounter  uint64
	beforeRegisterRequestHandlerCounter uint64
	RegisterRequestHandlerMock          mHostNetworkMockRegisterRequestHandler

	funcSendRequestToHost          func(ctx context.Context, t types.PacketType, requestData interface{}, receiver nwapi.Address) (f1 mm_network.Future, err error)
	inspectFuncSendRequestToHost   func(ctx context.Context, t types.PacketType, requestData interface{}, receiver nwapi.Address)
	afterSendRequestToHostCounter  uint64
	beforeSendRequestToHostCounter uint64
	SendRequestToHostMock          mHostNetworkMockSendRequestToHost
}

// NewHostNetworkMock returns a mock for network.HostNetwork
func NewHostNetworkMock(t minimock.Tester) *HostNetworkMock {
	m := &HostNetworkMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BuildResponseMock = mHostNetworkMockBuildResponse{mock: m}
	m.BuildResponseMock.callArgs = []*HostNetworkMockBuildResponseParams{}

	m.ReceiveLargePacketMock = mHostNetworkMockReceiveLargePacket{mock: m}
	m.ReceiveLargePacketMock.callArgs = []*HostNetworkMockReceiveLargePacketParams{}

	m.ReceiveSmallPacketMock = mHostNetworkMockReceiveSmallPacket{mock: m}
	m.ReceiveSmallPacketMock.callArgs = []*HostNetworkMockReceiveSmallPacketParams{}

	m.RegisterRequestHandlerMock = mHostNetworkMockRegisterRequestHandler{mock: m}
	m.RegisterRequestHandlerMock.callArgs = []*HostNetworkMockRegisterRequestHandlerParams{}

	m.SendRequestToHostMock = mHostNetworkMockSendRequestToHost{mock: m}
	m.SendRequestToHostMock.callArgs = []*HostNetworkMockSendRequestToHostParams{}

	return m
}

type mHostNetworkMockBuildResponse struct {
	mock               *HostNetworkMock
	defaultExpectation *HostNetworkMockBuildResponseExpectation
	expectations       []*HostNetworkMockBuildResponseExpectation

	callArgs []*HostNetworkMockBuildResponseParams
	mutex    sync.RWMutex
}

// HostNetworkMockBuildResponseExpectation specifies expectation struct of the HostNetwork.BuildResponse
type HostNetworkMockBuildResponseExpectation struct {
	mock    *HostNetworkMock
	params  *HostNetworkMockBuildResponseParams
	results *HostNetworkMockBuildResponseResults
	Counter uint64
}

// HostNetworkMockBuildResponseParams contains parameters of the HostNetwork.BuildResponse
type HostNetworkMockBuildResponseParams struct {
	ctx          context.Context
	request      mm_network.Packet
	responseData interface{}
}

// HostNetworkMockBuildResponseResults contains results of the HostNetwork.BuildResponse
type HostNetworkMockBuildResponseResults struct {
	p1 mm_network.Packet
}

// Expect sets up expected params for HostNetwork.BuildResponse
func (mmBuildResponse *mHostNetworkMockBuildResponse) Expect(ctx context.Context, request mm_network.Packet, responseData interface{}) *mHostNetworkMockBuildResponse {
	if mmBuildResponse.mock.funcBuildResponse != nil {
		mmBuildResponse.mock.t.Fatalf("HostNetworkMock.BuildResponse mock is already set by Set")
	}

	if mmBuildResponse.defaultExpectation == nil {
		mmBuildResponse.defaultExpectation = &HostNetworkMockBuildResponseExpectation{}
	}

	mmBuildResponse.defaultExpectation.params = &HostNetworkMockBuildResponseParams{ctx, request, responseData}
	for _, e := range mmBuildResponse.expectations {
		if minimock.Equal(e.params, mmBuildResponse.defaultExpectation.params) {
			mmBuildResponse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBuildResponse.defaultExpectation.params)
		}
	}

	return mmBuildResponse
}

// Inspect accepts an inspector function that has same arguments as the HostNetwork.BuildResponse
func (mmBuildResponse *mHostNetworkMockBuildResponse) Inspect(f func(ctx context.Context, request mm_network.Packet, responseData interface{})) *mHostNetworkMockBuildResponse {
	if mmBuildResponse.mock.inspectFuncBuildResponse != nil {
		mmBuildResponse.mock.t.Fatalf("Inspect function is already set for HostNetworkMock.BuildResponse")
	}

	mmBuildResponse.mock.inspectFuncBuildResponse = f

	return mmBuildResponse
}

// Return sets up results that will be returned by HostNetwork.BuildResponse
func (mmBuildResponse *mHostNetworkMockBuildResponse) Return(p1 mm_network.Packet) *HostNetworkMock {
	if mmBuildResponse.mock.funcBuildResponse != nil {
		mmBuildResponse.mock.t.Fatalf("HostNetworkMock.BuildResponse mock is already set by Set")
	}

	if mmBuildResponse.defaultExpectation == nil {
		mmBuildResponse.defaultExpectation = &HostNetworkMockBuildResponseExpectation{mock: mmBuildResponse.mock}
	}
	mmBuildResponse.defaultExpectation.results = &HostNetworkMockBuildResponseResults{p1}
	return mmBuildResponse.mock
}

//Set uses given function f to mock the HostNetwork.BuildResponse method
func (mmBuildResponse *mHostNetworkMockBuildResponse) Set(f func(ctx context.Context, request mm_network.Packet, responseData interface{}) (p1 mm_network.Packet)) *HostNetworkMock {
	if mmBuildResponse.defaultExpectation != nil {
		mmBuildResponse.mock.t.Fatalf("Default expectation is already set for the HostNetwork.BuildResponse method")
	}

	if len(mmBuildResponse.expectations) > 0 {
		mmBuildResponse.mock.t.Fatalf("Some expectations are already set for the HostNetwork.BuildResponse method")
	}

	mmBuildResponse.mock.funcBuildResponse = f
	return mmBuildResponse.mock
}

// When sets expectation for the HostNetwork.BuildResponse which will trigger the result defined by the following
// Then helper
func (mmBuildResponse *mHostNetworkMockBuildResponse) When(ctx context.Context, request mm_network.Packet, responseData interface{}) *HostNetworkMockBuildResponseExpectation {
	if mmBuildResponse.mock.funcBuildResponse != nil {
		mmBuildResponse.mock.t.Fatalf("HostNetworkMock.BuildResponse mock is already set by Set")
	}

	expectation := &HostNetworkMockBuildResponseExpectation{
		mock:   mmBuildResponse.mock,
		params: &HostNetworkMockBuildResponseParams{ctx, request, responseData},
	}
	mmBuildResponse.expectations = append(mmBuildResponse.expectations, expectation)
	return expectation
}

// Then sets up HostNetwork.BuildResponse return parameters for the expectation previously defined by the When method
func (e *HostNetworkMockBuildResponseExpectation) Then(p1 mm_network.Packet) *HostNetworkMock {
	e.results = &HostNetworkMockBuildResponseResults{p1}
	return e.mock
}

// BuildResponse implements network.HostNetwork
func (mmBuildResponse *HostNetworkMock) BuildResponse(ctx context.Context, request mm_network.Packet, responseData interface{}) (p1 mm_network.Packet) {
	mm_atomic.AddUint64(&mmBuildResponse.beforeBuildResponseCounter, 1)
	defer mm_atomic.AddUint64(&mmBuildResponse.afterBuildResponseCounter, 1)

	if mmBuildResponse.inspectFuncBuildResponse != nil {
		mmBuildResponse.inspectFuncBuildResponse(ctx, request, responseData)
	}

	mm_params := &HostNetworkMockBuildResponseParams{ctx, request, responseData}

	// Record call args
	mmBuildResponse.BuildResponseMock.mutex.Lock()
	mmBuildResponse.BuildResponseMock.callArgs = append(mmBuildResponse.BuildResponseMock.callArgs, mm_params)
	mmBuildResponse.BuildResponseMock.mutex.Unlock()

	for _, e := range mmBuildResponse.BuildResponseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1
		}
	}

	if mmBuildResponse.BuildResponseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBuildResponse.BuildResponseMock.defaultExpectation.Counter, 1)
		mm_want := mmBuildResponse.BuildResponseMock.defaultExpectation.params
		mm_got := HostNetworkMockBuildResponseParams{ctx, request, responseData}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBuildResponse.t.Errorf("HostNetworkMock.BuildResponse got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBuildResponse.BuildResponseMock.defaultExpectation.results
		if mm_results == nil {
			mmBuildResponse.t.Fatal("No results are set for the HostNetworkMock.BuildResponse")
		}
		return (*mm_results).p1
	}
	if mmBuildResponse.funcBuildResponse != nil {
		return mmBuildResponse.funcBuildResponse(ctx, request, responseData)
	}
	mmBuildResponse.t.Fatalf("Unexpected call to HostNetworkMock.BuildResponse. %v %v %v", ctx, request, responseData)
	return
}

// BuildResponseAfterCounter returns a count of finished HostNetworkMock.BuildResponse invocations
func (mmBuildResponse *HostNetworkMock) BuildResponseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuildResponse.afterBuildResponseCounter)
}

// BuildResponseBeforeCounter returns a count of HostNetworkMock.BuildResponse invocations
func (mmBuildResponse *HostNetworkMock) BuildResponseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuildResponse.beforeBuildResponseCounter)
}

// Calls returns a list of arguments used in each call to HostNetworkMock.BuildResponse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBuildResponse *mHostNetworkMockBuildResponse) Calls() []*HostNetworkMockBuildResponseParams {
	mmBuildResponse.mutex.RLock()

	argCopy := make([]*HostNetworkMockBuildResponseParams, len(mmBuildResponse.callArgs))
	copy(argCopy, mmBuildResponse.callArgs)

	mmBuildResponse.mutex.RUnlock()

	return argCopy
}

// MinimockBuildResponseDone returns true if the count of the BuildResponse invocations corresponds
// the number of defined expectations
func (m *HostNetworkMock) MinimockBuildResponseDone() bool {
	for _, e := range m.BuildResponseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BuildResponseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBuildResponseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuildResponse != nil && mm_atomic.LoadUint64(&m.afterBuildResponseCounter) < 1 {
		return false
	}
	return true
}

// MinimockBuildResponseInspect logs each unmet expectation
func (m *HostNetworkMock) MinimockBuildResponseInspect() {
	for _, e := range m.BuildResponseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HostNetworkMock.BuildResponse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BuildResponseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBuildResponseCounter) < 1 {
		if m.BuildResponseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HostNetworkMock.BuildResponse")
		} else {
			m.t.Errorf("Expected call to HostNetworkMock.BuildResponse with params: %#v", *m.BuildResponseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuildResponse != nil && mm_atomic.LoadUint64(&m.afterBuildResponseCounter) < 1 {
		m.t.Error("Expected call to HostNetworkMock.BuildResponse")
	}
}

type mHostNetworkMockReceiveLargePacket struct {
	mock               *HostNetworkMock
	defaultExpectation *HostNetworkMockReceiveLargePacketExpectation
	expectations       []*HostNetworkMockReceiveLargePacketExpectation

	callArgs []*HostNetworkMockReceiveLargePacketParams
	mutex    sync.RWMutex
}

// HostNetworkMockReceiveLargePacketExpectation specifies expectation struct of the HostNetwork.ReceiveLargePacket
type HostNetworkMockReceiveLargePacketExpectation struct {
	mock    *HostNetworkMock
	params  *HostNetworkMockReceiveLargePacketParams
	results *HostNetworkMockReceiveLargePacketResults
	Counter uint64
}

// HostNetworkMockReceiveLargePacketParams contains parameters of the HostNetwork.ReceiveLargePacket
type HostNetworkMockReceiveLargePacketParams struct {
	rp      *uniproto.ReceivedPacket
	preRead []byte
	r       io.LimitedReader
}

// HostNetworkMockReceiveLargePacketResults contains results of the HostNetwork.ReceiveLargePacket
type HostNetworkMockReceiveLargePacketResults struct {
	err error
}

// Expect sets up expected params for HostNetwork.ReceiveLargePacket
func (mmReceiveLargePacket *mHostNetworkMockReceiveLargePacket) Expect(rp *uniproto.ReceivedPacket, preRead []byte, r io.LimitedReader) *mHostNetworkMockReceiveLargePacket {
	if mmReceiveLargePacket.mock.funcReceiveLargePacket != nil {
		mmReceiveLargePacket.mock.t.Fatalf("HostNetworkMock.ReceiveLargePacket mock is already set by Set")
	}

	if mmReceiveLargePacket.defaultExpectation == nil {
		mmReceiveLargePacket.defaultExpectation = &HostNetworkMockReceiveLargePacketExpectation{}
	}

	mmReceiveLargePacket.defaultExpectation.params = &HostNetworkMockReceiveLargePacketParams{rp, preRead, r}
	for _, e := range mmReceiveLargePacket.expectations {
		if minimock.Equal(e.params, mmReceiveLargePacket.defaultExpectation.params) {
			mmReceiveLargePacket.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReceiveLargePacket.defaultExpectation.params)
		}
	}

	return mmReceiveLargePacket
}

// Inspect accepts an inspector function that has same arguments as the HostNetwork.ReceiveLargePacket
func (mmReceiveLargePacket *mHostNetworkMockReceiveLargePacket) Inspect(f func(rp *uniproto.ReceivedPacket, preRead []byte, r io.LimitedReader)) *mHostNetworkMockReceiveLargePacket {
	if mmReceiveLargePacket.mock.inspectFuncReceiveLargePacket != nil {
		mmReceiveLargePacket.mock.t.Fatalf("Inspect function is already set for HostNetworkMock.ReceiveLargePacket")
	}

	mmReceiveLargePacket.mock.inspectFuncReceiveLargePacket = f

	return mmReceiveLargePacket
}

// Return sets up results that will be returned by HostNetwork.ReceiveLargePacket
func (mmReceiveLargePacket *mHostNetworkMockReceiveLargePacket) Return(err error) *HostNetworkMock {
	if mmReceiveLargePacket.mock.funcReceiveLargePacket != nil {
		mmReceiveLargePacket.mock.t.Fatalf("HostNetworkMock.ReceiveLargePacket mock is already set by Set")
	}

	if mmReceiveLargePacket.defaultExpectation == nil {
		mmReceiveLargePacket.defaultExpectation = &HostNetworkMockReceiveLargePacketExpectation{mock: mmReceiveLargePacket.mock}
	}
	mmReceiveLargePacket.defaultExpectation.results = &HostNetworkMockReceiveLargePacketResults{err}
	return mmReceiveLargePacket.mock
}

//Set uses given function f to mock the HostNetwork.ReceiveLargePacket method
func (mmReceiveLargePacket *mHostNetworkMockReceiveLargePacket) Set(f func(rp *uniproto.ReceivedPacket, preRead []byte, r io.LimitedReader) (err error)) *HostNetworkMock {
	if mmReceiveLargePacket.defaultExpectation != nil {
		mmReceiveLargePacket.mock.t.Fatalf("Default expectation is already set for the HostNetwork.ReceiveLargePacket method")
	}

	if len(mmReceiveLargePacket.expectations) > 0 {
		mmReceiveLargePacket.mock.t.Fatalf("Some expectations are already set for the HostNetwork.ReceiveLargePacket method")
	}

	mmReceiveLargePacket.mock.funcReceiveLargePacket = f
	return mmReceiveLargePacket.mock
}

// When sets expectation for the HostNetwork.ReceiveLargePacket which will trigger the result defined by the following
// Then helper
func (mmReceiveLargePacket *mHostNetworkMockReceiveLargePacket) When(rp *uniproto.ReceivedPacket, preRead []byte, r io.LimitedReader) *HostNetworkMockReceiveLargePacketExpectation {
	if mmReceiveLargePacket.mock.funcReceiveLargePacket != nil {
		mmReceiveLargePacket.mock.t.Fatalf("HostNetworkMock.ReceiveLargePacket mock is already set by Set")
	}

	expectation := &HostNetworkMockReceiveLargePacketExpectation{
		mock:   mmReceiveLargePacket.mock,
		params: &HostNetworkMockReceiveLargePacketParams{rp, preRead, r},
	}
	mmReceiveLargePacket.expectations = append(mmReceiveLargePacket.expectations, expectation)
	return expectation
}

// Then sets up HostNetwork.ReceiveLargePacket return parameters for the expectation previously defined by the When method
func (e *HostNetworkMockReceiveLargePacketExpectation) Then(err error) *HostNetworkMock {
	e.results = &HostNetworkMockReceiveLargePacketResults{err}
	return e.mock
}

// ReceiveLargePacket implements network.HostNetwork
func (mmReceiveLargePacket *HostNetworkMock) ReceiveLargePacket(rp *uniproto.ReceivedPacket, preRead []byte, r io.LimitedReader) (err error) {
	mm_atomic.AddUint64(&mmReceiveLargePacket.beforeReceiveLargePacketCounter, 1)
	defer mm_atomic.AddUint64(&mmReceiveLargePacket.afterReceiveLargePacketCounter, 1)

	if mmReceiveLargePacket.inspectFuncReceiveLargePacket != nil {
		mmReceiveLargePacket.inspectFuncReceiveLargePacket(rp, preRead, r)
	}

	mm_params := &HostNetworkMockReceiveLargePacketParams{rp, preRead, r}

	// Record call args
	mmReceiveLargePacket.ReceiveLargePacketMock.mutex.Lock()
	mmReceiveLargePacket.ReceiveLargePacketMock.callArgs = append(mmReceiveLargePacket.ReceiveLargePacketMock.callArgs, mm_params)
	mmReceiveLargePacket.ReceiveLargePacketMock.mutex.Unlock()

	for _, e := range mmReceiveLargePacket.ReceiveLargePacketMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReceiveLargePacket.ReceiveLargePacketMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReceiveLargePacket.ReceiveLargePacketMock.defaultExpectation.Counter, 1)
		mm_want := mmReceiveLargePacket.ReceiveLargePacketMock.defaultExpectation.params
		mm_got := HostNetworkMockReceiveLargePacketParams{rp, preRead, r}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReceiveLargePacket.t.Errorf("HostNetworkMock.ReceiveLargePacket got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReceiveLargePacket.ReceiveLargePacketMock.defaultExpectation.results
		if mm_results == nil {
			mmReceiveLargePacket.t.Fatal("No results are set for the HostNetworkMock.ReceiveLargePacket")
		}
		return (*mm_results).err
	}
	if mmReceiveLargePacket.funcReceiveLargePacket != nil {
		return mmReceiveLargePacket.funcReceiveLargePacket(rp, preRead, r)
	}
	mmReceiveLargePacket.t.Fatalf("Unexpected call to HostNetworkMock.ReceiveLargePacket. %v %v %v", rp, preRead, r)
	return
}

// ReceiveLargePacketAfterCounter returns a count of finished HostNetworkMock.ReceiveLargePacket invocations
func (mmReceiveLargePacket *HostNetworkMock) ReceiveLargePacketAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveLargePacket.afterReceiveLargePacketCounter)
}

// ReceiveLargePacketBeforeCounter returns a count of HostNetworkMock.ReceiveLargePacket invocations
func (mmReceiveLargePacket *HostNetworkMock) ReceiveLargePacketBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveLargePacket.beforeReceiveLargePacketCounter)
}

// Calls returns a list of arguments used in each call to HostNetworkMock.ReceiveLargePacket.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReceiveLargePacket *mHostNetworkMockReceiveLargePacket) Calls() []*HostNetworkMockReceiveLargePacketParams {
	mmReceiveLargePacket.mutex.RLock()

	argCopy := make([]*HostNetworkMockReceiveLargePacketParams, len(mmReceiveLargePacket.callArgs))
	copy(argCopy, mmReceiveLargePacket.callArgs)

	mmReceiveLargePacket.mutex.RUnlock()

	return argCopy
}

// MinimockReceiveLargePacketDone returns true if the count of the ReceiveLargePacket invocations corresponds
// the number of defined expectations
func (m *HostNetworkMock) MinimockReceiveLargePacketDone() bool {
	for _, e := range m.ReceiveLargePacketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveLargePacketMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveLargePacketCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveLargePacket != nil && mm_atomic.LoadUint64(&m.afterReceiveLargePacketCounter) < 1 {
		return false
	}
	return true
}

// MinimockReceiveLargePacketInspect logs each unmet expectation
func (m *HostNetworkMock) MinimockReceiveLargePacketInspect() {
	for _, e := range m.ReceiveLargePacketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HostNetworkMock.ReceiveLargePacket with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveLargePacketMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveLargePacketCounter) < 1 {
		if m.ReceiveLargePacketMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HostNetworkMock.ReceiveLargePacket")
		} else {
			m.t.Errorf("Expected call to HostNetworkMock.ReceiveLargePacket with params: %#v", *m.ReceiveLargePacketMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveLargePacket != nil && mm_atomic.LoadUint64(&m.afterReceiveLargePacketCounter) < 1 {
		m.t.Error("Expected call to HostNetworkMock.ReceiveLargePacket")
	}
}

type mHostNetworkMockReceiveSmallPacket struct {
	mock               *HostNetworkMock
	defaultExpectation *HostNetworkMockReceiveSmallPacketExpectation
	expectations       []*HostNetworkMockReceiveSmallPacketExpectation

	callArgs []*HostNetworkMockReceiveSmallPacketParams
	mutex    sync.RWMutex
}

// HostNetworkMockReceiveSmallPacketExpectation specifies expectation struct of the HostNetwork.ReceiveSmallPacket
type HostNetworkMockReceiveSmallPacketExpectation struct {
	mock   *HostNetworkMock
	params *HostNetworkMockReceiveSmallPacketParams

	Counter uint64
}

// HostNetworkMockReceiveSmallPacketParams contains parameters of the HostNetwork.ReceiveSmallPacket
type HostNetworkMockReceiveSmallPacketParams struct {
	rp *uniproto.ReceivedPacket
	b  []byte
}

// Expect sets up expected params for HostNetwork.ReceiveSmallPacket
func (mmReceiveSmallPacket *mHostNetworkMockReceiveSmallPacket) Expect(rp *uniproto.ReceivedPacket, b []byte) *mHostNetworkMockReceiveSmallPacket {
	if mmReceiveSmallPacket.mock.funcReceiveSmallPacket != nil {
		mmReceiveSmallPacket.mock.t.Fatalf("HostNetworkMock.ReceiveSmallPacket mock is already set by Set")
	}

	if mmReceiveSmallPacket.defaultExpectation == nil {
		mmReceiveSmallPacket.defaultExpectation = &HostNetworkMockReceiveSmallPacketExpectation{}
	}

	mmReceiveSmallPacket.defaultExpectation.params = &HostNetworkMockReceiveSmallPacketParams{rp, b}
	for _, e := range mmReceiveSmallPacket.expectations {
		if minimock.Equal(e.params, mmReceiveSmallPacket.defaultExpectation.params) {
			mmReceiveSmallPacket.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReceiveSmallPacket.defaultExpectation.params)
		}
	}

	return mmReceiveSmallPacket
}

// Inspect accepts an inspector function that has same arguments as the HostNetwork.ReceiveSmallPacket
func (mmReceiveSmallPacket *mHostNetworkMockReceiveSmallPacket) Inspect(f func(rp *uniproto.ReceivedPacket, b []byte)) *mHostNetworkMockReceiveSmallPacket {
	if mmReceiveSmallPacket.mock.inspectFuncReceiveSmallPacket != nil {
		mmReceiveSmallPacket.mock.t.Fatalf("Inspect function is already set for HostNetworkMock.ReceiveSmallPacket")
	}

	mmReceiveSmallPacket.mock.inspectFuncReceiveSmallPacket = f

	return mmReceiveSmallPacket
}

// Return sets up results that will be returned by HostNetwork.ReceiveSmallPacket
func (mmReceiveSmallPacket *mHostNetworkMockReceiveSmallPacket) Return() *HostNetworkMock {
	if mmReceiveSmallPacket.mock.funcReceiveSmallPacket != nil {
		mmReceiveSmallPacket.mock.t.Fatalf("HostNetworkMock.ReceiveSmallPacket mock is already set by Set")
	}

	if mmReceiveSmallPacket.defaultExpectation == nil {
		mmReceiveSmallPacket.defaultExpectation = &HostNetworkMockReceiveSmallPacketExpectation{mock: mmReceiveSmallPacket.mock}
	}

	return mmReceiveSmallPacket.mock
}

//Set uses given function f to mock the HostNetwork.ReceiveSmallPacket method
func (mmReceiveSmallPacket *mHostNetworkMockReceiveSmallPacket) Set(f func(rp *uniproto.ReceivedPacket, b []byte)) *HostNetworkMock {
	if mmReceiveSmallPacket.defaultExpectation != nil {
		mmReceiveSmallPacket.mock.t.Fatalf("Default expectation is already set for the HostNetwork.ReceiveSmallPacket method")
	}

	if len(mmReceiveSmallPacket.expectations) > 0 {
		mmReceiveSmallPacket.mock.t.Fatalf("Some expectations are already set for the HostNetwork.ReceiveSmallPacket method")
	}

	mmReceiveSmallPacket.mock.funcReceiveSmallPacket = f
	return mmReceiveSmallPacket.mock
}

// ReceiveSmallPacket implements network.HostNetwork
func (mmReceiveSmallPacket *HostNetworkMock) ReceiveSmallPacket(rp *uniproto.ReceivedPacket, b []byte) {
	mm_atomic.AddUint64(&mmReceiveSmallPacket.beforeReceiveSmallPacketCounter, 1)
	defer mm_atomic.AddUint64(&mmReceiveSmallPacket.afterReceiveSmallPacketCounter, 1)

	if mmReceiveSmallPacket.inspectFuncReceiveSmallPacket != nil {
		mmReceiveSmallPacket.inspectFuncReceiveSmallPacket(rp, b)
	}

	mm_params := &HostNetworkMockReceiveSmallPacketParams{rp, b}

	// Record call args
	mmReceiveSmallPacket.ReceiveSmallPacketMock.mutex.Lock()
	mmReceiveSmallPacket.ReceiveSmallPacketMock.callArgs = append(mmReceiveSmallPacket.ReceiveSmallPacketMock.callArgs, mm_params)
	mmReceiveSmallPacket.ReceiveSmallPacketMock.mutex.Unlock()

	for _, e := range mmReceiveSmallPacket.ReceiveSmallPacketMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmReceiveSmallPacket.ReceiveSmallPacketMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReceiveSmallPacket.ReceiveSmallPacketMock.defaultExpectation.Counter, 1)
		mm_want := mmReceiveSmallPacket.ReceiveSmallPacketMock.defaultExpectation.params
		mm_got := HostNetworkMockReceiveSmallPacketParams{rp, b}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReceiveSmallPacket.t.Errorf("HostNetworkMock.ReceiveSmallPacket got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmReceiveSmallPacket.funcReceiveSmallPacket != nil {
		mmReceiveSmallPacket.funcReceiveSmallPacket(rp, b)
		return
	}
	mmReceiveSmallPacket.t.Fatalf("Unexpected call to HostNetworkMock.ReceiveSmallPacket. %v %v", rp, b)

}

// ReceiveSmallPacketAfterCounter returns a count of finished HostNetworkMock.ReceiveSmallPacket invocations
func (mmReceiveSmallPacket *HostNetworkMock) ReceiveSmallPacketAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveSmallPacket.afterReceiveSmallPacketCounter)
}

// ReceiveSmallPacketBeforeCounter returns a count of HostNetworkMock.ReceiveSmallPacket invocations
func (mmReceiveSmallPacket *HostNetworkMock) ReceiveSmallPacketBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveSmallPacket.beforeReceiveSmallPacketCounter)
}

// Calls returns a list of arguments used in each call to HostNetworkMock.ReceiveSmallPacket.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReceiveSmallPacket *mHostNetworkMockReceiveSmallPacket) Calls() []*HostNetworkMockReceiveSmallPacketParams {
	mmReceiveSmallPacket.mutex.RLock()

	argCopy := make([]*HostNetworkMockReceiveSmallPacketParams, len(mmReceiveSmallPacket.callArgs))
	copy(argCopy, mmReceiveSmallPacket.callArgs)

	mmReceiveSmallPacket.mutex.RUnlock()

	return argCopy
}

// MinimockReceiveSmallPacketDone returns true if the count of the ReceiveSmallPacket invocations corresponds
// the number of defined expectations
func (m *HostNetworkMock) MinimockReceiveSmallPacketDone() bool {
	for _, e := range m.ReceiveSmallPacketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveSmallPacketMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveSmallPacketCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveSmallPacket != nil && mm_atomic.LoadUint64(&m.afterReceiveSmallPacketCounter) < 1 {
		return false
	}
	return true
}

// MinimockReceiveSmallPacketInspect logs each unmet expectation
func (m *HostNetworkMock) MinimockReceiveSmallPacketInspect() {
	for _, e := range m.ReceiveSmallPacketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HostNetworkMock.ReceiveSmallPacket with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveSmallPacketMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveSmallPacketCounter) < 1 {
		if m.ReceiveSmallPacketMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HostNetworkMock.ReceiveSmallPacket")
		} else {
			m.t.Errorf("Expected call to HostNetworkMock.ReceiveSmallPacket with params: %#v", *m.ReceiveSmallPacketMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveSmallPacket != nil && mm_atomic.LoadUint64(&m.afterReceiveSmallPacketCounter) < 1 {
		m.t.Error("Expected call to HostNetworkMock.ReceiveSmallPacket")
	}
}

type mHostNetworkMockRegisterRequestHandler struct {
	mock               *HostNetworkMock
	defaultExpectation *HostNetworkMockRegisterRequestHandlerExpectation
	expectations       []*HostNetworkMockRegisterRequestHandlerExpectation

	callArgs []*HostNetworkMockRegisterRequestHandlerParams
	mutex    sync.RWMutex
}

// HostNetworkMockRegisterRequestHandlerExpectation specifies expectation struct of the HostNetwork.RegisterRequestHandler
type HostNetworkMockRegisterRequestHandlerExpectation struct {
	mock   *HostNetworkMock
	params *HostNetworkMockRegisterRequestHandlerParams

	Counter uint64
}

// HostNetworkMockRegisterRequestHandlerParams contains parameters of the HostNetwork.RegisterRequestHandler
type HostNetworkMockRegisterRequestHandlerParams struct {
	t       types.PacketType
	handler mm_network.RequestHandler
}

// Expect sets up expected params for HostNetwork.RegisterRequestHandler
func (mmRegisterRequestHandler *mHostNetworkMockRegisterRequestHandler) Expect(t types.PacketType, handler mm_network.RequestHandler) *mHostNetworkMockRegisterRequestHandler {
	if mmRegisterRequestHandler.mock.funcRegisterRequestHandler != nil {
		mmRegisterRequestHandler.mock.t.Fatalf("HostNetworkMock.RegisterRequestHandler mock is already set by Set")
	}

	if mmRegisterRequestHandler.defaultExpectation == nil {
		mmRegisterRequestHandler.defaultExpectation = &HostNetworkMockRegisterRequestHandlerExpectation{}
	}

	mmRegisterRequestHandler.defaultExpectation.params = &HostNetworkMockRegisterRequestHandlerParams{t, handler}
	for _, e := range mmRegisterRequestHandler.expectations {
		if minimock.Equal(e.params, mmRegisterRequestHandler.defaultExpectation.params) {
			mmRegisterRequestHandler.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterRequestHandler.defaultExpectation.params)
		}
	}

	return mmRegisterRequestHandler
}

// Inspect accepts an inspector function that has same arguments as the HostNetwork.RegisterRequestHandler
func (mmRegisterRequestHandler *mHostNetworkMockRegisterRequestHandler) Inspect(f func(t types.PacketType, handler mm_network.RequestHandler)) *mHostNetworkMockRegisterRequestHandler {
	if mmRegisterRequestHandler.mock.inspectFuncRegisterRequestHandler != nil {
		mmRegisterRequestHandler.mock.t.Fatalf("Inspect function is already set for HostNetworkMock.RegisterRequestHandler")
	}

	mmRegisterRequestHandler.mock.inspectFuncRegisterRequestHandler = f

	return mmRegisterRequestHandler
}

// Return sets up results that will be returned by HostNetwork.RegisterRequestHandler
func (mmRegisterRequestHandler *mHostNetworkMockRegisterRequestHandler) Return() *HostNetworkMock {
	if mmRegisterRequestHandler.mock.funcRegisterRequestHandler != nil {
		mmRegisterRequestHandler.mock.t.Fatalf("HostNetworkMock.RegisterRequestHandler mock is already set by Set")
	}

	if mmRegisterRequestHandler.defaultExpectation == nil {
		mmRegisterRequestHandler.defaultExpectation = &HostNetworkMockRegisterRequestHandlerExpectation{mock: mmRegisterRequestHandler.mock}
	}

	return mmRegisterRequestHandler.mock
}

//Set uses given function f to mock the HostNetwork.RegisterRequestHandler method
func (mmRegisterRequestHandler *mHostNetworkMockRegisterRequestHandler) Set(f func(t types.PacketType, handler mm_network.RequestHandler)) *HostNetworkMock {
	if mmRegisterRequestHandler.defaultExpectation != nil {
		mmRegisterRequestHandler.mock.t.Fatalf("Default expectation is already set for the HostNetwork.RegisterRequestHandler method")
	}

	if len(mmRegisterRequestHandler.expectations) > 0 {
		mmRegisterRequestHandler.mock.t.Fatalf("Some expectations are already set for the HostNetwork.RegisterRequestHandler method")
	}

	mmRegisterRequestHandler.mock.funcRegisterRequestHandler = f
	return mmRegisterRequestHandler.mock
}

// RegisterRequestHandler implements network.HostNetwork
func (mmRegisterRequestHandler *HostNetworkMock) RegisterRequestHandler(t types.PacketType, handler mm_network.RequestHandler) {
	mm_atomic.AddUint64(&mmRegisterRequestHandler.beforeRegisterRequestHandlerCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterRequestHandler.afterRegisterRequestHandlerCounter, 1)

	if mmRegisterRequestHandler.inspectFuncRegisterRequestHandler != nil {
		mmRegisterRequestHandler.inspectFuncRegisterRequestHandler(t, handler)
	}

	mm_params := &HostNetworkMockRegisterRequestHandlerParams{t, handler}

	// Record call args
	mmRegisterRequestHandler.RegisterRequestHandlerMock.mutex.Lock()
	mmRegisterRequestHandler.RegisterRequestHandlerMock.callArgs = append(mmRegisterRequestHandler.RegisterRequestHandlerMock.callArgs, mm_params)
	mmRegisterRequestHandler.RegisterRequestHandlerMock.mutex.Unlock()

	for _, e := range mmRegisterRequestHandler.RegisterRequestHandlerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmRegisterRequestHandler.RegisterRequestHandlerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterRequestHandler.RegisterRequestHandlerMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterRequestHandler.RegisterRequestHandlerMock.defaultExpectation.params
		mm_got := HostNetworkMockRegisterRequestHandlerParams{t, handler}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterRequestHandler.t.Errorf("HostNetworkMock.RegisterRequestHandler got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmRegisterRequestHandler.funcRegisterRequestHandler != nil {
		mmRegisterRequestHandler.funcRegisterRequestHandler(t, handler)
		return
	}
	mmRegisterRequestHandler.t.Fatalf("Unexpected call to HostNetworkMock.RegisterRequestHandler. %v %v", t, handler)

}

// RegisterRequestHandlerAfterCounter returns a count of finished HostNetworkMock.RegisterRequestHandler invocations
func (mmRegisterRequestHandler *HostNetworkMock) RegisterRequestHandlerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterRequestHandler.afterRegisterRequestHandlerCounter)
}

// RegisterRequestHandlerBeforeCounter returns a count of HostNetworkMock.RegisterRequestHandler invocations
func (mmRegisterRequestHandler *HostNetworkMock) RegisterRequestHandlerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterRequestHandler.beforeRegisterRequestHandlerCounter)
}

// Calls returns a list of arguments used in each call to HostNetworkMock.RegisterRequestHandler.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterRequestHandler *mHostNetworkMockRegisterRequestHandler) Calls() []*HostNetworkMockRegisterRequestHandlerParams {
	mmRegisterRequestHandler.mutex.RLock()

	argCopy := make([]*HostNetworkMockRegisterRequestHandlerParams, len(mmRegisterRequestHandler.callArgs))
	copy(argCopy, mmRegisterRequestHandler.callArgs)

	mmRegisterRequestHandler.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterRequestHandlerDone returns true if the count of the RegisterRequestHandler invocations corresponds
// the number of defined expectations
func (m *HostNetworkMock) MinimockRegisterRequestHandlerDone() bool {
	for _, e := range m.RegisterRequestHandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterRequestHandlerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterRequestHandlerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterRequestHandler != nil && mm_atomic.LoadUint64(&m.afterRegisterRequestHandlerCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterRequestHandlerInspect logs each unmet expectation
func (m *HostNetworkMock) MinimockRegisterRequestHandlerInspect() {
	for _, e := range m.RegisterRequestHandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HostNetworkMock.RegisterRequestHandler with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterRequestHandlerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterRequestHandlerCounter) < 1 {
		if m.RegisterRequestHandlerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HostNetworkMock.RegisterRequestHandler")
		} else {
			m.t.Errorf("Expected call to HostNetworkMock.RegisterRequestHandler with params: %#v", *m.RegisterRequestHandlerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterRequestHandler != nil && mm_atomic.LoadUint64(&m.afterRegisterRequestHandlerCounter) < 1 {
		m.t.Error("Expected call to HostNetworkMock.RegisterRequestHandler")
	}
}

type mHostNetworkMockSendRequestToHost struct {
	mock               *HostNetworkMock
	defaultExpectation *HostNetworkMockSendRequestToHostExpectation
	expectations       []*HostNetworkMockSendRequestToHostExpectation

	callArgs []*HostNetworkMockSendRequestToHostParams
	mutex    sync.RWMutex
}

// HostNetworkMockSendRequestToHostExpectation specifies expectation struct of the HostNetwork.SendRequestToHost
type HostNetworkMockSendRequestToHostExpectation struct {
	mock    *HostNetworkMock
	params  *HostNetworkMockSendRequestToHostParams
	results *HostNetworkMockSendRequestToHostResults
	Counter uint64
}

// HostNetworkMockSendRequestToHostParams contains parameters of the HostNetwork.SendRequestToHost
type HostNetworkMockSendRequestToHostParams struct {
	ctx         context.Context
	t           types.PacketType
	requestData interface{}
	receiver    nwapi.Address
}

// HostNetworkMockSendRequestToHostResults contains results of the HostNetwork.SendRequestToHost
type HostNetworkMockSendRequestToHostResults struct {
	f1  mm_network.Future
	err error
}

// Expect sets up expected params for HostNetwork.SendRequestToHost
func (mmSendRequestToHost *mHostNetworkMockSendRequestToHost) Expect(ctx context.Context, t types.PacketType, requestData interface{}, receiver nwapi.Address) *mHostNetworkMockSendRequestToHost {
	if mmSendRequestToHost.mock.funcSendRequestToHost != nil {
		mmSendRequestToHost.mock.t.Fatalf("HostNetworkMock.SendRequestToHost mock is already set by Set")
	}

	if mmSendRequestToHost.defaultExpectation == nil {
		mmSendRequestToHost.defaultExpectation = &HostNetworkMockSendRequestToHostExpectation{}
	}

	mmSendRequestToHost.defaultExpectation.params = &HostNetworkMockSendRequestToHostParams{ctx, t, requestData, receiver}
	for _, e := range mmSendRequestToHost.expectations {
		if minimock.Equal(e.params, mmSendRequestToHost.defaultExpectation.params) {
			mmSendRequestToHost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendRequestToHost.defaultExpectation.params)
		}
	}

	return mmSendRequestToHost
}

// Inspect accepts an inspector function that has same arguments as the HostNetwork.SendRequestToHost
func (mmSendRequestToHost *mHostNetworkMockSendRequestToHost) Inspect(f func(ctx context.Context, t types.PacketType, requestData interface{}, receiver nwapi.Address)) *mHostNetworkMockSendRequestToHost {
	if mmSendRequestToHost.mock.inspectFuncSendRequestToHost != nil {
		mmSendRequestToHost.mock.t.Fatalf("Inspect function is already set for HostNetworkMock.SendRequestToHost")
	}

	mmSendRequestToHost.mock.inspectFuncSendRequestToHost = f

	return mmSendRequestToHost
}

// Return sets up results that will be returned by HostNetwork.SendRequestToHost
func (mmSendRequestToHost *mHostNetworkMockSendRequestToHost) Return(f1 mm_network.Future, err error) *HostNetworkMock {
	if mmSendRequestToHost.mock.funcSendRequestToHost != nil {
		mmSendRequestToHost.mock.t.Fatalf("HostNetworkMock.SendRequestToHost mock is already set by Set")
	}

	if mmSendRequestToHost.defaultExpectation == nil {
		mmSendRequestToHost.defaultExpectation = &HostNetworkMockSendRequestToHostExpectation{mock: mmSendRequestToHost.mock}
	}
	mmSendRequestToHost.defaultExpectation.results = &HostNetworkMockSendRequestToHostResults{f1, err}
	return mmSendRequestToHost.mock
}

//Set uses given function f to mock the HostNetwork.SendRequestToHost method
func (mmSendRequestToHost *mHostNetworkMockSendRequestToHost) Set(f func(ctx context.Context, t types.PacketType, requestData interface{}, receiver nwapi.Address) (f1 mm_network.Future, err error)) *HostNetworkMock {
	if mmSendRequestToHost.defaultExpectation != nil {
		mmSendRequestToHost.mock.t.Fatalf("Default expectation is already set for the HostNetwork.SendRequestToHost method")
	}

	if len(mmSendRequestToHost.expectations) > 0 {
		mmSendRequestToHost.mock.t.Fatalf("Some expectations are already set for the HostNetwork.SendRequestToHost method")
	}

	mmSendRequestToHost.mock.funcSendRequestToHost = f
	return mmSendRequestToHost.mock
}

// When sets expectation for the HostNetwork.SendRequestToHost which will trigger the result defined by the following
// Then helper
func (mmSendRequestToHost *mHostNetworkMockSendRequestToHost) When(ctx context.Context, t types.PacketType, requestData interface{}, receiver nwapi.Address) *HostNetworkMockSendRequestToHostExpectation {
	if mmSendRequestToHost.mock.funcSendRequestToHost != nil {
		mmSendRequestToHost.mock.t.Fatalf("HostNetworkMock.SendRequestToHost mock is already set by Set")
	}

	expectation := &HostNetworkMockSendRequestToHostExpectation{
		mock:   mmSendRequestToHost.mock,
		params: &HostNetworkMockSendRequestToHostParams{ctx, t, requestData, receiver},
	}
	mmSendRequestToHost.expectations = append(mmSendRequestToHost.expectations, expectation)
	return expectation
}

// Then sets up HostNetwork.SendRequestToHost return parameters for the expectation previously defined by the When method
func (e *HostNetworkMockSendRequestToHostExpectation) Then(f1 mm_network.Future, err error) *HostNetworkMock {
	e.results = &HostNetworkMockSendRequestToHostResults{f1, err}
	return e.mock
}

// SendRequestToHost implements network.HostNetwork
func (mmSendRequestToHost *HostNetworkMock) SendRequestToHost(ctx context.Context, t types.PacketType, requestData interface{}, receiver nwapi.Address) (f1 mm_network.Future, err error) {
	mm_atomic.AddUint64(&mmSendRequestToHost.beforeSendRequestToHostCounter, 1)
	defer mm_atomic.AddUint64(&mmSendRequestToHost.afterSendRequestToHostCounter, 1)

	if mmSendRequestToHost.inspectFuncSendRequestToHost != nil {
		mmSendRequestToHost.inspectFuncSendRequestToHost(ctx, t, requestData, receiver)
	}

	mm_params := &HostNetworkMockSendRequestToHostParams{ctx, t, requestData, receiver}

	// Record call args
	mmSendRequestToHost.SendRequestToHostMock.mutex.Lock()
	mmSendRequestToHost.SendRequestToHostMock.callArgs = append(mmSendRequestToHost.SendRequestToHostMock.callArgs, mm_params)
	mmSendRequestToHost.SendRequestToHostMock.mutex.Unlock()

	for _, e := range mmSendRequestToHost.SendRequestToHostMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmSendRequestToHost.SendRequestToHostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendRequestToHost.SendRequestToHostMock.defaultExpectation.Counter, 1)
		mm_want := mmSendRequestToHost.SendRequestToHostMock.defaultExpectation.params
		mm_got := HostNetworkMockSendRequestToHostParams{ctx, t, requestData, receiver}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendRequestToHost.t.Errorf("HostNetworkMock.SendRequestToHost got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendRequestToHost.SendRequestToHostMock.defaultExpectation.results
		if mm_results == nil {
			mmSendRequestToHost.t.Fatal("No results are set for the HostNetworkMock.SendRequestToHost")
		}
		return (*mm_results).f1, (*mm_results).err
	}
	if mmSendRequestToHost.funcSendRequestToHost != nil {
		return mmSendRequestToHost.funcSendRequestToHost(ctx, t, requestData, receiver)
	}
	mmSendRequestToHost.t.Fatalf("Unexpected call to HostNetworkMock.SendRequestToHost. %v %v %v %v", ctx, t, requestData, receiver)
	return
}

// SendRequestToHostAfterCounter returns a count of finished HostNetworkMock.SendRequestToHost invocations
func (mmSendRequestToHost *HostNetworkMock) SendRequestToHostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendRequestToHost.afterSendRequestToHostCounter)
}

// SendRequestToHostBeforeCounter returns a count of HostNetworkMock.SendRequestToHost invocations
func (mmSendRequestToHost *HostNetworkMock) SendRequestToHostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendRequestToHost.beforeSendRequestToHostCounter)
}

// Calls returns a list of arguments used in each call to HostNetworkMock.SendRequestToHost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendRequestToHost *mHostNetworkMockSendRequestToHost) Calls() []*HostNetworkMockSendRequestToHostParams {
	mmSendRequestToHost.mutex.RLock()

	argCopy := make([]*HostNetworkMockSendRequestToHostParams, len(mmSendRequestToHost.callArgs))
	copy(argCopy, mmSendRequestToHost.callArgs)

	mmSendRequestToHost.mutex.RUnlock()

	return argCopy
}

// MinimockSendRequestToHostDone returns true if the count of the SendRequestToHost invocations corresponds
// the number of defined expectations
func (m *HostNetworkMock) MinimockSendRequestToHostDone() bool {
	for _, e := range m.SendRequestToHostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendRequestToHostMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendRequestToHostCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendRequestToHost != nil && mm_atomic.LoadUint64(&m.afterSendRequestToHostCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendRequestToHostInspect logs each unmet expectation
func (m *HostNetworkMock) MinimockSendRequestToHostInspect() {
	for _, e := range m.SendRequestToHostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HostNetworkMock.SendRequestToHost with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendRequestToHostMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendRequestToHostCounter) < 1 {
		if m.SendRequestToHostMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HostNetworkMock.SendRequestToHost")
		} else {
			m.t.Errorf("Expected call to HostNetworkMock.SendRequestToHost with params: %#v", *m.SendRequestToHostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendRequestToHost != nil && mm_atomic.LoadUint64(&m.afterSendRequestToHostCounter) < 1 {
		m.t.Error("Expected call to HostNetworkMock.SendRequestToHost")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *HostNetworkMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBuildResponseInspect()

		m.MinimockReceiveLargePacketInspect()

		m.MinimockReceiveSmallPacketInspect()

		m.MinimockRegisterRequestHandlerInspect()

		m.MinimockSendRequestToHostInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *HostNetworkMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *HostNetworkMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBuildResponseDone() &&
		m.MinimockReceiveLargePacketDone() &&
		m.MinimockReceiveSmallPacketDone() &&
		m.MinimockRegisterRequestHandlerDone() &&
		m.MinimockSendRequestToHostDone()
}
