package beat

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/pulse"
)

// AppenderMock implements Appender
type AppenderMock struct {
	t minimock.Tester

	funcAddCommittedBeat          func(b1 Beat) (err error)
	inspectFuncAddCommittedBeat   func(b1 Beat)
	afterAddCommittedBeatCounter  uint64
	beforeAddCommittedBeatCounter uint64
	AddCommittedBeatMock          mAppenderMockAddCommittedBeat

	funcAddExpectedBeat          func(b1 Beat) (err error)
	inspectFuncAddExpectedBeat   func(b1 Beat)
	afterAddExpectedBeatCounter  uint64
	beforeAddExpectedBeatCounter uint64
	AddExpectedBeatMock          mAppenderMockAddExpectedBeat

	funcEnsureLatestTimeBeat          func(b1 Beat) (err error)
	inspectFuncEnsureLatestTimeBeat   func(b1 Beat)
	afterEnsureLatestTimeBeatCounter  uint64
	beforeEnsureLatestTimeBeatCounter uint64
	EnsureLatestTimeBeatMock          mAppenderMockEnsureLatestTimeBeat

	funcLatestTimeBeat          func() (b1 Beat, err error)
	inspectFuncLatestTimeBeat   func()
	afterLatestTimeBeatCounter  uint64
	beforeLatestTimeBeatCounter uint64
	LatestTimeBeatMock          mAppenderMockLatestTimeBeat

	funcTimeBeat          func(n1 pulse.Number) (b1 Beat, err error)
	inspectFuncTimeBeat   func(n1 pulse.Number)
	afterTimeBeatCounter  uint64
	beforeTimeBeatCounter uint64
	TimeBeatMock          mAppenderMockTimeBeat
}

// NewAppenderMock returns a mock for Appender
func NewAppenderMock(t minimock.Tester) *AppenderMock {
	m := &AppenderMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddCommittedBeatMock = mAppenderMockAddCommittedBeat{mock: m}
	m.AddCommittedBeatMock.callArgs = []*AppenderMockAddCommittedBeatParams{}

	m.AddExpectedBeatMock = mAppenderMockAddExpectedBeat{mock: m}
	m.AddExpectedBeatMock.callArgs = []*AppenderMockAddExpectedBeatParams{}

	m.EnsureLatestTimeBeatMock = mAppenderMockEnsureLatestTimeBeat{mock: m}
	m.EnsureLatestTimeBeatMock.callArgs = []*AppenderMockEnsureLatestTimeBeatParams{}

	m.LatestTimeBeatMock = mAppenderMockLatestTimeBeat{mock: m}

	m.TimeBeatMock = mAppenderMockTimeBeat{mock: m}
	m.TimeBeatMock.callArgs = []*AppenderMockTimeBeatParams{}

	return m
}

type mAppenderMockAddCommittedBeat struct {
	mock               *AppenderMock
	defaultExpectation *AppenderMockAddCommittedBeatExpectation
	expectations       []*AppenderMockAddCommittedBeatExpectation

	callArgs []*AppenderMockAddCommittedBeatParams
	mutex    sync.RWMutex
}

// AppenderMockAddCommittedBeatExpectation specifies expectation struct of the Appender.AddCommittedBeat
type AppenderMockAddCommittedBeatExpectation struct {
	mock    *AppenderMock
	params  *AppenderMockAddCommittedBeatParams
	results *AppenderMockAddCommittedBeatResults
	Counter uint64
}

// AppenderMockAddCommittedBeatParams contains parameters of the Appender.AddCommittedBeat
type AppenderMockAddCommittedBeatParams struct {
	b1 Beat
}

// AppenderMockAddCommittedBeatResults contains results of the Appender.AddCommittedBeat
type AppenderMockAddCommittedBeatResults struct {
	err error
}

// Expect sets up expected params for Appender.AddCommittedBeat
func (mmAddCommittedBeat *mAppenderMockAddCommittedBeat) Expect(b1 Beat) *mAppenderMockAddCommittedBeat {
	if mmAddCommittedBeat.mock.funcAddCommittedBeat != nil {
		mmAddCommittedBeat.mock.t.Fatalf("AppenderMock.AddCommittedBeat mock is already set by Set")
	}

	if mmAddCommittedBeat.defaultExpectation == nil {
		mmAddCommittedBeat.defaultExpectation = &AppenderMockAddCommittedBeatExpectation{}
	}

	mmAddCommittedBeat.defaultExpectation.params = &AppenderMockAddCommittedBeatParams{b1}
	for _, e := range mmAddCommittedBeat.expectations {
		if minimock.Equal(e.params, mmAddCommittedBeat.defaultExpectation.params) {
			mmAddCommittedBeat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddCommittedBeat.defaultExpectation.params)
		}
	}

	return mmAddCommittedBeat
}

// Inspect accepts an inspector function that has same arguments as the Appender.AddCommittedBeat
func (mmAddCommittedBeat *mAppenderMockAddCommittedBeat) Inspect(f func(b1 Beat)) *mAppenderMockAddCommittedBeat {
	if mmAddCommittedBeat.mock.inspectFuncAddCommittedBeat != nil {
		mmAddCommittedBeat.mock.t.Fatalf("Inspect function is already set for AppenderMock.AddCommittedBeat")
	}

	mmAddCommittedBeat.mock.inspectFuncAddCommittedBeat = f

	return mmAddCommittedBeat
}

// Return sets up results that will be returned by Appender.AddCommittedBeat
func (mmAddCommittedBeat *mAppenderMockAddCommittedBeat) Return(err error) *AppenderMock {
	if mmAddCommittedBeat.mock.funcAddCommittedBeat != nil {
		mmAddCommittedBeat.mock.t.Fatalf("AppenderMock.AddCommittedBeat mock is already set by Set")
	}

	if mmAddCommittedBeat.defaultExpectation == nil {
		mmAddCommittedBeat.defaultExpectation = &AppenderMockAddCommittedBeatExpectation{mock: mmAddCommittedBeat.mock}
	}
	mmAddCommittedBeat.defaultExpectation.results = &AppenderMockAddCommittedBeatResults{err}
	return mmAddCommittedBeat.mock
}

//Set uses given function f to mock the Appender.AddCommittedBeat method
func (mmAddCommittedBeat *mAppenderMockAddCommittedBeat) Set(f func(b1 Beat) (err error)) *AppenderMock {
	if mmAddCommittedBeat.defaultExpectation != nil {
		mmAddCommittedBeat.mock.t.Fatalf("Default expectation is already set for the Appender.AddCommittedBeat method")
	}

	if len(mmAddCommittedBeat.expectations) > 0 {
		mmAddCommittedBeat.mock.t.Fatalf("Some expectations are already set for the Appender.AddCommittedBeat method")
	}

	mmAddCommittedBeat.mock.funcAddCommittedBeat = f
	return mmAddCommittedBeat.mock
}

// When sets expectation for the Appender.AddCommittedBeat which will trigger the result defined by the following
// Then helper
func (mmAddCommittedBeat *mAppenderMockAddCommittedBeat) When(b1 Beat) *AppenderMockAddCommittedBeatExpectation {
	if mmAddCommittedBeat.mock.funcAddCommittedBeat != nil {
		mmAddCommittedBeat.mock.t.Fatalf("AppenderMock.AddCommittedBeat mock is already set by Set")
	}

	expectation := &AppenderMockAddCommittedBeatExpectation{
		mock:   mmAddCommittedBeat.mock,
		params: &AppenderMockAddCommittedBeatParams{b1},
	}
	mmAddCommittedBeat.expectations = append(mmAddCommittedBeat.expectations, expectation)
	return expectation
}

// Then sets up Appender.AddCommittedBeat return parameters for the expectation previously defined by the When method
func (e *AppenderMockAddCommittedBeatExpectation) Then(err error) *AppenderMock {
	e.results = &AppenderMockAddCommittedBeatResults{err}
	return e.mock
}

// AddCommittedBeat implements Appender
func (mmAddCommittedBeat *AppenderMock) AddCommittedBeat(b1 Beat) (err error) {
	mm_atomic.AddUint64(&mmAddCommittedBeat.beforeAddCommittedBeatCounter, 1)
	defer mm_atomic.AddUint64(&mmAddCommittedBeat.afterAddCommittedBeatCounter, 1)

	if mmAddCommittedBeat.inspectFuncAddCommittedBeat != nil {
		mmAddCommittedBeat.inspectFuncAddCommittedBeat(b1)
	}

	mm_params := &AppenderMockAddCommittedBeatParams{b1}

	// Record call args
	mmAddCommittedBeat.AddCommittedBeatMock.mutex.Lock()
	mmAddCommittedBeat.AddCommittedBeatMock.callArgs = append(mmAddCommittedBeat.AddCommittedBeatMock.callArgs, mm_params)
	mmAddCommittedBeat.AddCommittedBeatMock.mutex.Unlock()

	for _, e := range mmAddCommittedBeat.AddCommittedBeatMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddCommittedBeat.AddCommittedBeatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddCommittedBeat.AddCommittedBeatMock.defaultExpectation.Counter, 1)
		mm_want := mmAddCommittedBeat.AddCommittedBeatMock.defaultExpectation.params
		mm_got := AppenderMockAddCommittedBeatParams{b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddCommittedBeat.t.Errorf("AppenderMock.AddCommittedBeat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddCommittedBeat.AddCommittedBeatMock.defaultExpectation.results
		if mm_results == nil {
			mmAddCommittedBeat.t.Fatal("No results are set for the AppenderMock.AddCommittedBeat")
		}
		return (*mm_results).err
	}
	if mmAddCommittedBeat.funcAddCommittedBeat != nil {
		return mmAddCommittedBeat.funcAddCommittedBeat(b1)
	}
	mmAddCommittedBeat.t.Fatalf("Unexpected call to AppenderMock.AddCommittedBeat. %v", b1)
	return
}

// AddCommittedBeatAfterCounter returns a count of finished AppenderMock.AddCommittedBeat invocations
func (mmAddCommittedBeat *AppenderMock) AddCommittedBeatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCommittedBeat.afterAddCommittedBeatCounter)
}

// AddCommittedBeatBeforeCounter returns a count of AppenderMock.AddCommittedBeat invocations
func (mmAddCommittedBeat *AppenderMock) AddCommittedBeatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCommittedBeat.beforeAddCommittedBeatCounter)
}

// Calls returns a list of arguments used in each call to AppenderMock.AddCommittedBeat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddCommittedBeat *mAppenderMockAddCommittedBeat) Calls() []*AppenderMockAddCommittedBeatParams {
	mmAddCommittedBeat.mutex.RLock()

	argCopy := make([]*AppenderMockAddCommittedBeatParams, len(mmAddCommittedBeat.callArgs))
	copy(argCopy, mmAddCommittedBeat.callArgs)

	mmAddCommittedBeat.mutex.RUnlock()

	return argCopy
}

// MinimockAddCommittedBeatDone returns true if the count of the AddCommittedBeat invocations corresponds
// the number of defined expectations
func (m *AppenderMock) MinimockAddCommittedBeatDone() bool {
	for _, e := range m.AddCommittedBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddCommittedBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCommittedBeatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddCommittedBeat != nil && mm_atomic.LoadUint64(&m.afterAddCommittedBeatCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddCommittedBeatInspect logs each unmet expectation
func (m *AppenderMock) MinimockAddCommittedBeatInspect() {
	for _, e := range m.AddCommittedBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppenderMock.AddCommittedBeat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddCommittedBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCommittedBeatCounter) < 1 {
		if m.AddCommittedBeatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AppenderMock.AddCommittedBeat")
		} else {
			m.t.Errorf("Expected call to AppenderMock.AddCommittedBeat with params: %#v", *m.AddCommittedBeatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddCommittedBeat != nil && mm_atomic.LoadUint64(&m.afterAddCommittedBeatCounter) < 1 {
		m.t.Error("Expected call to AppenderMock.AddCommittedBeat")
	}
}

type mAppenderMockAddExpectedBeat struct {
	mock               *AppenderMock
	defaultExpectation *AppenderMockAddExpectedBeatExpectation
	expectations       []*AppenderMockAddExpectedBeatExpectation

	callArgs []*AppenderMockAddExpectedBeatParams
	mutex    sync.RWMutex
}

// AppenderMockAddExpectedBeatExpectation specifies expectation struct of the Appender.AddExpectedBeat
type AppenderMockAddExpectedBeatExpectation struct {
	mock    *AppenderMock
	params  *AppenderMockAddExpectedBeatParams
	results *AppenderMockAddExpectedBeatResults
	Counter uint64
}

// AppenderMockAddExpectedBeatParams contains parameters of the Appender.AddExpectedBeat
type AppenderMockAddExpectedBeatParams struct {
	b1 Beat
}

// AppenderMockAddExpectedBeatResults contains results of the Appender.AddExpectedBeat
type AppenderMockAddExpectedBeatResults struct {
	err error
}

// Expect sets up expected params for Appender.AddExpectedBeat
func (mmAddExpectedBeat *mAppenderMockAddExpectedBeat) Expect(b1 Beat) *mAppenderMockAddExpectedBeat {
	if mmAddExpectedBeat.mock.funcAddExpectedBeat != nil {
		mmAddExpectedBeat.mock.t.Fatalf("AppenderMock.AddExpectedBeat mock is already set by Set")
	}

	if mmAddExpectedBeat.defaultExpectation == nil {
		mmAddExpectedBeat.defaultExpectation = &AppenderMockAddExpectedBeatExpectation{}
	}

	mmAddExpectedBeat.defaultExpectation.params = &AppenderMockAddExpectedBeatParams{b1}
	for _, e := range mmAddExpectedBeat.expectations {
		if minimock.Equal(e.params, mmAddExpectedBeat.defaultExpectation.params) {
			mmAddExpectedBeat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddExpectedBeat.defaultExpectation.params)
		}
	}

	return mmAddExpectedBeat
}

// Inspect accepts an inspector function that has same arguments as the Appender.AddExpectedBeat
func (mmAddExpectedBeat *mAppenderMockAddExpectedBeat) Inspect(f func(b1 Beat)) *mAppenderMockAddExpectedBeat {
	if mmAddExpectedBeat.mock.inspectFuncAddExpectedBeat != nil {
		mmAddExpectedBeat.mock.t.Fatalf("Inspect function is already set for AppenderMock.AddExpectedBeat")
	}

	mmAddExpectedBeat.mock.inspectFuncAddExpectedBeat = f

	return mmAddExpectedBeat
}

// Return sets up results that will be returned by Appender.AddExpectedBeat
func (mmAddExpectedBeat *mAppenderMockAddExpectedBeat) Return(err error) *AppenderMock {
	if mmAddExpectedBeat.mock.funcAddExpectedBeat != nil {
		mmAddExpectedBeat.mock.t.Fatalf("AppenderMock.AddExpectedBeat mock is already set by Set")
	}

	if mmAddExpectedBeat.defaultExpectation == nil {
		mmAddExpectedBeat.defaultExpectation = &AppenderMockAddExpectedBeatExpectation{mock: mmAddExpectedBeat.mock}
	}
	mmAddExpectedBeat.defaultExpectation.results = &AppenderMockAddExpectedBeatResults{err}
	return mmAddExpectedBeat.mock
}

//Set uses given function f to mock the Appender.AddExpectedBeat method
func (mmAddExpectedBeat *mAppenderMockAddExpectedBeat) Set(f func(b1 Beat) (err error)) *AppenderMock {
	if mmAddExpectedBeat.defaultExpectation != nil {
		mmAddExpectedBeat.mock.t.Fatalf("Default expectation is already set for the Appender.AddExpectedBeat method")
	}

	if len(mmAddExpectedBeat.expectations) > 0 {
		mmAddExpectedBeat.mock.t.Fatalf("Some expectations are already set for the Appender.AddExpectedBeat method")
	}

	mmAddExpectedBeat.mock.funcAddExpectedBeat = f
	return mmAddExpectedBeat.mock
}

// When sets expectation for the Appender.AddExpectedBeat which will trigger the result defined by the following
// Then helper
func (mmAddExpectedBeat *mAppenderMockAddExpectedBeat) When(b1 Beat) *AppenderMockAddExpectedBeatExpectation {
	if mmAddExpectedBeat.mock.funcAddExpectedBeat != nil {
		mmAddExpectedBeat.mock.t.Fatalf("AppenderMock.AddExpectedBeat mock is already set by Set")
	}

	expectation := &AppenderMockAddExpectedBeatExpectation{
		mock:   mmAddExpectedBeat.mock,
		params: &AppenderMockAddExpectedBeatParams{b1},
	}
	mmAddExpectedBeat.expectations = append(mmAddExpectedBeat.expectations, expectation)
	return expectation
}

// Then sets up Appender.AddExpectedBeat return parameters for the expectation previously defined by the When method
func (e *AppenderMockAddExpectedBeatExpectation) Then(err error) *AppenderMock {
	e.results = &AppenderMockAddExpectedBeatResults{err}
	return e.mock
}

// AddExpectedBeat implements Appender
func (mmAddExpectedBeat *AppenderMock) AddExpectedBeat(b1 Beat) (err error) {
	mm_atomic.AddUint64(&mmAddExpectedBeat.beforeAddExpectedBeatCounter, 1)
	defer mm_atomic.AddUint64(&mmAddExpectedBeat.afterAddExpectedBeatCounter, 1)

	if mmAddExpectedBeat.inspectFuncAddExpectedBeat != nil {
		mmAddExpectedBeat.inspectFuncAddExpectedBeat(b1)
	}

	mm_params := &AppenderMockAddExpectedBeatParams{b1}

	// Record call args
	mmAddExpectedBeat.AddExpectedBeatMock.mutex.Lock()
	mmAddExpectedBeat.AddExpectedBeatMock.callArgs = append(mmAddExpectedBeat.AddExpectedBeatMock.callArgs, mm_params)
	mmAddExpectedBeat.AddExpectedBeatMock.mutex.Unlock()

	for _, e := range mmAddExpectedBeat.AddExpectedBeatMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddExpectedBeat.AddExpectedBeatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddExpectedBeat.AddExpectedBeatMock.defaultExpectation.Counter, 1)
		mm_want := mmAddExpectedBeat.AddExpectedBeatMock.defaultExpectation.params
		mm_got := AppenderMockAddExpectedBeatParams{b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddExpectedBeat.t.Errorf("AppenderMock.AddExpectedBeat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddExpectedBeat.AddExpectedBeatMock.defaultExpectation.results
		if mm_results == nil {
			mmAddExpectedBeat.t.Fatal("No results are set for the AppenderMock.AddExpectedBeat")
		}
		return (*mm_results).err
	}
	if mmAddExpectedBeat.funcAddExpectedBeat != nil {
		return mmAddExpectedBeat.funcAddExpectedBeat(b1)
	}
	mmAddExpectedBeat.t.Fatalf("Unexpected call to AppenderMock.AddExpectedBeat. %v", b1)
	return
}

// AddExpectedBeatAfterCounter returns a count of finished AppenderMock.AddExpectedBeat invocations
func (mmAddExpectedBeat *AppenderMock) AddExpectedBeatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddExpectedBeat.afterAddExpectedBeatCounter)
}

// AddExpectedBeatBeforeCounter returns a count of AppenderMock.AddExpectedBeat invocations
func (mmAddExpectedBeat *AppenderMock) AddExpectedBeatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddExpectedBeat.beforeAddExpectedBeatCounter)
}

// Calls returns a list of arguments used in each call to AppenderMock.AddExpectedBeat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddExpectedBeat *mAppenderMockAddExpectedBeat) Calls() []*AppenderMockAddExpectedBeatParams {
	mmAddExpectedBeat.mutex.RLock()

	argCopy := make([]*AppenderMockAddExpectedBeatParams, len(mmAddExpectedBeat.callArgs))
	copy(argCopy, mmAddExpectedBeat.callArgs)

	mmAddExpectedBeat.mutex.RUnlock()

	return argCopy
}

// MinimockAddExpectedBeatDone returns true if the count of the AddExpectedBeat invocations corresponds
// the number of defined expectations
func (m *AppenderMock) MinimockAddExpectedBeatDone() bool {
	for _, e := range m.AddExpectedBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddExpectedBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddExpectedBeatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddExpectedBeat != nil && mm_atomic.LoadUint64(&m.afterAddExpectedBeatCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddExpectedBeatInspect logs each unmet expectation
func (m *AppenderMock) MinimockAddExpectedBeatInspect() {
	for _, e := range m.AddExpectedBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppenderMock.AddExpectedBeat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddExpectedBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddExpectedBeatCounter) < 1 {
		if m.AddExpectedBeatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AppenderMock.AddExpectedBeat")
		} else {
			m.t.Errorf("Expected call to AppenderMock.AddExpectedBeat with params: %#v", *m.AddExpectedBeatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddExpectedBeat != nil && mm_atomic.LoadUint64(&m.afterAddExpectedBeatCounter) < 1 {
		m.t.Error("Expected call to AppenderMock.AddExpectedBeat")
	}
}

type mAppenderMockEnsureLatestTimeBeat struct {
	mock               *AppenderMock
	defaultExpectation *AppenderMockEnsureLatestTimeBeatExpectation
	expectations       []*AppenderMockEnsureLatestTimeBeatExpectation

	callArgs []*AppenderMockEnsureLatestTimeBeatParams
	mutex    sync.RWMutex
}

// AppenderMockEnsureLatestTimeBeatExpectation specifies expectation struct of the Appender.EnsureLatestTimeBeat
type AppenderMockEnsureLatestTimeBeatExpectation struct {
	mock    *AppenderMock
	params  *AppenderMockEnsureLatestTimeBeatParams
	results *AppenderMockEnsureLatestTimeBeatResults
	Counter uint64
}

// AppenderMockEnsureLatestTimeBeatParams contains parameters of the Appender.EnsureLatestTimeBeat
type AppenderMockEnsureLatestTimeBeatParams struct {
	b1 Beat
}

// AppenderMockEnsureLatestTimeBeatResults contains results of the Appender.EnsureLatestTimeBeat
type AppenderMockEnsureLatestTimeBeatResults struct {
	err error
}

// Expect sets up expected params for Appender.EnsureLatestTimeBeat
func (mmEnsureLatestTimeBeat *mAppenderMockEnsureLatestTimeBeat) Expect(b1 Beat) *mAppenderMockEnsureLatestTimeBeat {
	if mmEnsureLatestTimeBeat.mock.funcEnsureLatestTimeBeat != nil {
		mmEnsureLatestTimeBeat.mock.t.Fatalf("AppenderMock.EnsureLatestTimeBeat mock is already set by Set")
	}

	if mmEnsureLatestTimeBeat.defaultExpectation == nil {
		mmEnsureLatestTimeBeat.defaultExpectation = &AppenderMockEnsureLatestTimeBeatExpectation{}
	}

	mmEnsureLatestTimeBeat.defaultExpectation.params = &AppenderMockEnsureLatestTimeBeatParams{b1}
	for _, e := range mmEnsureLatestTimeBeat.expectations {
		if minimock.Equal(e.params, mmEnsureLatestTimeBeat.defaultExpectation.params) {
			mmEnsureLatestTimeBeat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEnsureLatestTimeBeat.defaultExpectation.params)
		}
	}

	return mmEnsureLatestTimeBeat
}

// Inspect accepts an inspector function that has same arguments as the Appender.EnsureLatestTimeBeat
func (mmEnsureLatestTimeBeat *mAppenderMockEnsureLatestTimeBeat) Inspect(f func(b1 Beat)) *mAppenderMockEnsureLatestTimeBeat {
	if mmEnsureLatestTimeBeat.mock.inspectFuncEnsureLatestTimeBeat != nil {
		mmEnsureLatestTimeBeat.mock.t.Fatalf("Inspect function is already set for AppenderMock.EnsureLatestTimeBeat")
	}

	mmEnsureLatestTimeBeat.mock.inspectFuncEnsureLatestTimeBeat = f

	return mmEnsureLatestTimeBeat
}

// Return sets up results that will be returned by Appender.EnsureLatestTimeBeat
func (mmEnsureLatestTimeBeat *mAppenderMockEnsureLatestTimeBeat) Return(err error) *AppenderMock {
	if mmEnsureLatestTimeBeat.mock.funcEnsureLatestTimeBeat != nil {
		mmEnsureLatestTimeBeat.mock.t.Fatalf("AppenderMock.EnsureLatestTimeBeat mock is already set by Set")
	}

	if mmEnsureLatestTimeBeat.defaultExpectation == nil {
		mmEnsureLatestTimeBeat.defaultExpectation = &AppenderMockEnsureLatestTimeBeatExpectation{mock: mmEnsureLatestTimeBeat.mock}
	}
	mmEnsureLatestTimeBeat.defaultExpectation.results = &AppenderMockEnsureLatestTimeBeatResults{err}
	return mmEnsureLatestTimeBeat.mock
}

//Set uses given function f to mock the Appender.EnsureLatestTimeBeat method
func (mmEnsureLatestTimeBeat *mAppenderMockEnsureLatestTimeBeat) Set(f func(b1 Beat) (err error)) *AppenderMock {
	if mmEnsureLatestTimeBeat.defaultExpectation != nil {
		mmEnsureLatestTimeBeat.mock.t.Fatalf("Default expectation is already set for the Appender.EnsureLatestTimeBeat method")
	}

	if len(mmEnsureLatestTimeBeat.expectations) > 0 {
		mmEnsureLatestTimeBeat.mock.t.Fatalf("Some expectations are already set for the Appender.EnsureLatestTimeBeat method")
	}

	mmEnsureLatestTimeBeat.mock.funcEnsureLatestTimeBeat = f
	return mmEnsureLatestTimeBeat.mock
}

// When sets expectation for the Appender.EnsureLatestTimeBeat which will trigger the result defined by the following
// Then helper
func (mmEnsureLatestTimeBeat *mAppenderMockEnsureLatestTimeBeat) When(b1 Beat) *AppenderMockEnsureLatestTimeBeatExpectation {
	if mmEnsureLatestTimeBeat.mock.funcEnsureLatestTimeBeat != nil {
		mmEnsureLatestTimeBeat.mock.t.Fatalf("AppenderMock.EnsureLatestTimeBeat mock is already set by Set")
	}

	expectation := &AppenderMockEnsureLatestTimeBeatExpectation{
		mock:   mmEnsureLatestTimeBeat.mock,
		params: &AppenderMockEnsureLatestTimeBeatParams{b1},
	}
	mmEnsureLatestTimeBeat.expectations = append(mmEnsureLatestTimeBeat.expectations, expectation)
	return expectation
}

// Then sets up Appender.EnsureLatestTimeBeat return parameters for the expectation previously defined by the When method
func (e *AppenderMockEnsureLatestTimeBeatExpectation) Then(err error) *AppenderMock {
	e.results = &AppenderMockEnsureLatestTimeBeatResults{err}
	return e.mock
}

// EnsureLatestTimeBeat implements Appender
func (mmEnsureLatestTimeBeat *AppenderMock) EnsureLatestTimeBeat(b1 Beat) (err error) {
	mm_atomic.AddUint64(&mmEnsureLatestTimeBeat.beforeEnsureLatestTimeBeatCounter, 1)
	defer mm_atomic.AddUint64(&mmEnsureLatestTimeBeat.afterEnsureLatestTimeBeatCounter, 1)

	if mmEnsureLatestTimeBeat.inspectFuncEnsureLatestTimeBeat != nil {
		mmEnsureLatestTimeBeat.inspectFuncEnsureLatestTimeBeat(b1)
	}

	mm_params := &AppenderMockEnsureLatestTimeBeatParams{b1}

	// Record call args
	mmEnsureLatestTimeBeat.EnsureLatestTimeBeatMock.mutex.Lock()
	mmEnsureLatestTimeBeat.EnsureLatestTimeBeatMock.callArgs = append(mmEnsureLatestTimeBeat.EnsureLatestTimeBeatMock.callArgs, mm_params)
	mmEnsureLatestTimeBeat.EnsureLatestTimeBeatMock.mutex.Unlock()

	for _, e := range mmEnsureLatestTimeBeat.EnsureLatestTimeBeatMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmEnsureLatestTimeBeat.EnsureLatestTimeBeatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEnsureLatestTimeBeat.EnsureLatestTimeBeatMock.defaultExpectation.Counter, 1)
		mm_want := mmEnsureLatestTimeBeat.EnsureLatestTimeBeatMock.defaultExpectation.params
		mm_got := AppenderMockEnsureLatestTimeBeatParams{b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEnsureLatestTimeBeat.t.Errorf("AppenderMock.EnsureLatestTimeBeat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEnsureLatestTimeBeat.EnsureLatestTimeBeatMock.defaultExpectation.results
		if mm_results == nil {
			mmEnsureLatestTimeBeat.t.Fatal("No results are set for the AppenderMock.EnsureLatestTimeBeat")
		}
		return (*mm_results).err
	}
	if mmEnsureLatestTimeBeat.funcEnsureLatestTimeBeat != nil {
		return mmEnsureLatestTimeBeat.funcEnsureLatestTimeBeat(b1)
	}
	mmEnsureLatestTimeBeat.t.Fatalf("Unexpected call to AppenderMock.EnsureLatestTimeBeat. %v", b1)
	return
}

// EnsureLatestTimeBeatAfterCounter returns a count of finished AppenderMock.EnsureLatestTimeBeat invocations
func (mmEnsureLatestTimeBeat *AppenderMock) EnsureLatestTimeBeatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnsureLatestTimeBeat.afterEnsureLatestTimeBeatCounter)
}

// EnsureLatestTimeBeatBeforeCounter returns a count of AppenderMock.EnsureLatestTimeBeat invocations
func (mmEnsureLatestTimeBeat *AppenderMock) EnsureLatestTimeBeatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnsureLatestTimeBeat.beforeEnsureLatestTimeBeatCounter)
}

// Calls returns a list of arguments used in each call to AppenderMock.EnsureLatestTimeBeat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEnsureLatestTimeBeat *mAppenderMockEnsureLatestTimeBeat) Calls() []*AppenderMockEnsureLatestTimeBeatParams {
	mmEnsureLatestTimeBeat.mutex.RLock()

	argCopy := make([]*AppenderMockEnsureLatestTimeBeatParams, len(mmEnsureLatestTimeBeat.callArgs))
	copy(argCopy, mmEnsureLatestTimeBeat.callArgs)

	mmEnsureLatestTimeBeat.mutex.RUnlock()

	return argCopy
}

// MinimockEnsureLatestTimeBeatDone returns true if the count of the EnsureLatestTimeBeat invocations corresponds
// the number of defined expectations
func (m *AppenderMock) MinimockEnsureLatestTimeBeatDone() bool {
	for _, e := range m.EnsureLatestTimeBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EnsureLatestTimeBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEnsureLatestTimeBeatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnsureLatestTimeBeat != nil && mm_atomic.LoadUint64(&m.afterEnsureLatestTimeBeatCounter) < 1 {
		return false
	}
	return true
}

// MinimockEnsureLatestTimeBeatInspect logs each unmet expectation
func (m *AppenderMock) MinimockEnsureLatestTimeBeatInspect() {
	for _, e := range m.EnsureLatestTimeBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppenderMock.EnsureLatestTimeBeat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EnsureLatestTimeBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEnsureLatestTimeBeatCounter) < 1 {
		if m.EnsureLatestTimeBeatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AppenderMock.EnsureLatestTimeBeat")
		} else {
			m.t.Errorf("Expected call to AppenderMock.EnsureLatestTimeBeat with params: %#v", *m.EnsureLatestTimeBeatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnsureLatestTimeBeat != nil && mm_atomic.LoadUint64(&m.afterEnsureLatestTimeBeatCounter) < 1 {
		m.t.Error("Expected call to AppenderMock.EnsureLatestTimeBeat")
	}
}

type mAppenderMockLatestTimeBeat struct {
	mock               *AppenderMock
	defaultExpectation *AppenderMockLatestTimeBeatExpectation
	expectations       []*AppenderMockLatestTimeBeatExpectation
}

// AppenderMockLatestTimeBeatExpectation specifies expectation struct of the Appender.LatestTimeBeat
type AppenderMockLatestTimeBeatExpectation struct {
	mock *AppenderMock

	results *AppenderMockLatestTimeBeatResults
	Counter uint64
}

// AppenderMockLatestTimeBeatResults contains results of the Appender.LatestTimeBeat
type AppenderMockLatestTimeBeatResults struct {
	b1  Beat
	err error
}

// Expect sets up expected params for Appender.LatestTimeBeat
func (mmLatestTimeBeat *mAppenderMockLatestTimeBeat) Expect() *mAppenderMockLatestTimeBeat {
	if mmLatestTimeBeat.mock.funcLatestTimeBeat != nil {
		mmLatestTimeBeat.mock.t.Fatalf("AppenderMock.LatestTimeBeat mock is already set by Set")
	}

	if mmLatestTimeBeat.defaultExpectation == nil {
		mmLatestTimeBeat.defaultExpectation = &AppenderMockLatestTimeBeatExpectation{}
	}

	return mmLatestTimeBeat
}

// Inspect accepts an inspector function that has same arguments as the Appender.LatestTimeBeat
func (mmLatestTimeBeat *mAppenderMockLatestTimeBeat) Inspect(f func()) *mAppenderMockLatestTimeBeat {
	if mmLatestTimeBeat.mock.inspectFuncLatestTimeBeat != nil {
		mmLatestTimeBeat.mock.t.Fatalf("Inspect function is already set for AppenderMock.LatestTimeBeat")
	}

	mmLatestTimeBeat.mock.inspectFuncLatestTimeBeat = f

	return mmLatestTimeBeat
}

// Return sets up results that will be returned by Appender.LatestTimeBeat
func (mmLatestTimeBeat *mAppenderMockLatestTimeBeat) Return(b1 Beat, err error) *AppenderMock {
	if mmLatestTimeBeat.mock.funcLatestTimeBeat != nil {
		mmLatestTimeBeat.mock.t.Fatalf("AppenderMock.LatestTimeBeat mock is already set by Set")
	}

	if mmLatestTimeBeat.defaultExpectation == nil {
		mmLatestTimeBeat.defaultExpectation = &AppenderMockLatestTimeBeatExpectation{mock: mmLatestTimeBeat.mock}
	}
	mmLatestTimeBeat.defaultExpectation.results = &AppenderMockLatestTimeBeatResults{b1, err}
	return mmLatestTimeBeat.mock
}

//Set uses given function f to mock the Appender.LatestTimeBeat method
func (mmLatestTimeBeat *mAppenderMockLatestTimeBeat) Set(f func() (b1 Beat, err error)) *AppenderMock {
	if mmLatestTimeBeat.defaultExpectation != nil {
		mmLatestTimeBeat.mock.t.Fatalf("Default expectation is already set for the Appender.LatestTimeBeat method")
	}

	if len(mmLatestTimeBeat.expectations) > 0 {
		mmLatestTimeBeat.mock.t.Fatalf("Some expectations are already set for the Appender.LatestTimeBeat method")
	}

	mmLatestTimeBeat.mock.funcLatestTimeBeat = f
	return mmLatestTimeBeat.mock
}

// LatestTimeBeat implements Appender
func (mmLatestTimeBeat *AppenderMock) LatestTimeBeat() (b1 Beat, err error) {
	mm_atomic.AddUint64(&mmLatestTimeBeat.beforeLatestTimeBeatCounter, 1)
	defer mm_atomic.AddUint64(&mmLatestTimeBeat.afterLatestTimeBeatCounter, 1)

	if mmLatestTimeBeat.inspectFuncLatestTimeBeat != nil {
		mmLatestTimeBeat.inspectFuncLatestTimeBeat()
	}

	if mmLatestTimeBeat.LatestTimeBeatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLatestTimeBeat.LatestTimeBeatMock.defaultExpectation.Counter, 1)

		mm_results := mmLatestTimeBeat.LatestTimeBeatMock.defaultExpectation.results
		if mm_results == nil {
			mmLatestTimeBeat.t.Fatal("No results are set for the AppenderMock.LatestTimeBeat")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmLatestTimeBeat.funcLatestTimeBeat != nil {
		return mmLatestTimeBeat.funcLatestTimeBeat()
	}
	mmLatestTimeBeat.t.Fatalf("Unexpected call to AppenderMock.LatestTimeBeat.")
	return
}

// LatestTimeBeatAfterCounter returns a count of finished AppenderMock.LatestTimeBeat invocations
func (mmLatestTimeBeat *AppenderMock) LatestTimeBeatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLatestTimeBeat.afterLatestTimeBeatCounter)
}

// LatestTimeBeatBeforeCounter returns a count of AppenderMock.LatestTimeBeat invocations
func (mmLatestTimeBeat *AppenderMock) LatestTimeBeatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLatestTimeBeat.beforeLatestTimeBeatCounter)
}

// MinimockLatestTimeBeatDone returns true if the count of the LatestTimeBeat invocations corresponds
// the number of defined expectations
func (m *AppenderMock) MinimockLatestTimeBeatDone() bool {
	for _, e := range m.LatestTimeBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LatestTimeBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLatestTimeBeatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLatestTimeBeat != nil && mm_atomic.LoadUint64(&m.afterLatestTimeBeatCounter) < 1 {
		return false
	}
	return true
}

// MinimockLatestTimeBeatInspect logs each unmet expectation
func (m *AppenderMock) MinimockLatestTimeBeatInspect() {
	for _, e := range m.LatestTimeBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AppenderMock.LatestTimeBeat")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LatestTimeBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLatestTimeBeatCounter) < 1 {
		m.t.Error("Expected call to AppenderMock.LatestTimeBeat")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLatestTimeBeat != nil && mm_atomic.LoadUint64(&m.afterLatestTimeBeatCounter) < 1 {
		m.t.Error("Expected call to AppenderMock.LatestTimeBeat")
	}
}

type mAppenderMockTimeBeat struct {
	mock               *AppenderMock
	defaultExpectation *AppenderMockTimeBeatExpectation
	expectations       []*AppenderMockTimeBeatExpectation

	callArgs []*AppenderMockTimeBeatParams
	mutex    sync.RWMutex
}

// AppenderMockTimeBeatExpectation specifies expectation struct of the Appender.TimeBeat
type AppenderMockTimeBeatExpectation struct {
	mock    *AppenderMock
	params  *AppenderMockTimeBeatParams
	results *AppenderMockTimeBeatResults
	Counter uint64
}

// AppenderMockTimeBeatParams contains parameters of the Appender.TimeBeat
type AppenderMockTimeBeatParams struct {
	n1 pulse.Number
}

// AppenderMockTimeBeatResults contains results of the Appender.TimeBeat
type AppenderMockTimeBeatResults struct {
	b1  Beat
	err error
}

// Expect sets up expected params for Appender.TimeBeat
func (mmTimeBeat *mAppenderMockTimeBeat) Expect(n1 pulse.Number) *mAppenderMockTimeBeat {
	if mmTimeBeat.mock.funcTimeBeat != nil {
		mmTimeBeat.mock.t.Fatalf("AppenderMock.TimeBeat mock is already set by Set")
	}

	if mmTimeBeat.defaultExpectation == nil {
		mmTimeBeat.defaultExpectation = &AppenderMockTimeBeatExpectation{}
	}

	mmTimeBeat.defaultExpectation.params = &AppenderMockTimeBeatParams{n1}
	for _, e := range mmTimeBeat.expectations {
		if minimock.Equal(e.params, mmTimeBeat.defaultExpectation.params) {
			mmTimeBeat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTimeBeat.defaultExpectation.params)
		}
	}

	return mmTimeBeat
}

// Inspect accepts an inspector function that has same arguments as the Appender.TimeBeat
func (mmTimeBeat *mAppenderMockTimeBeat) Inspect(f func(n1 pulse.Number)) *mAppenderMockTimeBeat {
	if mmTimeBeat.mock.inspectFuncTimeBeat != nil {
		mmTimeBeat.mock.t.Fatalf("Inspect function is already set for AppenderMock.TimeBeat")
	}

	mmTimeBeat.mock.inspectFuncTimeBeat = f

	return mmTimeBeat
}

// Return sets up results that will be returned by Appender.TimeBeat
func (mmTimeBeat *mAppenderMockTimeBeat) Return(b1 Beat, err error) *AppenderMock {
	if mmTimeBeat.mock.funcTimeBeat != nil {
		mmTimeBeat.mock.t.Fatalf("AppenderMock.TimeBeat mock is already set by Set")
	}

	if mmTimeBeat.defaultExpectation == nil {
		mmTimeBeat.defaultExpectation = &AppenderMockTimeBeatExpectation{mock: mmTimeBeat.mock}
	}
	mmTimeBeat.defaultExpectation.results = &AppenderMockTimeBeatResults{b1, err}
	return mmTimeBeat.mock
}

//Set uses given function f to mock the Appender.TimeBeat method
func (mmTimeBeat *mAppenderMockTimeBeat) Set(f func(n1 pulse.Number) (b1 Beat, err error)) *AppenderMock {
	if mmTimeBeat.defaultExpectation != nil {
		mmTimeBeat.mock.t.Fatalf("Default expectation is already set for the Appender.TimeBeat method")
	}

	if len(mmTimeBeat.expectations) > 0 {
		mmTimeBeat.mock.t.Fatalf("Some expectations are already set for the Appender.TimeBeat method")
	}

	mmTimeBeat.mock.funcTimeBeat = f
	return mmTimeBeat.mock
}

// When sets expectation for the Appender.TimeBeat which will trigger the result defined by the following
// Then helper
func (mmTimeBeat *mAppenderMockTimeBeat) When(n1 pulse.Number) *AppenderMockTimeBeatExpectation {
	if mmTimeBeat.mock.funcTimeBeat != nil {
		mmTimeBeat.mock.t.Fatalf("AppenderMock.TimeBeat mock is already set by Set")
	}

	expectation := &AppenderMockTimeBeatExpectation{
		mock:   mmTimeBeat.mock,
		params: &AppenderMockTimeBeatParams{n1},
	}
	mmTimeBeat.expectations = append(mmTimeBeat.expectations, expectation)
	return expectation
}

// Then sets up Appender.TimeBeat return parameters for the expectation previously defined by the When method
func (e *AppenderMockTimeBeatExpectation) Then(b1 Beat, err error) *AppenderMock {
	e.results = &AppenderMockTimeBeatResults{b1, err}
	return e.mock
}

// TimeBeat implements Appender
func (mmTimeBeat *AppenderMock) TimeBeat(n1 pulse.Number) (b1 Beat, err error) {
	mm_atomic.AddUint64(&mmTimeBeat.beforeTimeBeatCounter, 1)
	defer mm_atomic.AddUint64(&mmTimeBeat.afterTimeBeatCounter, 1)

	if mmTimeBeat.inspectFuncTimeBeat != nil {
		mmTimeBeat.inspectFuncTimeBeat(n1)
	}

	mm_params := &AppenderMockTimeBeatParams{n1}

	// Record call args
	mmTimeBeat.TimeBeatMock.mutex.Lock()
	mmTimeBeat.TimeBeatMock.callArgs = append(mmTimeBeat.TimeBeatMock.callArgs, mm_params)
	mmTimeBeat.TimeBeatMock.mutex.Unlock()

	for _, e := range mmTimeBeat.TimeBeatMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmTimeBeat.TimeBeatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTimeBeat.TimeBeatMock.defaultExpectation.Counter, 1)
		mm_want := mmTimeBeat.TimeBeatMock.defaultExpectation.params
		mm_got := AppenderMockTimeBeatParams{n1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTimeBeat.t.Errorf("AppenderMock.TimeBeat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTimeBeat.TimeBeatMock.defaultExpectation.results
		if mm_results == nil {
			mmTimeBeat.t.Fatal("No results are set for the AppenderMock.TimeBeat")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmTimeBeat.funcTimeBeat != nil {
		return mmTimeBeat.funcTimeBeat(n1)
	}
	mmTimeBeat.t.Fatalf("Unexpected call to AppenderMock.TimeBeat. %v", n1)
	return
}

// TimeBeatAfterCounter returns a count of finished AppenderMock.TimeBeat invocations
func (mmTimeBeat *AppenderMock) TimeBeatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTimeBeat.afterTimeBeatCounter)
}

// TimeBeatBeforeCounter returns a count of AppenderMock.TimeBeat invocations
func (mmTimeBeat *AppenderMock) TimeBeatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTimeBeat.beforeTimeBeatCounter)
}

// Calls returns a list of arguments used in each call to AppenderMock.TimeBeat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTimeBeat *mAppenderMockTimeBeat) Calls() []*AppenderMockTimeBeatParams {
	mmTimeBeat.mutex.RLock()

	argCopy := make([]*AppenderMockTimeBeatParams, len(mmTimeBeat.callArgs))
	copy(argCopy, mmTimeBeat.callArgs)

	mmTimeBeat.mutex.RUnlock()

	return argCopy
}

// MinimockTimeBeatDone returns true if the count of the TimeBeat invocations corresponds
// the number of defined expectations
func (m *AppenderMock) MinimockTimeBeatDone() bool {
	for _, e := range m.TimeBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TimeBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTimeBeatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTimeBeat != nil && mm_atomic.LoadUint64(&m.afterTimeBeatCounter) < 1 {
		return false
	}
	return true
}

// MinimockTimeBeatInspect logs each unmet expectation
func (m *AppenderMock) MinimockTimeBeatInspect() {
	for _, e := range m.TimeBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppenderMock.TimeBeat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TimeBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTimeBeatCounter) < 1 {
		if m.TimeBeatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AppenderMock.TimeBeat")
		} else {
			m.t.Errorf("Expected call to AppenderMock.TimeBeat with params: %#v", *m.TimeBeatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTimeBeat != nil && mm_atomic.LoadUint64(&m.afterTimeBeatCounter) < 1 {
		m.t.Error("Expected call to AppenderMock.TimeBeat")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AppenderMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddCommittedBeatInspect()

		m.MinimockAddExpectedBeatInspect()

		m.MinimockEnsureLatestTimeBeatInspect()

		m.MinimockLatestTimeBeatInspect()

		m.MinimockTimeBeatInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AppenderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AppenderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddCommittedBeatDone() &&
		m.MinimockAddExpectedBeatDone() &&
		m.MinimockEnsureLatestTimeBeatDone() &&
		m.MinimockLatestTimeBeatDone() &&
		m.MinimockTimeBeatDone()
}
