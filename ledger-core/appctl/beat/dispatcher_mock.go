package beat

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// DispatcherMock implements Dispatcher
type DispatcherMock struct {
	t minimock.Tester

	funcCancelBeat          func()
	inspectFuncCancelBeat   func()
	afterCancelBeatCounter  uint64
	beforeCancelBeatCounter uint64
	CancelBeatMock          mDispatcherMockCancelBeat

	funcCommitBeat          func(b1 Beat)
	inspectFuncCommitBeat   func(b1 Beat)
	afterCommitBeatCounter  uint64
	beforeCommitBeatCounter uint64
	CommitBeatMock          mDispatcherMockCommitBeat

	funcPrepareBeat          func(a1 Ack)
	inspectFuncPrepareBeat   func(a1 Ack)
	afterPrepareBeatCounter  uint64
	beforePrepareBeatCounter uint64
	PrepareBeatMock          mDispatcherMockPrepareBeat

	funcProcess          func(msg *Message) (err error)
	inspectFuncProcess   func(msg *Message)
	afterProcessCounter  uint64
	beforeProcessCounter uint64
	ProcessMock          mDispatcherMockProcess
}

// NewDispatcherMock returns a mock for Dispatcher
func NewDispatcherMock(t minimock.Tester) *DispatcherMock {
	m := &DispatcherMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CancelBeatMock = mDispatcherMockCancelBeat{mock: m}

	m.CommitBeatMock = mDispatcherMockCommitBeat{mock: m}
	m.CommitBeatMock.callArgs = []*DispatcherMockCommitBeatParams{}

	m.PrepareBeatMock = mDispatcherMockPrepareBeat{mock: m}
	m.PrepareBeatMock.callArgs = []*DispatcherMockPrepareBeatParams{}

	m.ProcessMock = mDispatcherMockProcess{mock: m}
	m.ProcessMock.callArgs = []*DispatcherMockProcessParams{}

	return m
}

type mDispatcherMockCancelBeat struct {
	mock               *DispatcherMock
	defaultExpectation *DispatcherMockCancelBeatExpectation
	expectations       []*DispatcherMockCancelBeatExpectation
}

// DispatcherMockCancelBeatExpectation specifies expectation struct of the Dispatcher.CancelBeat
type DispatcherMockCancelBeatExpectation struct {
	mock *DispatcherMock

	Counter uint64
}

// Expect sets up expected params for Dispatcher.CancelBeat
func (mmCancelBeat *mDispatcherMockCancelBeat) Expect() *mDispatcherMockCancelBeat {
	if mmCancelBeat.mock.funcCancelBeat != nil {
		mmCancelBeat.mock.t.Fatalf("DispatcherMock.CancelBeat mock is already set by Set")
	}

	if mmCancelBeat.defaultExpectation == nil {
		mmCancelBeat.defaultExpectation = &DispatcherMockCancelBeatExpectation{}
	}

	return mmCancelBeat
}

// Inspect accepts an inspector function that has same arguments as the Dispatcher.CancelBeat
func (mmCancelBeat *mDispatcherMockCancelBeat) Inspect(f func()) *mDispatcherMockCancelBeat {
	if mmCancelBeat.mock.inspectFuncCancelBeat != nil {
		mmCancelBeat.mock.t.Fatalf("Inspect function is already set for DispatcherMock.CancelBeat")
	}

	mmCancelBeat.mock.inspectFuncCancelBeat = f

	return mmCancelBeat
}

// Return sets up results that will be returned by Dispatcher.CancelBeat
func (mmCancelBeat *mDispatcherMockCancelBeat) Return() *DispatcherMock {
	if mmCancelBeat.mock.funcCancelBeat != nil {
		mmCancelBeat.mock.t.Fatalf("DispatcherMock.CancelBeat mock is already set by Set")
	}

	if mmCancelBeat.defaultExpectation == nil {
		mmCancelBeat.defaultExpectation = &DispatcherMockCancelBeatExpectation{mock: mmCancelBeat.mock}
	}

	return mmCancelBeat.mock
}

//Set uses given function f to mock the Dispatcher.CancelBeat method
func (mmCancelBeat *mDispatcherMockCancelBeat) Set(f func()) *DispatcherMock {
	if mmCancelBeat.defaultExpectation != nil {
		mmCancelBeat.mock.t.Fatalf("Default expectation is already set for the Dispatcher.CancelBeat method")
	}

	if len(mmCancelBeat.expectations) > 0 {
		mmCancelBeat.mock.t.Fatalf("Some expectations are already set for the Dispatcher.CancelBeat method")
	}

	mmCancelBeat.mock.funcCancelBeat = f
	return mmCancelBeat.mock
}

// CancelBeat implements Dispatcher
func (mmCancelBeat *DispatcherMock) CancelBeat() {
	mm_atomic.AddUint64(&mmCancelBeat.beforeCancelBeatCounter, 1)
	defer mm_atomic.AddUint64(&mmCancelBeat.afterCancelBeatCounter, 1)

	if mmCancelBeat.inspectFuncCancelBeat != nil {
		mmCancelBeat.inspectFuncCancelBeat()
	}

	if mmCancelBeat.CancelBeatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancelBeat.CancelBeatMock.defaultExpectation.Counter, 1)

		return

	}
	if mmCancelBeat.funcCancelBeat != nil {
		mmCancelBeat.funcCancelBeat()
		return
	}
	mmCancelBeat.t.Fatalf("Unexpected call to DispatcherMock.CancelBeat.")

}

// CancelBeatAfterCounter returns a count of finished DispatcherMock.CancelBeat invocations
func (mmCancelBeat *DispatcherMock) CancelBeatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelBeat.afterCancelBeatCounter)
}

// CancelBeatBeforeCounter returns a count of DispatcherMock.CancelBeat invocations
func (mmCancelBeat *DispatcherMock) CancelBeatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelBeat.beforeCancelBeatCounter)
}

// MinimockCancelBeatDone returns true if the count of the CancelBeat invocations corresponds
// the number of defined expectations
func (m *DispatcherMock) MinimockCancelBeatDone() bool {
	for _, e := range m.CancelBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelBeatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelBeat != nil && mm_atomic.LoadUint64(&m.afterCancelBeatCounter) < 1 {
		return false
	}
	return true
}

// MinimockCancelBeatInspect logs each unmet expectation
func (m *DispatcherMock) MinimockCancelBeatInspect() {
	for _, e := range m.CancelBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DispatcherMock.CancelBeat")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelBeatCounter) < 1 {
		m.t.Error("Expected call to DispatcherMock.CancelBeat")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelBeat != nil && mm_atomic.LoadUint64(&m.afterCancelBeatCounter) < 1 {
		m.t.Error("Expected call to DispatcherMock.CancelBeat")
	}
}

type mDispatcherMockCommitBeat struct {
	mock               *DispatcherMock
	defaultExpectation *DispatcherMockCommitBeatExpectation
	expectations       []*DispatcherMockCommitBeatExpectation

	callArgs []*DispatcherMockCommitBeatParams
	mutex    sync.RWMutex
}

// DispatcherMockCommitBeatExpectation specifies expectation struct of the Dispatcher.CommitBeat
type DispatcherMockCommitBeatExpectation struct {
	mock   *DispatcherMock
	params *DispatcherMockCommitBeatParams

	Counter uint64
}

// DispatcherMockCommitBeatParams contains parameters of the Dispatcher.CommitBeat
type DispatcherMockCommitBeatParams struct {
	b1 Beat
}

// Expect sets up expected params for Dispatcher.CommitBeat
func (mmCommitBeat *mDispatcherMockCommitBeat) Expect(b1 Beat) *mDispatcherMockCommitBeat {
	if mmCommitBeat.mock.funcCommitBeat != nil {
		mmCommitBeat.mock.t.Fatalf("DispatcherMock.CommitBeat mock is already set by Set")
	}

	if mmCommitBeat.defaultExpectation == nil {
		mmCommitBeat.defaultExpectation = &DispatcherMockCommitBeatExpectation{}
	}

	mmCommitBeat.defaultExpectation.params = &DispatcherMockCommitBeatParams{b1}
	for _, e := range mmCommitBeat.expectations {
		if minimock.Equal(e.params, mmCommitBeat.defaultExpectation.params) {
			mmCommitBeat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommitBeat.defaultExpectation.params)
		}
	}

	return mmCommitBeat
}

// Inspect accepts an inspector function that has same arguments as the Dispatcher.CommitBeat
func (mmCommitBeat *mDispatcherMockCommitBeat) Inspect(f func(b1 Beat)) *mDispatcherMockCommitBeat {
	if mmCommitBeat.mock.inspectFuncCommitBeat != nil {
		mmCommitBeat.mock.t.Fatalf("Inspect function is already set for DispatcherMock.CommitBeat")
	}

	mmCommitBeat.mock.inspectFuncCommitBeat = f

	return mmCommitBeat
}

// Return sets up results that will be returned by Dispatcher.CommitBeat
func (mmCommitBeat *mDispatcherMockCommitBeat) Return() *DispatcherMock {
	if mmCommitBeat.mock.funcCommitBeat != nil {
		mmCommitBeat.mock.t.Fatalf("DispatcherMock.CommitBeat mock is already set by Set")
	}

	if mmCommitBeat.defaultExpectation == nil {
		mmCommitBeat.defaultExpectation = &DispatcherMockCommitBeatExpectation{mock: mmCommitBeat.mock}
	}

	return mmCommitBeat.mock
}

//Set uses given function f to mock the Dispatcher.CommitBeat method
func (mmCommitBeat *mDispatcherMockCommitBeat) Set(f func(b1 Beat)) *DispatcherMock {
	if mmCommitBeat.defaultExpectation != nil {
		mmCommitBeat.mock.t.Fatalf("Default expectation is already set for the Dispatcher.CommitBeat method")
	}

	if len(mmCommitBeat.expectations) > 0 {
		mmCommitBeat.mock.t.Fatalf("Some expectations are already set for the Dispatcher.CommitBeat method")
	}

	mmCommitBeat.mock.funcCommitBeat = f
	return mmCommitBeat.mock
}

// CommitBeat implements Dispatcher
func (mmCommitBeat *DispatcherMock) CommitBeat(b1 Beat) {
	mm_atomic.AddUint64(&mmCommitBeat.beforeCommitBeatCounter, 1)
	defer mm_atomic.AddUint64(&mmCommitBeat.afterCommitBeatCounter, 1)

	if mmCommitBeat.inspectFuncCommitBeat != nil {
		mmCommitBeat.inspectFuncCommitBeat(b1)
	}

	mm_params := &DispatcherMockCommitBeatParams{b1}

	// Record call args
	mmCommitBeat.CommitBeatMock.mutex.Lock()
	mmCommitBeat.CommitBeatMock.callArgs = append(mmCommitBeat.CommitBeatMock.callArgs, mm_params)
	mmCommitBeat.CommitBeatMock.mutex.Unlock()

	for _, e := range mmCommitBeat.CommitBeatMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmCommitBeat.CommitBeatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommitBeat.CommitBeatMock.defaultExpectation.Counter, 1)
		mm_want := mmCommitBeat.CommitBeatMock.defaultExpectation.params
		mm_got := DispatcherMockCommitBeatParams{b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCommitBeat.t.Errorf("DispatcherMock.CommitBeat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmCommitBeat.funcCommitBeat != nil {
		mmCommitBeat.funcCommitBeat(b1)
		return
	}
	mmCommitBeat.t.Fatalf("Unexpected call to DispatcherMock.CommitBeat. %v", b1)

}

// CommitBeatAfterCounter returns a count of finished DispatcherMock.CommitBeat invocations
func (mmCommitBeat *DispatcherMock) CommitBeatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommitBeat.afterCommitBeatCounter)
}

// CommitBeatBeforeCounter returns a count of DispatcherMock.CommitBeat invocations
func (mmCommitBeat *DispatcherMock) CommitBeatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommitBeat.beforeCommitBeatCounter)
}

// Calls returns a list of arguments used in each call to DispatcherMock.CommitBeat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommitBeat *mDispatcherMockCommitBeat) Calls() []*DispatcherMockCommitBeatParams {
	mmCommitBeat.mutex.RLock()

	argCopy := make([]*DispatcherMockCommitBeatParams, len(mmCommitBeat.callArgs))
	copy(argCopy, mmCommitBeat.callArgs)

	mmCommitBeat.mutex.RUnlock()

	return argCopy
}

// MinimockCommitBeatDone returns true if the count of the CommitBeat invocations corresponds
// the number of defined expectations
func (m *DispatcherMock) MinimockCommitBeatDone() bool {
	for _, e := range m.CommitBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitBeatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommitBeat != nil && mm_atomic.LoadUint64(&m.afterCommitBeatCounter) < 1 {
		return false
	}
	return true
}

// MinimockCommitBeatInspect logs each unmet expectation
func (m *DispatcherMock) MinimockCommitBeatInspect() {
	for _, e := range m.CommitBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DispatcherMock.CommitBeat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitBeatCounter) < 1 {
		if m.CommitBeatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DispatcherMock.CommitBeat")
		} else {
			m.t.Errorf("Expected call to DispatcherMock.CommitBeat with params: %#v", *m.CommitBeatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommitBeat != nil && mm_atomic.LoadUint64(&m.afterCommitBeatCounter) < 1 {
		m.t.Error("Expected call to DispatcherMock.CommitBeat")
	}
}

type mDispatcherMockPrepareBeat struct {
	mock               *DispatcherMock
	defaultExpectation *DispatcherMockPrepareBeatExpectation
	expectations       []*DispatcherMockPrepareBeatExpectation

	callArgs []*DispatcherMockPrepareBeatParams
	mutex    sync.RWMutex
}

// DispatcherMockPrepareBeatExpectation specifies expectation struct of the Dispatcher.PrepareBeat
type DispatcherMockPrepareBeatExpectation struct {
	mock   *DispatcherMock
	params *DispatcherMockPrepareBeatParams

	Counter uint64
}

// DispatcherMockPrepareBeatParams contains parameters of the Dispatcher.PrepareBeat
type DispatcherMockPrepareBeatParams struct {
	a1 Ack
}

// Expect sets up expected params for Dispatcher.PrepareBeat
func (mmPrepareBeat *mDispatcherMockPrepareBeat) Expect(a1 Ack) *mDispatcherMockPrepareBeat {
	if mmPrepareBeat.mock.funcPrepareBeat != nil {
		mmPrepareBeat.mock.t.Fatalf("DispatcherMock.PrepareBeat mock is already set by Set")
	}

	if mmPrepareBeat.defaultExpectation == nil {
		mmPrepareBeat.defaultExpectation = &DispatcherMockPrepareBeatExpectation{}
	}

	mmPrepareBeat.defaultExpectation.params = &DispatcherMockPrepareBeatParams{a1}
	for _, e := range mmPrepareBeat.expectations {
		if minimock.Equal(e.params, mmPrepareBeat.defaultExpectation.params) {
			mmPrepareBeat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrepareBeat.defaultExpectation.params)
		}
	}

	return mmPrepareBeat
}

// Inspect accepts an inspector function that has same arguments as the Dispatcher.PrepareBeat
func (mmPrepareBeat *mDispatcherMockPrepareBeat) Inspect(f func(a1 Ack)) *mDispatcherMockPrepareBeat {
	if mmPrepareBeat.mock.inspectFuncPrepareBeat != nil {
		mmPrepareBeat.mock.t.Fatalf("Inspect function is already set for DispatcherMock.PrepareBeat")
	}

	mmPrepareBeat.mock.inspectFuncPrepareBeat = f

	return mmPrepareBeat
}

// Return sets up results that will be returned by Dispatcher.PrepareBeat
func (mmPrepareBeat *mDispatcherMockPrepareBeat) Return() *DispatcherMock {
	if mmPrepareBeat.mock.funcPrepareBeat != nil {
		mmPrepareBeat.mock.t.Fatalf("DispatcherMock.PrepareBeat mock is already set by Set")
	}

	if mmPrepareBeat.defaultExpectation == nil {
		mmPrepareBeat.defaultExpectation = &DispatcherMockPrepareBeatExpectation{mock: mmPrepareBeat.mock}
	}

	return mmPrepareBeat.mock
}

//Set uses given function f to mock the Dispatcher.PrepareBeat method
func (mmPrepareBeat *mDispatcherMockPrepareBeat) Set(f func(a1 Ack)) *DispatcherMock {
	if mmPrepareBeat.defaultExpectation != nil {
		mmPrepareBeat.mock.t.Fatalf("Default expectation is already set for the Dispatcher.PrepareBeat method")
	}

	if len(mmPrepareBeat.expectations) > 0 {
		mmPrepareBeat.mock.t.Fatalf("Some expectations are already set for the Dispatcher.PrepareBeat method")
	}

	mmPrepareBeat.mock.funcPrepareBeat = f
	return mmPrepareBeat.mock
}

// PrepareBeat implements Dispatcher
func (mmPrepareBeat *DispatcherMock) PrepareBeat(a1 Ack) {
	mm_atomic.AddUint64(&mmPrepareBeat.beforePrepareBeatCounter, 1)
	defer mm_atomic.AddUint64(&mmPrepareBeat.afterPrepareBeatCounter, 1)

	if mmPrepareBeat.inspectFuncPrepareBeat != nil {
		mmPrepareBeat.inspectFuncPrepareBeat(a1)
	}

	mm_params := &DispatcherMockPrepareBeatParams{a1}

	// Record call args
	mmPrepareBeat.PrepareBeatMock.mutex.Lock()
	mmPrepareBeat.PrepareBeatMock.callArgs = append(mmPrepareBeat.PrepareBeatMock.callArgs, mm_params)
	mmPrepareBeat.PrepareBeatMock.mutex.Unlock()

	for _, e := range mmPrepareBeat.PrepareBeatMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPrepareBeat.PrepareBeatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrepareBeat.PrepareBeatMock.defaultExpectation.Counter, 1)
		mm_want := mmPrepareBeat.PrepareBeatMock.defaultExpectation.params
		mm_got := DispatcherMockPrepareBeatParams{a1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrepareBeat.t.Errorf("DispatcherMock.PrepareBeat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPrepareBeat.funcPrepareBeat != nil {
		mmPrepareBeat.funcPrepareBeat(a1)
		return
	}
	mmPrepareBeat.t.Fatalf("Unexpected call to DispatcherMock.PrepareBeat. %v", a1)

}

// PrepareBeatAfterCounter returns a count of finished DispatcherMock.PrepareBeat invocations
func (mmPrepareBeat *DispatcherMock) PrepareBeatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepareBeat.afterPrepareBeatCounter)
}

// PrepareBeatBeforeCounter returns a count of DispatcherMock.PrepareBeat invocations
func (mmPrepareBeat *DispatcherMock) PrepareBeatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepareBeat.beforePrepareBeatCounter)
}

// Calls returns a list of arguments used in each call to DispatcherMock.PrepareBeat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrepareBeat *mDispatcherMockPrepareBeat) Calls() []*DispatcherMockPrepareBeatParams {
	mmPrepareBeat.mutex.RLock()

	argCopy := make([]*DispatcherMockPrepareBeatParams, len(mmPrepareBeat.callArgs))
	copy(argCopy, mmPrepareBeat.callArgs)

	mmPrepareBeat.mutex.RUnlock()

	return argCopy
}

// MinimockPrepareBeatDone returns true if the count of the PrepareBeat invocations corresponds
// the number of defined expectations
func (m *DispatcherMock) MinimockPrepareBeatDone() bool {
	for _, e := range m.PrepareBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrepareBeatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepareBeat != nil && mm_atomic.LoadUint64(&m.afterPrepareBeatCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrepareBeatInspect logs each unmet expectation
func (m *DispatcherMock) MinimockPrepareBeatInspect() {
	for _, e := range m.PrepareBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DispatcherMock.PrepareBeat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrepareBeatCounter) < 1 {
		if m.PrepareBeatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DispatcherMock.PrepareBeat")
		} else {
			m.t.Errorf("Expected call to DispatcherMock.PrepareBeat with params: %#v", *m.PrepareBeatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepareBeat != nil && mm_atomic.LoadUint64(&m.afterPrepareBeatCounter) < 1 {
		m.t.Error("Expected call to DispatcherMock.PrepareBeat")
	}
}

type mDispatcherMockProcess struct {
	mock               *DispatcherMock
	defaultExpectation *DispatcherMockProcessExpectation
	expectations       []*DispatcherMockProcessExpectation

	callArgs []*DispatcherMockProcessParams
	mutex    sync.RWMutex
}

// DispatcherMockProcessExpectation specifies expectation struct of the Dispatcher.Process
type DispatcherMockProcessExpectation struct {
	mock    *DispatcherMock
	params  *DispatcherMockProcessParams
	results *DispatcherMockProcessResults
	Counter uint64
}

// DispatcherMockProcessParams contains parameters of the Dispatcher.Process
type DispatcherMockProcessParams struct {
	msg *Message
}

// DispatcherMockProcessResults contains results of the Dispatcher.Process
type DispatcherMockProcessResults struct {
	err error
}

// Expect sets up expected params for Dispatcher.Process
func (mmProcess *mDispatcherMockProcess) Expect(msg *Message) *mDispatcherMockProcess {
	if mmProcess.mock.funcProcess != nil {
		mmProcess.mock.t.Fatalf("DispatcherMock.Process mock is already set by Set")
	}

	if mmProcess.defaultExpectation == nil {
		mmProcess.defaultExpectation = &DispatcherMockProcessExpectation{}
	}

	mmProcess.defaultExpectation.params = &DispatcherMockProcessParams{msg}
	for _, e := range mmProcess.expectations {
		if minimock.Equal(e.params, mmProcess.defaultExpectation.params) {
			mmProcess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcess.defaultExpectation.params)
		}
	}

	return mmProcess
}

// Inspect accepts an inspector function that has same arguments as the Dispatcher.Process
func (mmProcess *mDispatcherMockProcess) Inspect(f func(msg *Message)) *mDispatcherMockProcess {
	if mmProcess.mock.inspectFuncProcess != nil {
		mmProcess.mock.t.Fatalf("Inspect function is already set for DispatcherMock.Process")
	}

	mmProcess.mock.inspectFuncProcess = f

	return mmProcess
}

// Return sets up results that will be returned by Dispatcher.Process
func (mmProcess *mDispatcherMockProcess) Return(err error) *DispatcherMock {
	if mmProcess.mock.funcProcess != nil {
		mmProcess.mock.t.Fatalf("DispatcherMock.Process mock is already set by Set")
	}

	if mmProcess.defaultExpectation == nil {
		mmProcess.defaultExpectation = &DispatcherMockProcessExpectation{mock: mmProcess.mock}
	}
	mmProcess.defaultExpectation.results = &DispatcherMockProcessResults{err}
	return mmProcess.mock
}

//Set uses given function f to mock the Dispatcher.Process method
func (mmProcess *mDispatcherMockProcess) Set(f func(msg *Message) (err error)) *DispatcherMock {
	if mmProcess.defaultExpectation != nil {
		mmProcess.mock.t.Fatalf("Default expectation is already set for the Dispatcher.Process method")
	}

	if len(mmProcess.expectations) > 0 {
		mmProcess.mock.t.Fatalf("Some expectations are already set for the Dispatcher.Process method")
	}

	mmProcess.mock.funcProcess = f
	return mmProcess.mock
}

// When sets expectation for the Dispatcher.Process which will trigger the result defined by the following
// Then helper
func (mmProcess *mDispatcherMockProcess) When(msg *Message) *DispatcherMockProcessExpectation {
	if mmProcess.mock.funcProcess != nil {
		mmProcess.mock.t.Fatalf("DispatcherMock.Process mock is already set by Set")
	}

	expectation := &DispatcherMockProcessExpectation{
		mock:   mmProcess.mock,
		params: &DispatcherMockProcessParams{msg},
	}
	mmProcess.expectations = append(mmProcess.expectations, expectation)
	return expectation
}

// Then sets up Dispatcher.Process return parameters for the expectation previously defined by the When method
func (e *DispatcherMockProcessExpectation) Then(err error) *DispatcherMock {
	e.results = &DispatcherMockProcessResults{err}
	return e.mock
}

// Process implements Dispatcher
func (mmProcess *DispatcherMock) Process(msg *Message) (err error) {
	mm_atomic.AddUint64(&mmProcess.beforeProcessCounter, 1)
	defer mm_atomic.AddUint64(&mmProcess.afterProcessCounter, 1)

	if mmProcess.inspectFuncProcess != nil {
		mmProcess.inspectFuncProcess(msg)
	}

	mm_params := &DispatcherMockProcessParams{msg}

	// Record call args
	mmProcess.ProcessMock.mutex.Lock()
	mmProcess.ProcessMock.callArgs = append(mmProcess.ProcessMock.callArgs, mm_params)
	mmProcess.ProcessMock.mutex.Unlock()

	for _, e := range mmProcess.ProcessMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmProcess.ProcessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcess.ProcessMock.defaultExpectation.Counter, 1)
		mm_want := mmProcess.ProcessMock.defaultExpectation.params
		mm_got := DispatcherMockProcessParams{msg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProcess.t.Errorf("DispatcherMock.Process got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmProcess.ProcessMock.defaultExpectation.results
		if mm_results == nil {
			mmProcess.t.Fatal("No results are set for the DispatcherMock.Process")
		}
		return (*mm_results).err
	}
	if mmProcess.funcProcess != nil {
		return mmProcess.funcProcess(msg)
	}
	mmProcess.t.Fatalf("Unexpected call to DispatcherMock.Process. %v", msg)
	return
}

// ProcessAfterCounter returns a count of finished DispatcherMock.Process invocations
func (mmProcess *DispatcherMock) ProcessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcess.afterProcessCounter)
}

// ProcessBeforeCounter returns a count of DispatcherMock.Process invocations
func (mmProcess *DispatcherMock) ProcessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcess.beforeProcessCounter)
}

// Calls returns a list of arguments used in each call to DispatcherMock.Process.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcess *mDispatcherMockProcess) Calls() []*DispatcherMockProcessParams {
	mmProcess.mutex.RLock()

	argCopy := make([]*DispatcherMockProcessParams, len(mmProcess.callArgs))
	copy(argCopy, mmProcess.callArgs)

	mmProcess.mutex.RUnlock()

	return argCopy
}

// MinimockProcessDone returns true if the count of the Process invocations corresponds
// the number of defined expectations
func (m *DispatcherMock) MinimockProcessDone() bool {
	for _, e := range m.ProcessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProcessCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcess != nil && mm_atomic.LoadUint64(&m.afterProcessCounter) < 1 {
		return false
	}
	return true
}

// MinimockProcessInspect logs each unmet expectation
func (m *DispatcherMock) MinimockProcessInspect() {
	for _, e := range m.ProcessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DispatcherMock.Process with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProcessCounter) < 1 {
		if m.ProcessMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DispatcherMock.Process")
		} else {
			m.t.Errorf("Expected call to DispatcherMock.Process with params: %#v", *m.ProcessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcess != nil && mm_atomic.LoadUint64(&m.afterProcessCounter) < 1 {
		m.t.Error("Expected call to DispatcherMock.Process")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DispatcherMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCancelBeatInspect()

		m.MinimockCommitBeatInspect()

		m.MinimockPrepareBeatInspect()

		m.MinimockProcessInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DispatcherMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DispatcherMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCancelBeatDone() &&
		m.MinimockCommitBeatDone() &&
		m.MinimockPrepareBeatDone() &&
		m.MinimockProcessDone()
}
