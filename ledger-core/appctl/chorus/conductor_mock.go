package chorus

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/appctl/beat"
)

// ConductorMock implements Conductor
type ConductorMock struct {
	t minimock.Tester

	funcCancelNodeState          func()
	inspectFuncCancelNodeState   func()
	afterCancelNodeStateCounter  uint64
	beforeCancelNodeStateCounter uint64
	CancelNodeStateMock          mConductorMockCancelNodeState

	funcCommitFirstPulseChange          func(b1 beat.Beat) (err error)
	inspectFuncCommitFirstPulseChange   func(b1 beat.Beat)
	afterCommitFirstPulseChangeCounter  uint64
	beforeCommitFirstPulseChangeCounter uint64
	CommitFirstPulseChangeMock          mConductorMockCommitFirstPulseChange

	funcCommitPulseChange          func(b1 beat.Beat) (err error)
	inspectFuncCommitPulseChange   func(b1 beat.Beat)
	afterCommitPulseChangeCounter  uint64
	beforeCommitPulseChangeCounter uint64
	CommitPulseChangeMock          mConductorMockCommitPulseChange

	funcRequestNodeState          func(n1 NodeStateFunc)
	inspectFuncRequestNodeState   func(n1 NodeStateFunc)
	afterRequestNodeStateCounter  uint64
	beforeRequestNodeStateCounter uint64
	RequestNodeStateMock          mConductorMockRequestNodeState
}

// NewConductorMock returns a mock for Conductor
func NewConductorMock(t minimock.Tester) *ConductorMock {
	m := &ConductorMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CancelNodeStateMock = mConductorMockCancelNodeState{mock: m}

	m.CommitFirstPulseChangeMock = mConductorMockCommitFirstPulseChange{mock: m}
	m.CommitFirstPulseChangeMock.callArgs = []*ConductorMockCommitFirstPulseChangeParams{}

	m.CommitPulseChangeMock = mConductorMockCommitPulseChange{mock: m}
	m.CommitPulseChangeMock.callArgs = []*ConductorMockCommitPulseChangeParams{}

	m.RequestNodeStateMock = mConductorMockRequestNodeState{mock: m}
	m.RequestNodeStateMock.callArgs = []*ConductorMockRequestNodeStateParams{}

	return m
}

type mConductorMockCancelNodeState struct {
	mock               *ConductorMock
	defaultExpectation *ConductorMockCancelNodeStateExpectation
	expectations       []*ConductorMockCancelNodeStateExpectation
}

// ConductorMockCancelNodeStateExpectation specifies expectation struct of the Conductor.CancelNodeState
type ConductorMockCancelNodeStateExpectation struct {
	mock *ConductorMock

	Counter uint64
}

// Expect sets up expected params for Conductor.CancelNodeState
func (mmCancelNodeState *mConductorMockCancelNodeState) Expect() *mConductorMockCancelNodeState {
	if mmCancelNodeState.mock.funcCancelNodeState != nil {
		mmCancelNodeState.mock.t.Fatalf("ConductorMock.CancelNodeState mock is already set by Set")
	}

	if mmCancelNodeState.defaultExpectation == nil {
		mmCancelNodeState.defaultExpectation = &ConductorMockCancelNodeStateExpectation{}
	}

	return mmCancelNodeState
}

// Inspect accepts an inspector function that has same arguments as the Conductor.CancelNodeState
func (mmCancelNodeState *mConductorMockCancelNodeState) Inspect(f func()) *mConductorMockCancelNodeState {
	if mmCancelNodeState.mock.inspectFuncCancelNodeState != nil {
		mmCancelNodeState.mock.t.Fatalf("Inspect function is already set for ConductorMock.CancelNodeState")
	}

	mmCancelNodeState.mock.inspectFuncCancelNodeState = f

	return mmCancelNodeState
}

// Return sets up results that will be returned by Conductor.CancelNodeState
func (mmCancelNodeState *mConductorMockCancelNodeState) Return() *ConductorMock {
	if mmCancelNodeState.mock.funcCancelNodeState != nil {
		mmCancelNodeState.mock.t.Fatalf("ConductorMock.CancelNodeState mock is already set by Set")
	}

	if mmCancelNodeState.defaultExpectation == nil {
		mmCancelNodeState.defaultExpectation = &ConductorMockCancelNodeStateExpectation{mock: mmCancelNodeState.mock}
	}

	return mmCancelNodeState.mock
}

//Set uses given function f to mock the Conductor.CancelNodeState method
func (mmCancelNodeState *mConductorMockCancelNodeState) Set(f func()) *ConductorMock {
	if mmCancelNodeState.defaultExpectation != nil {
		mmCancelNodeState.mock.t.Fatalf("Default expectation is already set for the Conductor.CancelNodeState method")
	}

	if len(mmCancelNodeState.expectations) > 0 {
		mmCancelNodeState.mock.t.Fatalf("Some expectations are already set for the Conductor.CancelNodeState method")
	}

	mmCancelNodeState.mock.funcCancelNodeState = f
	return mmCancelNodeState.mock
}

// CancelNodeState implements Conductor
func (mmCancelNodeState *ConductorMock) CancelNodeState() {
	mm_atomic.AddUint64(&mmCancelNodeState.beforeCancelNodeStateCounter, 1)
	defer mm_atomic.AddUint64(&mmCancelNodeState.afterCancelNodeStateCounter, 1)

	if mmCancelNodeState.inspectFuncCancelNodeState != nil {
		mmCancelNodeState.inspectFuncCancelNodeState()
	}

	if mmCancelNodeState.CancelNodeStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancelNodeState.CancelNodeStateMock.defaultExpectation.Counter, 1)

		return

	}
	if mmCancelNodeState.funcCancelNodeState != nil {
		mmCancelNodeState.funcCancelNodeState()
		return
	}
	mmCancelNodeState.t.Fatalf("Unexpected call to ConductorMock.CancelNodeState.")

}

// CancelNodeStateAfterCounter returns a count of finished ConductorMock.CancelNodeState invocations
func (mmCancelNodeState *ConductorMock) CancelNodeStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelNodeState.afterCancelNodeStateCounter)
}

// CancelNodeStateBeforeCounter returns a count of ConductorMock.CancelNodeState invocations
func (mmCancelNodeState *ConductorMock) CancelNodeStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelNodeState.beforeCancelNodeStateCounter)
}

// MinimockCancelNodeStateDone returns true if the count of the CancelNodeState invocations corresponds
// the number of defined expectations
func (m *ConductorMock) MinimockCancelNodeStateDone() bool {
	for _, e := range m.CancelNodeStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelNodeStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelNodeStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelNodeState != nil && mm_atomic.LoadUint64(&m.afterCancelNodeStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCancelNodeStateInspect logs each unmet expectation
func (m *ConductorMock) MinimockCancelNodeStateInspect() {
	for _, e := range m.CancelNodeStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConductorMock.CancelNodeState")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelNodeStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelNodeStateCounter) < 1 {
		m.t.Error("Expected call to ConductorMock.CancelNodeState")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelNodeState != nil && mm_atomic.LoadUint64(&m.afterCancelNodeStateCounter) < 1 {
		m.t.Error("Expected call to ConductorMock.CancelNodeState")
	}
}

type mConductorMockCommitFirstPulseChange struct {
	mock               *ConductorMock
	defaultExpectation *ConductorMockCommitFirstPulseChangeExpectation
	expectations       []*ConductorMockCommitFirstPulseChangeExpectation

	callArgs []*ConductorMockCommitFirstPulseChangeParams
	mutex    sync.RWMutex
}

// ConductorMockCommitFirstPulseChangeExpectation specifies expectation struct of the Conductor.CommitFirstPulseChange
type ConductorMockCommitFirstPulseChangeExpectation struct {
	mock    *ConductorMock
	params  *ConductorMockCommitFirstPulseChangeParams
	results *ConductorMockCommitFirstPulseChangeResults
	Counter uint64
}

// ConductorMockCommitFirstPulseChangeParams contains parameters of the Conductor.CommitFirstPulseChange
type ConductorMockCommitFirstPulseChangeParams struct {
	b1 beat.Beat
}

// ConductorMockCommitFirstPulseChangeResults contains results of the Conductor.CommitFirstPulseChange
type ConductorMockCommitFirstPulseChangeResults struct {
	err error
}

// Expect sets up expected params for Conductor.CommitFirstPulseChange
func (mmCommitFirstPulseChange *mConductorMockCommitFirstPulseChange) Expect(b1 beat.Beat) *mConductorMockCommitFirstPulseChange {
	if mmCommitFirstPulseChange.mock.funcCommitFirstPulseChange != nil {
		mmCommitFirstPulseChange.mock.t.Fatalf("ConductorMock.CommitFirstPulseChange mock is already set by Set")
	}

	if mmCommitFirstPulseChange.defaultExpectation == nil {
		mmCommitFirstPulseChange.defaultExpectation = &ConductorMockCommitFirstPulseChangeExpectation{}
	}

	mmCommitFirstPulseChange.defaultExpectation.params = &ConductorMockCommitFirstPulseChangeParams{b1}
	for _, e := range mmCommitFirstPulseChange.expectations {
		if minimock.Equal(e.params, mmCommitFirstPulseChange.defaultExpectation.params) {
			mmCommitFirstPulseChange.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommitFirstPulseChange.defaultExpectation.params)
		}
	}

	return mmCommitFirstPulseChange
}

// Inspect accepts an inspector function that has same arguments as the Conductor.CommitFirstPulseChange
func (mmCommitFirstPulseChange *mConductorMockCommitFirstPulseChange) Inspect(f func(b1 beat.Beat)) *mConductorMockCommitFirstPulseChange {
	if mmCommitFirstPulseChange.mock.inspectFuncCommitFirstPulseChange != nil {
		mmCommitFirstPulseChange.mock.t.Fatalf("Inspect function is already set for ConductorMock.CommitFirstPulseChange")
	}

	mmCommitFirstPulseChange.mock.inspectFuncCommitFirstPulseChange = f

	return mmCommitFirstPulseChange
}

// Return sets up results that will be returned by Conductor.CommitFirstPulseChange
func (mmCommitFirstPulseChange *mConductorMockCommitFirstPulseChange) Return(err error) *ConductorMock {
	if mmCommitFirstPulseChange.mock.funcCommitFirstPulseChange != nil {
		mmCommitFirstPulseChange.mock.t.Fatalf("ConductorMock.CommitFirstPulseChange mock is already set by Set")
	}

	if mmCommitFirstPulseChange.defaultExpectation == nil {
		mmCommitFirstPulseChange.defaultExpectation = &ConductorMockCommitFirstPulseChangeExpectation{mock: mmCommitFirstPulseChange.mock}
	}
	mmCommitFirstPulseChange.defaultExpectation.results = &ConductorMockCommitFirstPulseChangeResults{err}
	return mmCommitFirstPulseChange.mock
}

//Set uses given function f to mock the Conductor.CommitFirstPulseChange method
func (mmCommitFirstPulseChange *mConductorMockCommitFirstPulseChange) Set(f func(b1 beat.Beat) (err error)) *ConductorMock {
	if mmCommitFirstPulseChange.defaultExpectation != nil {
		mmCommitFirstPulseChange.mock.t.Fatalf("Default expectation is already set for the Conductor.CommitFirstPulseChange method")
	}

	if len(mmCommitFirstPulseChange.expectations) > 0 {
		mmCommitFirstPulseChange.mock.t.Fatalf("Some expectations are already set for the Conductor.CommitFirstPulseChange method")
	}

	mmCommitFirstPulseChange.mock.funcCommitFirstPulseChange = f
	return mmCommitFirstPulseChange.mock
}

// When sets expectation for the Conductor.CommitFirstPulseChange which will trigger the result defined by the following
// Then helper
func (mmCommitFirstPulseChange *mConductorMockCommitFirstPulseChange) When(b1 beat.Beat) *ConductorMockCommitFirstPulseChangeExpectation {
	if mmCommitFirstPulseChange.mock.funcCommitFirstPulseChange != nil {
		mmCommitFirstPulseChange.mock.t.Fatalf("ConductorMock.CommitFirstPulseChange mock is already set by Set")
	}

	expectation := &ConductorMockCommitFirstPulseChangeExpectation{
		mock:   mmCommitFirstPulseChange.mock,
		params: &ConductorMockCommitFirstPulseChangeParams{b1},
	}
	mmCommitFirstPulseChange.expectations = append(mmCommitFirstPulseChange.expectations, expectation)
	return expectation
}

// Then sets up Conductor.CommitFirstPulseChange return parameters for the expectation previously defined by the When method
func (e *ConductorMockCommitFirstPulseChangeExpectation) Then(err error) *ConductorMock {
	e.results = &ConductorMockCommitFirstPulseChangeResults{err}
	return e.mock
}

// CommitFirstPulseChange implements Conductor
func (mmCommitFirstPulseChange *ConductorMock) CommitFirstPulseChange(b1 beat.Beat) (err error) {
	mm_atomic.AddUint64(&mmCommitFirstPulseChange.beforeCommitFirstPulseChangeCounter, 1)
	defer mm_atomic.AddUint64(&mmCommitFirstPulseChange.afterCommitFirstPulseChangeCounter, 1)

	if mmCommitFirstPulseChange.inspectFuncCommitFirstPulseChange != nil {
		mmCommitFirstPulseChange.inspectFuncCommitFirstPulseChange(b1)
	}

	mm_params := &ConductorMockCommitFirstPulseChangeParams{b1}

	// Record call args
	mmCommitFirstPulseChange.CommitFirstPulseChangeMock.mutex.Lock()
	mmCommitFirstPulseChange.CommitFirstPulseChangeMock.callArgs = append(mmCommitFirstPulseChange.CommitFirstPulseChangeMock.callArgs, mm_params)
	mmCommitFirstPulseChange.CommitFirstPulseChangeMock.mutex.Unlock()

	for _, e := range mmCommitFirstPulseChange.CommitFirstPulseChangeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCommitFirstPulseChange.CommitFirstPulseChangeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommitFirstPulseChange.CommitFirstPulseChangeMock.defaultExpectation.Counter, 1)
		mm_want := mmCommitFirstPulseChange.CommitFirstPulseChangeMock.defaultExpectation.params
		mm_got := ConductorMockCommitFirstPulseChangeParams{b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCommitFirstPulseChange.t.Errorf("ConductorMock.CommitFirstPulseChange got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCommitFirstPulseChange.CommitFirstPulseChangeMock.defaultExpectation.results
		if mm_results == nil {
			mmCommitFirstPulseChange.t.Fatal("No results are set for the ConductorMock.CommitFirstPulseChange")
		}
		return (*mm_results).err
	}
	if mmCommitFirstPulseChange.funcCommitFirstPulseChange != nil {
		return mmCommitFirstPulseChange.funcCommitFirstPulseChange(b1)
	}
	mmCommitFirstPulseChange.t.Fatalf("Unexpected call to ConductorMock.CommitFirstPulseChange. %v", b1)
	return
}

// CommitFirstPulseChangeAfterCounter returns a count of finished ConductorMock.CommitFirstPulseChange invocations
func (mmCommitFirstPulseChange *ConductorMock) CommitFirstPulseChangeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommitFirstPulseChange.afterCommitFirstPulseChangeCounter)
}

// CommitFirstPulseChangeBeforeCounter returns a count of ConductorMock.CommitFirstPulseChange invocations
func (mmCommitFirstPulseChange *ConductorMock) CommitFirstPulseChangeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommitFirstPulseChange.beforeCommitFirstPulseChangeCounter)
}

// Calls returns a list of arguments used in each call to ConductorMock.CommitFirstPulseChange.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommitFirstPulseChange *mConductorMockCommitFirstPulseChange) Calls() []*ConductorMockCommitFirstPulseChangeParams {
	mmCommitFirstPulseChange.mutex.RLock()

	argCopy := make([]*ConductorMockCommitFirstPulseChangeParams, len(mmCommitFirstPulseChange.callArgs))
	copy(argCopy, mmCommitFirstPulseChange.callArgs)

	mmCommitFirstPulseChange.mutex.RUnlock()

	return argCopy
}

// MinimockCommitFirstPulseChangeDone returns true if the count of the CommitFirstPulseChange invocations corresponds
// the number of defined expectations
func (m *ConductorMock) MinimockCommitFirstPulseChangeDone() bool {
	for _, e := range m.CommitFirstPulseChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitFirstPulseChangeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitFirstPulseChangeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommitFirstPulseChange != nil && mm_atomic.LoadUint64(&m.afterCommitFirstPulseChangeCounter) < 1 {
		return false
	}
	return true
}

// MinimockCommitFirstPulseChangeInspect logs each unmet expectation
func (m *ConductorMock) MinimockCommitFirstPulseChangeInspect() {
	for _, e := range m.CommitFirstPulseChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConductorMock.CommitFirstPulseChange with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitFirstPulseChangeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitFirstPulseChangeCounter) < 1 {
		if m.CommitFirstPulseChangeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConductorMock.CommitFirstPulseChange")
		} else {
			m.t.Errorf("Expected call to ConductorMock.CommitFirstPulseChange with params: %#v", *m.CommitFirstPulseChangeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommitFirstPulseChange != nil && mm_atomic.LoadUint64(&m.afterCommitFirstPulseChangeCounter) < 1 {
		m.t.Error("Expected call to ConductorMock.CommitFirstPulseChange")
	}
}

type mConductorMockCommitPulseChange struct {
	mock               *ConductorMock
	defaultExpectation *ConductorMockCommitPulseChangeExpectation
	expectations       []*ConductorMockCommitPulseChangeExpectation

	callArgs []*ConductorMockCommitPulseChangeParams
	mutex    sync.RWMutex
}

// ConductorMockCommitPulseChangeExpectation specifies expectation struct of the Conductor.CommitPulseChange
type ConductorMockCommitPulseChangeExpectation struct {
	mock    *ConductorMock
	params  *ConductorMockCommitPulseChangeParams
	results *ConductorMockCommitPulseChangeResults
	Counter uint64
}

// ConductorMockCommitPulseChangeParams contains parameters of the Conductor.CommitPulseChange
type ConductorMockCommitPulseChangeParams struct {
	b1 beat.Beat
}

// ConductorMockCommitPulseChangeResults contains results of the Conductor.CommitPulseChange
type ConductorMockCommitPulseChangeResults struct {
	err error
}

// Expect sets up expected params for Conductor.CommitPulseChange
func (mmCommitPulseChange *mConductorMockCommitPulseChange) Expect(b1 beat.Beat) *mConductorMockCommitPulseChange {
	if mmCommitPulseChange.mock.funcCommitPulseChange != nil {
		mmCommitPulseChange.mock.t.Fatalf("ConductorMock.CommitPulseChange mock is already set by Set")
	}

	if mmCommitPulseChange.defaultExpectation == nil {
		mmCommitPulseChange.defaultExpectation = &ConductorMockCommitPulseChangeExpectation{}
	}

	mmCommitPulseChange.defaultExpectation.params = &ConductorMockCommitPulseChangeParams{b1}
	for _, e := range mmCommitPulseChange.expectations {
		if minimock.Equal(e.params, mmCommitPulseChange.defaultExpectation.params) {
			mmCommitPulseChange.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommitPulseChange.defaultExpectation.params)
		}
	}

	return mmCommitPulseChange
}

// Inspect accepts an inspector function that has same arguments as the Conductor.CommitPulseChange
func (mmCommitPulseChange *mConductorMockCommitPulseChange) Inspect(f func(b1 beat.Beat)) *mConductorMockCommitPulseChange {
	if mmCommitPulseChange.mock.inspectFuncCommitPulseChange != nil {
		mmCommitPulseChange.mock.t.Fatalf("Inspect function is already set for ConductorMock.CommitPulseChange")
	}

	mmCommitPulseChange.mock.inspectFuncCommitPulseChange = f

	return mmCommitPulseChange
}

// Return sets up results that will be returned by Conductor.CommitPulseChange
func (mmCommitPulseChange *mConductorMockCommitPulseChange) Return(err error) *ConductorMock {
	if mmCommitPulseChange.mock.funcCommitPulseChange != nil {
		mmCommitPulseChange.mock.t.Fatalf("ConductorMock.CommitPulseChange mock is already set by Set")
	}

	if mmCommitPulseChange.defaultExpectation == nil {
		mmCommitPulseChange.defaultExpectation = &ConductorMockCommitPulseChangeExpectation{mock: mmCommitPulseChange.mock}
	}
	mmCommitPulseChange.defaultExpectation.results = &ConductorMockCommitPulseChangeResults{err}
	return mmCommitPulseChange.mock
}

//Set uses given function f to mock the Conductor.CommitPulseChange method
func (mmCommitPulseChange *mConductorMockCommitPulseChange) Set(f func(b1 beat.Beat) (err error)) *ConductorMock {
	if mmCommitPulseChange.defaultExpectation != nil {
		mmCommitPulseChange.mock.t.Fatalf("Default expectation is already set for the Conductor.CommitPulseChange method")
	}

	if len(mmCommitPulseChange.expectations) > 0 {
		mmCommitPulseChange.mock.t.Fatalf("Some expectations are already set for the Conductor.CommitPulseChange method")
	}

	mmCommitPulseChange.mock.funcCommitPulseChange = f
	return mmCommitPulseChange.mock
}

// When sets expectation for the Conductor.CommitPulseChange which will trigger the result defined by the following
// Then helper
func (mmCommitPulseChange *mConductorMockCommitPulseChange) When(b1 beat.Beat) *ConductorMockCommitPulseChangeExpectation {
	if mmCommitPulseChange.mock.funcCommitPulseChange != nil {
		mmCommitPulseChange.mock.t.Fatalf("ConductorMock.CommitPulseChange mock is already set by Set")
	}

	expectation := &ConductorMockCommitPulseChangeExpectation{
		mock:   mmCommitPulseChange.mock,
		params: &ConductorMockCommitPulseChangeParams{b1},
	}
	mmCommitPulseChange.expectations = append(mmCommitPulseChange.expectations, expectation)
	return expectation
}

// Then sets up Conductor.CommitPulseChange return parameters for the expectation previously defined by the When method
func (e *ConductorMockCommitPulseChangeExpectation) Then(err error) *ConductorMock {
	e.results = &ConductorMockCommitPulseChangeResults{err}
	return e.mock
}

// CommitPulseChange implements Conductor
func (mmCommitPulseChange *ConductorMock) CommitPulseChange(b1 beat.Beat) (err error) {
	mm_atomic.AddUint64(&mmCommitPulseChange.beforeCommitPulseChangeCounter, 1)
	defer mm_atomic.AddUint64(&mmCommitPulseChange.afterCommitPulseChangeCounter, 1)

	if mmCommitPulseChange.inspectFuncCommitPulseChange != nil {
		mmCommitPulseChange.inspectFuncCommitPulseChange(b1)
	}

	mm_params := &ConductorMockCommitPulseChangeParams{b1}

	// Record call args
	mmCommitPulseChange.CommitPulseChangeMock.mutex.Lock()
	mmCommitPulseChange.CommitPulseChangeMock.callArgs = append(mmCommitPulseChange.CommitPulseChangeMock.callArgs, mm_params)
	mmCommitPulseChange.CommitPulseChangeMock.mutex.Unlock()

	for _, e := range mmCommitPulseChange.CommitPulseChangeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCommitPulseChange.CommitPulseChangeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommitPulseChange.CommitPulseChangeMock.defaultExpectation.Counter, 1)
		mm_want := mmCommitPulseChange.CommitPulseChangeMock.defaultExpectation.params
		mm_got := ConductorMockCommitPulseChangeParams{b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCommitPulseChange.t.Errorf("ConductorMock.CommitPulseChange got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCommitPulseChange.CommitPulseChangeMock.defaultExpectation.results
		if mm_results == nil {
			mmCommitPulseChange.t.Fatal("No results are set for the ConductorMock.CommitPulseChange")
		}
		return (*mm_results).err
	}
	if mmCommitPulseChange.funcCommitPulseChange != nil {
		return mmCommitPulseChange.funcCommitPulseChange(b1)
	}
	mmCommitPulseChange.t.Fatalf("Unexpected call to ConductorMock.CommitPulseChange. %v", b1)
	return
}

// CommitPulseChangeAfterCounter returns a count of finished ConductorMock.CommitPulseChange invocations
func (mmCommitPulseChange *ConductorMock) CommitPulseChangeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommitPulseChange.afterCommitPulseChangeCounter)
}

// CommitPulseChangeBeforeCounter returns a count of ConductorMock.CommitPulseChange invocations
func (mmCommitPulseChange *ConductorMock) CommitPulseChangeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommitPulseChange.beforeCommitPulseChangeCounter)
}

// Calls returns a list of arguments used in each call to ConductorMock.CommitPulseChange.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommitPulseChange *mConductorMockCommitPulseChange) Calls() []*ConductorMockCommitPulseChangeParams {
	mmCommitPulseChange.mutex.RLock()

	argCopy := make([]*ConductorMockCommitPulseChangeParams, len(mmCommitPulseChange.callArgs))
	copy(argCopy, mmCommitPulseChange.callArgs)

	mmCommitPulseChange.mutex.RUnlock()

	return argCopy
}

// MinimockCommitPulseChangeDone returns true if the count of the CommitPulseChange invocations corresponds
// the number of defined expectations
func (m *ConductorMock) MinimockCommitPulseChangeDone() bool {
	for _, e := range m.CommitPulseChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitPulseChangeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitPulseChangeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommitPulseChange != nil && mm_atomic.LoadUint64(&m.afterCommitPulseChangeCounter) < 1 {
		return false
	}
	return true
}

// MinimockCommitPulseChangeInspect logs each unmet expectation
func (m *ConductorMock) MinimockCommitPulseChangeInspect() {
	for _, e := range m.CommitPulseChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConductorMock.CommitPulseChange with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitPulseChangeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitPulseChangeCounter) < 1 {
		if m.CommitPulseChangeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConductorMock.CommitPulseChange")
		} else {
			m.t.Errorf("Expected call to ConductorMock.CommitPulseChange with params: %#v", *m.CommitPulseChangeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommitPulseChange != nil && mm_atomic.LoadUint64(&m.afterCommitPulseChangeCounter) < 1 {
		m.t.Error("Expected call to ConductorMock.CommitPulseChange")
	}
}

type mConductorMockRequestNodeState struct {
	mock               *ConductorMock
	defaultExpectation *ConductorMockRequestNodeStateExpectation
	expectations       []*ConductorMockRequestNodeStateExpectation

	callArgs []*ConductorMockRequestNodeStateParams
	mutex    sync.RWMutex
}

// ConductorMockRequestNodeStateExpectation specifies expectation struct of the Conductor.RequestNodeState
type ConductorMockRequestNodeStateExpectation struct {
	mock   *ConductorMock
	params *ConductorMockRequestNodeStateParams

	Counter uint64
}

// ConductorMockRequestNodeStateParams contains parameters of the Conductor.RequestNodeState
type ConductorMockRequestNodeStateParams struct {
	n1 NodeStateFunc
}

// Expect sets up expected params for Conductor.RequestNodeState
func (mmRequestNodeState *mConductorMockRequestNodeState) Expect(n1 NodeStateFunc) *mConductorMockRequestNodeState {
	if mmRequestNodeState.mock.funcRequestNodeState != nil {
		mmRequestNodeState.mock.t.Fatalf("ConductorMock.RequestNodeState mock is already set by Set")
	}

	if mmRequestNodeState.defaultExpectation == nil {
		mmRequestNodeState.defaultExpectation = &ConductorMockRequestNodeStateExpectation{}
	}

	mmRequestNodeState.defaultExpectation.params = &ConductorMockRequestNodeStateParams{n1}
	for _, e := range mmRequestNodeState.expectations {
		if minimock.Equal(e.params, mmRequestNodeState.defaultExpectation.params) {
			mmRequestNodeState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRequestNodeState.defaultExpectation.params)
		}
	}

	return mmRequestNodeState
}

// Inspect accepts an inspector function that has same arguments as the Conductor.RequestNodeState
func (mmRequestNodeState *mConductorMockRequestNodeState) Inspect(f func(n1 NodeStateFunc)) *mConductorMockRequestNodeState {
	if mmRequestNodeState.mock.inspectFuncRequestNodeState != nil {
		mmRequestNodeState.mock.t.Fatalf("Inspect function is already set for ConductorMock.RequestNodeState")
	}

	mmRequestNodeState.mock.inspectFuncRequestNodeState = f

	return mmRequestNodeState
}

// Return sets up results that will be returned by Conductor.RequestNodeState
func (mmRequestNodeState *mConductorMockRequestNodeState) Return() *ConductorMock {
	if mmRequestNodeState.mock.funcRequestNodeState != nil {
		mmRequestNodeState.mock.t.Fatalf("ConductorMock.RequestNodeState mock is already set by Set")
	}

	if mmRequestNodeState.defaultExpectation == nil {
		mmRequestNodeState.defaultExpectation = &ConductorMockRequestNodeStateExpectation{mock: mmRequestNodeState.mock}
	}

	return mmRequestNodeState.mock
}

//Set uses given function f to mock the Conductor.RequestNodeState method
func (mmRequestNodeState *mConductorMockRequestNodeState) Set(f func(n1 NodeStateFunc)) *ConductorMock {
	if mmRequestNodeState.defaultExpectation != nil {
		mmRequestNodeState.mock.t.Fatalf("Default expectation is already set for the Conductor.RequestNodeState method")
	}

	if len(mmRequestNodeState.expectations) > 0 {
		mmRequestNodeState.mock.t.Fatalf("Some expectations are already set for the Conductor.RequestNodeState method")
	}

	mmRequestNodeState.mock.funcRequestNodeState = f
	return mmRequestNodeState.mock
}

// RequestNodeState implements Conductor
func (mmRequestNodeState *ConductorMock) RequestNodeState(n1 NodeStateFunc) {
	mm_atomic.AddUint64(&mmRequestNodeState.beforeRequestNodeStateCounter, 1)
	defer mm_atomic.AddUint64(&mmRequestNodeState.afterRequestNodeStateCounter, 1)

	if mmRequestNodeState.inspectFuncRequestNodeState != nil {
		mmRequestNodeState.inspectFuncRequestNodeState(n1)
	}

	mm_params := &ConductorMockRequestNodeStateParams{n1}

	// Record call args
	mmRequestNodeState.RequestNodeStateMock.mutex.Lock()
	mmRequestNodeState.RequestNodeStateMock.callArgs = append(mmRequestNodeState.RequestNodeStateMock.callArgs, mm_params)
	mmRequestNodeState.RequestNodeStateMock.mutex.Unlock()

	for _, e := range mmRequestNodeState.RequestNodeStateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmRequestNodeState.RequestNodeStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRequestNodeState.RequestNodeStateMock.defaultExpectation.Counter, 1)
		mm_want := mmRequestNodeState.RequestNodeStateMock.defaultExpectation.params
		mm_got := ConductorMockRequestNodeStateParams{n1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRequestNodeState.t.Errorf("ConductorMock.RequestNodeState got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmRequestNodeState.funcRequestNodeState != nil {
		mmRequestNodeState.funcRequestNodeState(n1)
		return
	}
	mmRequestNodeState.t.Fatalf("Unexpected call to ConductorMock.RequestNodeState. %v", n1)

}

// RequestNodeStateAfterCounter returns a count of finished ConductorMock.RequestNodeState invocations
func (mmRequestNodeState *ConductorMock) RequestNodeStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRequestNodeState.afterRequestNodeStateCounter)
}

// RequestNodeStateBeforeCounter returns a count of ConductorMock.RequestNodeState invocations
func (mmRequestNodeState *ConductorMock) RequestNodeStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRequestNodeState.beforeRequestNodeStateCounter)
}

// Calls returns a list of arguments used in each call to ConductorMock.RequestNodeState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRequestNodeState *mConductorMockRequestNodeState) Calls() []*ConductorMockRequestNodeStateParams {
	mmRequestNodeState.mutex.RLock()

	argCopy := make([]*ConductorMockRequestNodeStateParams, len(mmRequestNodeState.callArgs))
	copy(argCopy, mmRequestNodeState.callArgs)

	mmRequestNodeState.mutex.RUnlock()

	return argCopy
}

// MinimockRequestNodeStateDone returns true if the count of the RequestNodeState invocations corresponds
// the number of defined expectations
func (m *ConductorMock) MinimockRequestNodeStateDone() bool {
	for _, e := range m.RequestNodeStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RequestNodeStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRequestNodeStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRequestNodeState != nil && mm_atomic.LoadUint64(&m.afterRequestNodeStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockRequestNodeStateInspect logs each unmet expectation
func (m *ConductorMock) MinimockRequestNodeStateInspect() {
	for _, e := range m.RequestNodeStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConductorMock.RequestNodeState with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RequestNodeStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRequestNodeStateCounter) < 1 {
		if m.RequestNodeStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConductorMock.RequestNodeState")
		} else {
			m.t.Errorf("Expected call to ConductorMock.RequestNodeState with params: %#v", *m.RequestNodeStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRequestNodeState != nil && mm_atomic.LoadUint64(&m.afterRequestNodeStateCounter) < 1 {
		m.t.Error("Expected call to ConductorMock.RequestNodeState")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ConductorMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCancelNodeStateInspect()

		m.MinimockCommitFirstPulseChangeInspect()

		m.MinimockCommitPulseChangeInspect()

		m.MinimockRequestNodeStateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ConductorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ConductorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCancelNodeStateDone() &&
		m.MinimockCommitFirstPulseChangeDone() &&
		m.MinimockCommitPulseChangeDone() &&
		m.MinimockRequestNodeStateDone()
}
