package lineage

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/pulse"
	"github.com/insolar/assured-ledger/ledger-core/reference"
)

// LineResolverMock implements lineResolver
type LineResolverMock struct {
	t minimock.Tester

	funcfindChainedDependency          func(root reference.Holder, ref reference.LocalHolder, mustBeOpen bool) (filNo filamentNo, recNo recordNo, dep ResolvedDependency, recap recordNo)
	inspectFuncfindChainedDependency   func(root reference.Holder, ref reference.LocalHolder, mustBeOpen bool)
	afterfindChainedDependencyCounter  uint64
	beforefindChainedDependencyCounter uint64
	findChainedDependencyMock          mLineResolverMockfindChainedDependency

	funcfindCollision          func(local reference.LocalHolder, record *Record) (r1 recordNo, err error)
	inspectFuncfindCollision   func(local reference.LocalHolder, record *Record)
	afterfindCollisionCounter  uint64
	beforefindCollisionCounter uint64
	findCollisionMock          mLineResolverMockfindCollision

	funcfindFilament          func(root reference.LocalHolder) (f1 filamentNo, r1 ResolvedDependency)
	inspectFuncfindFilament   func(root reference.LocalHolder)
	afterfindFilamentCounter  uint64
	beforefindFilamentCounter uint64
	findFilamentMock          mLineResolverMockfindFilament

	funcfindLineDependency          func(root reference.Holder, ref reference.LocalHolder) (r1 ResolvedDependency, err error)
	inspectFuncfindLineDependency   func(root reference.Holder, ref reference.LocalHolder)
	afterfindLineDependencyCounter  uint64
	beforefindLineDependencyCounter uint64
	findLineDependencyMock          mLineResolverMockfindLineDependency

	funcfindLocalDependency          func(root reference.LocalHolder, ref reference.LocalHolder) (f1 filamentNo, r1 recordNo, r2 ResolvedDependency)
	inspectFuncfindLocalDependency   func(root reference.LocalHolder, ref reference.LocalHolder)
	afterfindLocalDependencyCounter  uint64
	beforefindLocalDependencyCounter uint64
	findLocalDependencyMock          mLineResolverMockfindLocalDependency

	funcfindOtherDependency          func(ref reference.Holder) (r1 ResolvedDependency, err error)
	inspectFuncfindOtherDependency   func(ref reference.Holder)
	afterfindOtherDependencyCounter  uint64
	beforefindOtherDependencyCounter uint64
	findOtherDependencyMock          mLineResolverMockfindOtherDependency

	funcgetLineBase          func() (l1 reference.LocalHolder)
	inspectFuncgetLineBase   func()
	aftergetLineBaseCounter  uint64
	beforegetLineBaseCounter uint64
	getLineBaseMock          mLineResolverMockgetLineBase

	funcgetLocalPN          func() (n1 pulse.Number)
	inspectFuncgetLocalPN   func()
	aftergetLocalPNCounter  uint64
	beforegetLocalPNCounter uint64
	getLocalPNMock          mLineResolverMockgetLocalPN

	funcgetNextFilNo          func() (f1 filamentNo)
	inspectFuncgetNextFilNo   func()
	aftergetNextFilNoCounter  uint64
	beforegetNextFilNoCounter uint64
	getNextFilNoMock          mLineResolverMockgetNextFilNo

	funcgetNextRecNo          func() (r1 recordNo)
	inspectFuncgetNextRecNo   func()
	aftergetNextRecNoCounter  uint64
	beforegetNextRecNoCounter uint64
	getNextRecNoMock          mLineResolverMockgetNextRecNo
}

// NewLineResolverMock returns a mock for lineResolver
func NewLineResolverMock(t minimock.Tester) *LineResolverMock {
	m := &LineResolverMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.findChainedDependencyMock = mLineResolverMockfindChainedDependency{mock: m}
	m.findChainedDependencyMock.callArgs = []*LineResolverMockfindChainedDependencyParams{}

	m.findCollisionMock = mLineResolverMockfindCollision{mock: m}
	m.findCollisionMock.callArgs = []*LineResolverMockfindCollisionParams{}

	m.findFilamentMock = mLineResolverMockfindFilament{mock: m}
	m.findFilamentMock.callArgs = []*LineResolverMockfindFilamentParams{}

	m.findLineDependencyMock = mLineResolverMockfindLineDependency{mock: m}
	m.findLineDependencyMock.callArgs = []*LineResolverMockfindLineDependencyParams{}

	m.findLocalDependencyMock = mLineResolverMockfindLocalDependency{mock: m}
	m.findLocalDependencyMock.callArgs = []*LineResolverMockfindLocalDependencyParams{}

	m.findOtherDependencyMock = mLineResolverMockfindOtherDependency{mock: m}
	m.findOtherDependencyMock.callArgs = []*LineResolverMockfindOtherDependencyParams{}

	m.getLineBaseMock = mLineResolverMockgetLineBase{mock: m}

	m.getLocalPNMock = mLineResolverMockgetLocalPN{mock: m}

	m.getNextFilNoMock = mLineResolverMockgetNextFilNo{mock: m}

	m.getNextRecNoMock = mLineResolverMockgetNextRecNo{mock: m}

	return m
}

type mLineResolverMockfindChainedDependency struct {
	mock               *LineResolverMock
	defaultExpectation *LineResolverMockfindChainedDependencyExpectation
	expectations       []*LineResolverMockfindChainedDependencyExpectation

	callArgs []*LineResolverMockfindChainedDependencyParams
	mutex    sync.RWMutex
}

// LineResolverMockfindChainedDependencyExpectation specifies expectation struct of the lineResolver.findChainedDependency
type LineResolverMockfindChainedDependencyExpectation struct {
	mock    *LineResolverMock
	params  *LineResolverMockfindChainedDependencyParams
	results *LineResolverMockfindChainedDependencyResults
	Counter uint64
}

// LineResolverMockfindChainedDependencyParams contains parameters of the lineResolver.findChainedDependency
type LineResolverMockfindChainedDependencyParams struct {
	root       reference.Holder
	ref        reference.LocalHolder
	mustBeOpen bool
}

// LineResolverMockfindChainedDependencyResults contains results of the lineResolver.findChainedDependency
type LineResolverMockfindChainedDependencyResults struct {
	filNo filamentNo
	recNo recordNo
	dep   ResolvedDependency
	recap recordNo
}

// Expect sets up expected params for lineResolver.findChainedDependency
func (mmfindChainedDependency *mLineResolverMockfindChainedDependency) Expect(root reference.Holder, ref reference.LocalHolder, mustBeOpen bool) *mLineResolverMockfindChainedDependency {
	if mmfindChainedDependency.mock.funcfindChainedDependency != nil {
		mmfindChainedDependency.mock.t.Fatalf("LineResolverMock.findChainedDependency mock is already set by Set")
	}

	if mmfindChainedDependency.defaultExpectation == nil {
		mmfindChainedDependency.defaultExpectation = &LineResolverMockfindChainedDependencyExpectation{}
	}

	mmfindChainedDependency.defaultExpectation.params = &LineResolverMockfindChainedDependencyParams{root, ref, mustBeOpen}
	for _, e := range mmfindChainedDependency.expectations {
		if minimock.Equal(e.params, mmfindChainedDependency.defaultExpectation.params) {
			mmfindChainedDependency.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmfindChainedDependency.defaultExpectation.params)
		}
	}

	return mmfindChainedDependency
}

// Inspect accepts an inspector function that has same arguments as the lineResolver.findChainedDependency
func (mmfindChainedDependency *mLineResolverMockfindChainedDependency) Inspect(f func(root reference.Holder, ref reference.LocalHolder, mustBeOpen bool)) *mLineResolverMockfindChainedDependency {
	if mmfindChainedDependency.mock.inspectFuncfindChainedDependency != nil {
		mmfindChainedDependency.mock.t.Fatalf("Inspect function is already set for LineResolverMock.findChainedDependency")
	}

	mmfindChainedDependency.mock.inspectFuncfindChainedDependency = f

	return mmfindChainedDependency
}

// Return sets up results that will be returned by lineResolver.findChainedDependency
func (mmfindChainedDependency *mLineResolverMockfindChainedDependency) Return(filNo filamentNo, recNo recordNo, dep ResolvedDependency, recap recordNo) *LineResolverMock {
	if mmfindChainedDependency.mock.funcfindChainedDependency != nil {
		mmfindChainedDependency.mock.t.Fatalf("LineResolverMock.findChainedDependency mock is already set by Set")
	}

	if mmfindChainedDependency.defaultExpectation == nil {
		mmfindChainedDependency.defaultExpectation = &LineResolverMockfindChainedDependencyExpectation{mock: mmfindChainedDependency.mock}
	}
	mmfindChainedDependency.defaultExpectation.results = &LineResolverMockfindChainedDependencyResults{filNo, recNo, dep, recap}
	return mmfindChainedDependency.mock
}

//Set uses given function f to mock the lineResolver.findChainedDependency method
func (mmfindChainedDependency *mLineResolverMockfindChainedDependency) Set(f func(root reference.Holder, ref reference.LocalHolder, mustBeOpen bool) (filNo filamentNo, recNo recordNo, dep ResolvedDependency, recap recordNo)) *LineResolverMock {
	if mmfindChainedDependency.defaultExpectation != nil {
		mmfindChainedDependency.mock.t.Fatalf("Default expectation is already set for the lineResolver.findChainedDependency method")
	}

	if len(mmfindChainedDependency.expectations) > 0 {
		mmfindChainedDependency.mock.t.Fatalf("Some expectations are already set for the lineResolver.findChainedDependency method")
	}

	mmfindChainedDependency.mock.funcfindChainedDependency = f
	return mmfindChainedDependency.mock
}

// When sets expectation for the lineResolver.findChainedDependency which will trigger the result defined by the following
// Then helper
func (mmfindChainedDependency *mLineResolverMockfindChainedDependency) When(root reference.Holder, ref reference.LocalHolder, mustBeOpen bool) *LineResolverMockfindChainedDependencyExpectation {
	if mmfindChainedDependency.mock.funcfindChainedDependency != nil {
		mmfindChainedDependency.mock.t.Fatalf("LineResolverMock.findChainedDependency mock is already set by Set")
	}

	expectation := &LineResolverMockfindChainedDependencyExpectation{
		mock:   mmfindChainedDependency.mock,
		params: &LineResolverMockfindChainedDependencyParams{root, ref, mustBeOpen},
	}
	mmfindChainedDependency.expectations = append(mmfindChainedDependency.expectations, expectation)
	return expectation
}

// Then sets up lineResolver.findChainedDependency return parameters for the expectation previously defined by the When method
func (e *LineResolverMockfindChainedDependencyExpectation) Then(filNo filamentNo, recNo recordNo, dep ResolvedDependency, recap recordNo) *LineResolverMock {
	e.results = &LineResolverMockfindChainedDependencyResults{filNo, recNo, dep, recap}
	return e.mock
}

// findChainedDependency implements lineResolver
func (mmfindChainedDependency *LineResolverMock) findChainedDependency(root reference.Holder, ref reference.LocalHolder, mustBeOpen bool) (filNo filamentNo, recNo recordNo, dep ResolvedDependency, recap recordNo) {
	mm_atomic.AddUint64(&mmfindChainedDependency.beforefindChainedDependencyCounter, 1)
	defer mm_atomic.AddUint64(&mmfindChainedDependency.afterfindChainedDependencyCounter, 1)

	if mmfindChainedDependency.inspectFuncfindChainedDependency != nil {
		mmfindChainedDependency.inspectFuncfindChainedDependency(root, ref, mustBeOpen)
	}

	mm_params := &LineResolverMockfindChainedDependencyParams{root, ref, mustBeOpen}

	// Record call args
	mmfindChainedDependency.findChainedDependencyMock.mutex.Lock()
	mmfindChainedDependency.findChainedDependencyMock.callArgs = append(mmfindChainedDependency.findChainedDependencyMock.callArgs, mm_params)
	mmfindChainedDependency.findChainedDependencyMock.mutex.Unlock()

	for _, e := range mmfindChainedDependency.findChainedDependencyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.filNo, e.results.recNo, e.results.dep, e.results.recap
		}
	}

	if mmfindChainedDependency.findChainedDependencyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmfindChainedDependency.findChainedDependencyMock.defaultExpectation.Counter, 1)
		mm_want := mmfindChainedDependency.findChainedDependencyMock.defaultExpectation.params
		mm_got := LineResolverMockfindChainedDependencyParams{root, ref, mustBeOpen}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmfindChainedDependency.t.Errorf("LineResolverMock.findChainedDependency got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmfindChainedDependency.findChainedDependencyMock.defaultExpectation.results
		if mm_results == nil {
			mmfindChainedDependency.t.Fatal("No results are set for the LineResolverMock.findChainedDependency")
		}
		return (*mm_results).filNo, (*mm_results).recNo, (*mm_results).dep, (*mm_results).recap
	}
	if mmfindChainedDependency.funcfindChainedDependency != nil {
		return mmfindChainedDependency.funcfindChainedDependency(root, ref, mustBeOpen)
	}
	mmfindChainedDependency.t.Fatalf("Unexpected call to LineResolverMock.findChainedDependency. %v %v %v", root, ref, mustBeOpen)
	return
}

// findChainedDependencyAfterCounter returns a count of finished LineResolverMock.findChainedDependency invocations
func (mmfindChainedDependency *LineResolverMock) findChainedDependencyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmfindChainedDependency.afterfindChainedDependencyCounter)
}

// findChainedDependencyBeforeCounter returns a count of LineResolverMock.findChainedDependency invocations
func (mmfindChainedDependency *LineResolverMock) findChainedDependencyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmfindChainedDependency.beforefindChainedDependencyCounter)
}

// Calls returns a list of arguments used in each call to LineResolverMock.findChainedDependency.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmfindChainedDependency *mLineResolverMockfindChainedDependency) Calls() []*LineResolverMockfindChainedDependencyParams {
	mmfindChainedDependency.mutex.RLock()

	argCopy := make([]*LineResolverMockfindChainedDependencyParams, len(mmfindChainedDependency.callArgs))
	copy(argCopy, mmfindChainedDependency.callArgs)

	mmfindChainedDependency.mutex.RUnlock()

	return argCopy
}

// MinimockfindChainedDependencyDone returns true if the count of the findChainedDependency invocations corresponds
// the number of defined expectations
func (m *LineResolverMock) MinimockfindChainedDependencyDone() bool {
	for _, e := range m.findChainedDependencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.findChainedDependencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterfindChainedDependencyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcfindChainedDependency != nil && mm_atomic.LoadUint64(&m.afterfindChainedDependencyCounter) < 1 {
		return false
	}
	return true
}

// MinimockfindChainedDependencyInspect logs each unmet expectation
func (m *LineResolverMock) MinimockfindChainedDependencyInspect() {
	for _, e := range m.findChainedDependencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LineResolverMock.findChainedDependency with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.findChainedDependencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterfindChainedDependencyCounter) < 1 {
		if m.findChainedDependencyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LineResolverMock.findChainedDependency")
		} else {
			m.t.Errorf("Expected call to LineResolverMock.findChainedDependency with params: %#v", *m.findChainedDependencyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcfindChainedDependency != nil && mm_atomic.LoadUint64(&m.afterfindChainedDependencyCounter) < 1 {
		m.t.Error("Expected call to LineResolverMock.findChainedDependency")
	}
}

type mLineResolverMockfindCollision struct {
	mock               *LineResolverMock
	defaultExpectation *LineResolverMockfindCollisionExpectation
	expectations       []*LineResolverMockfindCollisionExpectation

	callArgs []*LineResolverMockfindCollisionParams
	mutex    sync.RWMutex
}

// LineResolverMockfindCollisionExpectation specifies expectation struct of the lineResolver.findCollision
type LineResolverMockfindCollisionExpectation struct {
	mock    *LineResolverMock
	params  *LineResolverMockfindCollisionParams
	results *LineResolverMockfindCollisionResults
	Counter uint64
}

// LineResolverMockfindCollisionParams contains parameters of the lineResolver.findCollision
type LineResolverMockfindCollisionParams struct {
	local  reference.LocalHolder
	record *Record
}

// LineResolverMockfindCollisionResults contains results of the lineResolver.findCollision
type LineResolverMockfindCollisionResults struct {
	r1  recordNo
	err error
}

// Expect sets up expected params for lineResolver.findCollision
func (mmfindCollision *mLineResolverMockfindCollision) Expect(local reference.LocalHolder, record *Record) *mLineResolverMockfindCollision {
	if mmfindCollision.mock.funcfindCollision != nil {
		mmfindCollision.mock.t.Fatalf("LineResolverMock.findCollision mock is already set by Set")
	}

	if mmfindCollision.defaultExpectation == nil {
		mmfindCollision.defaultExpectation = &LineResolverMockfindCollisionExpectation{}
	}

	mmfindCollision.defaultExpectation.params = &LineResolverMockfindCollisionParams{local, record}
	for _, e := range mmfindCollision.expectations {
		if minimock.Equal(e.params, mmfindCollision.defaultExpectation.params) {
			mmfindCollision.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmfindCollision.defaultExpectation.params)
		}
	}

	return mmfindCollision
}

// Inspect accepts an inspector function that has same arguments as the lineResolver.findCollision
func (mmfindCollision *mLineResolverMockfindCollision) Inspect(f func(local reference.LocalHolder, record *Record)) *mLineResolverMockfindCollision {
	if mmfindCollision.mock.inspectFuncfindCollision != nil {
		mmfindCollision.mock.t.Fatalf("Inspect function is already set for LineResolverMock.findCollision")
	}

	mmfindCollision.mock.inspectFuncfindCollision = f

	return mmfindCollision
}

// Return sets up results that will be returned by lineResolver.findCollision
func (mmfindCollision *mLineResolverMockfindCollision) Return(r1 recordNo, err error) *LineResolverMock {
	if mmfindCollision.mock.funcfindCollision != nil {
		mmfindCollision.mock.t.Fatalf("LineResolverMock.findCollision mock is already set by Set")
	}

	if mmfindCollision.defaultExpectation == nil {
		mmfindCollision.defaultExpectation = &LineResolverMockfindCollisionExpectation{mock: mmfindCollision.mock}
	}
	mmfindCollision.defaultExpectation.results = &LineResolverMockfindCollisionResults{r1, err}
	return mmfindCollision.mock
}

//Set uses given function f to mock the lineResolver.findCollision method
func (mmfindCollision *mLineResolverMockfindCollision) Set(f func(local reference.LocalHolder, record *Record) (r1 recordNo, err error)) *LineResolverMock {
	if mmfindCollision.defaultExpectation != nil {
		mmfindCollision.mock.t.Fatalf("Default expectation is already set for the lineResolver.findCollision method")
	}

	if len(mmfindCollision.expectations) > 0 {
		mmfindCollision.mock.t.Fatalf("Some expectations are already set for the lineResolver.findCollision method")
	}

	mmfindCollision.mock.funcfindCollision = f
	return mmfindCollision.mock
}

// When sets expectation for the lineResolver.findCollision which will trigger the result defined by the following
// Then helper
func (mmfindCollision *mLineResolverMockfindCollision) When(local reference.LocalHolder, record *Record) *LineResolverMockfindCollisionExpectation {
	if mmfindCollision.mock.funcfindCollision != nil {
		mmfindCollision.mock.t.Fatalf("LineResolverMock.findCollision mock is already set by Set")
	}

	expectation := &LineResolverMockfindCollisionExpectation{
		mock:   mmfindCollision.mock,
		params: &LineResolverMockfindCollisionParams{local, record},
	}
	mmfindCollision.expectations = append(mmfindCollision.expectations, expectation)
	return expectation
}

// Then sets up lineResolver.findCollision return parameters for the expectation previously defined by the When method
func (e *LineResolverMockfindCollisionExpectation) Then(r1 recordNo, err error) *LineResolverMock {
	e.results = &LineResolverMockfindCollisionResults{r1, err}
	return e.mock
}

// findCollision implements lineResolver
func (mmfindCollision *LineResolverMock) findCollision(local reference.LocalHolder, record *Record) (r1 recordNo, err error) {
	mm_atomic.AddUint64(&mmfindCollision.beforefindCollisionCounter, 1)
	defer mm_atomic.AddUint64(&mmfindCollision.afterfindCollisionCounter, 1)

	if mmfindCollision.inspectFuncfindCollision != nil {
		mmfindCollision.inspectFuncfindCollision(local, record)
	}

	mm_params := &LineResolverMockfindCollisionParams{local, record}

	// Record call args
	mmfindCollision.findCollisionMock.mutex.Lock()
	mmfindCollision.findCollisionMock.callArgs = append(mmfindCollision.findCollisionMock.callArgs, mm_params)
	mmfindCollision.findCollisionMock.mutex.Unlock()

	for _, e := range mmfindCollision.findCollisionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmfindCollision.findCollisionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmfindCollision.findCollisionMock.defaultExpectation.Counter, 1)
		mm_want := mmfindCollision.findCollisionMock.defaultExpectation.params
		mm_got := LineResolverMockfindCollisionParams{local, record}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmfindCollision.t.Errorf("LineResolverMock.findCollision got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmfindCollision.findCollisionMock.defaultExpectation.results
		if mm_results == nil {
			mmfindCollision.t.Fatal("No results are set for the LineResolverMock.findCollision")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmfindCollision.funcfindCollision != nil {
		return mmfindCollision.funcfindCollision(local, record)
	}
	mmfindCollision.t.Fatalf("Unexpected call to LineResolverMock.findCollision. %v %v", local, record)
	return
}

// findCollisionAfterCounter returns a count of finished LineResolverMock.findCollision invocations
func (mmfindCollision *LineResolverMock) findCollisionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmfindCollision.afterfindCollisionCounter)
}

// findCollisionBeforeCounter returns a count of LineResolverMock.findCollision invocations
func (mmfindCollision *LineResolverMock) findCollisionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmfindCollision.beforefindCollisionCounter)
}

// Calls returns a list of arguments used in each call to LineResolverMock.findCollision.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmfindCollision *mLineResolverMockfindCollision) Calls() []*LineResolverMockfindCollisionParams {
	mmfindCollision.mutex.RLock()

	argCopy := make([]*LineResolverMockfindCollisionParams, len(mmfindCollision.callArgs))
	copy(argCopy, mmfindCollision.callArgs)

	mmfindCollision.mutex.RUnlock()

	return argCopy
}

// MinimockfindCollisionDone returns true if the count of the findCollision invocations corresponds
// the number of defined expectations
func (m *LineResolverMock) MinimockfindCollisionDone() bool {
	for _, e := range m.findCollisionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.findCollisionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterfindCollisionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcfindCollision != nil && mm_atomic.LoadUint64(&m.afterfindCollisionCounter) < 1 {
		return false
	}
	return true
}

// MinimockfindCollisionInspect logs each unmet expectation
func (m *LineResolverMock) MinimockfindCollisionInspect() {
	for _, e := range m.findCollisionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LineResolverMock.findCollision with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.findCollisionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterfindCollisionCounter) < 1 {
		if m.findCollisionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LineResolverMock.findCollision")
		} else {
			m.t.Errorf("Expected call to LineResolverMock.findCollision with params: %#v", *m.findCollisionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcfindCollision != nil && mm_atomic.LoadUint64(&m.afterfindCollisionCounter) < 1 {
		m.t.Error("Expected call to LineResolverMock.findCollision")
	}
}

type mLineResolverMockfindFilament struct {
	mock               *LineResolverMock
	defaultExpectation *LineResolverMockfindFilamentExpectation
	expectations       []*LineResolverMockfindFilamentExpectation

	callArgs []*LineResolverMockfindFilamentParams
	mutex    sync.RWMutex
}

// LineResolverMockfindFilamentExpectation specifies expectation struct of the lineResolver.findFilament
type LineResolverMockfindFilamentExpectation struct {
	mock    *LineResolverMock
	params  *LineResolverMockfindFilamentParams
	results *LineResolverMockfindFilamentResults
	Counter uint64
}

// LineResolverMockfindFilamentParams contains parameters of the lineResolver.findFilament
type LineResolverMockfindFilamentParams struct {
	root reference.LocalHolder
}

// LineResolverMockfindFilamentResults contains results of the lineResolver.findFilament
type LineResolverMockfindFilamentResults struct {
	f1 filamentNo
	r1 ResolvedDependency
}

// Expect sets up expected params for lineResolver.findFilament
func (mmfindFilament *mLineResolverMockfindFilament) Expect(root reference.LocalHolder) *mLineResolverMockfindFilament {
	if mmfindFilament.mock.funcfindFilament != nil {
		mmfindFilament.mock.t.Fatalf("LineResolverMock.findFilament mock is already set by Set")
	}

	if mmfindFilament.defaultExpectation == nil {
		mmfindFilament.defaultExpectation = &LineResolverMockfindFilamentExpectation{}
	}

	mmfindFilament.defaultExpectation.params = &LineResolverMockfindFilamentParams{root}
	for _, e := range mmfindFilament.expectations {
		if minimock.Equal(e.params, mmfindFilament.defaultExpectation.params) {
			mmfindFilament.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmfindFilament.defaultExpectation.params)
		}
	}

	return mmfindFilament
}

// Inspect accepts an inspector function that has same arguments as the lineResolver.findFilament
func (mmfindFilament *mLineResolverMockfindFilament) Inspect(f func(root reference.LocalHolder)) *mLineResolverMockfindFilament {
	if mmfindFilament.mock.inspectFuncfindFilament != nil {
		mmfindFilament.mock.t.Fatalf("Inspect function is already set for LineResolverMock.findFilament")
	}

	mmfindFilament.mock.inspectFuncfindFilament = f

	return mmfindFilament
}

// Return sets up results that will be returned by lineResolver.findFilament
func (mmfindFilament *mLineResolverMockfindFilament) Return(f1 filamentNo, r1 ResolvedDependency) *LineResolverMock {
	if mmfindFilament.mock.funcfindFilament != nil {
		mmfindFilament.mock.t.Fatalf("LineResolverMock.findFilament mock is already set by Set")
	}

	if mmfindFilament.defaultExpectation == nil {
		mmfindFilament.defaultExpectation = &LineResolverMockfindFilamentExpectation{mock: mmfindFilament.mock}
	}
	mmfindFilament.defaultExpectation.results = &LineResolverMockfindFilamentResults{f1, r1}
	return mmfindFilament.mock
}

//Set uses given function f to mock the lineResolver.findFilament method
func (mmfindFilament *mLineResolverMockfindFilament) Set(f func(root reference.LocalHolder) (f1 filamentNo, r1 ResolvedDependency)) *LineResolverMock {
	if mmfindFilament.defaultExpectation != nil {
		mmfindFilament.mock.t.Fatalf("Default expectation is already set for the lineResolver.findFilament method")
	}

	if len(mmfindFilament.expectations) > 0 {
		mmfindFilament.mock.t.Fatalf("Some expectations are already set for the lineResolver.findFilament method")
	}

	mmfindFilament.mock.funcfindFilament = f
	return mmfindFilament.mock
}

// When sets expectation for the lineResolver.findFilament which will trigger the result defined by the following
// Then helper
func (mmfindFilament *mLineResolverMockfindFilament) When(root reference.LocalHolder) *LineResolverMockfindFilamentExpectation {
	if mmfindFilament.mock.funcfindFilament != nil {
		mmfindFilament.mock.t.Fatalf("LineResolverMock.findFilament mock is already set by Set")
	}

	expectation := &LineResolverMockfindFilamentExpectation{
		mock:   mmfindFilament.mock,
		params: &LineResolverMockfindFilamentParams{root},
	}
	mmfindFilament.expectations = append(mmfindFilament.expectations, expectation)
	return expectation
}

// Then sets up lineResolver.findFilament return parameters for the expectation previously defined by the When method
func (e *LineResolverMockfindFilamentExpectation) Then(f1 filamentNo, r1 ResolvedDependency) *LineResolverMock {
	e.results = &LineResolverMockfindFilamentResults{f1, r1}
	return e.mock
}

// findFilament implements lineResolver
func (mmfindFilament *LineResolverMock) findFilament(root reference.LocalHolder) (f1 filamentNo, r1 ResolvedDependency) {
	mm_atomic.AddUint64(&mmfindFilament.beforefindFilamentCounter, 1)
	defer mm_atomic.AddUint64(&mmfindFilament.afterfindFilamentCounter, 1)

	if mmfindFilament.inspectFuncfindFilament != nil {
		mmfindFilament.inspectFuncfindFilament(root)
	}

	mm_params := &LineResolverMockfindFilamentParams{root}

	// Record call args
	mmfindFilament.findFilamentMock.mutex.Lock()
	mmfindFilament.findFilamentMock.callArgs = append(mmfindFilament.findFilamentMock.callArgs, mm_params)
	mmfindFilament.findFilamentMock.mutex.Unlock()

	for _, e := range mmfindFilament.findFilamentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.r1
		}
	}

	if mmfindFilament.findFilamentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmfindFilament.findFilamentMock.defaultExpectation.Counter, 1)
		mm_want := mmfindFilament.findFilamentMock.defaultExpectation.params
		mm_got := LineResolverMockfindFilamentParams{root}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmfindFilament.t.Errorf("LineResolverMock.findFilament got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmfindFilament.findFilamentMock.defaultExpectation.results
		if mm_results == nil {
			mmfindFilament.t.Fatal("No results are set for the LineResolverMock.findFilament")
		}
		return (*mm_results).f1, (*mm_results).r1
	}
	if mmfindFilament.funcfindFilament != nil {
		return mmfindFilament.funcfindFilament(root)
	}
	mmfindFilament.t.Fatalf("Unexpected call to LineResolverMock.findFilament. %v", root)
	return
}

// findFilamentAfterCounter returns a count of finished LineResolverMock.findFilament invocations
func (mmfindFilament *LineResolverMock) findFilamentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmfindFilament.afterfindFilamentCounter)
}

// findFilamentBeforeCounter returns a count of LineResolverMock.findFilament invocations
func (mmfindFilament *LineResolverMock) findFilamentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmfindFilament.beforefindFilamentCounter)
}

// Calls returns a list of arguments used in each call to LineResolverMock.findFilament.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmfindFilament *mLineResolverMockfindFilament) Calls() []*LineResolverMockfindFilamentParams {
	mmfindFilament.mutex.RLock()

	argCopy := make([]*LineResolverMockfindFilamentParams, len(mmfindFilament.callArgs))
	copy(argCopy, mmfindFilament.callArgs)

	mmfindFilament.mutex.RUnlock()

	return argCopy
}

// MinimockfindFilamentDone returns true if the count of the findFilament invocations corresponds
// the number of defined expectations
func (m *LineResolverMock) MinimockfindFilamentDone() bool {
	for _, e := range m.findFilamentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.findFilamentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterfindFilamentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcfindFilament != nil && mm_atomic.LoadUint64(&m.afterfindFilamentCounter) < 1 {
		return false
	}
	return true
}

// MinimockfindFilamentInspect logs each unmet expectation
func (m *LineResolverMock) MinimockfindFilamentInspect() {
	for _, e := range m.findFilamentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LineResolverMock.findFilament with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.findFilamentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterfindFilamentCounter) < 1 {
		if m.findFilamentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LineResolverMock.findFilament")
		} else {
			m.t.Errorf("Expected call to LineResolverMock.findFilament with params: %#v", *m.findFilamentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcfindFilament != nil && mm_atomic.LoadUint64(&m.afterfindFilamentCounter) < 1 {
		m.t.Error("Expected call to LineResolverMock.findFilament")
	}
}

type mLineResolverMockfindLineDependency struct {
	mock               *LineResolverMock
	defaultExpectation *LineResolverMockfindLineDependencyExpectation
	expectations       []*LineResolverMockfindLineDependencyExpectation

	callArgs []*LineResolverMockfindLineDependencyParams
	mutex    sync.RWMutex
}

// LineResolverMockfindLineDependencyExpectation specifies expectation struct of the lineResolver.findLineDependency
type LineResolverMockfindLineDependencyExpectation struct {
	mock    *LineResolverMock
	params  *LineResolverMockfindLineDependencyParams
	results *LineResolverMockfindLineDependencyResults
	Counter uint64
}

// LineResolverMockfindLineDependencyParams contains parameters of the lineResolver.findLineDependency
type LineResolverMockfindLineDependencyParams struct {
	root reference.Holder
	ref  reference.LocalHolder
}

// LineResolverMockfindLineDependencyResults contains results of the lineResolver.findLineDependency
type LineResolverMockfindLineDependencyResults struct {
	r1  ResolvedDependency
	err error
}

// Expect sets up expected params for lineResolver.findLineDependency
func (mmfindLineDependency *mLineResolverMockfindLineDependency) Expect(root reference.Holder, ref reference.LocalHolder) *mLineResolverMockfindLineDependency {
	if mmfindLineDependency.mock.funcfindLineDependency != nil {
		mmfindLineDependency.mock.t.Fatalf("LineResolverMock.findLineDependency mock is already set by Set")
	}

	if mmfindLineDependency.defaultExpectation == nil {
		mmfindLineDependency.defaultExpectation = &LineResolverMockfindLineDependencyExpectation{}
	}

	mmfindLineDependency.defaultExpectation.params = &LineResolverMockfindLineDependencyParams{root, ref}
	for _, e := range mmfindLineDependency.expectations {
		if minimock.Equal(e.params, mmfindLineDependency.defaultExpectation.params) {
			mmfindLineDependency.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmfindLineDependency.defaultExpectation.params)
		}
	}

	return mmfindLineDependency
}

// Inspect accepts an inspector function that has same arguments as the lineResolver.findLineDependency
func (mmfindLineDependency *mLineResolverMockfindLineDependency) Inspect(f func(root reference.Holder, ref reference.LocalHolder)) *mLineResolverMockfindLineDependency {
	if mmfindLineDependency.mock.inspectFuncfindLineDependency != nil {
		mmfindLineDependency.mock.t.Fatalf("Inspect function is already set for LineResolverMock.findLineDependency")
	}

	mmfindLineDependency.mock.inspectFuncfindLineDependency = f

	return mmfindLineDependency
}

// Return sets up results that will be returned by lineResolver.findLineDependency
func (mmfindLineDependency *mLineResolverMockfindLineDependency) Return(r1 ResolvedDependency, err error) *LineResolverMock {
	if mmfindLineDependency.mock.funcfindLineDependency != nil {
		mmfindLineDependency.mock.t.Fatalf("LineResolverMock.findLineDependency mock is already set by Set")
	}

	if mmfindLineDependency.defaultExpectation == nil {
		mmfindLineDependency.defaultExpectation = &LineResolverMockfindLineDependencyExpectation{mock: mmfindLineDependency.mock}
	}
	mmfindLineDependency.defaultExpectation.results = &LineResolverMockfindLineDependencyResults{r1, err}
	return mmfindLineDependency.mock
}

//Set uses given function f to mock the lineResolver.findLineDependency method
func (mmfindLineDependency *mLineResolverMockfindLineDependency) Set(f func(root reference.Holder, ref reference.LocalHolder) (r1 ResolvedDependency, err error)) *LineResolverMock {
	if mmfindLineDependency.defaultExpectation != nil {
		mmfindLineDependency.mock.t.Fatalf("Default expectation is already set for the lineResolver.findLineDependency method")
	}

	if len(mmfindLineDependency.expectations) > 0 {
		mmfindLineDependency.mock.t.Fatalf("Some expectations are already set for the lineResolver.findLineDependency method")
	}

	mmfindLineDependency.mock.funcfindLineDependency = f
	return mmfindLineDependency.mock
}

// When sets expectation for the lineResolver.findLineDependency which will trigger the result defined by the following
// Then helper
func (mmfindLineDependency *mLineResolverMockfindLineDependency) When(root reference.Holder, ref reference.LocalHolder) *LineResolverMockfindLineDependencyExpectation {
	if mmfindLineDependency.mock.funcfindLineDependency != nil {
		mmfindLineDependency.mock.t.Fatalf("LineResolverMock.findLineDependency mock is already set by Set")
	}

	expectation := &LineResolverMockfindLineDependencyExpectation{
		mock:   mmfindLineDependency.mock,
		params: &LineResolverMockfindLineDependencyParams{root, ref},
	}
	mmfindLineDependency.expectations = append(mmfindLineDependency.expectations, expectation)
	return expectation
}

// Then sets up lineResolver.findLineDependency return parameters for the expectation previously defined by the When method
func (e *LineResolverMockfindLineDependencyExpectation) Then(r1 ResolvedDependency, err error) *LineResolverMock {
	e.results = &LineResolverMockfindLineDependencyResults{r1, err}
	return e.mock
}

// findLineDependency implements lineResolver
func (mmfindLineDependency *LineResolverMock) findLineDependency(root reference.Holder, ref reference.LocalHolder) (r1 ResolvedDependency, err error) {
	mm_atomic.AddUint64(&mmfindLineDependency.beforefindLineDependencyCounter, 1)
	defer mm_atomic.AddUint64(&mmfindLineDependency.afterfindLineDependencyCounter, 1)

	if mmfindLineDependency.inspectFuncfindLineDependency != nil {
		mmfindLineDependency.inspectFuncfindLineDependency(root, ref)
	}

	mm_params := &LineResolverMockfindLineDependencyParams{root, ref}

	// Record call args
	mmfindLineDependency.findLineDependencyMock.mutex.Lock()
	mmfindLineDependency.findLineDependencyMock.callArgs = append(mmfindLineDependency.findLineDependencyMock.callArgs, mm_params)
	mmfindLineDependency.findLineDependencyMock.mutex.Unlock()

	for _, e := range mmfindLineDependency.findLineDependencyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmfindLineDependency.findLineDependencyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmfindLineDependency.findLineDependencyMock.defaultExpectation.Counter, 1)
		mm_want := mmfindLineDependency.findLineDependencyMock.defaultExpectation.params
		mm_got := LineResolverMockfindLineDependencyParams{root, ref}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmfindLineDependency.t.Errorf("LineResolverMock.findLineDependency got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmfindLineDependency.findLineDependencyMock.defaultExpectation.results
		if mm_results == nil {
			mmfindLineDependency.t.Fatal("No results are set for the LineResolverMock.findLineDependency")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmfindLineDependency.funcfindLineDependency != nil {
		return mmfindLineDependency.funcfindLineDependency(root, ref)
	}
	mmfindLineDependency.t.Fatalf("Unexpected call to LineResolverMock.findLineDependency. %v %v", root, ref)
	return
}

// findLineDependencyAfterCounter returns a count of finished LineResolverMock.findLineDependency invocations
func (mmfindLineDependency *LineResolverMock) findLineDependencyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmfindLineDependency.afterfindLineDependencyCounter)
}

// findLineDependencyBeforeCounter returns a count of LineResolverMock.findLineDependency invocations
func (mmfindLineDependency *LineResolverMock) findLineDependencyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmfindLineDependency.beforefindLineDependencyCounter)
}

// Calls returns a list of arguments used in each call to LineResolverMock.findLineDependency.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmfindLineDependency *mLineResolverMockfindLineDependency) Calls() []*LineResolverMockfindLineDependencyParams {
	mmfindLineDependency.mutex.RLock()

	argCopy := make([]*LineResolverMockfindLineDependencyParams, len(mmfindLineDependency.callArgs))
	copy(argCopy, mmfindLineDependency.callArgs)

	mmfindLineDependency.mutex.RUnlock()

	return argCopy
}

// MinimockfindLineDependencyDone returns true if the count of the findLineDependency invocations corresponds
// the number of defined expectations
func (m *LineResolverMock) MinimockfindLineDependencyDone() bool {
	for _, e := range m.findLineDependencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.findLineDependencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterfindLineDependencyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcfindLineDependency != nil && mm_atomic.LoadUint64(&m.afterfindLineDependencyCounter) < 1 {
		return false
	}
	return true
}

// MinimockfindLineDependencyInspect logs each unmet expectation
func (m *LineResolverMock) MinimockfindLineDependencyInspect() {
	for _, e := range m.findLineDependencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LineResolverMock.findLineDependency with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.findLineDependencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterfindLineDependencyCounter) < 1 {
		if m.findLineDependencyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LineResolverMock.findLineDependency")
		} else {
			m.t.Errorf("Expected call to LineResolverMock.findLineDependency with params: %#v", *m.findLineDependencyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcfindLineDependency != nil && mm_atomic.LoadUint64(&m.afterfindLineDependencyCounter) < 1 {
		m.t.Error("Expected call to LineResolverMock.findLineDependency")
	}
}

type mLineResolverMockfindLocalDependency struct {
	mock               *LineResolverMock
	defaultExpectation *LineResolverMockfindLocalDependencyExpectation
	expectations       []*LineResolverMockfindLocalDependencyExpectation

	callArgs []*LineResolverMockfindLocalDependencyParams
	mutex    sync.RWMutex
}

// LineResolverMockfindLocalDependencyExpectation specifies expectation struct of the lineResolver.findLocalDependency
type LineResolverMockfindLocalDependencyExpectation struct {
	mock    *LineResolverMock
	params  *LineResolverMockfindLocalDependencyParams
	results *LineResolverMockfindLocalDependencyResults
	Counter uint64
}

// LineResolverMockfindLocalDependencyParams contains parameters of the lineResolver.findLocalDependency
type LineResolverMockfindLocalDependencyParams struct {
	root reference.LocalHolder
	ref  reference.LocalHolder
}

// LineResolverMockfindLocalDependencyResults contains results of the lineResolver.findLocalDependency
type LineResolverMockfindLocalDependencyResults struct {
	f1 filamentNo
	r1 recordNo
	r2 ResolvedDependency
}

// Expect sets up expected params for lineResolver.findLocalDependency
func (mmfindLocalDependency *mLineResolverMockfindLocalDependency) Expect(root reference.LocalHolder, ref reference.LocalHolder) *mLineResolverMockfindLocalDependency {
	if mmfindLocalDependency.mock.funcfindLocalDependency != nil {
		mmfindLocalDependency.mock.t.Fatalf("LineResolverMock.findLocalDependency mock is already set by Set")
	}

	if mmfindLocalDependency.defaultExpectation == nil {
		mmfindLocalDependency.defaultExpectation = &LineResolverMockfindLocalDependencyExpectation{}
	}

	mmfindLocalDependency.defaultExpectation.params = &LineResolverMockfindLocalDependencyParams{root, ref}
	for _, e := range mmfindLocalDependency.expectations {
		if minimock.Equal(e.params, mmfindLocalDependency.defaultExpectation.params) {
			mmfindLocalDependency.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmfindLocalDependency.defaultExpectation.params)
		}
	}

	return mmfindLocalDependency
}

// Inspect accepts an inspector function that has same arguments as the lineResolver.findLocalDependency
func (mmfindLocalDependency *mLineResolverMockfindLocalDependency) Inspect(f func(root reference.LocalHolder, ref reference.LocalHolder)) *mLineResolverMockfindLocalDependency {
	if mmfindLocalDependency.mock.inspectFuncfindLocalDependency != nil {
		mmfindLocalDependency.mock.t.Fatalf("Inspect function is already set for LineResolverMock.findLocalDependency")
	}

	mmfindLocalDependency.mock.inspectFuncfindLocalDependency = f

	return mmfindLocalDependency
}

// Return sets up results that will be returned by lineResolver.findLocalDependency
func (mmfindLocalDependency *mLineResolverMockfindLocalDependency) Return(f1 filamentNo, r1 recordNo, r2 ResolvedDependency) *LineResolverMock {
	if mmfindLocalDependency.mock.funcfindLocalDependency != nil {
		mmfindLocalDependency.mock.t.Fatalf("LineResolverMock.findLocalDependency mock is already set by Set")
	}

	if mmfindLocalDependency.defaultExpectation == nil {
		mmfindLocalDependency.defaultExpectation = &LineResolverMockfindLocalDependencyExpectation{mock: mmfindLocalDependency.mock}
	}
	mmfindLocalDependency.defaultExpectation.results = &LineResolverMockfindLocalDependencyResults{f1, r1, r2}
	return mmfindLocalDependency.mock
}

//Set uses given function f to mock the lineResolver.findLocalDependency method
func (mmfindLocalDependency *mLineResolverMockfindLocalDependency) Set(f func(root reference.LocalHolder, ref reference.LocalHolder) (f1 filamentNo, r1 recordNo, r2 ResolvedDependency)) *LineResolverMock {
	if mmfindLocalDependency.defaultExpectation != nil {
		mmfindLocalDependency.mock.t.Fatalf("Default expectation is already set for the lineResolver.findLocalDependency method")
	}

	if len(mmfindLocalDependency.expectations) > 0 {
		mmfindLocalDependency.mock.t.Fatalf("Some expectations are already set for the lineResolver.findLocalDependency method")
	}

	mmfindLocalDependency.mock.funcfindLocalDependency = f
	return mmfindLocalDependency.mock
}

// When sets expectation for the lineResolver.findLocalDependency which will trigger the result defined by the following
// Then helper
func (mmfindLocalDependency *mLineResolverMockfindLocalDependency) When(root reference.LocalHolder, ref reference.LocalHolder) *LineResolverMockfindLocalDependencyExpectation {
	if mmfindLocalDependency.mock.funcfindLocalDependency != nil {
		mmfindLocalDependency.mock.t.Fatalf("LineResolverMock.findLocalDependency mock is already set by Set")
	}

	expectation := &LineResolverMockfindLocalDependencyExpectation{
		mock:   mmfindLocalDependency.mock,
		params: &LineResolverMockfindLocalDependencyParams{root, ref},
	}
	mmfindLocalDependency.expectations = append(mmfindLocalDependency.expectations, expectation)
	return expectation
}

// Then sets up lineResolver.findLocalDependency return parameters for the expectation previously defined by the When method
func (e *LineResolverMockfindLocalDependencyExpectation) Then(f1 filamentNo, r1 recordNo, r2 ResolvedDependency) *LineResolverMock {
	e.results = &LineResolverMockfindLocalDependencyResults{f1, r1, r2}
	return e.mock
}

// findLocalDependency implements lineResolver
func (mmfindLocalDependency *LineResolverMock) findLocalDependency(root reference.LocalHolder, ref reference.LocalHolder) (f1 filamentNo, r1 recordNo, r2 ResolvedDependency) {
	mm_atomic.AddUint64(&mmfindLocalDependency.beforefindLocalDependencyCounter, 1)
	defer mm_atomic.AddUint64(&mmfindLocalDependency.afterfindLocalDependencyCounter, 1)

	if mmfindLocalDependency.inspectFuncfindLocalDependency != nil {
		mmfindLocalDependency.inspectFuncfindLocalDependency(root, ref)
	}

	mm_params := &LineResolverMockfindLocalDependencyParams{root, ref}

	// Record call args
	mmfindLocalDependency.findLocalDependencyMock.mutex.Lock()
	mmfindLocalDependency.findLocalDependencyMock.callArgs = append(mmfindLocalDependency.findLocalDependencyMock.callArgs, mm_params)
	mmfindLocalDependency.findLocalDependencyMock.mutex.Unlock()

	for _, e := range mmfindLocalDependency.findLocalDependencyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.r1, e.results.r2
		}
	}

	if mmfindLocalDependency.findLocalDependencyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmfindLocalDependency.findLocalDependencyMock.defaultExpectation.Counter, 1)
		mm_want := mmfindLocalDependency.findLocalDependencyMock.defaultExpectation.params
		mm_got := LineResolverMockfindLocalDependencyParams{root, ref}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmfindLocalDependency.t.Errorf("LineResolverMock.findLocalDependency got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmfindLocalDependency.findLocalDependencyMock.defaultExpectation.results
		if mm_results == nil {
			mmfindLocalDependency.t.Fatal("No results are set for the LineResolverMock.findLocalDependency")
		}
		return (*mm_results).f1, (*mm_results).r1, (*mm_results).r2
	}
	if mmfindLocalDependency.funcfindLocalDependency != nil {
		return mmfindLocalDependency.funcfindLocalDependency(root, ref)
	}
	mmfindLocalDependency.t.Fatalf("Unexpected call to LineResolverMock.findLocalDependency. %v %v", root, ref)
	return
}

// findLocalDependencyAfterCounter returns a count of finished LineResolverMock.findLocalDependency invocations
func (mmfindLocalDependency *LineResolverMock) findLocalDependencyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmfindLocalDependency.afterfindLocalDependencyCounter)
}

// findLocalDependencyBeforeCounter returns a count of LineResolverMock.findLocalDependency invocations
func (mmfindLocalDependency *LineResolverMock) findLocalDependencyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmfindLocalDependency.beforefindLocalDependencyCounter)
}

// Calls returns a list of arguments used in each call to LineResolverMock.findLocalDependency.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmfindLocalDependency *mLineResolverMockfindLocalDependency) Calls() []*LineResolverMockfindLocalDependencyParams {
	mmfindLocalDependency.mutex.RLock()

	argCopy := make([]*LineResolverMockfindLocalDependencyParams, len(mmfindLocalDependency.callArgs))
	copy(argCopy, mmfindLocalDependency.callArgs)

	mmfindLocalDependency.mutex.RUnlock()

	return argCopy
}

// MinimockfindLocalDependencyDone returns true if the count of the findLocalDependency invocations corresponds
// the number of defined expectations
func (m *LineResolverMock) MinimockfindLocalDependencyDone() bool {
	for _, e := range m.findLocalDependencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.findLocalDependencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterfindLocalDependencyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcfindLocalDependency != nil && mm_atomic.LoadUint64(&m.afterfindLocalDependencyCounter) < 1 {
		return false
	}
	return true
}

// MinimockfindLocalDependencyInspect logs each unmet expectation
func (m *LineResolverMock) MinimockfindLocalDependencyInspect() {
	for _, e := range m.findLocalDependencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LineResolverMock.findLocalDependency with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.findLocalDependencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterfindLocalDependencyCounter) < 1 {
		if m.findLocalDependencyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LineResolverMock.findLocalDependency")
		} else {
			m.t.Errorf("Expected call to LineResolverMock.findLocalDependency with params: %#v", *m.findLocalDependencyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcfindLocalDependency != nil && mm_atomic.LoadUint64(&m.afterfindLocalDependencyCounter) < 1 {
		m.t.Error("Expected call to LineResolverMock.findLocalDependency")
	}
}

type mLineResolverMockfindOtherDependency struct {
	mock               *LineResolverMock
	defaultExpectation *LineResolverMockfindOtherDependencyExpectation
	expectations       []*LineResolverMockfindOtherDependencyExpectation

	callArgs []*LineResolverMockfindOtherDependencyParams
	mutex    sync.RWMutex
}

// LineResolverMockfindOtherDependencyExpectation specifies expectation struct of the lineResolver.findOtherDependency
type LineResolverMockfindOtherDependencyExpectation struct {
	mock    *LineResolverMock
	params  *LineResolverMockfindOtherDependencyParams
	results *LineResolverMockfindOtherDependencyResults
	Counter uint64
}

// LineResolverMockfindOtherDependencyParams contains parameters of the lineResolver.findOtherDependency
type LineResolverMockfindOtherDependencyParams struct {
	ref reference.Holder
}

// LineResolverMockfindOtherDependencyResults contains results of the lineResolver.findOtherDependency
type LineResolverMockfindOtherDependencyResults struct {
	r1  ResolvedDependency
	err error
}

// Expect sets up expected params for lineResolver.findOtherDependency
func (mmfindOtherDependency *mLineResolverMockfindOtherDependency) Expect(ref reference.Holder) *mLineResolverMockfindOtherDependency {
	if mmfindOtherDependency.mock.funcfindOtherDependency != nil {
		mmfindOtherDependency.mock.t.Fatalf("LineResolverMock.findOtherDependency mock is already set by Set")
	}

	if mmfindOtherDependency.defaultExpectation == nil {
		mmfindOtherDependency.defaultExpectation = &LineResolverMockfindOtherDependencyExpectation{}
	}

	mmfindOtherDependency.defaultExpectation.params = &LineResolverMockfindOtherDependencyParams{ref}
	for _, e := range mmfindOtherDependency.expectations {
		if minimock.Equal(e.params, mmfindOtherDependency.defaultExpectation.params) {
			mmfindOtherDependency.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmfindOtherDependency.defaultExpectation.params)
		}
	}

	return mmfindOtherDependency
}

// Inspect accepts an inspector function that has same arguments as the lineResolver.findOtherDependency
func (mmfindOtherDependency *mLineResolverMockfindOtherDependency) Inspect(f func(ref reference.Holder)) *mLineResolverMockfindOtherDependency {
	if mmfindOtherDependency.mock.inspectFuncfindOtherDependency != nil {
		mmfindOtherDependency.mock.t.Fatalf("Inspect function is already set for LineResolverMock.findOtherDependency")
	}

	mmfindOtherDependency.mock.inspectFuncfindOtherDependency = f

	return mmfindOtherDependency
}

// Return sets up results that will be returned by lineResolver.findOtherDependency
func (mmfindOtherDependency *mLineResolverMockfindOtherDependency) Return(r1 ResolvedDependency, err error) *LineResolverMock {
	if mmfindOtherDependency.mock.funcfindOtherDependency != nil {
		mmfindOtherDependency.mock.t.Fatalf("LineResolverMock.findOtherDependency mock is already set by Set")
	}

	if mmfindOtherDependency.defaultExpectation == nil {
		mmfindOtherDependency.defaultExpectation = &LineResolverMockfindOtherDependencyExpectation{mock: mmfindOtherDependency.mock}
	}
	mmfindOtherDependency.defaultExpectation.results = &LineResolverMockfindOtherDependencyResults{r1, err}
	return mmfindOtherDependency.mock
}

//Set uses given function f to mock the lineResolver.findOtherDependency method
func (mmfindOtherDependency *mLineResolverMockfindOtherDependency) Set(f func(ref reference.Holder) (r1 ResolvedDependency, err error)) *LineResolverMock {
	if mmfindOtherDependency.defaultExpectation != nil {
		mmfindOtherDependency.mock.t.Fatalf("Default expectation is already set for the lineResolver.findOtherDependency method")
	}

	if len(mmfindOtherDependency.expectations) > 0 {
		mmfindOtherDependency.mock.t.Fatalf("Some expectations are already set for the lineResolver.findOtherDependency method")
	}

	mmfindOtherDependency.mock.funcfindOtherDependency = f
	return mmfindOtherDependency.mock
}

// When sets expectation for the lineResolver.findOtherDependency which will trigger the result defined by the following
// Then helper
func (mmfindOtherDependency *mLineResolverMockfindOtherDependency) When(ref reference.Holder) *LineResolverMockfindOtherDependencyExpectation {
	if mmfindOtherDependency.mock.funcfindOtherDependency != nil {
		mmfindOtherDependency.mock.t.Fatalf("LineResolverMock.findOtherDependency mock is already set by Set")
	}

	expectation := &LineResolverMockfindOtherDependencyExpectation{
		mock:   mmfindOtherDependency.mock,
		params: &LineResolverMockfindOtherDependencyParams{ref},
	}
	mmfindOtherDependency.expectations = append(mmfindOtherDependency.expectations, expectation)
	return expectation
}

// Then sets up lineResolver.findOtherDependency return parameters for the expectation previously defined by the When method
func (e *LineResolverMockfindOtherDependencyExpectation) Then(r1 ResolvedDependency, err error) *LineResolverMock {
	e.results = &LineResolverMockfindOtherDependencyResults{r1, err}
	return e.mock
}

// findOtherDependency implements lineResolver
func (mmfindOtherDependency *LineResolverMock) findOtherDependency(ref reference.Holder) (r1 ResolvedDependency, err error) {
	mm_atomic.AddUint64(&mmfindOtherDependency.beforefindOtherDependencyCounter, 1)
	defer mm_atomic.AddUint64(&mmfindOtherDependency.afterfindOtherDependencyCounter, 1)

	if mmfindOtherDependency.inspectFuncfindOtherDependency != nil {
		mmfindOtherDependency.inspectFuncfindOtherDependency(ref)
	}

	mm_params := &LineResolverMockfindOtherDependencyParams{ref}

	// Record call args
	mmfindOtherDependency.findOtherDependencyMock.mutex.Lock()
	mmfindOtherDependency.findOtherDependencyMock.callArgs = append(mmfindOtherDependency.findOtherDependencyMock.callArgs, mm_params)
	mmfindOtherDependency.findOtherDependencyMock.mutex.Unlock()

	for _, e := range mmfindOtherDependency.findOtherDependencyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmfindOtherDependency.findOtherDependencyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmfindOtherDependency.findOtherDependencyMock.defaultExpectation.Counter, 1)
		mm_want := mmfindOtherDependency.findOtherDependencyMock.defaultExpectation.params
		mm_got := LineResolverMockfindOtherDependencyParams{ref}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmfindOtherDependency.t.Errorf("LineResolverMock.findOtherDependency got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmfindOtherDependency.findOtherDependencyMock.defaultExpectation.results
		if mm_results == nil {
			mmfindOtherDependency.t.Fatal("No results are set for the LineResolverMock.findOtherDependency")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmfindOtherDependency.funcfindOtherDependency != nil {
		return mmfindOtherDependency.funcfindOtherDependency(ref)
	}
	mmfindOtherDependency.t.Fatalf("Unexpected call to LineResolverMock.findOtherDependency. %v", ref)
	return
}

// findOtherDependencyAfterCounter returns a count of finished LineResolverMock.findOtherDependency invocations
func (mmfindOtherDependency *LineResolverMock) findOtherDependencyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmfindOtherDependency.afterfindOtherDependencyCounter)
}

// findOtherDependencyBeforeCounter returns a count of LineResolverMock.findOtherDependency invocations
func (mmfindOtherDependency *LineResolverMock) findOtherDependencyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmfindOtherDependency.beforefindOtherDependencyCounter)
}

// Calls returns a list of arguments used in each call to LineResolverMock.findOtherDependency.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmfindOtherDependency *mLineResolverMockfindOtherDependency) Calls() []*LineResolverMockfindOtherDependencyParams {
	mmfindOtherDependency.mutex.RLock()

	argCopy := make([]*LineResolverMockfindOtherDependencyParams, len(mmfindOtherDependency.callArgs))
	copy(argCopy, mmfindOtherDependency.callArgs)

	mmfindOtherDependency.mutex.RUnlock()

	return argCopy
}

// MinimockfindOtherDependencyDone returns true if the count of the findOtherDependency invocations corresponds
// the number of defined expectations
func (m *LineResolverMock) MinimockfindOtherDependencyDone() bool {
	for _, e := range m.findOtherDependencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.findOtherDependencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterfindOtherDependencyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcfindOtherDependency != nil && mm_atomic.LoadUint64(&m.afterfindOtherDependencyCounter) < 1 {
		return false
	}
	return true
}

// MinimockfindOtherDependencyInspect logs each unmet expectation
func (m *LineResolverMock) MinimockfindOtherDependencyInspect() {
	for _, e := range m.findOtherDependencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LineResolverMock.findOtherDependency with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.findOtherDependencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterfindOtherDependencyCounter) < 1 {
		if m.findOtherDependencyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LineResolverMock.findOtherDependency")
		} else {
			m.t.Errorf("Expected call to LineResolverMock.findOtherDependency with params: %#v", *m.findOtherDependencyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcfindOtherDependency != nil && mm_atomic.LoadUint64(&m.afterfindOtherDependencyCounter) < 1 {
		m.t.Error("Expected call to LineResolverMock.findOtherDependency")
	}
}

type mLineResolverMockgetLineBase struct {
	mock               *LineResolverMock
	defaultExpectation *LineResolverMockgetLineBaseExpectation
	expectations       []*LineResolverMockgetLineBaseExpectation
}

// LineResolverMockgetLineBaseExpectation specifies expectation struct of the lineResolver.getLineBase
type LineResolverMockgetLineBaseExpectation struct {
	mock *LineResolverMock

	results *LineResolverMockgetLineBaseResults
	Counter uint64
}

// LineResolverMockgetLineBaseResults contains results of the lineResolver.getLineBase
type LineResolverMockgetLineBaseResults struct {
	l1 reference.LocalHolder
}

// Expect sets up expected params for lineResolver.getLineBase
func (mmgetLineBase *mLineResolverMockgetLineBase) Expect() *mLineResolverMockgetLineBase {
	if mmgetLineBase.mock.funcgetLineBase != nil {
		mmgetLineBase.mock.t.Fatalf("LineResolverMock.getLineBase mock is already set by Set")
	}

	if mmgetLineBase.defaultExpectation == nil {
		mmgetLineBase.defaultExpectation = &LineResolverMockgetLineBaseExpectation{}
	}

	return mmgetLineBase
}

// Inspect accepts an inspector function that has same arguments as the lineResolver.getLineBase
func (mmgetLineBase *mLineResolverMockgetLineBase) Inspect(f func()) *mLineResolverMockgetLineBase {
	if mmgetLineBase.mock.inspectFuncgetLineBase != nil {
		mmgetLineBase.mock.t.Fatalf("Inspect function is already set for LineResolverMock.getLineBase")
	}

	mmgetLineBase.mock.inspectFuncgetLineBase = f

	return mmgetLineBase
}

// Return sets up results that will be returned by lineResolver.getLineBase
func (mmgetLineBase *mLineResolverMockgetLineBase) Return(l1 reference.LocalHolder) *LineResolverMock {
	if mmgetLineBase.mock.funcgetLineBase != nil {
		mmgetLineBase.mock.t.Fatalf("LineResolverMock.getLineBase mock is already set by Set")
	}

	if mmgetLineBase.defaultExpectation == nil {
		mmgetLineBase.defaultExpectation = &LineResolverMockgetLineBaseExpectation{mock: mmgetLineBase.mock}
	}
	mmgetLineBase.defaultExpectation.results = &LineResolverMockgetLineBaseResults{l1}
	return mmgetLineBase.mock
}

//Set uses given function f to mock the lineResolver.getLineBase method
func (mmgetLineBase *mLineResolverMockgetLineBase) Set(f func() (l1 reference.LocalHolder)) *LineResolverMock {
	if mmgetLineBase.defaultExpectation != nil {
		mmgetLineBase.mock.t.Fatalf("Default expectation is already set for the lineResolver.getLineBase method")
	}

	if len(mmgetLineBase.expectations) > 0 {
		mmgetLineBase.mock.t.Fatalf("Some expectations are already set for the lineResolver.getLineBase method")
	}

	mmgetLineBase.mock.funcgetLineBase = f
	return mmgetLineBase.mock
}

// getLineBase implements lineResolver
func (mmgetLineBase *LineResolverMock) getLineBase() (l1 reference.LocalHolder) {
	mm_atomic.AddUint64(&mmgetLineBase.beforegetLineBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmgetLineBase.aftergetLineBaseCounter, 1)

	if mmgetLineBase.inspectFuncgetLineBase != nil {
		mmgetLineBase.inspectFuncgetLineBase()
	}

	if mmgetLineBase.getLineBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmgetLineBase.getLineBaseMock.defaultExpectation.Counter, 1)

		mm_results := mmgetLineBase.getLineBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmgetLineBase.t.Fatal("No results are set for the LineResolverMock.getLineBase")
		}
		return (*mm_results).l1
	}
	if mmgetLineBase.funcgetLineBase != nil {
		return mmgetLineBase.funcgetLineBase()
	}
	mmgetLineBase.t.Fatalf("Unexpected call to LineResolverMock.getLineBase.")
	return
}

// getLineBaseAfterCounter returns a count of finished LineResolverMock.getLineBase invocations
func (mmgetLineBase *LineResolverMock) getLineBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmgetLineBase.aftergetLineBaseCounter)
}

// getLineBaseBeforeCounter returns a count of LineResolverMock.getLineBase invocations
func (mmgetLineBase *LineResolverMock) getLineBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmgetLineBase.beforegetLineBaseCounter)
}

// MinimockgetLineBaseDone returns true if the count of the getLineBase invocations corresponds
// the number of defined expectations
func (m *LineResolverMock) MinimockgetLineBaseDone() bool {
	for _, e := range m.getLineBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.getLineBaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftergetLineBaseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcgetLineBase != nil && mm_atomic.LoadUint64(&m.aftergetLineBaseCounter) < 1 {
		return false
	}
	return true
}

// MinimockgetLineBaseInspect logs each unmet expectation
func (m *LineResolverMock) MinimockgetLineBaseInspect() {
	for _, e := range m.getLineBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LineResolverMock.getLineBase")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.getLineBaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftergetLineBaseCounter) < 1 {
		m.t.Error("Expected call to LineResolverMock.getLineBase")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcgetLineBase != nil && mm_atomic.LoadUint64(&m.aftergetLineBaseCounter) < 1 {
		m.t.Error("Expected call to LineResolverMock.getLineBase")
	}
}

type mLineResolverMockgetLocalPN struct {
	mock               *LineResolverMock
	defaultExpectation *LineResolverMockgetLocalPNExpectation
	expectations       []*LineResolverMockgetLocalPNExpectation
}

// LineResolverMockgetLocalPNExpectation specifies expectation struct of the lineResolver.getLocalPN
type LineResolverMockgetLocalPNExpectation struct {
	mock *LineResolverMock

	results *LineResolverMockgetLocalPNResults
	Counter uint64
}

// LineResolverMockgetLocalPNResults contains results of the lineResolver.getLocalPN
type LineResolverMockgetLocalPNResults struct {
	n1 pulse.Number
}

// Expect sets up expected params for lineResolver.getLocalPN
func (mmgetLocalPN *mLineResolverMockgetLocalPN) Expect() *mLineResolverMockgetLocalPN {
	if mmgetLocalPN.mock.funcgetLocalPN != nil {
		mmgetLocalPN.mock.t.Fatalf("LineResolverMock.getLocalPN mock is already set by Set")
	}

	if mmgetLocalPN.defaultExpectation == nil {
		mmgetLocalPN.defaultExpectation = &LineResolverMockgetLocalPNExpectation{}
	}

	return mmgetLocalPN
}

// Inspect accepts an inspector function that has same arguments as the lineResolver.getLocalPN
func (mmgetLocalPN *mLineResolverMockgetLocalPN) Inspect(f func()) *mLineResolverMockgetLocalPN {
	if mmgetLocalPN.mock.inspectFuncgetLocalPN != nil {
		mmgetLocalPN.mock.t.Fatalf("Inspect function is already set for LineResolverMock.getLocalPN")
	}

	mmgetLocalPN.mock.inspectFuncgetLocalPN = f

	return mmgetLocalPN
}

// Return sets up results that will be returned by lineResolver.getLocalPN
func (mmgetLocalPN *mLineResolverMockgetLocalPN) Return(n1 pulse.Number) *LineResolverMock {
	if mmgetLocalPN.mock.funcgetLocalPN != nil {
		mmgetLocalPN.mock.t.Fatalf("LineResolverMock.getLocalPN mock is already set by Set")
	}

	if mmgetLocalPN.defaultExpectation == nil {
		mmgetLocalPN.defaultExpectation = &LineResolverMockgetLocalPNExpectation{mock: mmgetLocalPN.mock}
	}
	mmgetLocalPN.defaultExpectation.results = &LineResolverMockgetLocalPNResults{n1}
	return mmgetLocalPN.mock
}

//Set uses given function f to mock the lineResolver.getLocalPN method
func (mmgetLocalPN *mLineResolverMockgetLocalPN) Set(f func() (n1 pulse.Number)) *LineResolverMock {
	if mmgetLocalPN.defaultExpectation != nil {
		mmgetLocalPN.mock.t.Fatalf("Default expectation is already set for the lineResolver.getLocalPN method")
	}

	if len(mmgetLocalPN.expectations) > 0 {
		mmgetLocalPN.mock.t.Fatalf("Some expectations are already set for the lineResolver.getLocalPN method")
	}

	mmgetLocalPN.mock.funcgetLocalPN = f
	return mmgetLocalPN.mock
}

// getLocalPN implements lineResolver
func (mmgetLocalPN *LineResolverMock) getLocalPN() (n1 pulse.Number) {
	mm_atomic.AddUint64(&mmgetLocalPN.beforegetLocalPNCounter, 1)
	defer mm_atomic.AddUint64(&mmgetLocalPN.aftergetLocalPNCounter, 1)

	if mmgetLocalPN.inspectFuncgetLocalPN != nil {
		mmgetLocalPN.inspectFuncgetLocalPN()
	}

	if mmgetLocalPN.getLocalPNMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmgetLocalPN.getLocalPNMock.defaultExpectation.Counter, 1)

		mm_results := mmgetLocalPN.getLocalPNMock.defaultExpectation.results
		if mm_results == nil {
			mmgetLocalPN.t.Fatal("No results are set for the LineResolverMock.getLocalPN")
		}
		return (*mm_results).n1
	}
	if mmgetLocalPN.funcgetLocalPN != nil {
		return mmgetLocalPN.funcgetLocalPN()
	}
	mmgetLocalPN.t.Fatalf("Unexpected call to LineResolverMock.getLocalPN.")
	return
}

// getLocalPNAfterCounter returns a count of finished LineResolverMock.getLocalPN invocations
func (mmgetLocalPN *LineResolverMock) getLocalPNAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmgetLocalPN.aftergetLocalPNCounter)
}

// getLocalPNBeforeCounter returns a count of LineResolverMock.getLocalPN invocations
func (mmgetLocalPN *LineResolverMock) getLocalPNBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmgetLocalPN.beforegetLocalPNCounter)
}

// MinimockgetLocalPNDone returns true if the count of the getLocalPN invocations corresponds
// the number of defined expectations
func (m *LineResolverMock) MinimockgetLocalPNDone() bool {
	for _, e := range m.getLocalPNMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.getLocalPNMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftergetLocalPNCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcgetLocalPN != nil && mm_atomic.LoadUint64(&m.aftergetLocalPNCounter) < 1 {
		return false
	}
	return true
}

// MinimockgetLocalPNInspect logs each unmet expectation
func (m *LineResolverMock) MinimockgetLocalPNInspect() {
	for _, e := range m.getLocalPNMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LineResolverMock.getLocalPN")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.getLocalPNMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftergetLocalPNCounter) < 1 {
		m.t.Error("Expected call to LineResolverMock.getLocalPN")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcgetLocalPN != nil && mm_atomic.LoadUint64(&m.aftergetLocalPNCounter) < 1 {
		m.t.Error("Expected call to LineResolverMock.getLocalPN")
	}
}

type mLineResolverMockgetNextFilNo struct {
	mock               *LineResolverMock
	defaultExpectation *LineResolverMockgetNextFilNoExpectation
	expectations       []*LineResolverMockgetNextFilNoExpectation
}

// LineResolverMockgetNextFilNoExpectation specifies expectation struct of the lineResolver.getNextFilNo
type LineResolverMockgetNextFilNoExpectation struct {
	mock *LineResolverMock

	results *LineResolverMockgetNextFilNoResults
	Counter uint64
}

// LineResolverMockgetNextFilNoResults contains results of the lineResolver.getNextFilNo
type LineResolverMockgetNextFilNoResults struct {
	f1 filamentNo
}

// Expect sets up expected params for lineResolver.getNextFilNo
func (mmgetNextFilNo *mLineResolverMockgetNextFilNo) Expect() *mLineResolverMockgetNextFilNo {
	if mmgetNextFilNo.mock.funcgetNextFilNo != nil {
		mmgetNextFilNo.mock.t.Fatalf("LineResolverMock.getNextFilNo mock is already set by Set")
	}

	if mmgetNextFilNo.defaultExpectation == nil {
		mmgetNextFilNo.defaultExpectation = &LineResolverMockgetNextFilNoExpectation{}
	}

	return mmgetNextFilNo
}

// Inspect accepts an inspector function that has same arguments as the lineResolver.getNextFilNo
func (mmgetNextFilNo *mLineResolverMockgetNextFilNo) Inspect(f func()) *mLineResolverMockgetNextFilNo {
	if mmgetNextFilNo.mock.inspectFuncgetNextFilNo != nil {
		mmgetNextFilNo.mock.t.Fatalf("Inspect function is already set for LineResolverMock.getNextFilNo")
	}

	mmgetNextFilNo.mock.inspectFuncgetNextFilNo = f

	return mmgetNextFilNo
}

// Return sets up results that will be returned by lineResolver.getNextFilNo
func (mmgetNextFilNo *mLineResolverMockgetNextFilNo) Return(f1 filamentNo) *LineResolverMock {
	if mmgetNextFilNo.mock.funcgetNextFilNo != nil {
		mmgetNextFilNo.mock.t.Fatalf("LineResolverMock.getNextFilNo mock is already set by Set")
	}

	if mmgetNextFilNo.defaultExpectation == nil {
		mmgetNextFilNo.defaultExpectation = &LineResolverMockgetNextFilNoExpectation{mock: mmgetNextFilNo.mock}
	}
	mmgetNextFilNo.defaultExpectation.results = &LineResolverMockgetNextFilNoResults{f1}
	return mmgetNextFilNo.mock
}

//Set uses given function f to mock the lineResolver.getNextFilNo method
func (mmgetNextFilNo *mLineResolverMockgetNextFilNo) Set(f func() (f1 filamentNo)) *LineResolverMock {
	if mmgetNextFilNo.defaultExpectation != nil {
		mmgetNextFilNo.mock.t.Fatalf("Default expectation is already set for the lineResolver.getNextFilNo method")
	}

	if len(mmgetNextFilNo.expectations) > 0 {
		mmgetNextFilNo.mock.t.Fatalf("Some expectations are already set for the lineResolver.getNextFilNo method")
	}

	mmgetNextFilNo.mock.funcgetNextFilNo = f
	return mmgetNextFilNo.mock
}

// getNextFilNo implements lineResolver
func (mmgetNextFilNo *LineResolverMock) getNextFilNo() (f1 filamentNo) {
	mm_atomic.AddUint64(&mmgetNextFilNo.beforegetNextFilNoCounter, 1)
	defer mm_atomic.AddUint64(&mmgetNextFilNo.aftergetNextFilNoCounter, 1)

	if mmgetNextFilNo.inspectFuncgetNextFilNo != nil {
		mmgetNextFilNo.inspectFuncgetNextFilNo()
	}

	if mmgetNextFilNo.getNextFilNoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmgetNextFilNo.getNextFilNoMock.defaultExpectation.Counter, 1)

		mm_results := mmgetNextFilNo.getNextFilNoMock.defaultExpectation.results
		if mm_results == nil {
			mmgetNextFilNo.t.Fatal("No results are set for the LineResolverMock.getNextFilNo")
		}
		return (*mm_results).f1
	}
	if mmgetNextFilNo.funcgetNextFilNo != nil {
		return mmgetNextFilNo.funcgetNextFilNo()
	}
	mmgetNextFilNo.t.Fatalf("Unexpected call to LineResolverMock.getNextFilNo.")
	return
}

// getNextFilNoAfterCounter returns a count of finished LineResolverMock.getNextFilNo invocations
func (mmgetNextFilNo *LineResolverMock) getNextFilNoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmgetNextFilNo.aftergetNextFilNoCounter)
}

// getNextFilNoBeforeCounter returns a count of LineResolverMock.getNextFilNo invocations
func (mmgetNextFilNo *LineResolverMock) getNextFilNoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmgetNextFilNo.beforegetNextFilNoCounter)
}

// MinimockgetNextFilNoDone returns true if the count of the getNextFilNo invocations corresponds
// the number of defined expectations
func (m *LineResolverMock) MinimockgetNextFilNoDone() bool {
	for _, e := range m.getNextFilNoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.getNextFilNoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftergetNextFilNoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcgetNextFilNo != nil && mm_atomic.LoadUint64(&m.aftergetNextFilNoCounter) < 1 {
		return false
	}
	return true
}

// MinimockgetNextFilNoInspect logs each unmet expectation
func (m *LineResolverMock) MinimockgetNextFilNoInspect() {
	for _, e := range m.getNextFilNoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LineResolverMock.getNextFilNo")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.getNextFilNoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftergetNextFilNoCounter) < 1 {
		m.t.Error("Expected call to LineResolverMock.getNextFilNo")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcgetNextFilNo != nil && mm_atomic.LoadUint64(&m.aftergetNextFilNoCounter) < 1 {
		m.t.Error("Expected call to LineResolverMock.getNextFilNo")
	}
}

type mLineResolverMockgetNextRecNo struct {
	mock               *LineResolverMock
	defaultExpectation *LineResolverMockgetNextRecNoExpectation
	expectations       []*LineResolverMockgetNextRecNoExpectation
}

// LineResolverMockgetNextRecNoExpectation specifies expectation struct of the lineResolver.getNextRecNo
type LineResolverMockgetNextRecNoExpectation struct {
	mock *LineResolverMock

	results *LineResolverMockgetNextRecNoResults
	Counter uint64
}

// LineResolverMockgetNextRecNoResults contains results of the lineResolver.getNextRecNo
type LineResolverMockgetNextRecNoResults struct {
	r1 recordNo
}

// Expect sets up expected params for lineResolver.getNextRecNo
func (mmgetNextRecNo *mLineResolverMockgetNextRecNo) Expect() *mLineResolverMockgetNextRecNo {
	if mmgetNextRecNo.mock.funcgetNextRecNo != nil {
		mmgetNextRecNo.mock.t.Fatalf("LineResolverMock.getNextRecNo mock is already set by Set")
	}

	if mmgetNextRecNo.defaultExpectation == nil {
		mmgetNextRecNo.defaultExpectation = &LineResolverMockgetNextRecNoExpectation{}
	}

	return mmgetNextRecNo
}

// Inspect accepts an inspector function that has same arguments as the lineResolver.getNextRecNo
func (mmgetNextRecNo *mLineResolverMockgetNextRecNo) Inspect(f func()) *mLineResolverMockgetNextRecNo {
	if mmgetNextRecNo.mock.inspectFuncgetNextRecNo != nil {
		mmgetNextRecNo.mock.t.Fatalf("Inspect function is already set for LineResolverMock.getNextRecNo")
	}

	mmgetNextRecNo.mock.inspectFuncgetNextRecNo = f

	return mmgetNextRecNo
}

// Return sets up results that will be returned by lineResolver.getNextRecNo
func (mmgetNextRecNo *mLineResolverMockgetNextRecNo) Return(r1 recordNo) *LineResolverMock {
	if mmgetNextRecNo.mock.funcgetNextRecNo != nil {
		mmgetNextRecNo.mock.t.Fatalf("LineResolverMock.getNextRecNo mock is already set by Set")
	}

	if mmgetNextRecNo.defaultExpectation == nil {
		mmgetNextRecNo.defaultExpectation = &LineResolverMockgetNextRecNoExpectation{mock: mmgetNextRecNo.mock}
	}
	mmgetNextRecNo.defaultExpectation.results = &LineResolverMockgetNextRecNoResults{r1}
	return mmgetNextRecNo.mock
}

//Set uses given function f to mock the lineResolver.getNextRecNo method
func (mmgetNextRecNo *mLineResolverMockgetNextRecNo) Set(f func() (r1 recordNo)) *LineResolverMock {
	if mmgetNextRecNo.defaultExpectation != nil {
		mmgetNextRecNo.mock.t.Fatalf("Default expectation is already set for the lineResolver.getNextRecNo method")
	}

	if len(mmgetNextRecNo.expectations) > 0 {
		mmgetNextRecNo.mock.t.Fatalf("Some expectations are already set for the lineResolver.getNextRecNo method")
	}

	mmgetNextRecNo.mock.funcgetNextRecNo = f
	return mmgetNextRecNo.mock
}

// getNextRecNo implements lineResolver
func (mmgetNextRecNo *LineResolverMock) getNextRecNo() (r1 recordNo) {
	mm_atomic.AddUint64(&mmgetNextRecNo.beforegetNextRecNoCounter, 1)
	defer mm_atomic.AddUint64(&mmgetNextRecNo.aftergetNextRecNoCounter, 1)

	if mmgetNextRecNo.inspectFuncgetNextRecNo != nil {
		mmgetNextRecNo.inspectFuncgetNextRecNo()
	}

	if mmgetNextRecNo.getNextRecNoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmgetNextRecNo.getNextRecNoMock.defaultExpectation.Counter, 1)

		mm_results := mmgetNextRecNo.getNextRecNoMock.defaultExpectation.results
		if mm_results == nil {
			mmgetNextRecNo.t.Fatal("No results are set for the LineResolverMock.getNextRecNo")
		}
		return (*mm_results).r1
	}
	if mmgetNextRecNo.funcgetNextRecNo != nil {
		return mmgetNextRecNo.funcgetNextRecNo()
	}
	mmgetNextRecNo.t.Fatalf("Unexpected call to LineResolverMock.getNextRecNo.")
	return
}

// getNextRecNoAfterCounter returns a count of finished LineResolverMock.getNextRecNo invocations
func (mmgetNextRecNo *LineResolverMock) getNextRecNoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmgetNextRecNo.aftergetNextRecNoCounter)
}

// getNextRecNoBeforeCounter returns a count of LineResolverMock.getNextRecNo invocations
func (mmgetNextRecNo *LineResolverMock) getNextRecNoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmgetNextRecNo.beforegetNextRecNoCounter)
}

// MinimockgetNextRecNoDone returns true if the count of the getNextRecNo invocations corresponds
// the number of defined expectations
func (m *LineResolverMock) MinimockgetNextRecNoDone() bool {
	for _, e := range m.getNextRecNoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.getNextRecNoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftergetNextRecNoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcgetNextRecNo != nil && mm_atomic.LoadUint64(&m.aftergetNextRecNoCounter) < 1 {
		return false
	}
	return true
}

// MinimockgetNextRecNoInspect logs each unmet expectation
func (m *LineResolverMock) MinimockgetNextRecNoInspect() {
	for _, e := range m.getNextRecNoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LineResolverMock.getNextRecNo")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.getNextRecNoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftergetNextRecNoCounter) < 1 {
		m.t.Error("Expected call to LineResolverMock.getNextRecNo")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcgetNextRecNo != nil && mm_atomic.LoadUint64(&m.aftergetNextRecNoCounter) < 1 {
		m.t.Error("Expected call to LineResolverMock.getNextRecNo")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LineResolverMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockfindChainedDependencyInspect()

		m.MinimockfindCollisionInspect()

		m.MinimockfindFilamentInspect()

		m.MinimockfindLineDependencyInspect()

		m.MinimockfindLocalDependencyInspect()

		m.MinimockfindOtherDependencyInspect()

		m.MinimockgetLineBaseInspect()

		m.MinimockgetLocalPNInspect()

		m.MinimockgetNextFilNoInspect()

		m.MinimockgetNextRecNoInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LineResolverMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LineResolverMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockfindChainedDependencyDone() &&
		m.MinimockfindCollisionDone() &&
		m.MinimockfindFilamentDone() &&
		m.MinimockfindLineDependencyDone() &&
		m.MinimockfindLocalDependencyDone() &&
		m.MinimockfindOtherDependencyDone() &&
		m.MinimockgetLineBaseDone() &&
		m.MinimockgetLocalPNDone() &&
		m.MinimockgetNextFilNoDone() &&
		m.MinimockgetNextRecNoDone()
}
