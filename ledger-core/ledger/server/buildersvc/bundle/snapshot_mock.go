package bundle

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/ledger"
)

// SnapshotMock implements Snapshot
type SnapshotMock struct {
	t minimock.Tester

	funcChainedRollback          func()
	inspectFuncChainedRollback   func()
	afterChainedRollbackCounter  uint64
	beforeChainedRollbackCounter uint64
	ChainedRollbackMock          mSnapshotMockChainedRollback

	funcCommit          func() (err error)
	inspectFuncCommit   func()
	afterCommitCounter  uint64
	beforeCommitCounter uint64
	CommitMock          mSnapshotMockCommit

	funcCompleted          func() (err error)
	inspectFuncCompleted   func()
	afterCompletedCounter  uint64
	beforeCompletedCounter uint64
	CompletedMock          mSnapshotMockCompleted

	funcGetDirectorySection          func(s1 ledger.SectionID) (d1 DirectorySection, err error)
	inspectFuncGetDirectorySection   func(s1 ledger.SectionID)
	afterGetDirectorySectionCounter  uint64
	beforeGetDirectorySectionCounter uint64
	GetDirectorySectionMock          mSnapshotMockGetDirectorySection

	funcGetPayloadSection          func(s1 ledger.SectionID) (p1 PayloadSection, err error)
	inspectFuncGetPayloadSection   func(s1 ledger.SectionID)
	afterGetPayloadSectionCounter  uint64
	beforeGetPayloadSectionCounter uint64
	GetPayloadSectionMock          mSnapshotMockGetPayloadSection

	funcPrepared          func() (err error)
	inspectFuncPrepared   func()
	afterPreparedCounter  uint64
	beforePreparedCounter uint64
	PreparedMock          mSnapshotMockPrepared

	funcRollback          func()
	inspectFuncRollback   func()
	afterRollbackCounter  uint64
	beforeRollbackCounter uint64
	RollbackMock          mSnapshotMockRollback
}

// NewSnapshotMock returns a mock for Snapshot
func NewSnapshotMock(t minimock.Tester) *SnapshotMock {
	m := &SnapshotMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChainedRollbackMock = mSnapshotMockChainedRollback{mock: m}

	m.CommitMock = mSnapshotMockCommit{mock: m}

	m.CompletedMock = mSnapshotMockCompleted{mock: m}

	m.GetDirectorySectionMock = mSnapshotMockGetDirectorySection{mock: m}
	m.GetDirectorySectionMock.callArgs = []*SnapshotMockGetDirectorySectionParams{}

	m.GetPayloadSectionMock = mSnapshotMockGetPayloadSection{mock: m}
	m.GetPayloadSectionMock.callArgs = []*SnapshotMockGetPayloadSectionParams{}

	m.PreparedMock = mSnapshotMockPrepared{mock: m}

	m.RollbackMock = mSnapshotMockRollback{mock: m}

	return m
}

type mSnapshotMockChainedRollback struct {
	mock               *SnapshotMock
	defaultExpectation *SnapshotMockChainedRollbackExpectation
	expectations       []*SnapshotMockChainedRollbackExpectation
}

// SnapshotMockChainedRollbackExpectation specifies expectation struct of the Snapshot.ChainedRollback
type SnapshotMockChainedRollbackExpectation struct {
	mock *SnapshotMock

	Counter uint64
}

// Expect sets up expected params for Snapshot.ChainedRollback
func (mmChainedRollback *mSnapshotMockChainedRollback) Expect() *mSnapshotMockChainedRollback {
	if mmChainedRollback.mock.funcChainedRollback != nil {
		mmChainedRollback.mock.t.Fatalf("SnapshotMock.ChainedRollback mock is already set by Set")
	}

	if mmChainedRollback.defaultExpectation == nil {
		mmChainedRollback.defaultExpectation = &SnapshotMockChainedRollbackExpectation{}
	}

	return mmChainedRollback
}

// Inspect accepts an inspector function that has same arguments as the Snapshot.ChainedRollback
func (mmChainedRollback *mSnapshotMockChainedRollback) Inspect(f func()) *mSnapshotMockChainedRollback {
	if mmChainedRollback.mock.inspectFuncChainedRollback != nil {
		mmChainedRollback.mock.t.Fatalf("Inspect function is already set for SnapshotMock.ChainedRollback")
	}

	mmChainedRollback.mock.inspectFuncChainedRollback = f

	return mmChainedRollback
}

// Return sets up results that will be returned by Snapshot.ChainedRollback
func (mmChainedRollback *mSnapshotMockChainedRollback) Return() *SnapshotMock {
	if mmChainedRollback.mock.funcChainedRollback != nil {
		mmChainedRollback.mock.t.Fatalf("SnapshotMock.ChainedRollback mock is already set by Set")
	}

	if mmChainedRollback.defaultExpectation == nil {
		mmChainedRollback.defaultExpectation = &SnapshotMockChainedRollbackExpectation{mock: mmChainedRollback.mock}
	}

	return mmChainedRollback.mock
}

//Set uses given function f to mock the Snapshot.ChainedRollback method
func (mmChainedRollback *mSnapshotMockChainedRollback) Set(f func()) *SnapshotMock {
	if mmChainedRollback.defaultExpectation != nil {
		mmChainedRollback.mock.t.Fatalf("Default expectation is already set for the Snapshot.ChainedRollback method")
	}

	if len(mmChainedRollback.expectations) > 0 {
		mmChainedRollback.mock.t.Fatalf("Some expectations are already set for the Snapshot.ChainedRollback method")
	}

	mmChainedRollback.mock.funcChainedRollback = f
	return mmChainedRollback.mock
}

// ChainedRollback implements Snapshot
func (mmChainedRollback *SnapshotMock) ChainedRollback() {
	mm_atomic.AddUint64(&mmChainedRollback.beforeChainedRollbackCounter, 1)
	defer mm_atomic.AddUint64(&mmChainedRollback.afterChainedRollbackCounter, 1)

	if mmChainedRollback.inspectFuncChainedRollback != nil {
		mmChainedRollback.inspectFuncChainedRollback()
	}

	if mmChainedRollback.ChainedRollbackMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChainedRollback.ChainedRollbackMock.defaultExpectation.Counter, 1)

		return

	}
	if mmChainedRollback.funcChainedRollback != nil {
		mmChainedRollback.funcChainedRollback()
		return
	}
	mmChainedRollback.t.Fatalf("Unexpected call to SnapshotMock.ChainedRollback.")

}

// ChainedRollbackAfterCounter returns a count of finished SnapshotMock.ChainedRollback invocations
func (mmChainedRollback *SnapshotMock) ChainedRollbackAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChainedRollback.afterChainedRollbackCounter)
}

// ChainedRollbackBeforeCounter returns a count of SnapshotMock.ChainedRollback invocations
func (mmChainedRollback *SnapshotMock) ChainedRollbackBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChainedRollback.beforeChainedRollbackCounter)
}

// MinimockChainedRollbackDone returns true if the count of the ChainedRollback invocations corresponds
// the number of defined expectations
func (m *SnapshotMock) MinimockChainedRollbackDone() bool {
	for _, e := range m.ChainedRollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChainedRollbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChainedRollbackCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChainedRollback != nil && mm_atomic.LoadUint64(&m.afterChainedRollbackCounter) < 1 {
		return false
	}
	return true
}

// MinimockChainedRollbackInspect logs each unmet expectation
func (m *SnapshotMock) MinimockChainedRollbackInspect() {
	for _, e := range m.ChainedRollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SnapshotMock.ChainedRollback")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChainedRollbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChainedRollbackCounter) < 1 {
		m.t.Error("Expected call to SnapshotMock.ChainedRollback")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChainedRollback != nil && mm_atomic.LoadUint64(&m.afterChainedRollbackCounter) < 1 {
		m.t.Error("Expected call to SnapshotMock.ChainedRollback")
	}
}

type mSnapshotMockCommit struct {
	mock               *SnapshotMock
	defaultExpectation *SnapshotMockCommitExpectation
	expectations       []*SnapshotMockCommitExpectation
}

// SnapshotMockCommitExpectation specifies expectation struct of the Snapshot.Commit
type SnapshotMockCommitExpectation struct {
	mock *SnapshotMock

	results *SnapshotMockCommitResults
	Counter uint64
}

// SnapshotMockCommitResults contains results of the Snapshot.Commit
type SnapshotMockCommitResults struct {
	err error
}

// Expect sets up expected params for Snapshot.Commit
func (mmCommit *mSnapshotMockCommit) Expect() *mSnapshotMockCommit {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("SnapshotMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &SnapshotMockCommitExpectation{}
	}

	return mmCommit
}

// Inspect accepts an inspector function that has same arguments as the Snapshot.Commit
func (mmCommit *mSnapshotMockCommit) Inspect(f func()) *mSnapshotMockCommit {
	if mmCommit.mock.inspectFuncCommit != nil {
		mmCommit.mock.t.Fatalf("Inspect function is already set for SnapshotMock.Commit")
	}

	mmCommit.mock.inspectFuncCommit = f

	return mmCommit
}

// Return sets up results that will be returned by Snapshot.Commit
func (mmCommit *mSnapshotMockCommit) Return(err error) *SnapshotMock {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("SnapshotMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &SnapshotMockCommitExpectation{mock: mmCommit.mock}
	}
	mmCommit.defaultExpectation.results = &SnapshotMockCommitResults{err}
	return mmCommit.mock
}

//Set uses given function f to mock the Snapshot.Commit method
func (mmCommit *mSnapshotMockCommit) Set(f func() (err error)) *SnapshotMock {
	if mmCommit.defaultExpectation != nil {
		mmCommit.mock.t.Fatalf("Default expectation is already set for the Snapshot.Commit method")
	}

	if len(mmCommit.expectations) > 0 {
		mmCommit.mock.t.Fatalf("Some expectations are already set for the Snapshot.Commit method")
	}

	mmCommit.mock.funcCommit = f
	return mmCommit.mock
}

// Commit implements Snapshot
func (mmCommit *SnapshotMock) Commit() (err error) {
	mm_atomic.AddUint64(&mmCommit.beforeCommitCounter, 1)
	defer mm_atomic.AddUint64(&mmCommit.afterCommitCounter, 1)

	if mmCommit.inspectFuncCommit != nil {
		mmCommit.inspectFuncCommit()
	}

	if mmCommit.CommitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommit.CommitMock.defaultExpectation.Counter, 1)

		mm_results := mmCommit.CommitMock.defaultExpectation.results
		if mm_results == nil {
			mmCommit.t.Fatal("No results are set for the SnapshotMock.Commit")
		}
		return (*mm_results).err
	}
	if mmCommit.funcCommit != nil {
		return mmCommit.funcCommit()
	}
	mmCommit.t.Fatalf("Unexpected call to SnapshotMock.Commit.")
	return
}

// CommitAfterCounter returns a count of finished SnapshotMock.Commit invocations
func (mmCommit *SnapshotMock) CommitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.afterCommitCounter)
}

// CommitBeforeCounter returns a count of SnapshotMock.Commit invocations
func (mmCommit *SnapshotMock) CommitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.beforeCommitCounter)
}

// MinimockCommitDone returns true if the count of the Commit invocations corresponds
// the number of defined expectations
func (m *SnapshotMock) MinimockCommitDone() bool {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		return false
	}
	return true
}

// MinimockCommitInspect logs each unmet expectation
func (m *SnapshotMock) MinimockCommitInspect() {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SnapshotMock.Commit")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		m.t.Error("Expected call to SnapshotMock.Commit")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		m.t.Error("Expected call to SnapshotMock.Commit")
	}
}

type mSnapshotMockCompleted struct {
	mock               *SnapshotMock
	defaultExpectation *SnapshotMockCompletedExpectation
	expectations       []*SnapshotMockCompletedExpectation
}

// SnapshotMockCompletedExpectation specifies expectation struct of the Snapshot.Completed
type SnapshotMockCompletedExpectation struct {
	mock *SnapshotMock

	results *SnapshotMockCompletedResults
	Counter uint64
}

// SnapshotMockCompletedResults contains results of the Snapshot.Completed
type SnapshotMockCompletedResults struct {
	err error
}

// Expect sets up expected params for Snapshot.Completed
func (mmCompleted *mSnapshotMockCompleted) Expect() *mSnapshotMockCompleted {
	if mmCompleted.mock.funcCompleted != nil {
		mmCompleted.mock.t.Fatalf("SnapshotMock.Completed mock is already set by Set")
	}

	if mmCompleted.defaultExpectation == nil {
		mmCompleted.defaultExpectation = &SnapshotMockCompletedExpectation{}
	}

	return mmCompleted
}

// Inspect accepts an inspector function that has same arguments as the Snapshot.Completed
func (mmCompleted *mSnapshotMockCompleted) Inspect(f func()) *mSnapshotMockCompleted {
	if mmCompleted.mock.inspectFuncCompleted != nil {
		mmCompleted.mock.t.Fatalf("Inspect function is already set for SnapshotMock.Completed")
	}

	mmCompleted.mock.inspectFuncCompleted = f

	return mmCompleted
}

// Return sets up results that will be returned by Snapshot.Completed
func (mmCompleted *mSnapshotMockCompleted) Return(err error) *SnapshotMock {
	if mmCompleted.mock.funcCompleted != nil {
		mmCompleted.mock.t.Fatalf("SnapshotMock.Completed mock is already set by Set")
	}

	if mmCompleted.defaultExpectation == nil {
		mmCompleted.defaultExpectation = &SnapshotMockCompletedExpectation{mock: mmCompleted.mock}
	}
	mmCompleted.defaultExpectation.results = &SnapshotMockCompletedResults{err}
	return mmCompleted.mock
}

//Set uses given function f to mock the Snapshot.Completed method
func (mmCompleted *mSnapshotMockCompleted) Set(f func() (err error)) *SnapshotMock {
	if mmCompleted.defaultExpectation != nil {
		mmCompleted.mock.t.Fatalf("Default expectation is already set for the Snapshot.Completed method")
	}

	if len(mmCompleted.expectations) > 0 {
		mmCompleted.mock.t.Fatalf("Some expectations are already set for the Snapshot.Completed method")
	}

	mmCompleted.mock.funcCompleted = f
	return mmCompleted.mock
}

// Completed implements Snapshot
func (mmCompleted *SnapshotMock) Completed() (err error) {
	mm_atomic.AddUint64(&mmCompleted.beforeCompletedCounter, 1)
	defer mm_atomic.AddUint64(&mmCompleted.afterCompletedCounter, 1)

	if mmCompleted.inspectFuncCompleted != nil {
		mmCompleted.inspectFuncCompleted()
	}

	if mmCompleted.CompletedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCompleted.CompletedMock.defaultExpectation.Counter, 1)

		mm_results := mmCompleted.CompletedMock.defaultExpectation.results
		if mm_results == nil {
			mmCompleted.t.Fatal("No results are set for the SnapshotMock.Completed")
		}
		return (*mm_results).err
	}
	if mmCompleted.funcCompleted != nil {
		return mmCompleted.funcCompleted()
	}
	mmCompleted.t.Fatalf("Unexpected call to SnapshotMock.Completed.")
	return
}

// CompletedAfterCounter returns a count of finished SnapshotMock.Completed invocations
func (mmCompleted *SnapshotMock) CompletedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompleted.afterCompletedCounter)
}

// CompletedBeforeCounter returns a count of SnapshotMock.Completed invocations
func (mmCompleted *SnapshotMock) CompletedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompleted.beforeCompletedCounter)
}

// MinimockCompletedDone returns true if the count of the Completed invocations corresponds
// the number of defined expectations
func (m *SnapshotMock) MinimockCompletedDone() bool {
	for _, e := range m.CompletedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CompletedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCompletedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCompleted != nil && mm_atomic.LoadUint64(&m.afterCompletedCounter) < 1 {
		return false
	}
	return true
}

// MinimockCompletedInspect logs each unmet expectation
func (m *SnapshotMock) MinimockCompletedInspect() {
	for _, e := range m.CompletedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SnapshotMock.Completed")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CompletedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCompletedCounter) < 1 {
		m.t.Error("Expected call to SnapshotMock.Completed")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCompleted != nil && mm_atomic.LoadUint64(&m.afterCompletedCounter) < 1 {
		m.t.Error("Expected call to SnapshotMock.Completed")
	}
}

type mSnapshotMockGetDirectorySection struct {
	mock               *SnapshotMock
	defaultExpectation *SnapshotMockGetDirectorySectionExpectation
	expectations       []*SnapshotMockGetDirectorySectionExpectation

	callArgs []*SnapshotMockGetDirectorySectionParams
	mutex    sync.RWMutex
}

// SnapshotMockGetDirectorySectionExpectation specifies expectation struct of the Snapshot.GetDirectorySection
type SnapshotMockGetDirectorySectionExpectation struct {
	mock    *SnapshotMock
	params  *SnapshotMockGetDirectorySectionParams
	results *SnapshotMockGetDirectorySectionResults
	Counter uint64
}

// SnapshotMockGetDirectorySectionParams contains parameters of the Snapshot.GetDirectorySection
type SnapshotMockGetDirectorySectionParams struct {
	s1 ledger.SectionID
}

// SnapshotMockGetDirectorySectionResults contains results of the Snapshot.GetDirectorySection
type SnapshotMockGetDirectorySectionResults struct {
	d1  DirectorySection
	err error
}

// Expect sets up expected params for Snapshot.GetDirectorySection
func (mmGetDirectorySection *mSnapshotMockGetDirectorySection) Expect(s1 ledger.SectionID) *mSnapshotMockGetDirectorySection {
	if mmGetDirectorySection.mock.funcGetDirectorySection != nil {
		mmGetDirectorySection.mock.t.Fatalf("SnapshotMock.GetDirectorySection mock is already set by Set")
	}

	if mmGetDirectorySection.defaultExpectation == nil {
		mmGetDirectorySection.defaultExpectation = &SnapshotMockGetDirectorySectionExpectation{}
	}

	mmGetDirectorySection.defaultExpectation.params = &SnapshotMockGetDirectorySectionParams{s1}
	for _, e := range mmGetDirectorySection.expectations {
		if minimock.Equal(e.params, mmGetDirectorySection.defaultExpectation.params) {
			mmGetDirectorySection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDirectorySection.defaultExpectation.params)
		}
	}

	return mmGetDirectorySection
}

// Inspect accepts an inspector function that has same arguments as the Snapshot.GetDirectorySection
func (mmGetDirectorySection *mSnapshotMockGetDirectorySection) Inspect(f func(s1 ledger.SectionID)) *mSnapshotMockGetDirectorySection {
	if mmGetDirectorySection.mock.inspectFuncGetDirectorySection != nil {
		mmGetDirectorySection.mock.t.Fatalf("Inspect function is already set for SnapshotMock.GetDirectorySection")
	}

	mmGetDirectorySection.mock.inspectFuncGetDirectorySection = f

	return mmGetDirectorySection
}

// Return sets up results that will be returned by Snapshot.GetDirectorySection
func (mmGetDirectorySection *mSnapshotMockGetDirectorySection) Return(d1 DirectorySection, err error) *SnapshotMock {
	if mmGetDirectorySection.mock.funcGetDirectorySection != nil {
		mmGetDirectorySection.mock.t.Fatalf("SnapshotMock.GetDirectorySection mock is already set by Set")
	}

	if mmGetDirectorySection.defaultExpectation == nil {
		mmGetDirectorySection.defaultExpectation = &SnapshotMockGetDirectorySectionExpectation{mock: mmGetDirectorySection.mock}
	}
	mmGetDirectorySection.defaultExpectation.results = &SnapshotMockGetDirectorySectionResults{d1, err}
	return mmGetDirectorySection.mock
}

//Set uses given function f to mock the Snapshot.GetDirectorySection method
func (mmGetDirectorySection *mSnapshotMockGetDirectorySection) Set(f func(s1 ledger.SectionID) (d1 DirectorySection, err error)) *SnapshotMock {
	if mmGetDirectorySection.defaultExpectation != nil {
		mmGetDirectorySection.mock.t.Fatalf("Default expectation is already set for the Snapshot.GetDirectorySection method")
	}

	if len(mmGetDirectorySection.expectations) > 0 {
		mmGetDirectorySection.mock.t.Fatalf("Some expectations are already set for the Snapshot.GetDirectorySection method")
	}

	mmGetDirectorySection.mock.funcGetDirectorySection = f
	return mmGetDirectorySection.mock
}

// When sets expectation for the Snapshot.GetDirectorySection which will trigger the result defined by the following
// Then helper
func (mmGetDirectorySection *mSnapshotMockGetDirectorySection) When(s1 ledger.SectionID) *SnapshotMockGetDirectorySectionExpectation {
	if mmGetDirectorySection.mock.funcGetDirectorySection != nil {
		mmGetDirectorySection.mock.t.Fatalf("SnapshotMock.GetDirectorySection mock is already set by Set")
	}

	expectation := &SnapshotMockGetDirectorySectionExpectation{
		mock:   mmGetDirectorySection.mock,
		params: &SnapshotMockGetDirectorySectionParams{s1},
	}
	mmGetDirectorySection.expectations = append(mmGetDirectorySection.expectations, expectation)
	return expectation
}

// Then sets up Snapshot.GetDirectorySection return parameters for the expectation previously defined by the When method
func (e *SnapshotMockGetDirectorySectionExpectation) Then(d1 DirectorySection, err error) *SnapshotMock {
	e.results = &SnapshotMockGetDirectorySectionResults{d1, err}
	return e.mock
}

// GetDirectorySection implements Snapshot
func (mmGetDirectorySection *SnapshotMock) GetDirectorySection(s1 ledger.SectionID) (d1 DirectorySection, err error) {
	mm_atomic.AddUint64(&mmGetDirectorySection.beforeGetDirectorySectionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDirectorySection.afterGetDirectorySectionCounter, 1)

	if mmGetDirectorySection.inspectFuncGetDirectorySection != nil {
		mmGetDirectorySection.inspectFuncGetDirectorySection(s1)
	}

	mm_params := &SnapshotMockGetDirectorySectionParams{s1}

	// Record call args
	mmGetDirectorySection.GetDirectorySectionMock.mutex.Lock()
	mmGetDirectorySection.GetDirectorySectionMock.callArgs = append(mmGetDirectorySection.GetDirectorySectionMock.callArgs, mm_params)
	mmGetDirectorySection.GetDirectorySectionMock.mutex.Unlock()

	for _, e := range mmGetDirectorySection.GetDirectorySectionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.d1, e.results.err
		}
	}

	if mmGetDirectorySection.GetDirectorySectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDirectorySection.GetDirectorySectionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDirectorySection.GetDirectorySectionMock.defaultExpectation.params
		mm_got := SnapshotMockGetDirectorySectionParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDirectorySection.t.Errorf("SnapshotMock.GetDirectorySection got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDirectorySection.GetDirectorySectionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDirectorySection.t.Fatal("No results are set for the SnapshotMock.GetDirectorySection")
		}
		return (*mm_results).d1, (*mm_results).err
	}
	if mmGetDirectorySection.funcGetDirectorySection != nil {
		return mmGetDirectorySection.funcGetDirectorySection(s1)
	}
	mmGetDirectorySection.t.Fatalf("Unexpected call to SnapshotMock.GetDirectorySection. %v", s1)
	return
}

// GetDirectorySectionAfterCounter returns a count of finished SnapshotMock.GetDirectorySection invocations
func (mmGetDirectorySection *SnapshotMock) GetDirectorySectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDirectorySection.afterGetDirectorySectionCounter)
}

// GetDirectorySectionBeforeCounter returns a count of SnapshotMock.GetDirectorySection invocations
func (mmGetDirectorySection *SnapshotMock) GetDirectorySectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDirectorySection.beforeGetDirectorySectionCounter)
}

// Calls returns a list of arguments used in each call to SnapshotMock.GetDirectorySection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDirectorySection *mSnapshotMockGetDirectorySection) Calls() []*SnapshotMockGetDirectorySectionParams {
	mmGetDirectorySection.mutex.RLock()

	argCopy := make([]*SnapshotMockGetDirectorySectionParams, len(mmGetDirectorySection.callArgs))
	copy(argCopy, mmGetDirectorySection.callArgs)

	mmGetDirectorySection.mutex.RUnlock()

	return argCopy
}

// MinimockGetDirectorySectionDone returns true if the count of the GetDirectorySection invocations corresponds
// the number of defined expectations
func (m *SnapshotMock) MinimockGetDirectorySectionDone() bool {
	for _, e := range m.GetDirectorySectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDirectorySectionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDirectorySectionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDirectorySection != nil && mm_atomic.LoadUint64(&m.afterGetDirectorySectionCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDirectorySectionInspect logs each unmet expectation
func (m *SnapshotMock) MinimockGetDirectorySectionInspect() {
	for _, e := range m.GetDirectorySectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SnapshotMock.GetDirectorySection with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDirectorySectionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDirectorySectionCounter) < 1 {
		if m.GetDirectorySectionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SnapshotMock.GetDirectorySection")
		} else {
			m.t.Errorf("Expected call to SnapshotMock.GetDirectorySection with params: %#v", *m.GetDirectorySectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDirectorySection != nil && mm_atomic.LoadUint64(&m.afterGetDirectorySectionCounter) < 1 {
		m.t.Error("Expected call to SnapshotMock.GetDirectorySection")
	}
}

type mSnapshotMockGetPayloadSection struct {
	mock               *SnapshotMock
	defaultExpectation *SnapshotMockGetPayloadSectionExpectation
	expectations       []*SnapshotMockGetPayloadSectionExpectation

	callArgs []*SnapshotMockGetPayloadSectionParams
	mutex    sync.RWMutex
}

// SnapshotMockGetPayloadSectionExpectation specifies expectation struct of the Snapshot.GetPayloadSection
type SnapshotMockGetPayloadSectionExpectation struct {
	mock    *SnapshotMock
	params  *SnapshotMockGetPayloadSectionParams
	results *SnapshotMockGetPayloadSectionResults
	Counter uint64
}

// SnapshotMockGetPayloadSectionParams contains parameters of the Snapshot.GetPayloadSection
type SnapshotMockGetPayloadSectionParams struct {
	s1 ledger.SectionID
}

// SnapshotMockGetPayloadSectionResults contains results of the Snapshot.GetPayloadSection
type SnapshotMockGetPayloadSectionResults struct {
	p1  PayloadSection
	err error
}

// Expect sets up expected params for Snapshot.GetPayloadSection
func (mmGetPayloadSection *mSnapshotMockGetPayloadSection) Expect(s1 ledger.SectionID) *mSnapshotMockGetPayloadSection {
	if mmGetPayloadSection.mock.funcGetPayloadSection != nil {
		mmGetPayloadSection.mock.t.Fatalf("SnapshotMock.GetPayloadSection mock is already set by Set")
	}

	if mmGetPayloadSection.defaultExpectation == nil {
		mmGetPayloadSection.defaultExpectation = &SnapshotMockGetPayloadSectionExpectation{}
	}

	mmGetPayloadSection.defaultExpectation.params = &SnapshotMockGetPayloadSectionParams{s1}
	for _, e := range mmGetPayloadSection.expectations {
		if minimock.Equal(e.params, mmGetPayloadSection.defaultExpectation.params) {
			mmGetPayloadSection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPayloadSection.defaultExpectation.params)
		}
	}

	return mmGetPayloadSection
}

// Inspect accepts an inspector function that has same arguments as the Snapshot.GetPayloadSection
func (mmGetPayloadSection *mSnapshotMockGetPayloadSection) Inspect(f func(s1 ledger.SectionID)) *mSnapshotMockGetPayloadSection {
	if mmGetPayloadSection.mock.inspectFuncGetPayloadSection != nil {
		mmGetPayloadSection.mock.t.Fatalf("Inspect function is already set for SnapshotMock.GetPayloadSection")
	}

	mmGetPayloadSection.mock.inspectFuncGetPayloadSection = f

	return mmGetPayloadSection
}

// Return sets up results that will be returned by Snapshot.GetPayloadSection
func (mmGetPayloadSection *mSnapshotMockGetPayloadSection) Return(p1 PayloadSection, err error) *SnapshotMock {
	if mmGetPayloadSection.mock.funcGetPayloadSection != nil {
		mmGetPayloadSection.mock.t.Fatalf("SnapshotMock.GetPayloadSection mock is already set by Set")
	}

	if mmGetPayloadSection.defaultExpectation == nil {
		mmGetPayloadSection.defaultExpectation = &SnapshotMockGetPayloadSectionExpectation{mock: mmGetPayloadSection.mock}
	}
	mmGetPayloadSection.defaultExpectation.results = &SnapshotMockGetPayloadSectionResults{p1, err}
	return mmGetPayloadSection.mock
}

//Set uses given function f to mock the Snapshot.GetPayloadSection method
func (mmGetPayloadSection *mSnapshotMockGetPayloadSection) Set(f func(s1 ledger.SectionID) (p1 PayloadSection, err error)) *SnapshotMock {
	if mmGetPayloadSection.defaultExpectation != nil {
		mmGetPayloadSection.mock.t.Fatalf("Default expectation is already set for the Snapshot.GetPayloadSection method")
	}

	if len(mmGetPayloadSection.expectations) > 0 {
		mmGetPayloadSection.mock.t.Fatalf("Some expectations are already set for the Snapshot.GetPayloadSection method")
	}

	mmGetPayloadSection.mock.funcGetPayloadSection = f
	return mmGetPayloadSection.mock
}

// When sets expectation for the Snapshot.GetPayloadSection which will trigger the result defined by the following
// Then helper
func (mmGetPayloadSection *mSnapshotMockGetPayloadSection) When(s1 ledger.SectionID) *SnapshotMockGetPayloadSectionExpectation {
	if mmGetPayloadSection.mock.funcGetPayloadSection != nil {
		mmGetPayloadSection.mock.t.Fatalf("SnapshotMock.GetPayloadSection mock is already set by Set")
	}

	expectation := &SnapshotMockGetPayloadSectionExpectation{
		mock:   mmGetPayloadSection.mock,
		params: &SnapshotMockGetPayloadSectionParams{s1},
	}
	mmGetPayloadSection.expectations = append(mmGetPayloadSection.expectations, expectation)
	return expectation
}

// Then sets up Snapshot.GetPayloadSection return parameters for the expectation previously defined by the When method
func (e *SnapshotMockGetPayloadSectionExpectation) Then(p1 PayloadSection, err error) *SnapshotMock {
	e.results = &SnapshotMockGetPayloadSectionResults{p1, err}
	return e.mock
}

// GetPayloadSection implements Snapshot
func (mmGetPayloadSection *SnapshotMock) GetPayloadSection(s1 ledger.SectionID) (p1 PayloadSection, err error) {
	mm_atomic.AddUint64(&mmGetPayloadSection.beforeGetPayloadSectionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPayloadSection.afterGetPayloadSectionCounter, 1)

	if mmGetPayloadSection.inspectFuncGetPayloadSection != nil {
		mmGetPayloadSection.inspectFuncGetPayloadSection(s1)
	}

	mm_params := &SnapshotMockGetPayloadSectionParams{s1}

	// Record call args
	mmGetPayloadSection.GetPayloadSectionMock.mutex.Lock()
	mmGetPayloadSection.GetPayloadSectionMock.callArgs = append(mmGetPayloadSection.GetPayloadSectionMock.callArgs, mm_params)
	mmGetPayloadSection.GetPayloadSectionMock.mutex.Unlock()

	for _, e := range mmGetPayloadSection.GetPayloadSectionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmGetPayloadSection.GetPayloadSectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPayloadSection.GetPayloadSectionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPayloadSection.GetPayloadSectionMock.defaultExpectation.params
		mm_got := SnapshotMockGetPayloadSectionParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPayloadSection.t.Errorf("SnapshotMock.GetPayloadSection got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPayloadSection.GetPayloadSectionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPayloadSection.t.Fatal("No results are set for the SnapshotMock.GetPayloadSection")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmGetPayloadSection.funcGetPayloadSection != nil {
		return mmGetPayloadSection.funcGetPayloadSection(s1)
	}
	mmGetPayloadSection.t.Fatalf("Unexpected call to SnapshotMock.GetPayloadSection. %v", s1)
	return
}

// GetPayloadSectionAfterCounter returns a count of finished SnapshotMock.GetPayloadSection invocations
func (mmGetPayloadSection *SnapshotMock) GetPayloadSectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPayloadSection.afterGetPayloadSectionCounter)
}

// GetPayloadSectionBeforeCounter returns a count of SnapshotMock.GetPayloadSection invocations
func (mmGetPayloadSection *SnapshotMock) GetPayloadSectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPayloadSection.beforeGetPayloadSectionCounter)
}

// Calls returns a list of arguments used in each call to SnapshotMock.GetPayloadSection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPayloadSection *mSnapshotMockGetPayloadSection) Calls() []*SnapshotMockGetPayloadSectionParams {
	mmGetPayloadSection.mutex.RLock()

	argCopy := make([]*SnapshotMockGetPayloadSectionParams, len(mmGetPayloadSection.callArgs))
	copy(argCopy, mmGetPayloadSection.callArgs)

	mmGetPayloadSection.mutex.RUnlock()

	return argCopy
}

// MinimockGetPayloadSectionDone returns true if the count of the GetPayloadSection invocations corresponds
// the number of defined expectations
func (m *SnapshotMock) MinimockGetPayloadSectionDone() bool {
	for _, e := range m.GetPayloadSectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPayloadSectionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPayloadSectionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPayloadSection != nil && mm_atomic.LoadUint64(&m.afterGetPayloadSectionCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPayloadSectionInspect logs each unmet expectation
func (m *SnapshotMock) MinimockGetPayloadSectionInspect() {
	for _, e := range m.GetPayloadSectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SnapshotMock.GetPayloadSection with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPayloadSectionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPayloadSectionCounter) < 1 {
		if m.GetPayloadSectionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SnapshotMock.GetPayloadSection")
		} else {
			m.t.Errorf("Expected call to SnapshotMock.GetPayloadSection with params: %#v", *m.GetPayloadSectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPayloadSection != nil && mm_atomic.LoadUint64(&m.afterGetPayloadSectionCounter) < 1 {
		m.t.Error("Expected call to SnapshotMock.GetPayloadSection")
	}
}

type mSnapshotMockPrepared struct {
	mock               *SnapshotMock
	defaultExpectation *SnapshotMockPreparedExpectation
	expectations       []*SnapshotMockPreparedExpectation
}

// SnapshotMockPreparedExpectation specifies expectation struct of the Snapshot.Prepared
type SnapshotMockPreparedExpectation struct {
	mock *SnapshotMock

	results *SnapshotMockPreparedResults
	Counter uint64
}

// SnapshotMockPreparedResults contains results of the Snapshot.Prepared
type SnapshotMockPreparedResults struct {
	err error
}

// Expect sets up expected params for Snapshot.Prepared
func (mmPrepared *mSnapshotMockPrepared) Expect() *mSnapshotMockPrepared {
	if mmPrepared.mock.funcPrepared != nil {
		mmPrepared.mock.t.Fatalf("SnapshotMock.Prepared mock is already set by Set")
	}

	if mmPrepared.defaultExpectation == nil {
		mmPrepared.defaultExpectation = &SnapshotMockPreparedExpectation{}
	}

	return mmPrepared
}

// Inspect accepts an inspector function that has same arguments as the Snapshot.Prepared
func (mmPrepared *mSnapshotMockPrepared) Inspect(f func()) *mSnapshotMockPrepared {
	if mmPrepared.mock.inspectFuncPrepared != nil {
		mmPrepared.mock.t.Fatalf("Inspect function is already set for SnapshotMock.Prepared")
	}

	mmPrepared.mock.inspectFuncPrepared = f

	return mmPrepared
}

// Return sets up results that will be returned by Snapshot.Prepared
func (mmPrepared *mSnapshotMockPrepared) Return(err error) *SnapshotMock {
	if mmPrepared.mock.funcPrepared != nil {
		mmPrepared.mock.t.Fatalf("SnapshotMock.Prepared mock is already set by Set")
	}

	if mmPrepared.defaultExpectation == nil {
		mmPrepared.defaultExpectation = &SnapshotMockPreparedExpectation{mock: mmPrepared.mock}
	}
	mmPrepared.defaultExpectation.results = &SnapshotMockPreparedResults{err}
	return mmPrepared.mock
}

//Set uses given function f to mock the Snapshot.Prepared method
func (mmPrepared *mSnapshotMockPrepared) Set(f func() (err error)) *SnapshotMock {
	if mmPrepared.defaultExpectation != nil {
		mmPrepared.mock.t.Fatalf("Default expectation is already set for the Snapshot.Prepared method")
	}

	if len(mmPrepared.expectations) > 0 {
		mmPrepared.mock.t.Fatalf("Some expectations are already set for the Snapshot.Prepared method")
	}

	mmPrepared.mock.funcPrepared = f
	return mmPrepared.mock
}

// Prepared implements Snapshot
func (mmPrepared *SnapshotMock) Prepared() (err error) {
	mm_atomic.AddUint64(&mmPrepared.beforePreparedCounter, 1)
	defer mm_atomic.AddUint64(&mmPrepared.afterPreparedCounter, 1)

	if mmPrepared.inspectFuncPrepared != nil {
		mmPrepared.inspectFuncPrepared()
	}

	if mmPrepared.PreparedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrepared.PreparedMock.defaultExpectation.Counter, 1)

		mm_results := mmPrepared.PreparedMock.defaultExpectation.results
		if mm_results == nil {
			mmPrepared.t.Fatal("No results are set for the SnapshotMock.Prepared")
		}
		return (*mm_results).err
	}
	if mmPrepared.funcPrepared != nil {
		return mmPrepared.funcPrepared()
	}
	mmPrepared.t.Fatalf("Unexpected call to SnapshotMock.Prepared.")
	return
}

// PreparedAfterCounter returns a count of finished SnapshotMock.Prepared invocations
func (mmPrepared *SnapshotMock) PreparedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepared.afterPreparedCounter)
}

// PreparedBeforeCounter returns a count of SnapshotMock.Prepared invocations
func (mmPrepared *SnapshotMock) PreparedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepared.beforePreparedCounter)
}

// MinimockPreparedDone returns true if the count of the Prepared invocations corresponds
// the number of defined expectations
func (m *SnapshotMock) MinimockPreparedDone() bool {
	for _, e := range m.PreparedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PreparedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPreparedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepared != nil && mm_atomic.LoadUint64(&m.afterPreparedCounter) < 1 {
		return false
	}
	return true
}

// MinimockPreparedInspect logs each unmet expectation
func (m *SnapshotMock) MinimockPreparedInspect() {
	for _, e := range m.PreparedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SnapshotMock.Prepared")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PreparedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPreparedCounter) < 1 {
		m.t.Error("Expected call to SnapshotMock.Prepared")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepared != nil && mm_atomic.LoadUint64(&m.afterPreparedCounter) < 1 {
		m.t.Error("Expected call to SnapshotMock.Prepared")
	}
}

type mSnapshotMockRollback struct {
	mock               *SnapshotMock
	defaultExpectation *SnapshotMockRollbackExpectation
	expectations       []*SnapshotMockRollbackExpectation
}

// SnapshotMockRollbackExpectation specifies expectation struct of the Snapshot.Rollback
type SnapshotMockRollbackExpectation struct {
	mock *SnapshotMock

	Counter uint64
}

// Expect sets up expected params for Snapshot.Rollback
func (mmRollback *mSnapshotMockRollback) Expect() *mSnapshotMockRollback {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("SnapshotMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &SnapshotMockRollbackExpectation{}
	}

	return mmRollback
}

// Inspect accepts an inspector function that has same arguments as the Snapshot.Rollback
func (mmRollback *mSnapshotMockRollback) Inspect(f func()) *mSnapshotMockRollback {
	if mmRollback.mock.inspectFuncRollback != nil {
		mmRollback.mock.t.Fatalf("Inspect function is already set for SnapshotMock.Rollback")
	}

	mmRollback.mock.inspectFuncRollback = f

	return mmRollback
}

// Return sets up results that will be returned by Snapshot.Rollback
func (mmRollback *mSnapshotMockRollback) Return() *SnapshotMock {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("SnapshotMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &SnapshotMockRollbackExpectation{mock: mmRollback.mock}
	}

	return mmRollback.mock
}

//Set uses given function f to mock the Snapshot.Rollback method
func (mmRollback *mSnapshotMockRollback) Set(f func()) *SnapshotMock {
	if mmRollback.defaultExpectation != nil {
		mmRollback.mock.t.Fatalf("Default expectation is already set for the Snapshot.Rollback method")
	}

	if len(mmRollback.expectations) > 0 {
		mmRollback.mock.t.Fatalf("Some expectations are already set for the Snapshot.Rollback method")
	}

	mmRollback.mock.funcRollback = f
	return mmRollback.mock
}

// Rollback implements Snapshot
func (mmRollback *SnapshotMock) Rollback() {
	mm_atomic.AddUint64(&mmRollback.beforeRollbackCounter, 1)
	defer mm_atomic.AddUint64(&mmRollback.afterRollbackCounter, 1)

	if mmRollback.inspectFuncRollback != nil {
		mmRollback.inspectFuncRollback()
	}

	if mmRollback.RollbackMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRollback.RollbackMock.defaultExpectation.Counter, 1)

		return

	}
	if mmRollback.funcRollback != nil {
		mmRollback.funcRollback()
		return
	}
	mmRollback.t.Fatalf("Unexpected call to SnapshotMock.Rollback.")

}

// RollbackAfterCounter returns a count of finished SnapshotMock.Rollback invocations
func (mmRollback *SnapshotMock) RollbackAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.afterRollbackCounter)
}

// RollbackBeforeCounter returns a count of SnapshotMock.Rollback invocations
func (mmRollback *SnapshotMock) RollbackBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.beforeRollbackCounter)
}

// MinimockRollbackDone returns true if the count of the Rollback invocations corresponds
// the number of defined expectations
func (m *SnapshotMock) MinimockRollbackDone() bool {
	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollback != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		return false
	}
	return true
}

// MinimockRollbackInspect logs each unmet expectation
func (m *SnapshotMock) MinimockRollbackInspect() {
	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SnapshotMock.Rollback")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		m.t.Error("Expected call to SnapshotMock.Rollback")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollback != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		m.t.Error("Expected call to SnapshotMock.Rollback")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SnapshotMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockChainedRollbackInspect()

		m.MinimockCommitInspect()

		m.MinimockCompletedInspect()

		m.MinimockGetDirectorySectionInspect()

		m.MinimockGetPayloadSectionInspect()

		m.MinimockPreparedInspect()

		m.MinimockRollbackInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SnapshotMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SnapshotMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChainedRollbackDone() &&
		m.MinimockCommitDone() &&
		m.MinimockCompletedDone() &&
		m.MinimockGetDirectorySectionDone() &&
		m.MinimockGetPayloadSectionDone() &&
		m.MinimockPreparedDone() &&
		m.MinimockRollbackDone()
}
