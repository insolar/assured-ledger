package bundle

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// SnapshotWriterMock implements SnapshotWriter
type SnapshotWriterMock struct {
	t minimock.Tester

	funcDirtyReader          func() (d1 DirtyReader)
	inspectFuncDirtyReader   func()
	afterDirtyReaderCounter  uint64
	beforeDirtyReaderCounter uint64
	DirtyReaderMock          mSnapshotWriterMockDirtyReader

	funcMarkReadOnly          func() (err error)
	inspectFuncMarkReadOnly   func()
	afterMarkReadOnlyCounter  uint64
	beforeMarkReadOnlyCounter uint64
	MarkReadOnlyMock          mSnapshotWriterMockMarkReadOnly

	funcTakeSnapshot          func() (s1 Snapshot, err error)
	inspectFuncTakeSnapshot   func()
	afterTakeSnapshotCounter  uint64
	beforeTakeSnapshotCounter uint64
	TakeSnapshotMock          mSnapshotWriterMockTakeSnapshot
}

// NewSnapshotWriterMock returns a mock for SnapshotWriter
func NewSnapshotWriterMock(t minimock.Tester) *SnapshotWriterMock {
	m := &SnapshotWriterMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DirtyReaderMock = mSnapshotWriterMockDirtyReader{mock: m}

	m.MarkReadOnlyMock = mSnapshotWriterMockMarkReadOnly{mock: m}

	m.TakeSnapshotMock = mSnapshotWriterMockTakeSnapshot{mock: m}

	return m
}

type mSnapshotWriterMockDirtyReader struct {
	mock               *SnapshotWriterMock
	defaultExpectation *SnapshotWriterMockDirtyReaderExpectation
	expectations       []*SnapshotWriterMockDirtyReaderExpectation
}

// SnapshotWriterMockDirtyReaderExpectation specifies expectation struct of the SnapshotWriter.DirtyReader
type SnapshotWriterMockDirtyReaderExpectation struct {
	mock *SnapshotWriterMock

	results *SnapshotWriterMockDirtyReaderResults
	Counter uint64
}

// SnapshotWriterMockDirtyReaderResults contains results of the SnapshotWriter.DirtyReader
type SnapshotWriterMockDirtyReaderResults struct {
	d1 DirtyReader
}

// Expect sets up expected params for SnapshotWriter.DirtyReader
func (mmDirtyReader *mSnapshotWriterMockDirtyReader) Expect() *mSnapshotWriterMockDirtyReader {
	if mmDirtyReader.mock.funcDirtyReader != nil {
		mmDirtyReader.mock.t.Fatalf("SnapshotWriterMock.DirtyReader mock is already set by Set")
	}

	if mmDirtyReader.defaultExpectation == nil {
		mmDirtyReader.defaultExpectation = &SnapshotWriterMockDirtyReaderExpectation{}
	}

	return mmDirtyReader
}

// Inspect accepts an inspector function that has same arguments as the SnapshotWriter.DirtyReader
func (mmDirtyReader *mSnapshotWriterMockDirtyReader) Inspect(f func()) *mSnapshotWriterMockDirtyReader {
	if mmDirtyReader.mock.inspectFuncDirtyReader != nil {
		mmDirtyReader.mock.t.Fatalf("Inspect function is already set for SnapshotWriterMock.DirtyReader")
	}

	mmDirtyReader.mock.inspectFuncDirtyReader = f

	return mmDirtyReader
}

// Return sets up results that will be returned by SnapshotWriter.DirtyReader
func (mmDirtyReader *mSnapshotWriterMockDirtyReader) Return(d1 DirtyReader) *SnapshotWriterMock {
	if mmDirtyReader.mock.funcDirtyReader != nil {
		mmDirtyReader.mock.t.Fatalf("SnapshotWriterMock.DirtyReader mock is already set by Set")
	}

	if mmDirtyReader.defaultExpectation == nil {
		mmDirtyReader.defaultExpectation = &SnapshotWriterMockDirtyReaderExpectation{mock: mmDirtyReader.mock}
	}
	mmDirtyReader.defaultExpectation.results = &SnapshotWriterMockDirtyReaderResults{d1}
	return mmDirtyReader.mock
}

//Set uses given function f to mock the SnapshotWriter.DirtyReader method
func (mmDirtyReader *mSnapshotWriterMockDirtyReader) Set(f func() (d1 DirtyReader)) *SnapshotWriterMock {
	if mmDirtyReader.defaultExpectation != nil {
		mmDirtyReader.mock.t.Fatalf("Default expectation is already set for the SnapshotWriter.DirtyReader method")
	}

	if len(mmDirtyReader.expectations) > 0 {
		mmDirtyReader.mock.t.Fatalf("Some expectations are already set for the SnapshotWriter.DirtyReader method")
	}

	mmDirtyReader.mock.funcDirtyReader = f
	return mmDirtyReader.mock
}

// DirtyReader implements SnapshotWriter
func (mmDirtyReader *SnapshotWriterMock) DirtyReader() (d1 DirtyReader) {
	mm_atomic.AddUint64(&mmDirtyReader.beforeDirtyReaderCounter, 1)
	defer mm_atomic.AddUint64(&mmDirtyReader.afterDirtyReaderCounter, 1)

	if mmDirtyReader.inspectFuncDirtyReader != nil {
		mmDirtyReader.inspectFuncDirtyReader()
	}

	if mmDirtyReader.DirtyReaderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDirtyReader.DirtyReaderMock.defaultExpectation.Counter, 1)

		mm_results := mmDirtyReader.DirtyReaderMock.defaultExpectation.results
		if mm_results == nil {
			mmDirtyReader.t.Fatal("No results are set for the SnapshotWriterMock.DirtyReader")
		}
		return (*mm_results).d1
	}
	if mmDirtyReader.funcDirtyReader != nil {
		return mmDirtyReader.funcDirtyReader()
	}
	mmDirtyReader.t.Fatalf("Unexpected call to SnapshotWriterMock.DirtyReader.")
	return
}

// DirtyReaderAfterCounter returns a count of finished SnapshotWriterMock.DirtyReader invocations
func (mmDirtyReader *SnapshotWriterMock) DirtyReaderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDirtyReader.afterDirtyReaderCounter)
}

// DirtyReaderBeforeCounter returns a count of SnapshotWriterMock.DirtyReader invocations
func (mmDirtyReader *SnapshotWriterMock) DirtyReaderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDirtyReader.beforeDirtyReaderCounter)
}

// MinimockDirtyReaderDone returns true if the count of the DirtyReader invocations corresponds
// the number of defined expectations
func (m *SnapshotWriterMock) MinimockDirtyReaderDone() bool {
	for _, e := range m.DirtyReaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DirtyReaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDirtyReaderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDirtyReader != nil && mm_atomic.LoadUint64(&m.afterDirtyReaderCounter) < 1 {
		return false
	}
	return true
}

// MinimockDirtyReaderInspect logs each unmet expectation
func (m *SnapshotWriterMock) MinimockDirtyReaderInspect() {
	for _, e := range m.DirtyReaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SnapshotWriterMock.DirtyReader")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DirtyReaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDirtyReaderCounter) < 1 {
		m.t.Error("Expected call to SnapshotWriterMock.DirtyReader")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDirtyReader != nil && mm_atomic.LoadUint64(&m.afterDirtyReaderCounter) < 1 {
		m.t.Error("Expected call to SnapshotWriterMock.DirtyReader")
	}
}

type mSnapshotWriterMockMarkReadOnly struct {
	mock               *SnapshotWriterMock
	defaultExpectation *SnapshotWriterMockMarkReadOnlyExpectation
	expectations       []*SnapshotWriterMockMarkReadOnlyExpectation
}

// SnapshotWriterMockMarkReadOnlyExpectation specifies expectation struct of the SnapshotWriter.MarkReadOnly
type SnapshotWriterMockMarkReadOnlyExpectation struct {
	mock *SnapshotWriterMock

	results *SnapshotWriterMockMarkReadOnlyResults
	Counter uint64
}

// SnapshotWriterMockMarkReadOnlyResults contains results of the SnapshotWriter.MarkReadOnly
type SnapshotWriterMockMarkReadOnlyResults struct {
	err error
}

// Expect sets up expected params for SnapshotWriter.MarkReadOnly
func (mmMarkReadOnly *mSnapshotWriterMockMarkReadOnly) Expect() *mSnapshotWriterMockMarkReadOnly {
	if mmMarkReadOnly.mock.funcMarkReadOnly != nil {
		mmMarkReadOnly.mock.t.Fatalf("SnapshotWriterMock.MarkReadOnly mock is already set by Set")
	}

	if mmMarkReadOnly.defaultExpectation == nil {
		mmMarkReadOnly.defaultExpectation = &SnapshotWriterMockMarkReadOnlyExpectation{}
	}

	return mmMarkReadOnly
}

// Inspect accepts an inspector function that has same arguments as the SnapshotWriter.MarkReadOnly
func (mmMarkReadOnly *mSnapshotWriterMockMarkReadOnly) Inspect(f func()) *mSnapshotWriterMockMarkReadOnly {
	if mmMarkReadOnly.mock.inspectFuncMarkReadOnly != nil {
		mmMarkReadOnly.mock.t.Fatalf("Inspect function is already set for SnapshotWriterMock.MarkReadOnly")
	}

	mmMarkReadOnly.mock.inspectFuncMarkReadOnly = f

	return mmMarkReadOnly
}

// Return sets up results that will be returned by SnapshotWriter.MarkReadOnly
func (mmMarkReadOnly *mSnapshotWriterMockMarkReadOnly) Return(err error) *SnapshotWriterMock {
	if mmMarkReadOnly.mock.funcMarkReadOnly != nil {
		mmMarkReadOnly.mock.t.Fatalf("SnapshotWriterMock.MarkReadOnly mock is already set by Set")
	}

	if mmMarkReadOnly.defaultExpectation == nil {
		mmMarkReadOnly.defaultExpectation = &SnapshotWriterMockMarkReadOnlyExpectation{mock: mmMarkReadOnly.mock}
	}
	mmMarkReadOnly.defaultExpectation.results = &SnapshotWriterMockMarkReadOnlyResults{err}
	return mmMarkReadOnly.mock
}

//Set uses given function f to mock the SnapshotWriter.MarkReadOnly method
func (mmMarkReadOnly *mSnapshotWriterMockMarkReadOnly) Set(f func() (err error)) *SnapshotWriterMock {
	if mmMarkReadOnly.defaultExpectation != nil {
		mmMarkReadOnly.mock.t.Fatalf("Default expectation is already set for the SnapshotWriter.MarkReadOnly method")
	}

	if len(mmMarkReadOnly.expectations) > 0 {
		mmMarkReadOnly.mock.t.Fatalf("Some expectations are already set for the SnapshotWriter.MarkReadOnly method")
	}

	mmMarkReadOnly.mock.funcMarkReadOnly = f
	return mmMarkReadOnly.mock
}

// MarkReadOnly implements SnapshotWriter
func (mmMarkReadOnly *SnapshotWriterMock) MarkReadOnly() (err error) {
	mm_atomic.AddUint64(&mmMarkReadOnly.beforeMarkReadOnlyCounter, 1)
	defer mm_atomic.AddUint64(&mmMarkReadOnly.afterMarkReadOnlyCounter, 1)

	if mmMarkReadOnly.inspectFuncMarkReadOnly != nil {
		mmMarkReadOnly.inspectFuncMarkReadOnly()
	}

	if mmMarkReadOnly.MarkReadOnlyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMarkReadOnly.MarkReadOnlyMock.defaultExpectation.Counter, 1)

		mm_results := mmMarkReadOnly.MarkReadOnlyMock.defaultExpectation.results
		if mm_results == nil {
			mmMarkReadOnly.t.Fatal("No results are set for the SnapshotWriterMock.MarkReadOnly")
		}
		return (*mm_results).err
	}
	if mmMarkReadOnly.funcMarkReadOnly != nil {
		return mmMarkReadOnly.funcMarkReadOnly()
	}
	mmMarkReadOnly.t.Fatalf("Unexpected call to SnapshotWriterMock.MarkReadOnly.")
	return
}

// MarkReadOnlyAfterCounter returns a count of finished SnapshotWriterMock.MarkReadOnly invocations
func (mmMarkReadOnly *SnapshotWriterMock) MarkReadOnlyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkReadOnly.afterMarkReadOnlyCounter)
}

// MarkReadOnlyBeforeCounter returns a count of SnapshotWriterMock.MarkReadOnly invocations
func (mmMarkReadOnly *SnapshotWriterMock) MarkReadOnlyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkReadOnly.beforeMarkReadOnlyCounter)
}

// MinimockMarkReadOnlyDone returns true if the count of the MarkReadOnly invocations corresponds
// the number of defined expectations
func (m *SnapshotWriterMock) MinimockMarkReadOnlyDone() bool {
	for _, e := range m.MarkReadOnlyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MarkReadOnlyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMarkReadOnlyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarkReadOnly != nil && mm_atomic.LoadUint64(&m.afterMarkReadOnlyCounter) < 1 {
		return false
	}
	return true
}

// MinimockMarkReadOnlyInspect logs each unmet expectation
func (m *SnapshotWriterMock) MinimockMarkReadOnlyInspect() {
	for _, e := range m.MarkReadOnlyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SnapshotWriterMock.MarkReadOnly")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MarkReadOnlyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMarkReadOnlyCounter) < 1 {
		m.t.Error("Expected call to SnapshotWriterMock.MarkReadOnly")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarkReadOnly != nil && mm_atomic.LoadUint64(&m.afterMarkReadOnlyCounter) < 1 {
		m.t.Error("Expected call to SnapshotWriterMock.MarkReadOnly")
	}
}

type mSnapshotWriterMockTakeSnapshot struct {
	mock               *SnapshotWriterMock
	defaultExpectation *SnapshotWriterMockTakeSnapshotExpectation
	expectations       []*SnapshotWriterMockTakeSnapshotExpectation
}

// SnapshotWriterMockTakeSnapshotExpectation specifies expectation struct of the SnapshotWriter.TakeSnapshot
type SnapshotWriterMockTakeSnapshotExpectation struct {
	mock *SnapshotWriterMock

	results *SnapshotWriterMockTakeSnapshotResults
	Counter uint64
}

// SnapshotWriterMockTakeSnapshotResults contains results of the SnapshotWriter.TakeSnapshot
type SnapshotWriterMockTakeSnapshotResults struct {
	s1  Snapshot
	err error
}

// Expect sets up expected params for SnapshotWriter.TakeSnapshot
func (mmTakeSnapshot *mSnapshotWriterMockTakeSnapshot) Expect() *mSnapshotWriterMockTakeSnapshot {
	if mmTakeSnapshot.mock.funcTakeSnapshot != nil {
		mmTakeSnapshot.mock.t.Fatalf("SnapshotWriterMock.TakeSnapshot mock is already set by Set")
	}

	if mmTakeSnapshot.defaultExpectation == nil {
		mmTakeSnapshot.defaultExpectation = &SnapshotWriterMockTakeSnapshotExpectation{}
	}

	return mmTakeSnapshot
}

// Inspect accepts an inspector function that has same arguments as the SnapshotWriter.TakeSnapshot
func (mmTakeSnapshot *mSnapshotWriterMockTakeSnapshot) Inspect(f func()) *mSnapshotWriterMockTakeSnapshot {
	if mmTakeSnapshot.mock.inspectFuncTakeSnapshot != nil {
		mmTakeSnapshot.mock.t.Fatalf("Inspect function is already set for SnapshotWriterMock.TakeSnapshot")
	}

	mmTakeSnapshot.mock.inspectFuncTakeSnapshot = f

	return mmTakeSnapshot
}

// Return sets up results that will be returned by SnapshotWriter.TakeSnapshot
func (mmTakeSnapshot *mSnapshotWriterMockTakeSnapshot) Return(s1 Snapshot, err error) *SnapshotWriterMock {
	if mmTakeSnapshot.mock.funcTakeSnapshot != nil {
		mmTakeSnapshot.mock.t.Fatalf("SnapshotWriterMock.TakeSnapshot mock is already set by Set")
	}

	if mmTakeSnapshot.defaultExpectation == nil {
		mmTakeSnapshot.defaultExpectation = &SnapshotWriterMockTakeSnapshotExpectation{mock: mmTakeSnapshot.mock}
	}
	mmTakeSnapshot.defaultExpectation.results = &SnapshotWriterMockTakeSnapshotResults{s1, err}
	return mmTakeSnapshot.mock
}

//Set uses given function f to mock the SnapshotWriter.TakeSnapshot method
func (mmTakeSnapshot *mSnapshotWriterMockTakeSnapshot) Set(f func() (s1 Snapshot, err error)) *SnapshotWriterMock {
	if mmTakeSnapshot.defaultExpectation != nil {
		mmTakeSnapshot.mock.t.Fatalf("Default expectation is already set for the SnapshotWriter.TakeSnapshot method")
	}

	if len(mmTakeSnapshot.expectations) > 0 {
		mmTakeSnapshot.mock.t.Fatalf("Some expectations are already set for the SnapshotWriter.TakeSnapshot method")
	}

	mmTakeSnapshot.mock.funcTakeSnapshot = f
	return mmTakeSnapshot.mock
}

// TakeSnapshot implements SnapshotWriter
func (mmTakeSnapshot *SnapshotWriterMock) TakeSnapshot() (s1 Snapshot, err error) {
	mm_atomic.AddUint64(&mmTakeSnapshot.beforeTakeSnapshotCounter, 1)
	defer mm_atomic.AddUint64(&mmTakeSnapshot.afterTakeSnapshotCounter, 1)

	if mmTakeSnapshot.inspectFuncTakeSnapshot != nil {
		mmTakeSnapshot.inspectFuncTakeSnapshot()
	}

	if mmTakeSnapshot.TakeSnapshotMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTakeSnapshot.TakeSnapshotMock.defaultExpectation.Counter, 1)

		mm_results := mmTakeSnapshot.TakeSnapshotMock.defaultExpectation.results
		if mm_results == nil {
			mmTakeSnapshot.t.Fatal("No results are set for the SnapshotWriterMock.TakeSnapshot")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmTakeSnapshot.funcTakeSnapshot != nil {
		return mmTakeSnapshot.funcTakeSnapshot()
	}
	mmTakeSnapshot.t.Fatalf("Unexpected call to SnapshotWriterMock.TakeSnapshot.")
	return
}

// TakeSnapshotAfterCounter returns a count of finished SnapshotWriterMock.TakeSnapshot invocations
func (mmTakeSnapshot *SnapshotWriterMock) TakeSnapshotAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTakeSnapshot.afterTakeSnapshotCounter)
}

// TakeSnapshotBeforeCounter returns a count of SnapshotWriterMock.TakeSnapshot invocations
func (mmTakeSnapshot *SnapshotWriterMock) TakeSnapshotBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTakeSnapshot.beforeTakeSnapshotCounter)
}

// MinimockTakeSnapshotDone returns true if the count of the TakeSnapshot invocations corresponds
// the number of defined expectations
func (m *SnapshotWriterMock) MinimockTakeSnapshotDone() bool {
	for _, e := range m.TakeSnapshotMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TakeSnapshotMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTakeSnapshotCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTakeSnapshot != nil && mm_atomic.LoadUint64(&m.afterTakeSnapshotCounter) < 1 {
		return false
	}
	return true
}

// MinimockTakeSnapshotInspect logs each unmet expectation
func (m *SnapshotWriterMock) MinimockTakeSnapshotInspect() {
	for _, e := range m.TakeSnapshotMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SnapshotWriterMock.TakeSnapshot")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TakeSnapshotMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTakeSnapshotCounter) < 1 {
		m.t.Error("Expected call to SnapshotWriterMock.TakeSnapshot")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTakeSnapshot != nil && mm_atomic.LoadUint64(&m.afterTakeSnapshotCounter) < 1 {
		m.t.Error("Expected call to SnapshotWriterMock.TakeSnapshot")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SnapshotWriterMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDirtyReaderInspect()

		m.MinimockMarkReadOnlyInspect()

		m.MinimockTakeSnapshotInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SnapshotWriterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SnapshotWriterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDirtyReaderDone() &&
		m.MinimockMarkReadOnlyDone() &&
		m.MinimockTakeSnapshotDone()
}
