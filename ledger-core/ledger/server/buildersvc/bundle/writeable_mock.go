package bundle

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/ledger"
)

// WriteableMock implements Writeable
type WriteableMock struct {
	t minimock.Tester

	funcApplyRollback          func()
	inspectFuncApplyRollback   func()
	afterApplyRollbackCounter  uint64
	beforeApplyRollbackCounter uint64
	ApplyRollbackMock          mWriteableMockApplyRollback

	funcApplyWrite          func() (da1 []ledger.DirectoryIndex, err error)
	inspectFuncApplyWrite   func()
	afterApplyWriteCounter  uint64
	beforeApplyWriteCounter uint64
	ApplyWriteMock          mWriteableMockApplyWrite

	funcPrepareWrite          func(s1 Snapshot) (err error)
	inspectFuncPrepareWrite   func(s1 Snapshot)
	afterPrepareWriteCounter  uint64
	beforePrepareWriteCounter uint64
	PrepareWriteMock          mWriteableMockPrepareWrite
}

// NewWriteableMock returns a mock for Writeable
func NewWriteableMock(t minimock.Tester) *WriteableMock {
	m := &WriteableMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ApplyRollbackMock = mWriteableMockApplyRollback{mock: m}

	m.ApplyWriteMock = mWriteableMockApplyWrite{mock: m}

	m.PrepareWriteMock = mWriteableMockPrepareWrite{mock: m}
	m.PrepareWriteMock.callArgs = []*WriteableMockPrepareWriteParams{}

	return m
}

type mWriteableMockApplyRollback struct {
	mock               *WriteableMock
	defaultExpectation *WriteableMockApplyRollbackExpectation
	expectations       []*WriteableMockApplyRollbackExpectation
}

// WriteableMockApplyRollbackExpectation specifies expectation struct of the Writeable.ApplyRollback
type WriteableMockApplyRollbackExpectation struct {
	mock *WriteableMock

	Counter uint64
}

// Expect sets up expected params for Writeable.ApplyRollback
func (mmApplyRollback *mWriteableMockApplyRollback) Expect() *mWriteableMockApplyRollback {
	if mmApplyRollback.mock.funcApplyRollback != nil {
		mmApplyRollback.mock.t.Fatalf("WriteableMock.ApplyRollback mock is already set by Set")
	}

	if mmApplyRollback.defaultExpectation == nil {
		mmApplyRollback.defaultExpectation = &WriteableMockApplyRollbackExpectation{}
	}

	return mmApplyRollback
}

// Inspect accepts an inspector function that has same arguments as the Writeable.ApplyRollback
func (mmApplyRollback *mWriteableMockApplyRollback) Inspect(f func()) *mWriteableMockApplyRollback {
	if mmApplyRollback.mock.inspectFuncApplyRollback != nil {
		mmApplyRollback.mock.t.Fatalf("Inspect function is already set for WriteableMock.ApplyRollback")
	}

	mmApplyRollback.mock.inspectFuncApplyRollback = f

	return mmApplyRollback
}

// Return sets up results that will be returned by Writeable.ApplyRollback
func (mmApplyRollback *mWriteableMockApplyRollback) Return() *WriteableMock {
	if mmApplyRollback.mock.funcApplyRollback != nil {
		mmApplyRollback.mock.t.Fatalf("WriteableMock.ApplyRollback mock is already set by Set")
	}

	if mmApplyRollback.defaultExpectation == nil {
		mmApplyRollback.defaultExpectation = &WriteableMockApplyRollbackExpectation{mock: mmApplyRollback.mock}
	}

	return mmApplyRollback.mock
}

//Set uses given function f to mock the Writeable.ApplyRollback method
func (mmApplyRollback *mWriteableMockApplyRollback) Set(f func()) *WriteableMock {
	if mmApplyRollback.defaultExpectation != nil {
		mmApplyRollback.mock.t.Fatalf("Default expectation is already set for the Writeable.ApplyRollback method")
	}

	if len(mmApplyRollback.expectations) > 0 {
		mmApplyRollback.mock.t.Fatalf("Some expectations are already set for the Writeable.ApplyRollback method")
	}

	mmApplyRollback.mock.funcApplyRollback = f
	return mmApplyRollback.mock
}

// ApplyRollback implements Writeable
func (mmApplyRollback *WriteableMock) ApplyRollback() {
	mm_atomic.AddUint64(&mmApplyRollback.beforeApplyRollbackCounter, 1)
	defer mm_atomic.AddUint64(&mmApplyRollback.afterApplyRollbackCounter, 1)

	if mmApplyRollback.inspectFuncApplyRollback != nil {
		mmApplyRollback.inspectFuncApplyRollback()
	}

	if mmApplyRollback.ApplyRollbackMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmApplyRollback.ApplyRollbackMock.defaultExpectation.Counter, 1)

		return

	}
	if mmApplyRollback.funcApplyRollback != nil {
		mmApplyRollback.funcApplyRollback()
		return
	}
	mmApplyRollback.t.Fatalf("Unexpected call to WriteableMock.ApplyRollback.")

}

// ApplyRollbackAfterCounter returns a count of finished WriteableMock.ApplyRollback invocations
func (mmApplyRollback *WriteableMock) ApplyRollbackAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyRollback.afterApplyRollbackCounter)
}

// ApplyRollbackBeforeCounter returns a count of WriteableMock.ApplyRollback invocations
func (mmApplyRollback *WriteableMock) ApplyRollbackBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyRollback.beforeApplyRollbackCounter)
}

// MinimockApplyRollbackDone returns true if the count of the ApplyRollback invocations corresponds
// the number of defined expectations
func (m *WriteableMock) MinimockApplyRollbackDone() bool {
	for _, e := range m.ApplyRollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyRollbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterApplyRollbackCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApplyRollback != nil && mm_atomic.LoadUint64(&m.afterApplyRollbackCounter) < 1 {
		return false
	}
	return true
}

// MinimockApplyRollbackInspect logs each unmet expectation
func (m *WriteableMock) MinimockApplyRollbackInspect() {
	for _, e := range m.ApplyRollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to WriteableMock.ApplyRollback")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyRollbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterApplyRollbackCounter) < 1 {
		m.t.Error("Expected call to WriteableMock.ApplyRollback")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApplyRollback != nil && mm_atomic.LoadUint64(&m.afterApplyRollbackCounter) < 1 {
		m.t.Error("Expected call to WriteableMock.ApplyRollback")
	}
}

type mWriteableMockApplyWrite struct {
	mock               *WriteableMock
	defaultExpectation *WriteableMockApplyWriteExpectation
	expectations       []*WriteableMockApplyWriteExpectation
}

// WriteableMockApplyWriteExpectation specifies expectation struct of the Writeable.ApplyWrite
type WriteableMockApplyWriteExpectation struct {
	mock *WriteableMock

	results *WriteableMockApplyWriteResults
	Counter uint64
}

// WriteableMockApplyWriteResults contains results of the Writeable.ApplyWrite
type WriteableMockApplyWriteResults struct {
	da1 []ledger.DirectoryIndex
	err error
}

// Expect sets up expected params for Writeable.ApplyWrite
func (mmApplyWrite *mWriteableMockApplyWrite) Expect() *mWriteableMockApplyWrite {
	if mmApplyWrite.mock.funcApplyWrite != nil {
		mmApplyWrite.mock.t.Fatalf("WriteableMock.ApplyWrite mock is already set by Set")
	}

	if mmApplyWrite.defaultExpectation == nil {
		mmApplyWrite.defaultExpectation = &WriteableMockApplyWriteExpectation{}
	}

	return mmApplyWrite
}

// Inspect accepts an inspector function that has same arguments as the Writeable.ApplyWrite
func (mmApplyWrite *mWriteableMockApplyWrite) Inspect(f func()) *mWriteableMockApplyWrite {
	if mmApplyWrite.mock.inspectFuncApplyWrite != nil {
		mmApplyWrite.mock.t.Fatalf("Inspect function is already set for WriteableMock.ApplyWrite")
	}

	mmApplyWrite.mock.inspectFuncApplyWrite = f

	return mmApplyWrite
}

// Return sets up results that will be returned by Writeable.ApplyWrite
func (mmApplyWrite *mWriteableMockApplyWrite) Return(da1 []ledger.DirectoryIndex, err error) *WriteableMock {
	if mmApplyWrite.mock.funcApplyWrite != nil {
		mmApplyWrite.mock.t.Fatalf("WriteableMock.ApplyWrite mock is already set by Set")
	}

	if mmApplyWrite.defaultExpectation == nil {
		mmApplyWrite.defaultExpectation = &WriteableMockApplyWriteExpectation{mock: mmApplyWrite.mock}
	}
	mmApplyWrite.defaultExpectation.results = &WriteableMockApplyWriteResults{da1, err}
	return mmApplyWrite.mock
}

//Set uses given function f to mock the Writeable.ApplyWrite method
func (mmApplyWrite *mWriteableMockApplyWrite) Set(f func() (da1 []ledger.DirectoryIndex, err error)) *WriteableMock {
	if mmApplyWrite.defaultExpectation != nil {
		mmApplyWrite.mock.t.Fatalf("Default expectation is already set for the Writeable.ApplyWrite method")
	}

	if len(mmApplyWrite.expectations) > 0 {
		mmApplyWrite.mock.t.Fatalf("Some expectations are already set for the Writeable.ApplyWrite method")
	}

	mmApplyWrite.mock.funcApplyWrite = f
	return mmApplyWrite.mock
}

// ApplyWrite implements Writeable
func (mmApplyWrite *WriteableMock) ApplyWrite() (da1 []ledger.DirectoryIndex, err error) {
	mm_atomic.AddUint64(&mmApplyWrite.beforeApplyWriteCounter, 1)
	defer mm_atomic.AddUint64(&mmApplyWrite.afterApplyWriteCounter, 1)

	if mmApplyWrite.inspectFuncApplyWrite != nil {
		mmApplyWrite.inspectFuncApplyWrite()
	}

	if mmApplyWrite.ApplyWriteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmApplyWrite.ApplyWriteMock.defaultExpectation.Counter, 1)

		mm_results := mmApplyWrite.ApplyWriteMock.defaultExpectation.results
		if mm_results == nil {
			mmApplyWrite.t.Fatal("No results are set for the WriteableMock.ApplyWrite")
		}
		return (*mm_results).da1, (*mm_results).err
	}
	if mmApplyWrite.funcApplyWrite != nil {
		return mmApplyWrite.funcApplyWrite()
	}
	mmApplyWrite.t.Fatalf("Unexpected call to WriteableMock.ApplyWrite.")
	return
}

// ApplyWriteAfterCounter returns a count of finished WriteableMock.ApplyWrite invocations
func (mmApplyWrite *WriteableMock) ApplyWriteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyWrite.afterApplyWriteCounter)
}

// ApplyWriteBeforeCounter returns a count of WriteableMock.ApplyWrite invocations
func (mmApplyWrite *WriteableMock) ApplyWriteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyWrite.beforeApplyWriteCounter)
}

// MinimockApplyWriteDone returns true if the count of the ApplyWrite invocations corresponds
// the number of defined expectations
func (m *WriteableMock) MinimockApplyWriteDone() bool {
	for _, e := range m.ApplyWriteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyWriteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterApplyWriteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApplyWrite != nil && mm_atomic.LoadUint64(&m.afterApplyWriteCounter) < 1 {
		return false
	}
	return true
}

// MinimockApplyWriteInspect logs each unmet expectation
func (m *WriteableMock) MinimockApplyWriteInspect() {
	for _, e := range m.ApplyWriteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to WriteableMock.ApplyWrite")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyWriteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterApplyWriteCounter) < 1 {
		m.t.Error("Expected call to WriteableMock.ApplyWrite")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApplyWrite != nil && mm_atomic.LoadUint64(&m.afterApplyWriteCounter) < 1 {
		m.t.Error("Expected call to WriteableMock.ApplyWrite")
	}
}

type mWriteableMockPrepareWrite struct {
	mock               *WriteableMock
	defaultExpectation *WriteableMockPrepareWriteExpectation
	expectations       []*WriteableMockPrepareWriteExpectation

	callArgs []*WriteableMockPrepareWriteParams
	mutex    sync.RWMutex
}

// WriteableMockPrepareWriteExpectation specifies expectation struct of the Writeable.PrepareWrite
type WriteableMockPrepareWriteExpectation struct {
	mock    *WriteableMock
	params  *WriteableMockPrepareWriteParams
	results *WriteableMockPrepareWriteResults
	Counter uint64
}

// WriteableMockPrepareWriteParams contains parameters of the Writeable.PrepareWrite
type WriteableMockPrepareWriteParams struct {
	s1 Snapshot
}

// WriteableMockPrepareWriteResults contains results of the Writeable.PrepareWrite
type WriteableMockPrepareWriteResults struct {
	err error
}

// Expect sets up expected params for Writeable.PrepareWrite
func (mmPrepareWrite *mWriteableMockPrepareWrite) Expect(s1 Snapshot) *mWriteableMockPrepareWrite {
	if mmPrepareWrite.mock.funcPrepareWrite != nil {
		mmPrepareWrite.mock.t.Fatalf("WriteableMock.PrepareWrite mock is already set by Set")
	}

	if mmPrepareWrite.defaultExpectation == nil {
		mmPrepareWrite.defaultExpectation = &WriteableMockPrepareWriteExpectation{}
	}

	mmPrepareWrite.defaultExpectation.params = &WriteableMockPrepareWriteParams{s1}
	for _, e := range mmPrepareWrite.expectations {
		if minimock.Equal(e.params, mmPrepareWrite.defaultExpectation.params) {
			mmPrepareWrite.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrepareWrite.defaultExpectation.params)
		}
	}

	return mmPrepareWrite
}

// Inspect accepts an inspector function that has same arguments as the Writeable.PrepareWrite
func (mmPrepareWrite *mWriteableMockPrepareWrite) Inspect(f func(s1 Snapshot)) *mWriteableMockPrepareWrite {
	if mmPrepareWrite.mock.inspectFuncPrepareWrite != nil {
		mmPrepareWrite.mock.t.Fatalf("Inspect function is already set for WriteableMock.PrepareWrite")
	}

	mmPrepareWrite.mock.inspectFuncPrepareWrite = f

	return mmPrepareWrite
}

// Return sets up results that will be returned by Writeable.PrepareWrite
func (mmPrepareWrite *mWriteableMockPrepareWrite) Return(err error) *WriteableMock {
	if mmPrepareWrite.mock.funcPrepareWrite != nil {
		mmPrepareWrite.mock.t.Fatalf("WriteableMock.PrepareWrite mock is already set by Set")
	}

	if mmPrepareWrite.defaultExpectation == nil {
		mmPrepareWrite.defaultExpectation = &WriteableMockPrepareWriteExpectation{mock: mmPrepareWrite.mock}
	}
	mmPrepareWrite.defaultExpectation.results = &WriteableMockPrepareWriteResults{err}
	return mmPrepareWrite.mock
}

//Set uses given function f to mock the Writeable.PrepareWrite method
func (mmPrepareWrite *mWriteableMockPrepareWrite) Set(f func(s1 Snapshot) (err error)) *WriteableMock {
	if mmPrepareWrite.defaultExpectation != nil {
		mmPrepareWrite.mock.t.Fatalf("Default expectation is already set for the Writeable.PrepareWrite method")
	}

	if len(mmPrepareWrite.expectations) > 0 {
		mmPrepareWrite.mock.t.Fatalf("Some expectations are already set for the Writeable.PrepareWrite method")
	}

	mmPrepareWrite.mock.funcPrepareWrite = f
	return mmPrepareWrite.mock
}

// When sets expectation for the Writeable.PrepareWrite which will trigger the result defined by the following
// Then helper
func (mmPrepareWrite *mWriteableMockPrepareWrite) When(s1 Snapshot) *WriteableMockPrepareWriteExpectation {
	if mmPrepareWrite.mock.funcPrepareWrite != nil {
		mmPrepareWrite.mock.t.Fatalf("WriteableMock.PrepareWrite mock is already set by Set")
	}

	expectation := &WriteableMockPrepareWriteExpectation{
		mock:   mmPrepareWrite.mock,
		params: &WriteableMockPrepareWriteParams{s1},
	}
	mmPrepareWrite.expectations = append(mmPrepareWrite.expectations, expectation)
	return expectation
}

// Then sets up Writeable.PrepareWrite return parameters for the expectation previously defined by the When method
func (e *WriteableMockPrepareWriteExpectation) Then(err error) *WriteableMock {
	e.results = &WriteableMockPrepareWriteResults{err}
	return e.mock
}

// PrepareWrite implements Writeable
func (mmPrepareWrite *WriteableMock) PrepareWrite(s1 Snapshot) (err error) {
	mm_atomic.AddUint64(&mmPrepareWrite.beforePrepareWriteCounter, 1)
	defer mm_atomic.AddUint64(&mmPrepareWrite.afterPrepareWriteCounter, 1)

	if mmPrepareWrite.inspectFuncPrepareWrite != nil {
		mmPrepareWrite.inspectFuncPrepareWrite(s1)
	}

	mm_params := &WriteableMockPrepareWriteParams{s1}

	// Record call args
	mmPrepareWrite.PrepareWriteMock.mutex.Lock()
	mmPrepareWrite.PrepareWriteMock.callArgs = append(mmPrepareWrite.PrepareWriteMock.callArgs, mm_params)
	mmPrepareWrite.PrepareWriteMock.mutex.Unlock()

	for _, e := range mmPrepareWrite.PrepareWriteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPrepareWrite.PrepareWriteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrepareWrite.PrepareWriteMock.defaultExpectation.Counter, 1)
		mm_want := mmPrepareWrite.PrepareWriteMock.defaultExpectation.params
		mm_got := WriteableMockPrepareWriteParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrepareWrite.t.Errorf("WriteableMock.PrepareWrite got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPrepareWrite.PrepareWriteMock.defaultExpectation.results
		if mm_results == nil {
			mmPrepareWrite.t.Fatal("No results are set for the WriteableMock.PrepareWrite")
		}
		return (*mm_results).err
	}
	if mmPrepareWrite.funcPrepareWrite != nil {
		return mmPrepareWrite.funcPrepareWrite(s1)
	}
	mmPrepareWrite.t.Fatalf("Unexpected call to WriteableMock.PrepareWrite. %v", s1)
	return
}

// PrepareWriteAfterCounter returns a count of finished WriteableMock.PrepareWrite invocations
func (mmPrepareWrite *WriteableMock) PrepareWriteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepareWrite.afterPrepareWriteCounter)
}

// PrepareWriteBeforeCounter returns a count of WriteableMock.PrepareWrite invocations
func (mmPrepareWrite *WriteableMock) PrepareWriteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepareWrite.beforePrepareWriteCounter)
}

// Calls returns a list of arguments used in each call to WriteableMock.PrepareWrite.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrepareWrite *mWriteableMockPrepareWrite) Calls() []*WriteableMockPrepareWriteParams {
	mmPrepareWrite.mutex.RLock()

	argCopy := make([]*WriteableMockPrepareWriteParams, len(mmPrepareWrite.callArgs))
	copy(argCopy, mmPrepareWrite.callArgs)

	mmPrepareWrite.mutex.RUnlock()

	return argCopy
}

// MinimockPrepareWriteDone returns true if the count of the PrepareWrite invocations corresponds
// the number of defined expectations
func (m *WriteableMock) MinimockPrepareWriteDone() bool {
	for _, e := range m.PrepareWriteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareWriteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrepareWriteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepareWrite != nil && mm_atomic.LoadUint64(&m.afterPrepareWriteCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrepareWriteInspect logs each unmet expectation
func (m *WriteableMock) MinimockPrepareWriteInspect() {
	for _, e := range m.PrepareWriteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to WriteableMock.PrepareWrite with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareWriteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrepareWriteCounter) < 1 {
		if m.PrepareWriteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to WriteableMock.PrepareWrite")
		} else {
			m.t.Errorf("Expected call to WriteableMock.PrepareWrite with params: %#v", *m.PrepareWriteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepareWrite != nil && mm_atomic.LoadUint64(&m.afterPrepareWriteCounter) < 1 {
		m.t.Error("Expected call to WriteableMock.PrepareWrite")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *WriteableMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockApplyRollbackInspect()

		m.MinimockApplyWriteInspect()

		m.MinimockPrepareWriteInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *WriteableMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *WriteableMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockApplyRollbackDone() &&
		m.MinimockApplyWriteDone() &&
		m.MinimockPrepareWriteDone()
}
