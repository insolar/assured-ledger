package bundle

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/ledger"
)

// DirectorySectionMock implements DirectorySection
type DirectorySectionMock struct {
	t minimock.Tester

	funcAllocateEntryStorage          func(size int) (p1 PayloadReceptacle, s1 ledger.StorageLocator, err error)
	inspectFuncAllocateEntryStorage   func(size int)
	afterAllocateEntryStorageCounter  uint64
	beforeAllocateEntryStorageCounter uint64
	AllocateEntryStorageMock          mDirectorySectionMockAllocateEntryStorage

	funcAppendDirectoryEntry          func(index ledger.DirectoryIndex, entry DirectoryEntry) (err error)
	inspectFuncAppendDirectoryEntry   func(index ledger.DirectoryIndex, entry DirectoryEntry)
	afterAppendDirectoryEntryCounter  uint64
	beforeAppendDirectoryEntryCounter uint64
	AppendDirectoryEntryMock          mDirectorySectionMockAppendDirectoryEntry

	funcGetNextDirectoryIndex          func() (d1 ledger.DirectoryIndex)
	inspectFuncGetNextDirectoryIndex   func()
	afterGetNextDirectoryIndexCounter  uint64
	beforeGetNextDirectoryIndexCounter uint64
	GetNextDirectoryIndexMock          mDirectorySectionMockGetNextDirectoryIndex
}

// NewDirectorySectionMock returns a mock for DirectorySection
func NewDirectorySectionMock(t minimock.Tester) *DirectorySectionMock {
	m := &DirectorySectionMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AllocateEntryStorageMock = mDirectorySectionMockAllocateEntryStorage{mock: m}
	m.AllocateEntryStorageMock.callArgs = []*DirectorySectionMockAllocateEntryStorageParams{}

	m.AppendDirectoryEntryMock = mDirectorySectionMockAppendDirectoryEntry{mock: m}
	m.AppendDirectoryEntryMock.callArgs = []*DirectorySectionMockAppendDirectoryEntryParams{}

	m.GetNextDirectoryIndexMock = mDirectorySectionMockGetNextDirectoryIndex{mock: m}

	return m
}

type mDirectorySectionMockAllocateEntryStorage struct {
	mock               *DirectorySectionMock
	defaultExpectation *DirectorySectionMockAllocateEntryStorageExpectation
	expectations       []*DirectorySectionMockAllocateEntryStorageExpectation

	callArgs []*DirectorySectionMockAllocateEntryStorageParams
	mutex    sync.RWMutex
}

// DirectorySectionMockAllocateEntryStorageExpectation specifies expectation struct of the DirectorySection.AllocateEntryStorage
type DirectorySectionMockAllocateEntryStorageExpectation struct {
	mock    *DirectorySectionMock
	params  *DirectorySectionMockAllocateEntryStorageParams
	results *DirectorySectionMockAllocateEntryStorageResults
	Counter uint64
}

// DirectorySectionMockAllocateEntryStorageParams contains parameters of the DirectorySection.AllocateEntryStorage
type DirectorySectionMockAllocateEntryStorageParams struct {
	size int
}

// DirectorySectionMockAllocateEntryStorageResults contains results of the DirectorySection.AllocateEntryStorage
type DirectorySectionMockAllocateEntryStorageResults struct {
	p1  PayloadReceptacle
	s1  ledger.StorageLocator
	err error
}

// Expect sets up expected params for DirectorySection.AllocateEntryStorage
func (mmAllocateEntryStorage *mDirectorySectionMockAllocateEntryStorage) Expect(size int) *mDirectorySectionMockAllocateEntryStorage {
	if mmAllocateEntryStorage.mock.funcAllocateEntryStorage != nil {
		mmAllocateEntryStorage.mock.t.Fatalf("DirectorySectionMock.AllocateEntryStorage mock is already set by Set")
	}

	if mmAllocateEntryStorage.defaultExpectation == nil {
		mmAllocateEntryStorage.defaultExpectation = &DirectorySectionMockAllocateEntryStorageExpectation{}
	}

	mmAllocateEntryStorage.defaultExpectation.params = &DirectorySectionMockAllocateEntryStorageParams{size}
	for _, e := range mmAllocateEntryStorage.expectations {
		if minimock.Equal(e.params, mmAllocateEntryStorage.defaultExpectation.params) {
			mmAllocateEntryStorage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAllocateEntryStorage.defaultExpectation.params)
		}
	}

	return mmAllocateEntryStorage
}

// Inspect accepts an inspector function that has same arguments as the DirectorySection.AllocateEntryStorage
func (mmAllocateEntryStorage *mDirectorySectionMockAllocateEntryStorage) Inspect(f func(size int)) *mDirectorySectionMockAllocateEntryStorage {
	if mmAllocateEntryStorage.mock.inspectFuncAllocateEntryStorage != nil {
		mmAllocateEntryStorage.mock.t.Fatalf("Inspect function is already set for DirectorySectionMock.AllocateEntryStorage")
	}

	mmAllocateEntryStorage.mock.inspectFuncAllocateEntryStorage = f

	return mmAllocateEntryStorage
}

// Return sets up results that will be returned by DirectorySection.AllocateEntryStorage
func (mmAllocateEntryStorage *mDirectorySectionMockAllocateEntryStorage) Return(p1 PayloadReceptacle, s1 ledger.StorageLocator, err error) *DirectorySectionMock {
	if mmAllocateEntryStorage.mock.funcAllocateEntryStorage != nil {
		mmAllocateEntryStorage.mock.t.Fatalf("DirectorySectionMock.AllocateEntryStorage mock is already set by Set")
	}

	if mmAllocateEntryStorage.defaultExpectation == nil {
		mmAllocateEntryStorage.defaultExpectation = &DirectorySectionMockAllocateEntryStorageExpectation{mock: mmAllocateEntryStorage.mock}
	}
	mmAllocateEntryStorage.defaultExpectation.results = &DirectorySectionMockAllocateEntryStorageResults{p1, s1, err}
	return mmAllocateEntryStorage.mock
}

//Set uses given function f to mock the DirectorySection.AllocateEntryStorage method
func (mmAllocateEntryStorage *mDirectorySectionMockAllocateEntryStorage) Set(f func(size int) (p1 PayloadReceptacle, s1 ledger.StorageLocator, err error)) *DirectorySectionMock {
	if mmAllocateEntryStorage.defaultExpectation != nil {
		mmAllocateEntryStorage.mock.t.Fatalf("Default expectation is already set for the DirectorySection.AllocateEntryStorage method")
	}

	if len(mmAllocateEntryStorage.expectations) > 0 {
		mmAllocateEntryStorage.mock.t.Fatalf("Some expectations are already set for the DirectorySection.AllocateEntryStorage method")
	}

	mmAllocateEntryStorage.mock.funcAllocateEntryStorage = f
	return mmAllocateEntryStorage.mock
}

// When sets expectation for the DirectorySection.AllocateEntryStorage which will trigger the result defined by the following
// Then helper
func (mmAllocateEntryStorage *mDirectorySectionMockAllocateEntryStorage) When(size int) *DirectorySectionMockAllocateEntryStorageExpectation {
	if mmAllocateEntryStorage.mock.funcAllocateEntryStorage != nil {
		mmAllocateEntryStorage.mock.t.Fatalf("DirectorySectionMock.AllocateEntryStorage mock is already set by Set")
	}

	expectation := &DirectorySectionMockAllocateEntryStorageExpectation{
		mock:   mmAllocateEntryStorage.mock,
		params: &DirectorySectionMockAllocateEntryStorageParams{size},
	}
	mmAllocateEntryStorage.expectations = append(mmAllocateEntryStorage.expectations, expectation)
	return expectation
}

// Then sets up DirectorySection.AllocateEntryStorage return parameters for the expectation previously defined by the When method
func (e *DirectorySectionMockAllocateEntryStorageExpectation) Then(p1 PayloadReceptacle, s1 ledger.StorageLocator, err error) *DirectorySectionMock {
	e.results = &DirectorySectionMockAllocateEntryStorageResults{p1, s1, err}
	return e.mock
}

// AllocateEntryStorage implements DirectorySection
func (mmAllocateEntryStorage *DirectorySectionMock) AllocateEntryStorage(size int) (p1 PayloadReceptacle, s1 ledger.StorageLocator, err error) {
	mm_atomic.AddUint64(&mmAllocateEntryStorage.beforeAllocateEntryStorageCounter, 1)
	defer mm_atomic.AddUint64(&mmAllocateEntryStorage.afterAllocateEntryStorageCounter, 1)

	if mmAllocateEntryStorage.inspectFuncAllocateEntryStorage != nil {
		mmAllocateEntryStorage.inspectFuncAllocateEntryStorage(size)
	}

	mm_params := &DirectorySectionMockAllocateEntryStorageParams{size}

	// Record call args
	mmAllocateEntryStorage.AllocateEntryStorageMock.mutex.Lock()
	mmAllocateEntryStorage.AllocateEntryStorageMock.callArgs = append(mmAllocateEntryStorage.AllocateEntryStorageMock.callArgs, mm_params)
	mmAllocateEntryStorage.AllocateEntryStorageMock.mutex.Unlock()

	for _, e := range mmAllocateEntryStorage.AllocateEntryStorageMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.s1, e.results.err
		}
	}

	if mmAllocateEntryStorage.AllocateEntryStorageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAllocateEntryStorage.AllocateEntryStorageMock.defaultExpectation.Counter, 1)
		mm_want := mmAllocateEntryStorage.AllocateEntryStorageMock.defaultExpectation.params
		mm_got := DirectorySectionMockAllocateEntryStorageParams{size}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAllocateEntryStorage.t.Errorf("DirectorySectionMock.AllocateEntryStorage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAllocateEntryStorage.AllocateEntryStorageMock.defaultExpectation.results
		if mm_results == nil {
			mmAllocateEntryStorage.t.Fatal("No results are set for the DirectorySectionMock.AllocateEntryStorage")
		}
		return (*mm_results).p1, (*mm_results).s1, (*mm_results).err
	}
	if mmAllocateEntryStorage.funcAllocateEntryStorage != nil {
		return mmAllocateEntryStorage.funcAllocateEntryStorage(size)
	}
	mmAllocateEntryStorage.t.Fatalf("Unexpected call to DirectorySectionMock.AllocateEntryStorage. %v", size)
	return
}

// AllocateEntryStorageAfterCounter returns a count of finished DirectorySectionMock.AllocateEntryStorage invocations
func (mmAllocateEntryStorage *DirectorySectionMock) AllocateEntryStorageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAllocateEntryStorage.afterAllocateEntryStorageCounter)
}

// AllocateEntryStorageBeforeCounter returns a count of DirectorySectionMock.AllocateEntryStorage invocations
func (mmAllocateEntryStorage *DirectorySectionMock) AllocateEntryStorageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAllocateEntryStorage.beforeAllocateEntryStorageCounter)
}

// Calls returns a list of arguments used in each call to DirectorySectionMock.AllocateEntryStorage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAllocateEntryStorage *mDirectorySectionMockAllocateEntryStorage) Calls() []*DirectorySectionMockAllocateEntryStorageParams {
	mmAllocateEntryStorage.mutex.RLock()

	argCopy := make([]*DirectorySectionMockAllocateEntryStorageParams, len(mmAllocateEntryStorage.callArgs))
	copy(argCopy, mmAllocateEntryStorage.callArgs)

	mmAllocateEntryStorage.mutex.RUnlock()

	return argCopy
}

// MinimockAllocateEntryStorageDone returns true if the count of the AllocateEntryStorage invocations corresponds
// the number of defined expectations
func (m *DirectorySectionMock) MinimockAllocateEntryStorageDone() bool {
	for _, e := range m.AllocateEntryStorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AllocateEntryStorageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAllocateEntryStorageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAllocateEntryStorage != nil && mm_atomic.LoadUint64(&m.afterAllocateEntryStorageCounter) < 1 {
		return false
	}
	return true
}

// MinimockAllocateEntryStorageInspect logs each unmet expectation
func (m *DirectorySectionMock) MinimockAllocateEntryStorageInspect() {
	for _, e := range m.AllocateEntryStorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DirectorySectionMock.AllocateEntryStorage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AllocateEntryStorageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAllocateEntryStorageCounter) < 1 {
		if m.AllocateEntryStorageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DirectorySectionMock.AllocateEntryStorage")
		} else {
			m.t.Errorf("Expected call to DirectorySectionMock.AllocateEntryStorage with params: %#v", *m.AllocateEntryStorageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAllocateEntryStorage != nil && mm_atomic.LoadUint64(&m.afterAllocateEntryStorageCounter) < 1 {
		m.t.Error("Expected call to DirectorySectionMock.AllocateEntryStorage")
	}
}

type mDirectorySectionMockAppendDirectoryEntry struct {
	mock               *DirectorySectionMock
	defaultExpectation *DirectorySectionMockAppendDirectoryEntryExpectation
	expectations       []*DirectorySectionMockAppendDirectoryEntryExpectation

	callArgs []*DirectorySectionMockAppendDirectoryEntryParams
	mutex    sync.RWMutex
}

// DirectorySectionMockAppendDirectoryEntryExpectation specifies expectation struct of the DirectorySection.AppendDirectoryEntry
type DirectorySectionMockAppendDirectoryEntryExpectation struct {
	mock    *DirectorySectionMock
	params  *DirectorySectionMockAppendDirectoryEntryParams
	results *DirectorySectionMockAppendDirectoryEntryResults
	Counter uint64
}

// DirectorySectionMockAppendDirectoryEntryParams contains parameters of the DirectorySection.AppendDirectoryEntry
type DirectorySectionMockAppendDirectoryEntryParams struct {
	index ledger.DirectoryIndex
	entry DirectoryEntry
}

// DirectorySectionMockAppendDirectoryEntryResults contains results of the DirectorySection.AppendDirectoryEntry
type DirectorySectionMockAppendDirectoryEntryResults struct {
	err error
}

// Expect sets up expected params for DirectorySection.AppendDirectoryEntry
func (mmAppendDirectoryEntry *mDirectorySectionMockAppendDirectoryEntry) Expect(index ledger.DirectoryIndex, entry DirectoryEntry) *mDirectorySectionMockAppendDirectoryEntry {
	if mmAppendDirectoryEntry.mock.funcAppendDirectoryEntry != nil {
		mmAppendDirectoryEntry.mock.t.Fatalf("DirectorySectionMock.AppendDirectoryEntry mock is already set by Set")
	}

	if mmAppendDirectoryEntry.defaultExpectation == nil {
		mmAppendDirectoryEntry.defaultExpectation = &DirectorySectionMockAppendDirectoryEntryExpectation{}
	}

	mmAppendDirectoryEntry.defaultExpectation.params = &DirectorySectionMockAppendDirectoryEntryParams{index, entry}
	for _, e := range mmAppendDirectoryEntry.expectations {
		if minimock.Equal(e.params, mmAppendDirectoryEntry.defaultExpectation.params) {
			mmAppendDirectoryEntry.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAppendDirectoryEntry.defaultExpectation.params)
		}
	}

	return mmAppendDirectoryEntry
}

// Inspect accepts an inspector function that has same arguments as the DirectorySection.AppendDirectoryEntry
func (mmAppendDirectoryEntry *mDirectorySectionMockAppendDirectoryEntry) Inspect(f func(index ledger.DirectoryIndex, entry DirectoryEntry)) *mDirectorySectionMockAppendDirectoryEntry {
	if mmAppendDirectoryEntry.mock.inspectFuncAppendDirectoryEntry != nil {
		mmAppendDirectoryEntry.mock.t.Fatalf("Inspect function is already set for DirectorySectionMock.AppendDirectoryEntry")
	}

	mmAppendDirectoryEntry.mock.inspectFuncAppendDirectoryEntry = f

	return mmAppendDirectoryEntry
}

// Return sets up results that will be returned by DirectorySection.AppendDirectoryEntry
func (mmAppendDirectoryEntry *mDirectorySectionMockAppendDirectoryEntry) Return(err error) *DirectorySectionMock {
	if mmAppendDirectoryEntry.mock.funcAppendDirectoryEntry != nil {
		mmAppendDirectoryEntry.mock.t.Fatalf("DirectorySectionMock.AppendDirectoryEntry mock is already set by Set")
	}

	if mmAppendDirectoryEntry.defaultExpectation == nil {
		mmAppendDirectoryEntry.defaultExpectation = &DirectorySectionMockAppendDirectoryEntryExpectation{mock: mmAppendDirectoryEntry.mock}
	}
	mmAppendDirectoryEntry.defaultExpectation.results = &DirectorySectionMockAppendDirectoryEntryResults{err}
	return mmAppendDirectoryEntry.mock
}

//Set uses given function f to mock the DirectorySection.AppendDirectoryEntry method
func (mmAppendDirectoryEntry *mDirectorySectionMockAppendDirectoryEntry) Set(f func(index ledger.DirectoryIndex, entry DirectoryEntry) (err error)) *DirectorySectionMock {
	if mmAppendDirectoryEntry.defaultExpectation != nil {
		mmAppendDirectoryEntry.mock.t.Fatalf("Default expectation is already set for the DirectorySection.AppendDirectoryEntry method")
	}

	if len(mmAppendDirectoryEntry.expectations) > 0 {
		mmAppendDirectoryEntry.mock.t.Fatalf("Some expectations are already set for the DirectorySection.AppendDirectoryEntry method")
	}

	mmAppendDirectoryEntry.mock.funcAppendDirectoryEntry = f
	return mmAppendDirectoryEntry.mock
}

// When sets expectation for the DirectorySection.AppendDirectoryEntry which will trigger the result defined by the following
// Then helper
func (mmAppendDirectoryEntry *mDirectorySectionMockAppendDirectoryEntry) When(index ledger.DirectoryIndex, entry DirectoryEntry) *DirectorySectionMockAppendDirectoryEntryExpectation {
	if mmAppendDirectoryEntry.mock.funcAppendDirectoryEntry != nil {
		mmAppendDirectoryEntry.mock.t.Fatalf("DirectorySectionMock.AppendDirectoryEntry mock is already set by Set")
	}

	expectation := &DirectorySectionMockAppendDirectoryEntryExpectation{
		mock:   mmAppendDirectoryEntry.mock,
		params: &DirectorySectionMockAppendDirectoryEntryParams{index, entry},
	}
	mmAppendDirectoryEntry.expectations = append(mmAppendDirectoryEntry.expectations, expectation)
	return expectation
}

// Then sets up DirectorySection.AppendDirectoryEntry return parameters for the expectation previously defined by the When method
func (e *DirectorySectionMockAppendDirectoryEntryExpectation) Then(err error) *DirectorySectionMock {
	e.results = &DirectorySectionMockAppendDirectoryEntryResults{err}
	return e.mock
}

// AppendDirectoryEntry implements DirectorySection
func (mmAppendDirectoryEntry *DirectorySectionMock) AppendDirectoryEntry(index ledger.DirectoryIndex, entry DirectoryEntry) (err error) {
	mm_atomic.AddUint64(&mmAppendDirectoryEntry.beforeAppendDirectoryEntryCounter, 1)
	defer mm_atomic.AddUint64(&mmAppendDirectoryEntry.afterAppendDirectoryEntryCounter, 1)

	if mmAppendDirectoryEntry.inspectFuncAppendDirectoryEntry != nil {
		mmAppendDirectoryEntry.inspectFuncAppendDirectoryEntry(index, entry)
	}

	mm_params := &DirectorySectionMockAppendDirectoryEntryParams{index, entry}

	// Record call args
	mmAppendDirectoryEntry.AppendDirectoryEntryMock.mutex.Lock()
	mmAppendDirectoryEntry.AppendDirectoryEntryMock.callArgs = append(mmAppendDirectoryEntry.AppendDirectoryEntryMock.callArgs, mm_params)
	mmAppendDirectoryEntry.AppendDirectoryEntryMock.mutex.Unlock()

	for _, e := range mmAppendDirectoryEntry.AppendDirectoryEntryMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAppendDirectoryEntry.AppendDirectoryEntryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAppendDirectoryEntry.AppendDirectoryEntryMock.defaultExpectation.Counter, 1)
		mm_want := mmAppendDirectoryEntry.AppendDirectoryEntryMock.defaultExpectation.params
		mm_got := DirectorySectionMockAppendDirectoryEntryParams{index, entry}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAppendDirectoryEntry.t.Errorf("DirectorySectionMock.AppendDirectoryEntry got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAppendDirectoryEntry.AppendDirectoryEntryMock.defaultExpectation.results
		if mm_results == nil {
			mmAppendDirectoryEntry.t.Fatal("No results are set for the DirectorySectionMock.AppendDirectoryEntry")
		}
		return (*mm_results).err
	}
	if mmAppendDirectoryEntry.funcAppendDirectoryEntry != nil {
		return mmAppendDirectoryEntry.funcAppendDirectoryEntry(index, entry)
	}
	mmAppendDirectoryEntry.t.Fatalf("Unexpected call to DirectorySectionMock.AppendDirectoryEntry. %v %v", index, entry)
	return
}

// AppendDirectoryEntryAfterCounter returns a count of finished DirectorySectionMock.AppendDirectoryEntry invocations
func (mmAppendDirectoryEntry *DirectorySectionMock) AppendDirectoryEntryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAppendDirectoryEntry.afterAppendDirectoryEntryCounter)
}

// AppendDirectoryEntryBeforeCounter returns a count of DirectorySectionMock.AppendDirectoryEntry invocations
func (mmAppendDirectoryEntry *DirectorySectionMock) AppendDirectoryEntryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAppendDirectoryEntry.beforeAppendDirectoryEntryCounter)
}

// Calls returns a list of arguments used in each call to DirectorySectionMock.AppendDirectoryEntry.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAppendDirectoryEntry *mDirectorySectionMockAppendDirectoryEntry) Calls() []*DirectorySectionMockAppendDirectoryEntryParams {
	mmAppendDirectoryEntry.mutex.RLock()

	argCopy := make([]*DirectorySectionMockAppendDirectoryEntryParams, len(mmAppendDirectoryEntry.callArgs))
	copy(argCopy, mmAppendDirectoryEntry.callArgs)

	mmAppendDirectoryEntry.mutex.RUnlock()

	return argCopy
}

// MinimockAppendDirectoryEntryDone returns true if the count of the AppendDirectoryEntry invocations corresponds
// the number of defined expectations
func (m *DirectorySectionMock) MinimockAppendDirectoryEntryDone() bool {
	for _, e := range m.AppendDirectoryEntryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AppendDirectoryEntryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAppendDirectoryEntryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAppendDirectoryEntry != nil && mm_atomic.LoadUint64(&m.afterAppendDirectoryEntryCounter) < 1 {
		return false
	}
	return true
}

// MinimockAppendDirectoryEntryInspect logs each unmet expectation
func (m *DirectorySectionMock) MinimockAppendDirectoryEntryInspect() {
	for _, e := range m.AppendDirectoryEntryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DirectorySectionMock.AppendDirectoryEntry with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AppendDirectoryEntryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAppendDirectoryEntryCounter) < 1 {
		if m.AppendDirectoryEntryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DirectorySectionMock.AppendDirectoryEntry")
		} else {
			m.t.Errorf("Expected call to DirectorySectionMock.AppendDirectoryEntry with params: %#v", *m.AppendDirectoryEntryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAppendDirectoryEntry != nil && mm_atomic.LoadUint64(&m.afterAppendDirectoryEntryCounter) < 1 {
		m.t.Error("Expected call to DirectorySectionMock.AppendDirectoryEntry")
	}
}

type mDirectorySectionMockGetNextDirectoryIndex struct {
	mock               *DirectorySectionMock
	defaultExpectation *DirectorySectionMockGetNextDirectoryIndexExpectation
	expectations       []*DirectorySectionMockGetNextDirectoryIndexExpectation
}

// DirectorySectionMockGetNextDirectoryIndexExpectation specifies expectation struct of the DirectorySection.GetNextDirectoryIndex
type DirectorySectionMockGetNextDirectoryIndexExpectation struct {
	mock *DirectorySectionMock

	results *DirectorySectionMockGetNextDirectoryIndexResults
	Counter uint64
}

// DirectorySectionMockGetNextDirectoryIndexResults contains results of the DirectorySection.GetNextDirectoryIndex
type DirectorySectionMockGetNextDirectoryIndexResults struct {
	d1 ledger.DirectoryIndex
}

// Expect sets up expected params for DirectorySection.GetNextDirectoryIndex
func (mmGetNextDirectoryIndex *mDirectorySectionMockGetNextDirectoryIndex) Expect() *mDirectorySectionMockGetNextDirectoryIndex {
	if mmGetNextDirectoryIndex.mock.funcGetNextDirectoryIndex != nil {
		mmGetNextDirectoryIndex.mock.t.Fatalf("DirectorySectionMock.GetNextDirectoryIndex mock is already set by Set")
	}

	if mmGetNextDirectoryIndex.defaultExpectation == nil {
		mmGetNextDirectoryIndex.defaultExpectation = &DirectorySectionMockGetNextDirectoryIndexExpectation{}
	}

	return mmGetNextDirectoryIndex
}

// Inspect accepts an inspector function that has same arguments as the DirectorySection.GetNextDirectoryIndex
func (mmGetNextDirectoryIndex *mDirectorySectionMockGetNextDirectoryIndex) Inspect(f func()) *mDirectorySectionMockGetNextDirectoryIndex {
	if mmGetNextDirectoryIndex.mock.inspectFuncGetNextDirectoryIndex != nil {
		mmGetNextDirectoryIndex.mock.t.Fatalf("Inspect function is already set for DirectorySectionMock.GetNextDirectoryIndex")
	}

	mmGetNextDirectoryIndex.mock.inspectFuncGetNextDirectoryIndex = f

	return mmGetNextDirectoryIndex
}

// Return sets up results that will be returned by DirectorySection.GetNextDirectoryIndex
func (mmGetNextDirectoryIndex *mDirectorySectionMockGetNextDirectoryIndex) Return(d1 ledger.DirectoryIndex) *DirectorySectionMock {
	if mmGetNextDirectoryIndex.mock.funcGetNextDirectoryIndex != nil {
		mmGetNextDirectoryIndex.mock.t.Fatalf("DirectorySectionMock.GetNextDirectoryIndex mock is already set by Set")
	}

	if mmGetNextDirectoryIndex.defaultExpectation == nil {
		mmGetNextDirectoryIndex.defaultExpectation = &DirectorySectionMockGetNextDirectoryIndexExpectation{mock: mmGetNextDirectoryIndex.mock}
	}
	mmGetNextDirectoryIndex.defaultExpectation.results = &DirectorySectionMockGetNextDirectoryIndexResults{d1}
	return mmGetNextDirectoryIndex.mock
}

//Set uses given function f to mock the DirectorySection.GetNextDirectoryIndex method
func (mmGetNextDirectoryIndex *mDirectorySectionMockGetNextDirectoryIndex) Set(f func() (d1 ledger.DirectoryIndex)) *DirectorySectionMock {
	if mmGetNextDirectoryIndex.defaultExpectation != nil {
		mmGetNextDirectoryIndex.mock.t.Fatalf("Default expectation is already set for the DirectorySection.GetNextDirectoryIndex method")
	}

	if len(mmGetNextDirectoryIndex.expectations) > 0 {
		mmGetNextDirectoryIndex.mock.t.Fatalf("Some expectations are already set for the DirectorySection.GetNextDirectoryIndex method")
	}

	mmGetNextDirectoryIndex.mock.funcGetNextDirectoryIndex = f
	return mmGetNextDirectoryIndex.mock
}

// GetNextDirectoryIndex implements DirectorySection
func (mmGetNextDirectoryIndex *DirectorySectionMock) GetNextDirectoryIndex() (d1 ledger.DirectoryIndex) {
	mm_atomic.AddUint64(&mmGetNextDirectoryIndex.beforeGetNextDirectoryIndexCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNextDirectoryIndex.afterGetNextDirectoryIndexCounter, 1)

	if mmGetNextDirectoryIndex.inspectFuncGetNextDirectoryIndex != nil {
		mmGetNextDirectoryIndex.inspectFuncGetNextDirectoryIndex()
	}

	if mmGetNextDirectoryIndex.GetNextDirectoryIndexMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNextDirectoryIndex.GetNextDirectoryIndexMock.defaultExpectation.Counter, 1)

		mm_results := mmGetNextDirectoryIndex.GetNextDirectoryIndexMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNextDirectoryIndex.t.Fatal("No results are set for the DirectorySectionMock.GetNextDirectoryIndex")
		}
		return (*mm_results).d1
	}
	if mmGetNextDirectoryIndex.funcGetNextDirectoryIndex != nil {
		return mmGetNextDirectoryIndex.funcGetNextDirectoryIndex()
	}
	mmGetNextDirectoryIndex.t.Fatalf("Unexpected call to DirectorySectionMock.GetNextDirectoryIndex.")
	return
}

// GetNextDirectoryIndexAfterCounter returns a count of finished DirectorySectionMock.GetNextDirectoryIndex invocations
func (mmGetNextDirectoryIndex *DirectorySectionMock) GetNextDirectoryIndexAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNextDirectoryIndex.afterGetNextDirectoryIndexCounter)
}

// GetNextDirectoryIndexBeforeCounter returns a count of DirectorySectionMock.GetNextDirectoryIndex invocations
func (mmGetNextDirectoryIndex *DirectorySectionMock) GetNextDirectoryIndexBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNextDirectoryIndex.beforeGetNextDirectoryIndexCounter)
}

// MinimockGetNextDirectoryIndexDone returns true if the count of the GetNextDirectoryIndex invocations corresponds
// the number of defined expectations
func (m *DirectorySectionMock) MinimockGetNextDirectoryIndexDone() bool {
	for _, e := range m.GetNextDirectoryIndexMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNextDirectoryIndexMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNextDirectoryIndexCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNextDirectoryIndex != nil && mm_atomic.LoadUint64(&m.afterGetNextDirectoryIndexCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetNextDirectoryIndexInspect logs each unmet expectation
func (m *DirectorySectionMock) MinimockGetNextDirectoryIndexInspect() {
	for _, e := range m.GetNextDirectoryIndexMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DirectorySectionMock.GetNextDirectoryIndex")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNextDirectoryIndexMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNextDirectoryIndexCounter) < 1 {
		m.t.Error("Expected call to DirectorySectionMock.GetNextDirectoryIndex")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNextDirectoryIndex != nil && mm_atomic.LoadUint64(&m.afterGetNextDirectoryIndexCounter) < 1 {
		m.t.Error("Expected call to DirectorySectionMock.GetNextDirectoryIndex")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DirectorySectionMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAllocateEntryStorageInspect()

		m.MinimockAppendDirectoryEntryInspect()

		m.MinimockGetNextDirectoryIndexInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DirectorySectionMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DirectorySectionMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAllocateEntryStorageDone() &&
		m.MinimockAppendDirectoryEntryDone() &&
		m.MinimockGetNextDirectoryIndexDone()
}
