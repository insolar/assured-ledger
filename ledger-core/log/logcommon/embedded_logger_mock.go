package logcommon

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"reflect"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/log/logfmt"
)

// EmbeddedLoggerMock implements EmbeddedLogger
type EmbeddedLoggerMock struct {
	t minimock.Tester

	funcCopy          func() (e1 EmbeddedLoggerBuilder)
	inspectFuncCopy   func()
	afterCopyCounter  uint64
	beforeCopyCounter uint64
	CopyMock          mEmbeddedLoggerMockCopy

	funcEmbeddedFlush          func(msg string)
	inspectFuncEmbeddedFlush   func(msg string)
	afterEmbeddedFlushCounter  uint64
	beforeEmbeddedFlushCounter uint64
	EmbeddedFlushMock          mEmbeddedLoggerMockEmbeddedFlush

	funcFieldsOf          func(v1 reflect.Value) (l1 logfmt.LogObjectMarshaller)
	inspectFuncFieldsOf   func(v1 reflect.Value)
	afterFieldsOfCounter  uint64
	beforeFieldsOfCounter uint64
	FieldsOfMock          mEmbeddedLoggerMockFieldsOf

	funcIs          func(l1 Level) (b1 bool)
	inspectFuncIs   func(l1 Level)
	afterIsCounter  uint64
	beforeIsCounter uint64
	IsMock          mEmbeddedLoggerMockIs

	funcNewEvent          func(level Level) (f1 func(args []interface{}))
	inspectFuncNewEvent   func(level Level)
	afterNewEventCounter  uint64
	beforeNewEventCounter uint64
	NewEventMock          mEmbeddedLoggerMockNewEvent

	funcNewEventFmt          func(level Level) (f1 func(fmt string, args []interface{}))
	inspectFuncNewEventFmt   func(level Level)
	afterNewEventFmtCounter  uint64
	beforeNewEventFmtCounter uint64
	NewEventFmtMock          mEmbeddedLoggerMockNewEventFmt

	funcNewEventStruct          func(level Level) (f1 func(interface{}, []logfmt.LogFieldMarshaller))
	inspectFuncNewEventStruct   func(level Level)
	afterNewEventStructCounter  uint64
	beforeNewEventStructCounter uint64
	NewEventStructMock          mEmbeddedLoggerMockNewEventStruct
}

// NewEmbeddedLoggerMock returns a mock for EmbeddedLogger
func NewEmbeddedLoggerMock(t minimock.Tester) *EmbeddedLoggerMock {
	m := &EmbeddedLoggerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CopyMock = mEmbeddedLoggerMockCopy{mock: m}

	m.EmbeddedFlushMock = mEmbeddedLoggerMockEmbeddedFlush{mock: m}
	m.EmbeddedFlushMock.callArgs = []*EmbeddedLoggerMockEmbeddedFlushParams{}

	m.FieldsOfMock = mEmbeddedLoggerMockFieldsOf{mock: m}
	m.FieldsOfMock.callArgs = []*EmbeddedLoggerMockFieldsOfParams{}

	m.IsMock = mEmbeddedLoggerMockIs{mock: m}
	m.IsMock.callArgs = []*EmbeddedLoggerMockIsParams{}

	m.NewEventMock = mEmbeddedLoggerMockNewEvent{mock: m}
	m.NewEventMock.callArgs = []*EmbeddedLoggerMockNewEventParams{}

	m.NewEventFmtMock = mEmbeddedLoggerMockNewEventFmt{mock: m}
	m.NewEventFmtMock.callArgs = []*EmbeddedLoggerMockNewEventFmtParams{}

	m.NewEventStructMock = mEmbeddedLoggerMockNewEventStruct{mock: m}
	m.NewEventStructMock.callArgs = []*EmbeddedLoggerMockNewEventStructParams{}

	return m
}

type mEmbeddedLoggerMockCopy struct {
	mock               *EmbeddedLoggerMock
	defaultExpectation *EmbeddedLoggerMockCopyExpectation
	expectations       []*EmbeddedLoggerMockCopyExpectation
}

// EmbeddedLoggerMockCopyExpectation specifies expectation struct of the EmbeddedLogger.Copy
type EmbeddedLoggerMockCopyExpectation struct {
	mock *EmbeddedLoggerMock

	results *EmbeddedLoggerMockCopyResults
	Counter uint64
}

// EmbeddedLoggerMockCopyResults contains results of the EmbeddedLogger.Copy
type EmbeddedLoggerMockCopyResults struct {
	e1 EmbeddedLoggerBuilder
}

// Expect sets up expected params for EmbeddedLogger.Copy
func (mmCopy *mEmbeddedLoggerMockCopy) Expect() *mEmbeddedLoggerMockCopy {
	if mmCopy.mock.funcCopy != nil {
		mmCopy.mock.t.Fatalf("EmbeddedLoggerMock.Copy mock is already set by Set")
	}

	if mmCopy.defaultExpectation == nil {
		mmCopy.defaultExpectation = &EmbeddedLoggerMockCopyExpectation{}
	}

	return mmCopy
}

// Inspect accepts an inspector function that has same arguments as the EmbeddedLogger.Copy
func (mmCopy *mEmbeddedLoggerMockCopy) Inspect(f func()) *mEmbeddedLoggerMockCopy {
	if mmCopy.mock.inspectFuncCopy != nil {
		mmCopy.mock.t.Fatalf("Inspect function is already set for EmbeddedLoggerMock.Copy")
	}

	mmCopy.mock.inspectFuncCopy = f

	return mmCopy
}

// Return sets up results that will be returned by EmbeddedLogger.Copy
func (mmCopy *mEmbeddedLoggerMockCopy) Return(e1 EmbeddedLoggerBuilder) *EmbeddedLoggerMock {
	if mmCopy.mock.funcCopy != nil {
		mmCopy.mock.t.Fatalf("EmbeddedLoggerMock.Copy mock is already set by Set")
	}

	if mmCopy.defaultExpectation == nil {
		mmCopy.defaultExpectation = &EmbeddedLoggerMockCopyExpectation{mock: mmCopy.mock}
	}
	mmCopy.defaultExpectation.results = &EmbeddedLoggerMockCopyResults{e1}
	return mmCopy.mock
}

//Set uses given function f to mock the EmbeddedLogger.Copy method
func (mmCopy *mEmbeddedLoggerMockCopy) Set(f func() (e1 EmbeddedLoggerBuilder)) *EmbeddedLoggerMock {
	if mmCopy.defaultExpectation != nil {
		mmCopy.mock.t.Fatalf("Default expectation is already set for the EmbeddedLogger.Copy method")
	}

	if len(mmCopy.expectations) > 0 {
		mmCopy.mock.t.Fatalf("Some expectations are already set for the EmbeddedLogger.Copy method")
	}

	mmCopy.mock.funcCopy = f
	return mmCopy.mock
}

// Copy implements EmbeddedLogger
func (mmCopy *EmbeddedLoggerMock) Copy() (e1 EmbeddedLoggerBuilder) {
	mm_atomic.AddUint64(&mmCopy.beforeCopyCounter, 1)
	defer mm_atomic.AddUint64(&mmCopy.afterCopyCounter, 1)

	if mmCopy.inspectFuncCopy != nil {
		mmCopy.inspectFuncCopy()
	}

	if mmCopy.CopyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopy.CopyMock.defaultExpectation.Counter, 1)

		mm_results := mmCopy.CopyMock.defaultExpectation.results
		if mm_results == nil {
			mmCopy.t.Fatal("No results are set for the EmbeddedLoggerMock.Copy")
		}
		return (*mm_results).e1
	}
	if mmCopy.funcCopy != nil {
		return mmCopy.funcCopy()
	}
	mmCopy.t.Fatalf("Unexpected call to EmbeddedLoggerMock.Copy.")
	return
}

// CopyAfterCounter returns a count of finished EmbeddedLoggerMock.Copy invocations
func (mmCopy *EmbeddedLoggerMock) CopyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopy.afterCopyCounter)
}

// CopyBeforeCounter returns a count of EmbeddedLoggerMock.Copy invocations
func (mmCopy *EmbeddedLoggerMock) CopyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopy.beforeCopyCounter)
}

// MinimockCopyDone returns true if the count of the Copy invocations corresponds
// the number of defined expectations
func (m *EmbeddedLoggerMock) MinimockCopyDone() bool {
	for _, e := range m.CopyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopy != nil && mm_atomic.LoadUint64(&m.afterCopyCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyInspect logs each unmet expectation
func (m *EmbeddedLoggerMock) MinimockCopyInspect() {
	for _, e := range m.CopyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to EmbeddedLoggerMock.Copy")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyCounter) < 1 {
		m.t.Error("Expected call to EmbeddedLoggerMock.Copy")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopy != nil && mm_atomic.LoadUint64(&m.afterCopyCounter) < 1 {
		m.t.Error("Expected call to EmbeddedLoggerMock.Copy")
	}
}

type mEmbeddedLoggerMockEmbeddedFlush struct {
	mock               *EmbeddedLoggerMock
	defaultExpectation *EmbeddedLoggerMockEmbeddedFlushExpectation
	expectations       []*EmbeddedLoggerMockEmbeddedFlushExpectation

	callArgs []*EmbeddedLoggerMockEmbeddedFlushParams
	mutex    sync.RWMutex
}

// EmbeddedLoggerMockEmbeddedFlushExpectation specifies expectation struct of the EmbeddedLogger.EmbeddedFlush
type EmbeddedLoggerMockEmbeddedFlushExpectation struct {
	mock   *EmbeddedLoggerMock
	params *EmbeddedLoggerMockEmbeddedFlushParams

	Counter uint64
}

// EmbeddedLoggerMockEmbeddedFlushParams contains parameters of the EmbeddedLogger.EmbeddedFlush
type EmbeddedLoggerMockEmbeddedFlushParams struct {
	msg string
}

// Expect sets up expected params for EmbeddedLogger.EmbeddedFlush
func (mmEmbeddedFlush *mEmbeddedLoggerMockEmbeddedFlush) Expect(msg string) *mEmbeddedLoggerMockEmbeddedFlush {
	if mmEmbeddedFlush.mock.funcEmbeddedFlush != nil {
		mmEmbeddedFlush.mock.t.Fatalf("EmbeddedLoggerMock.EmbeddedFlush mock is already set by Set")
	}

	if mmEmbeddedFlush.defaultExpectation == nil {
		mmEmbeddedFlush.defaultExpectation = &EmbeddedLoggerMockEmbeddedFlushExpectation{}
	}

	mmEmbeddedFlush.defaultExpectation.params = &EmbeddedLoggerMockEmbeddedFlushParams{msg}
	for _, e := range mmEmbeddedFlush.expectations {
		if minimock.Equal(e.params, mmEmbeddedFlush.defaultExpectation.params) {
			mmEmbeddedFlush.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEmbeddedFlush.defaultExpectation.params)
		}
	}

	return mmEmbeddedFlush
}

// Inspect accepts an inspector function that has same arguments as the EmbeddedLogger.EmbeddedFlush
func (mmEmbeddedFlush *mEmbeddedLoggerMockEmbeddedFlush) Inspect(f func(msg string)) *mEmbeddedLoggerMockEmbeddedFlush {
	if mmEmbeddedFlush.mock.inspectFuncEmbeddedFlush != nil {
		mmEmbeddedFlush.mock.t.Fatalf("Inspect function is already set for EmbeddedLoggerMock.EmbeddedFlush")
	}

	mmEmbeddedFlush.mock.inspectFuncEmbeddedFlush = f

	return mmEmbeddedFlush
}

// Return sets up results that will be returned by EmbeddedLogger.EmbeddedFlush
func (mmEmbeddedFlush *mEmbeddedLoggerMockEmbeddedFlush) Return() *EmbeddedLoggerMock {
	if mmEmbeddedFlush.mock.funcEmbeddedFlush != nil {
		mmEmbeddedFlush.mock.t.Fatalf("EmbeddedLoggerMock.EmbeddedFlush mock is already set by Set")
	}

	if mmEmbeddedFlush.defaultExpectation == nil {
		mmEmbeddedFlush.defaultExpectation = &EmbeddedLoggerMockEmbeddedFlushExpectation{mock: mmEmbeddedFlush.mock}
	}

	return mmEmbeddedFlush.mock
}

//Set uses given function f to mock the EmbeddedLogger.EmbeddedFlush method
func (mmEmbeddedFlush *mEmbeddedLoggerMockEmbeddedFlush) Set(f func(msg string)) *EmbeddedLoggerMock {
	if mmEmbeddedFlush.defaultExpectation != nil {
		mmEmbeddedFlush.mock.t.Fatalf("Default expectation is already set for the EmbeddedLogger.EmbeddedFlush method")
	}

	if len(mmEmbeddedFlush.expectations) > 0 {
		mmEmbeddedFlush.mock.t.Fatalf("Some expectations are already set for the EmbeddedLogger.EmbeddedFlush method")
	}

	mmEmbeddedFlush.mock.funcEmbeddedFlush = f
	return mmEmbeddedFlush.mock
}

// EmbeddedFlush implements EmbeddedLogger
func (mmEmbeddedFlush *EmbeddedLoggerMock) EmbeddedFlush(msg string) {
	mm_atomic.AddUint64(&mmEmbeddedFlush.beforeEmbeddedFlushCounter, 1)
	defer mm_atomic.AddUint64(&mmEmbeddedFlush.afterEmbeddedFlushCounter, 1)

	if mmEmbeddedFlush.inspectFuncEmbeddedFlush != nil {
		mmEmbeddedFlush.inspectFuncEmbeddedFlush(msg)
	}

	mm_params := &EmbeddedLoggerMockEmbeddedFlushParams{msg}

	// Record call args
	mmEmbeddedFlush.EmbeddedFlushMock.mutex.Lock()
	mmEmbeddedFlush.EmbeddedFlushMock.callArgs = append(mmEmbeddedFlush.EmbeddedFlushMock.callArgs, mm_params)
	mmEmbeddedFlush.EmbeddedFlushMock.mutex.Unlock()

	for _, e := range mmEmbeddedFlush.EmbeddedFlushMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmEmbeddedFlush.EmbeddedFlushMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEmbeddedFlush.EmbeddedFlushMock.defaultExpectation.Counter, 1)
		mm_want := mmEmbeddedFlush.EmbeddedFlushMock.defaultExpectation.params
		mm_got := EmbeddedLoggerMockEmbeddedFlushParams{msg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEmbeddedFlush.t.Errorf("EmbeddedLoggerMock.EmbeddedFlush got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmEmbeddedFlush.funcEmbeddedFlush != nil {
		mmEmbeddedFlush.funcEmbeddedFlush(msg)
		return
	}
	mmEmbeddedFlush.t.Fatalf("Unexpected call to EmbeddedLoggerMock.EmbeddedFlush. %v", msg)

}

// EmbeddedFlushAfterCounter returns a count of finished EmbeddedLoggerMock.EmbeddedFlush invocations
func (mmEmbeddedFlush *EmbeddedLoggerMock) EmbeddedFlushAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEmbeddedFlush.afterEmbeddedFlushCounter)
}

// EmbeddedFlushBeforeCounter returns a count of EmbeddedLoggerMock.EmbeddedFlush invocations
func (mmEmbeddedFlush *EmbeddedLoggerMock) EmbeddedFlushBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEmbeddedFlush.beforeEmbeddedFlushCounter)
}

// Calls returns a list of arguments used in each call to EmbeddedLoggerMock.EmbeddedFlush.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEmbeddedFlush *mEmbeddedLoggerMockEmbeddedFlush) Calls() []*EmbeddedLoggerMockEmbeddedFlushParams {
	mmEmbeddedFlush.mutex.RLock()

	argCopy := make([]*EmbeddedLoggerMockEmbeddedFlushParams, len(mmEmbeddedFlush.callArgs))
	copy(argCopy, mmEmbeddedFlush.callArgs)

	mmEmbeddedFlush.mutex.RUnlock()

	return argCopy
}

// MinimockEmbeddedFlushDone returns true if the count of the EmbeddedFlush invocations corresponds
// the number of defined expectations
func (m *EmbeddedLoggerMock) MinimockEmbeddedFlushDone() bool {
	for _, e := range m.EmbeddedFlushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EmbeddedFlushMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEmbeddedFlushCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEmbeddedFlush != nil && mm_atomic.LoadUint64(&m.afterEmbeddedFlushCounter) < 1 {
		return false
	}
	return true
}

// MinimockEmbeddedFlushInspect logs each unmet expectation
func (m *EmbeddedLoggerMock) MinimockEmbeddedFlushInspect() {
	for _, e := range m.EmbeddedFlushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmbeddedLoggerMock.EmbeddedFlush with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EmbeddedFlushMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEmbeddedFlushCounter) < 1 {
		if m.EmbeddedFlushMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmbeddedLoggerMock.EmbeddedFlush")
		} else {
			m.t.Errorf("Expected call to EmbeddedLoggerMock.EmbeddedFlush with params: %#v", *m.EmbeddedFlushMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEmbeddedFlush != nil && mm_atomic.LoadUint64(&m.afterEmbeddedFlushCounter) < 1 {
		m.t.Error("Expected call to EmbeddedLoggerMock.EmbeddedFlush")
	}
}

type mEmbeddedLoggerMockFieldsOf struct {
	mock               *EmbeddedLoggerMock
	defaultExpectation *EmbeddedLoggerMockFieldsOfExpectation
	expectations       []*EmbeddedLoggerMockFieldsOfExpectation

	callArgs []*EmbeddedLoggerMockFieldsOfParams
	mutex    sync.RWMutex
}

// EmbeddedLoggerMockFieldsOfExpectation specifies expectation struct of the EmbeddedLogger.FieldsOf
type EmbeddedLoggerMockFieldsOfExpectation struct {
	mock    *EmbeddedLoggerMock
	params  *EmbeddedLoggerMockFieldsOfParams
	results *EmbeddedLoggerMockFieldsOfResults
	Counter uint64
}

// EmbeddedLoggerMockFieldsOfParams contains parameters of the EmbeddedLogger.FieldsOf
type EmbeddedLoggerMockFieldsOfParams struct {
	v1 reflect.Value
}

// EmbeddedLoggerMockFieldsOfResults contains results of the EmbeddedLogger.FieldsOf
type EmbeddedLoggerMockFieldsOfResults struct {
	l1 logfmt.LogObjectMarshaller
}

// Expect sets up expected params for EmbeddedLogger.FieldsOf
func (mmFieldsOf *mEmbeddedLoggerMockFieldsOf) Expect(v1 reflect.Value) *mEmbeddedLoggerMockFieldsOf {
	if mmFieldsOf.mock.funcFieldsOf != nil {
		mmFieldsOf.mock.t.Fatalf("EmbeddedLoggerMock.FieldsOf mock is already set by Set")
	}

	if mmFieldsOf.defaultExpectation == nil {
		mmFieldsOf.defaultExpectation = &EmbeddedLoggerMockFieldsOfExpectation{}
	}

	mmFieldsOf.defaultExpectation.params = &EmbeddedLoggerMockFieldsOfParams{v1}
	for _, e := range mmFieldsOf.expectations {
		if minimock.Equal(e.params, mmFieldsOf.defaultExpectation.params) {
			mmFieldsOf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFieldsOf.defaultExpectation.params)
		}
	}

	return mmFieldsOf
}

// Inspect accepts an inspector function that has same arguments as the EmbeddedLogger.FieldsOf
func (mmFieldsOf *mEmbeddedLoggerMockFieldsOf) Inspect(f func(v1 reflect.Value)) *mEmbeddedLoggerMockFieldsOf {
	if mmFieldsOf.mock.inspectFuncFieldsOf != nil {
		mmFieldsOf.mock.t.Fatalf("Inspect function is already set for EmbeddedLoggerMock.FieldsOf")
	}

	mmFieldsOf.mock.inspectFuncFieldsOf = f

	return mmFieldsOf
}

// Return sets up results that will be returned by EmbeddedLogger.FieldsOf
func (mmFieldsOf *mEmbeddedLoggerMockFieldsOf) Return(l1 logfmt.LogObjectMarshaller) *EmbeddedLoggerMock {
	if mmFieldsOf.mock.funcFieldsOf != nil {
		mmFieldsOf.mock.t.Fatalf("EmbeddedLoggerMock.FieldsOf mock is already set by Set")
	}

	if mmFieldsOf.defaultExpectation == nil {
		mmFieldsOf.defaultExpectation = &EmbeddedLoggerMockFieldsOfExpectation{mock: mmFieldsOf.mock}
	}
	mmFieldsOf.defaultExpectation.results = &EmbeddedLoggerMockFieldsOfResults{l1}
	return mmFieldsOf.mock
}

//Set uses given function f to mock the EmbeddedLogger.FieldsOf method
func (mmFieldsOf *mEmbeddedLoggerMockFieldsOf) Set(f func(v1 reflect.Value) (l1 logfmt.LogObjectMarshaller)) *EmbeddedLoggerMock {
	if mmFieldsOf.defaultExpectation != nil {
		mmFieldsOf.mock.t.Fatalf("Default expectation is already set for the EmbeddedLogger.FieldsOf method")
	}

	if len(mmFieldsOf.expectations) > 0 {
		mmFieldsOf.mock.t.Fatalf("Some expectations are already set for the EmbeddedLogger.FieldsOf method")
	}

	mmFieldsOf.mock.funcFieldsOf = f
	return mmFieldsOf.mock
}

// When sets expectation for the EmbeddedLogger.FieldsOf which will trigger the result defined by the following
// Then helper
func (mmFieldsOf *mEmbeddedLoggerMockFieldsOf) When(v1 reflect.Value) *EmbeddedLoggerMockFieldsOfExpectation {
	if mmFieldsOf.mock.funcFieldsOf != nil {
		mmFieldsOf.mock.t.Fatalf("EmbeddedLoggerMock.FieldsOf mock is already set by Set")
	}

	expectation := &EmbeddedLoggerMockFieldsOfExpectation{
		mock:   mmFieldsOf.mock,
		params: &EmbeddedLoggerMockFieldsOfParams{v1},
	}
	mmFieldsOf.expectations = append(mmFieldsOf.expectations, expectation)
	return expectation
}

// Then sets up EmbeddedLogger.FieldsOf return parameters for the expectation previously defined by the When method
func (e *EmbeddedLoggerMockFieldsOfExpectation) Then(l1 logfmt.LogObjectMarshaller) *EmbeddedLoggerMock {
	e.results = &EmbeddedLoggerMockFieldsOfResults{l1}
	return e.mock
}

// FieldsOf implements EmbeddedLogger
func (mmFieldsOf *EmbeddedLoggerMock) FieldsOf(v1 reflect.Value) (l1 logfmt.LogObjectMarshaller) {
	mm_atomic.AddUint64(&mmFieldsOf.beforeFieldsOfCounter, 1)
	defer mm_atomic.AddUint64(&mmFieldsOf.afterFieldsOfCounter, 1)

	if mmFieldsOf.inspectFuncFieldsOf != nil {
		mmFieldsOf.inspectFuncFieldsOf(v1)
	}

	mm_params := &EmbeddedLoggerMockFieldsOfParams{v1}

	// Record call args
	mmFieldsOf.FieldsOfMock.mutex.Lock()
	mmFieldsOf.FieldsOfMock.callArgs = append(mmFieldsOf.FieldsOfMock.callArgs, mm_params)
	mmFieldsOf.FieldsOfMock.mutex.Unlock()

	for _, e := range mmFieldsOf.FieldsOfMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1
		}
	}

	if mmFieldsOf.FieldsOfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFieldsOf.FieldsOfMock.defaultExpectation.Counter, 1)
		mm_want := mmFieldsOf.FieldsOfMock.defaultExpectation.params
		mm_got := EmbeddedLoggerMockFieldsOfParams{v1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFieldsOf.t.Errorf("EmbeddedLoggerMock.FieldsOf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFieldsOf.FieldsOfMock.defaultExpectation.results
		if mm_results == nil {
			mmFieldsOf.t.Fatal("No results are set for the EmbeddedLoggerMock.FieldsOf")
		}
		return (*mm_results).l1
	}
	if mmFieldsOf.funcFieldsOf != nil {
		return mmFieldsOf.funcFieldsOf(v1)
	}
	mmFieldsOf.t.Fatalf("Unexpected call to EmbeddedLoggerMock.FieldsOf. %v", v1)
	return
}

// FieldsOfAfterCounter returns a count of finished EmbeddedLoggerMock.FieldsOf invocations
func (mmFieldsOf *EmbeddedLoggerMock) FieldsOfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFieldsOf.afterFieldsOfCounter)
}

// FieldsOfBeforeCounter returns a count of EmbeddedLoggerMock.FieldsOf invocations
func (mmFieldsOf *EmbeddedLoggerMock) FieldsOfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFieldsOf.beforeFieldsOfCounter)
}

// Calls returns a list of arguments used in each call to EmbeddedLoggerMock.FieldsOf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFieldsOf *mEmbeddedLoggerMockFieldsOf) Calls() []*EmbeddedLoggerMockFieldsOfParams {
	mmFieldsOf.mutex.RLock()

	argCopy := make([]*EmbeddedLoggerMockFieldsOfParams, len(mmFieldsOf.callArgs))
	copy(argCopy, mmFieldsOf.callArgs)

	mmFieldsOf.mutex.RUnlock()

	return argCopy
}

// MinimockFieldsOfDone returns true if the count of the FieldsOf invocations corresponds
// the number of defined expectations
func (m *EmbeddedLoggerMock) MinimockFieldsOfDone() bool {
	for _, e := range m.FieldsOfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FieldsOfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFieldsOfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFieldsOf != nil && mm_atomic.LoadUint64(&m.afterFieldsOfCounter) < 1 {
		return false
	}
	return true
}

// MinimockFieldsOfInspect logs each unmet expectation
func (m *EmbeddedLoggerMock) MinimockFieldsOfInspect() {
	for _, e := range m.FieldsOfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmbeddedLoggerMock.FieldsOf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FieldsOfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFieldsOfCounter) < 1 {
		if m.FieldsOfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmbeddedLoggerMock.FieldsOf")
		} else {
			m.t.Errorf("Expected call to EmbeddedLoggerMock.FieldsOf with params: %#v", *m.FieldsOfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFieldsOf != nil && mm_atomic.LoadUint64(&m.afterFieldsOfCounter) < 1 {
		m.t.Error("Expected call to EmbeddedLoggerMock.FieldsOf")
	}
}

type mEmbeddedLoggerMockIs struct {
	mock               *EmbeddedLoggerMock
	defaultExpectation *EmbeddedLoggerMockIsExpectation
	expectations       []*EmbeddedLoggerMockIsExpectation

	callArgs []*EmbeddedLoggerMockIsParams
	mutex    sync.RWMutex
}

// EmbeddedLoggerMockIsExpectation specifies expectation struct of the EmbeddedLogger.Is
type EmbeddedLoggerMockIsExpectation struct {
	mock    *EmbeddedLoggerMock
	params  *EmbeddedLoggerMockIsParams
	results *EmbeddedLoggerMockIsResults
	Counter uint64
}

// EmbeddedLoggerMockIsParams contains parameters of the EmbeddedLogger.Is
type EmbeddedLoggerMockIsParams struct {
	l1 Level
}

// EmbeddedLoggerMockIsResults contains results of the EmbeddedLogger.Is
type EmbeddedLoggerMockIsResults struct {
	b1 bool
}

// Expect sets up expected params for EmbeddedLogger.Is
func (mmIs *mEmbeddedLoggerMockIs) Expect(l1 Level) *mEmbeddedLoggerMockIs {
	if mmIs.mock.funcIs != nil {
		mmIs.mock.t.Fatalf("EmbeddedLoggerMock.Is mock is already set by Set")
	}

	if mmIs.defaultExpectation == nil {
		mmIs.defaultExpectation = &EmbeddedLoggerMockIsExpectation{}
	}

	mmIs.defaultExpectation.params = &EmbeddedLoggerMockIsParams{l1}
	for _, e := range mmIs.expectations {
		if minimock.Equal(e.params, mmIs.defaultExpectation.params) {
			mmIs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIs.defaultExpectation.params)
		}
	}

	return mmIs
}

// Inspect accepts an inspector function that has same arguments as the EmbeddedLogger.Is
func (mmIs *mEmbeddedLoggerMockIs) Inspect(f func(l1 Level)) *mEmbeddedLoggerMockIs {
	if mmIs.mock.inspectFuncIs != nil {
		mmIs.mock.t.Fatalf("Inspect function is already set for EmbeddedLoggerMock.Is")
	}

	mmIs.mock.inspectFuncIs = f

	return mmIs
}

// Return sets up results that will be returned by EmbeddedLogger.Is
func (mmIs *mEmbeddedLoggerMockIs) Return(b1 bool) *EmbeddedLoggerMock {
	if mmIs.mock.funcIs != nil {
		mmIs.mock.t.Fatalf("EmbeddedLoggerMock.Is mock is already set by Set")
	}

	if mmIs.defaultExpectation == nil {
		mmIs.defaultExpectation = &EmbeddedLoggerMockIsExpectation{mock: mmIs.mock}
	}
	mmIs.defaultExpectation.results = &EmbeddedLoggerMockIsResults{b1}
	return mmIs.mock
}

//Set uses given function f to mock the EmbeddedLogger.Is method
func (mmIs *mEmbeddedLoggerMockIs) Set(f func(l1 Level) (b1 bool)) *EmbeddedLoggerMock {
	if mmIs.defaultExpectation != nil {
		mmIs.mock.t.Fatalf("Default expectation is already set for the EmbeddedLogger.Is method")
	}

	if len(mmIs.expectations) > 0 {
		mmIs.mock.t.Fatalf("Some expectations are already set for the EmbeddedLogger.Is method")
	}

	mmIs.mock.funcIs = f
	return mmIs.mock
}

// When sets expectation for the EmbeddedLogger.Is which will trigger the result defined by the following
// Then helper
func (mmIs *mEmbeddedLoggerMockIs) When(l1 Level) *EmbeddedLoggerMockIsExpectation {
	if mmIs.mock.funcIs != nil {
		mmIs.mock.t.Fatalf("EmbeddedLoggerMock.Is mock is already set by Set")
	}

	expectation := &EmbeddedLoggerMockIsExpectation{
		mock:   mmIs.mock,
		params: &EmbeddedLoggerMockIsParams{l1},
	}
	mmIs.expectations = append(mmIs.expectations, expectation)
	return expectation
}

// Then sets up EmbeddedLogger.Is return parameters for the expectation previously defined by the When method
func (e *EmbeddedLoggerMockIsExpectation) Then(b1 bool) *EmbeddedLoggerMock {
	e.results = &EmbeddedLoggerMockIsResults{b1}
	return e.mock
}

// Is implements EmbeddedLogger
func (mmIs *EmbeddedLoggerMock) Is(l1 Level) (b1 bool) {
	mm_atomic.AddUint64(&mmIs.beforeIsCounter, 1)
	defer mm_atomic.AddUint64(&mmIs.afterIsCounter, 1)

	if mmIs.inspectFuncIs != nil {
		mmIs.inspectFuncIs(l1)
	}

	mm_params := &EmbeddedLoggerMockIsParams{l1}

	// Record call args
	mmIs.IsMock.mutex.Lock()
	mmIs.IsMock.callArgs = append(mmIs.IsMock.callArgs, mm_params)
	mmIs.IsMock.mutex.Unlock()

	for _, e := range mmIs.IsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIs.IsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIs.IsMock.defaultExpectation.Counter, 1)
		mm_want := mmIs.IsMock.defaultExpectation.params
		mm_got := EmbeddedLoggerMockIsParams{l1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIs.t.Errorf("EmbeddedLoggerMock.Is got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIs.IsMock.defaultExpectation.results
		if mm_results == nil {
			mmIs.t.Fatal("No results are set for the EmbeddedLoggerMock.Is")
		}
		return (*mm_results).b1
	}
	if mmIs.funcIs != nil {
		return mmIs.funcIs(l1)
	}
	mmIs.t.Fatalf("Unexpected call to EmbeddedLoggerMock.Is. %v", l1)
	return
}

// IsAfterCounter returns a count of finished EmbeddedLoggerMock.Is invocations
func (mmIs *EmbeddedLoggerMock) IsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIs.afterIsCounter)
}

// IsBeforeCounter returns a count of EmbeddedLoggerMock.Is invocations
func (mmIs *EmbeddedLoggerMock) IsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIs.beforeIsCounter)
}

// Calls returns a list of arguments used in each call to EmbeddedLoggerMock.Is.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIs *mEmbeddedLoggerMockIs) Calls() []*EmbeddedLoggerMockIsParams {
	mmIs.mutex.RLock()

	argCopy := make([]*EmbeddedLoggerMockIsParams, len(mmIs.callArgs))
	copy(argCopy, mmIs.callArgs)

	mmIs.mutex.RUnlock()

	return argCopy
}

// MinimockIsDone returns true if the count of the Is invocations corresponds
// the number of defined expectations
func (m *EmbeddedLoggerMock) MinimockIsDone() bool {
	for _, e := range m.IsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIs != nil && mm_atomic.LoadUint64(&m.afterIsCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsInspect logs each unmet expectation
func (m *EmbeddedLoggerMock) MinimockIsInspect() {
	for _, e := range m.IsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmbeddedLoggerMock.Is with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsCounter) < 1 {
		if m.IsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmbeddedLoggerMock.Is")
		} else {
			m.t.Errorf("Expected call to EmbeddedLoggerMock.Is with params: %#v", *m.IsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIs != nil && mm_atomic.LoadUint64(&m.afterIsCounter) < 1 {
		m.t.Error("Expected call to EmbeddedLoggerMock.Is")
	}
}

type mEmbeddedLoggerMockNewEvent struct {
	mock               *EmbeddedLoggerMock
	defaultExpectation *EmbeddedLoggerMockNewEventExpectation
	expectations       []*EmbeddedLoggerMockNewEventExpectation

	callArgs []*EmbeddedLoggerMockNewEventParams
	mutex    sync.RWMutex
}

// EmbeddedLoggerMockNewEventExpectation specifies expectation struct of the EmbeddedLogger.NewEvent
type EmbeddedLoggerMockNewEventExpectation struct {
	mock    *EmbeddedLoggerMock
	params  *EmbeddedLoggerMockNewEventParams
	results *EmbeddedLoggerMockNewEventResults
	Counter uint64
}

// EmbeddedLoggerMockNewEventParams contains parameters of the EmbeddedLogger.NewEvent
type EmbeddedLoggerMockNewEventParams struct {
	level Level
}

// EmbeddedLoggerMockNewEventResults contains results of the EmbeddedLogger.NewEvent
type EmbeddedLoggerMockNewEventResults struct {
	f1 func(args []interface{})
}

// Expect sets up expected params for EmbeddedLogger.NewEvent
func (mmNewEvent *mEmbeddedLoggerMockNewEvent) Expect(level Level) *mEmbeddedLoggerMockNewEvent {
	if mmNewEvent.mock.funcNewEvent != nil {
		mmNewEvent.mock.t.Fatalf("EmbeddedLoggerMock.NewEvent mock is already set by Set")
	}

	if mmNewEvent.defaultExpectation == nil {
		mmNewEvent.defaultExpectation = &EmbeddedLoggerMockNewEventExpectation{}
	}

	mmNewEvent.defaultExpectation.params = &EmbeddedLoggerMockNewEventParams{level}
	for _, e := range mmNewEvent.expectations {
		if minimock.Equal(e.params, mmNewEvent.defaultExpectation.params) {
			mmNewEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNewEvent.defaultExpectation.params)
		}
	}

	return mmNewEvent
}

// Inspect accepts an inspector function that has same arguments as the EmbeddedLogger.NewEvent
func (mmNewEvent *mEmbeddedLoggerMockNewEvent) Inspect(f func(level Level)) *mEmbeddedLoggerMockNewEvent {
	if mmNewEvent.mock.inspectFuncNewEvent != nil {
		mmNewEvent.mock.t.Fatalf("Inspect function is already set for EmbeddedLoggerMock.NewEvent")
	}

	mmNewEvent.mock.inspectFuncNewEvent = f

	return mmNewEvent
}

// Return sets up results that will be returned by EmbeddedLogger.NewEvent
func (mmNewEvent *mEmbeddedLoggerMockNewEvent) Return(f1 func(args []interface{})) *EmbeddedLoggerMock {
	if mmNewEvent.mock.funcNewEvent != nil {
		mmNewEvent.mock.t.Fatalf("EmbeddedLoggerMock.NewEvent mock is already set by Set")
	}

	if mmNewEvent.defaultExpectation == nil {
		mmNewEvent.defaultExpectation = &EmbeddedLoggerMockNewEventExpectation{mock: mmNewEvent.mock}
	}
	mmNewEvent.defaultExpectation.results = &EmbeddedLoggerMockNewEventResults{f1}
	return mmNewEvent.mock
}

//Set uses given function f to mock the EmbeddedLogger.NewEvent method
func (mmNewEvent *mEmbeddedLoggerMockNewEvent) Set(f func(level Level) (f1 func(args []interface{}))) *EmbeddedLoggerMock {
	if mmNewEvent.defaultExpectation != nil {
		mmNewEvent.mock.t.Fatalf("Default expectation is already set for the EmbeddedLogger.NewEvent method")
	}

	if len(mmNewEvent.expectations) > 0 {
		mmNewEvent.mock.t.Fatalf("Some expectations are already set for the EmbeddedLogger.NewEvent method")
	}

	mmNewEvent.mock.funcNewEvent = f
	return mmNewEvent.mock
}

// When sets expectation for the EmbeddedLogger.NewEvent which will trigger the result defined by the following
// Then helper
func (mmNewEvent *mEmbeddedLoggerMockNewEvent) When(level Level) *EmbeddedLoggerMockNewEventExpectation {
	if mmNewEvent.mock.funcNewEvent != nil {
		mmNewEvent.mock.t.Fatalf("EmbeddedLoggerMock.NewEvent mock is already set by Set")
	}

	expectation := &EmbeddedLoggerMockNewEventExpectation{
		mock:   mmNewEvent.mock,
		params: &EmbeddedLoggerMockNewEventParams{level},
	}
	mmNewEvent.expectations = append(mmNewEvent.expectations, expectation)
	return expectation
}

// Then sets up EmbeddedLogger.NewEvent return parameters for the expectation previously defined by the When method
func (e *EmbeddedLoggerMockNewEventExpectation) Then(f1 func(args []interface{})) *EmbeddedLoggerMock {
	e.results = &EmbeddedLoggerMockNewEventResults{f1}
	return e.mock
}

// NewEvent implements EmbeddedLogger
func (mmNewEvent *EmbeddedLoggerMock) NewEvent(level Level) (f1 func(args []interface{})) {
	mm_atomic.AddUint64(&mmNewEvent.beforeNewEventCounter, 1)
	defer mm_atomic.AddUint64(&mmNewEvent.afterNewEventCounter, 1)

	if mmNewEvent.inspectFuncNewEvent != nil {
		mmNewEvent.inspectFuncNewEvent(level)
	}

	mm_params := &EmbeddedLoggerMockNewEventParams{level}

	// Record call args
	mmNewEvent.NewEventMock.mutex.Lock()
	mmNewEvent.NewEventMock.callArgs = append(mmNewEvent.NewEventMock.callArgs, mm_params)
	mmNewEvent.NewEventMock.mutex.Unlock()

	for _, e := range mmNewEvent.NewEventMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1
		}
	}

	if mmNewEvent.NewEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewEvent.NewEventMock.defaultExpectation.Counter, 1)
		mm_want := mmNewEvent.NewEventMock.defaultExpectation.params
		mm_got := EmbeddedLoggerMockNewEventParams{level}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNewEvent.t.Errorf("EmbeddedLoggerMock.NewEvent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNewEvent.NewEventMock.defaultExpectation.results
		if mm_results == nil {
			mmNewEvent.t.Fatal("No results are set for the EmbeddedLoggerMock.NewEvent")
		}
		return (*mm_results).f1
	}
	if mmNewEvent.funcNewEvent != nil {
		return mmNewEvent.funcNewEvent(level)
	}
	mmNewEvent.t.Fatalf("Unexpected call to EmbeddedLoggerMock.NewEvent. %v", level)
	return
}

// NewEventAfterCounter returns a count of finished EmbeddedLoggerMock.NewEvent invocations
func (mmNewEvent *EmbeddedLoggerMock) NewEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewEvent.afterNewEventCounter)
}

// NewEventBeforeCounter returns a count of EmbeddedLoggerMock.NewEvent invocations
func (mmNewEvent *EmbeddedLoggerMock) NewEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewEvent.beforeNewEventCounter)
}

// Calls returns a list of arguments used in each call to EmbeddedLoggerMock.NewEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNewEvent *mEmbeddedLoggerMockNewEvent) Calls() []*EmbeddedLoggerMockNewEventParams {
	mmNewEvent.mutex.RLock()

	argCopy := make([]*EmbeddedLoggerMockNewEventParams, len(mmNewEvent.callArgs))
	copy(argCopy, mmNewEvent.callArgs)

	mmNewEvent.mutex.RUnlock()

	return argCopy
}

// MinimockNewEventDone returns true if the count of the NewEvent invocations corresponds
// the number of defined expectations
func (m *EmbeddedLoggerMock) MinimockNewEventDone() bool {
	for _, e := range m.NewEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewEventCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewEvent != nil && mm_atomic.LoadUint64(&m.afterNewEventCounter) < 1 {
		return false
	}
	return true
}

// MinimockNewEventInspect logs each unmet expectation
func (m *EmbeddedLoggerMock) MinimockNewEventInspect() {
	for _, e := range m.NewEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmbeddedLoggerMock.NewEvent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewEventCounter) < 1 {
		if m.NewEventMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmbeddedLoggerMock.NewEvent")
		} else {
			m.t.Errorf("Expected call to EmbeddedLoggerMock.NewEvent with params: %#v", *m.NewEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewEvent != nil && mm_atomic.LoadUint64(&m.afterNewEventCounter) < 1 {
		m.t.Error("Expected call to EmbeddedLoggerMock.NewEvent")
	}
}

type mEmbeddedLoggerMockNewEventFmt struct {
	mock               *EmbeddedLoggerMock
	defaultExpectation *EmbeddedLoggerMockNewEventFmtExpectation
	expectations       []*EmbeddedLoggerMockNewEventFmtExpectation

	callArgs []*EmbeddedLoggerMockNewEventFmtParams
	mutex    sync.RWMutex
}

// EmbeddedLoggerMockNewEventFmtExpectation specifies expectation struct of the EmbeddedLogger.NewEventFmt
type EmbeddedLoggerMockNewEventFmtExpectation struct {
	mock    *EmbeddedLoggerMock
	params  *EmbeddedLoggerMockNewEventFmtParams
	results *EmbeddedLoggerMockNewEventFmtResults
	Counter uint64
}

// EmbeddedLoggerMockNewEventFmtParams contains parameters of the EmbeddedLogger.NewEventFmt
type EmbeddedLoggerMockNewEventFmtParams struct {
	level Level
}

// EmbeddedLoggerMockNewEventFmtResults contains results of the EmbeddedLogger.NewEventFmt
type EmbeddedLoggerMockNewEventFmtResults struct {
	f1 func(fmt string, args []interface{})
}

// Expect sets up expected params for EmbeddedLogger.NewEventFmt
func (mmNewEventFmt *mEmbeddedLoggerMockNewEventFmt) Expect(level Level) *mEmbeddedLoggerMockNewEventFmt {
	if mmNewEventFmt.mock.funcNewEventFmt != nil {
		mmNewEventFmt.mock.t.Fatalf("EmbeddedLoggerMock.NewEventFmt mock is already set by Set")
	}

	if mmNewEventFmt.defaultExpectation == nil {
		mmNewEventFmt.defaultExpectation = &EmbeddedLoggerMockNewEventFmtExpectation{}
	}

	mmNewEventFmt.defaultExpectation.params = &EmbeddedLoggerMockNewEventFmtParams{level}
	for _, e := range mmNewEventFmt.expectations {
		if minimock.Equal(e.params, mmNewEventFmt.defaultExpectation.params) {
			mmNewEventFmt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNewEventFmt.defaultExpectation.params)
		}
	}

	return mmNewEventFmt
}

// Inspect accepts an inspector function that has same arguments as the EmbeddedLogger.NewEventFmt
func (mmNewEventFmt *mEmbeddedLoggerMockNewEventFmt) Inspect(f func(level Level)) *mEmbeddedLoggerMockNewEventFmt {
	if mmNewEventFmt.mock.inspectFuncNewEventFmt != nil {
		mmNewEventFmt.mock.t.Fatalf("Inspect function is already set for EmbeddedLoggerMock.NewEventFmt")
	}

	mmNewEventFmt.mock.inspectFuncNewEventFmt = f

	return mmNewEventFmt
}

// Return sets up results that will be returned by EmbeddedLogger.NewEventFmt
func (mmNewEventFmt *mEmbeddedLoggerMockNewEventFmt) Return(f1 func(fmt string, args []interface{})) *EmbeddedLoggerMock {
	if mmNewEventFmt.mock.funcNewEventFmt != nil {
		mmNewEventFmt.mock.t.Fatalf("EmbeddedLoggerMock.NewEventFmt mock is already set by Set")
	}

	if mmNewEventFmt.defaultExpectation == nil {
		mmNewEventFmt.defaultExpectation = &EmbeddedLoggerMockNewEventFmtExpectation{mock: mmNewEventFmt.mock}
	}
	mmNewEventFmt.defaultExpectation.results = &EmbeddedLoggerMockNewEventFmtResults{f1}
	return mmNewEventFmt.mock
}

//Set uses given function f to mock the EmbeddedLogger.NewEventFmt method
func (mmNewEventFmt *mEmbeddedLoggerMockNewEventFmt) Set(f func(level Level) (f1 func(fmt string, args []interface{}))) *EmbeddedLoggerMock {
	if mmNewEventFmt.defaultExpectation != nil {
		mmNewEventFmt.mock.t.Fatalf("Default expectation is already set for the EmbeddedLogger.NewEventFmt method")
	}

	if len(mmNewEventFmt.expectations) > 0 {
		mmNewEventFmt.mock.t.Fatalf("Some expectations are already set for the EmbeddedLogger.NewEventFmt method")
	}

	mmNewEventFmt.mock.funcNewEventFmt = f
	return mmNewEventFmt.mock
}

// When sets expectation for the EmbeddedLogger.NewEventFmt which will trigger the result defined by the following
// Then helper
func (mmNewEventFmt *mEmbeddedLoggerMockNewEventFmt) When(level Level) *EmbeddedLoggerMockNewEventFmtExpectation {
	if mmNewEventFmt.mock.funcNewEventFmt != nil {
		mmNewEventFmt.mock.t.Fatalf("EmbeddedLoggerMock.NewEventFmt mock is already set by Set")
	}

	expectation := &EmbeddedLoggerMockNewEventFmtExpectation{
		mock:   mmNewEventFmt.mock,
		params: &EmbeddedLoggerMockNewEventFmtParams{level},
	}
	mmNewEventFmt.expectations = append(mmNewEventFmt.expectations, expectation)
	return expectation
}

// Then sets up EmbeddedLogger.NewEventFmt return parameters for the expectation previously defined by the When method
func (e *EmbeddedLoggerMockNewEventFmtExpectation) Then(f1 func(fmt string, args []interface{})) *EmbeddedLoggerMock {
	e.results = &EmbeddedLoggerMockNewEventFmtResults{f1}
	return e.mock
}

// NewEventFmt implements EmbeddedLogger
func (mmNewEventFmt *EmbeddedLoggerMock) NewEventFmt(level Level) (f1 func(fmt string, args []interface{})) {
	mm_atomic.AddUint64(&mmNewEventFmt.beforeNewEventFmtCounter, 1)
	defer mm_atomic.AddUint64(&mmNewEventFmt.afterNewEventFmtCounter, 1)

	if mmNewEventFmt.inspectFuncNewEventFmt != nil {
		mmNewEventFmt.inspectFuncNewEventFmt(level)
	}

	mm_params := &EmbeddedLoggerMockNewEventFmtParams{level}

	// Record call args
	mmNewEventFmt.NewEventFmtMock.mutex.Lock()
	mmNewEventFmt.NewEventFmtMock.callArgs = append(mmNewEventFmt.NewEventFmtMock.callArgs, mm_params)
	mmNewEventFmt.NewEventFmtMock.mutex.Unlock()

	for _, e := range mmNewEventFmt.NewEventFmtMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1
		}
	}

	if mmNewEventFmt.NewEventFmtMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewEventFmt.NewEventFmtMock.defaultExpectation.Counter, 1)
		mm_want := mmNewEventFmt.NewEventFmtMock.defaultExpectation.params
		mm_got := EmbeddedLoggerMockNewEventFmtParams{level}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNewEventFmt.t.Errorf("EmbeddedLoggerMock.NewEventFmt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNewEventFmt.NewEventFmtMock.defaultExpectation.results
		if mm_results == nil {
			mmNewEventFmt.t.Fatal("No results are set for the EmbeddedLoggerMock.NewEventFmt")
		}
		return (*mm_results).f1
	}
	if mmNewEventFmt.funcNewEventFmt != nil {
		return mmNewEventFmt.funcNewEventFmt(level)
	}
	mmNewEventFmt.t.Fatalf("Unexpected call to EmbeddedLoggerMock.NewEventFmt. %v", level)
	return
}

// NewEventFmtAfterCounter returns a count of finished EmbeddedLoggerMock.NewEventFmt invocations
func (mmNewEventFmt *EmbeddedLoggerMock) NewEventFmtAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewEventFmt.afterNewEventFmtCounter)
}

// NewEventFmtBeforeCounter returns a count of EmbeddedLoggerMock.NewEventFmt invocations
func (mmNewEventFmt *EmbeddedLoggerMock) NewEventFmtBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewEventFmt.beforeNewEventFmtCounter)
}

// Calls returns a list of arguments used in each call to EmbeddedLoggerMock.NewEventFmt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNewEventFmt *mEmbeddedLoggerMockNewEventFmt) Calls() []*EmbeddedLoggerMockNewEventFmtParams {
	mmNewEventFmt.mutex.RLock()

	argCopy := make([]*EmbeddedLoggerMockNewEventFmtParams, len(mmNewEventFmt.callArgs))
	copy(argCopy, mmNewEventFmt.callArgs)

	mmNewEventFmt.mutex.RUnlock()

	return argCopy
}

// MinimockNewEventFmtDone returns true if the count of the NewEventFmt invocations corresponds
// the number of defined expectations
func (m *EmbeddedLoggerMock) MinimockNewEventFmtDone() bool {
	for _, e := range m.NewEventFmtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewEventFmtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewEventFmtCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewEventFmt != nil && mm_atomic.LoadUint64(&m.afterNewEventFmtCounter) < 1 {
		return false
	}
	return true
}

// MinimockNewEventFmtInspect logs each unmet expectation
func (m *EmbeddedLoggerMock) MinimockNewEventFmtInspect() {
	for _, e := range m.NewEventFmtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmbeddedLoggerMock.NewEventFmt with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewEventFmtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewEventFmtCounter) < 1 {
		if m.NewEventFmtMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmbeddedLoggerMock.NewEventFmt")
		} else {
			m.t.Errorf("Expected call to EmbeddedLoggerMock.NewEventFmt with params: %#v", *m.NewEventFmtMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewEventFmt != nil && mm_atomic.LoadUint64(&m.afterNewEventFmtCounter) < 1 {
		m.t.Error("Expected call to EmbeddedLoggerMock.NewEventFmt")
	}
}

type mEmbeddedLoggerMockNewEventStruct struct {
	mock               *EmbeddedLoggerMock
	defaultExpectation *EmbeddedLoggerMockNewEventStructExpectation
	expectations       []*EmbeddedLoggerMockNewEventStructExpectation

	callArgs []*EmbeddedLoggerMockNewEventStructParams
	mutex    sync.RWMutex
}

// EmbeddedLoggerMockNewEventStructExpectation specifies expectation struct of the EmbeddedLogger.NewEventStruct
type EmbeddedLoggerMockNewEventStructExpectation struct {
	mock    *EmbeddedLoggerMock
	params  *EmbeddedLoggerMockNewEventStructParams
	results *EmbeddedLoggerMockNewEventStructResults
	Counter uint64
}

// EmbeddedLoggerMockNewEventStructParams contains parameters of the EmbeddedLogger.NewEventStruct
type EmbeddedLoggerMockNewEventStructParams struct {
	level Level
}

// EmbeddedLoggerMockNewEventStructResults contains results of the EmbeddedLogger.NewEventStruct
type EmbeddedLoggerMockNewEventStructResults struct {
	f1 func(interface{}, []logfmt.LogFieldMarshaller)
}

// Expect sets up expected params for EmbeddedLogger.NewEventStruct
func (mmNewEventStruct *mEmbeddedLoggerMockNewEventStruct) Expect(level Level) *mEmbeddedLoggerMockNewEventStruct {
	if mmNewEventStruct.mock.funcNewEventStruct != nil {
		mmNewEventStruct.mock.t.Fatalf("EmbeddedLoggerMock.NewEventStruct mock is already set by Set")
	}

	if mmNewEventStruct.defaultExpectation == nil {
		mmNewEventStruct.defaultExpectation = &EmbeddedLoggerMockNewEventStructExpectation{}
	}

	mmNewEventStruct.defaultExpectation.params = &EmbeddedLoggerMockNewEventStructParams{level}
	for _, e := range mmNewEventStruct.expectations {
		if minimock.Equal(e.params, mmNewEventStruct.defaultExpectation.params) {
			mmNewEventStruct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNewEventStruct.defaultExpectation.params)
		}
	}

	return mmNewEventStruct
}

// Inspect accepts an inspector function that has same arguments as the EmbeddedLogger.NewEventStruct
func (mmNewEventStruct *mEmbeddedLoggerMockNewEventStruct) Inspect(f func(level Level)) *mEmbeddedLoggerMockNewEventStruct {
	if mmNewEventStruct.mock.inspectFuncNewEventStruct != nil {
		mmNewEventStruct.mock.t.Fatalf("Inspect function is already set for EmbeddedLoggerMock.NewEventStruct")
	}

	mmNewEventStruct.mock.inspectFuncNewEventStruct = f

	return mmNewEventStruct
}

// Return sets up results that will be returned by EmbeddedLogger.NewEventStruct
func (mmNewEventStruct *mEmbeddedLoggerMockNewEventStruct) Return(f1 func(interface{}, []logfmt.LogFieldMarshaller)) *EmbeddedLoggerMock {
	if mmNewEventStruct.mock.funcNewEventStruct != nil {
		mmNewEventStruct.mock.t.Fatalf("EmbeddedLoggerMock.NewEventStruct mock is already set by Set")
	}

	if mmNewEventStruct.defaultExpectation == nil {
		mmNewEventStruct.defaultExpectation = &EmbeddedLoggerMockNewEventStructExpectation{mock: mmNewEventStruct.mock}
	}
	mmNewEventStruct.defaultExpectation.results = &EmbeddedLoggerMockNewEventStructResults{f1}
	return mmNewEventStruct.mock
}

//Set uses given function f to mock the EmbeddedLogger.NewEventStruct method
func (mmNewEventStruct *mEmbeddedLoggerMockNewEventStruct) Set(f func(level Level) (f1 func(interface{}, []logfmt.LogFieldMarshaller))) *EmbeddedLoggerMock {
	if mmNewEventStruct.defaultExpectation != nil {
		mmNewEventStruct.mock.t.Fatalf("Default expectation is already set for the EmbeddedLogger.NewEventStruct method")
	}

	if len(mmNewEventStruct.expectations) > 0 {
		mmNewEventStruct.mock.t.Fatalf("Some expectations are already set for the EmbeddedLogger.NewEventStruct method")
	}

	mmNewEventStruct.mock.funcNewEventStruct = f
	return mmNewEventStruct.mock
}

// When sets expectation for the EmbeddedLogger.NewEventStruct which will trigger the result defined by the following
// Then helper
func (mmNewEventStruct *mEmbeddedLoggerMockNewEventStruct) When(level Level) *EmbeddedLoggerMockNewEventStructExpectation {
	if mmNewEventStruct.mock.funcNewEventStruct != nil {
		mmNewEventStruct.mock.t.Fatalf("EmbeddedLoggerMock.NewEventStruct mock is already set by Set")
	}

	expectation := &EmbeddedLoggerMockNewEventStructExpectation{
		mock:   mmNewEventStruct.mock,
		params: &EmbeddedLoggerMockNewEventStructParams{level},
	}
	mmNewEventStruct.expectations = append(mmNewEventStruct.expectations, expectation)
	return expectation
}

// Then sets up EmbeddedLogger.NewEventStruct return parameters for the expectation previously defined by the When method
func (e *EmbeddedLoggerMockNewEventStructExpectation) Then(f1 func(interface{}, []logfmt.LogFieldMarshaller)) *EmbeddedLoggerMock {
	e.results = &EmbeddedLoggerMockNewEventStructResults{f1}
	return e.mock
}

// NewEventStruct implements EmbeddedLogger
func (mmNewEventStruct *EmbeddedLoggerMock) NewEventStruct(level Level) (f1 func(interface{}, []logfmt.LogFieldMarshaller)) {
	mm_atomic.AddUint64(&mmNewEventStruct.beforeNewEventStructCounter, 1)
	defer mm_atomic.AddUint64(&mmNewEventStruct.afterNewEventStructCounter, 1)

	if mmNewEventStruct.inspectFuncNewEventStruct != nil {
		mmNewEventStruct.inspectFuncNewEventStruct(level)
	}

	mm_params := &EmbeddedLoggerMockNewEventStructParams{level}

	// Record call args
	mmNewEventStruct.NewEventStructMock.mutex.Lock()
	mmNewEventStruct.NewEventStructMock.callArgs = append(mmNewEventStruct.NewEventStructMock.callArgs, mm_params)
	mmNewEventStruct.NewEventStructMock.mutex.Unlock()

	for _, e := range mmNewEventStruct.NewEventStructMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1
		}
	}

	if mmNewEventStruct.NewEventStructMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewEventStruct.NewEventStructMock.defaultExpectation.Counter, 1)
		mm_want := mmNewEventStruct.NewEventStructMock.defaultExpectation.params
		mm_got := EmbeddedLoggerMockNewEventStructParams{level}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNewEventStruct.t.Errorf("EmbeddedLoggerMock.NewEventStruct got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNewEventStruct.NewEventStructMock.defaultExpectation.results
		if mm_results == nil {
			mmNewEventStruct.t.Fatal("No results are set for the EmbeddedLoggerMock.NewEventStruct")
		}
		return (*mm_results).f1
	}
	if mmNewEventStruct.funcNewEventStruct != nil {
		return mmNewEventStruct.funcNewEventStruct(level)
	}
	mmNewEventStruct.t.Fatalf("Unexpected call to EmbeddedLoggerMock.NewEventStruct. %v", level)
	return
}

// NewEventStructAfterCounter returns a count of finished EmbeddedLoggerMock.NewEventStruct invocations
func (mmNewEventStruct *EmbeddedLoggerMock) NewEventStructAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewEventStruct.afterNewEventStructCounter)
}

// NewEventStructBeforeCounter returns a count of EmbeddedLoggerMock.NewEventStruct invocations
func (mmNewEventStruct *EmbeddedLoggerMock) NewEventStructBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewEventStruct.beforeNewEventStructCounter)
}

// Calls returns a list of arguments used in each call to EmbeddedLoggerMock.NewEventStruct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNewEventStruct *mEmbeddedLoggerMockNewEventStruct) Calls() []*EmbeddedLoggerMockNewEventStructParams {
	mmNewEventStruct.mutex.RLock()

	argCopy := make([]*EmbeddedLoggerMockNewEventStructParams, len(mmNewEventStruct.callArgs))
	copy(argCopy, mmNewEventStruct.callArgs)

	mmNewEventStruct.mutex.RUnlock()

	return argCopy
}

// MinimockNewEventStructDone returns true if the count of the NewEventStruct invocations corresponds
// the number of defined expectations
func (m *EmbeddedLoggerMock) MinimockNewEventStructDone() bool {
	for _, e := range m.NewEventStructMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewEventStructMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewEventStructCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewEventStruct != nil && mm_atomic.LoadUint64(&m.afterNewEventStructCounter) < 1 {
		return false
	}
	return true
}

// MinimockNewEventStructInspect logs each unmet expectation
func (m *EmbeddedLoggerMock) MinimockNewEventStructInspect() {
	for _, e := range m.NewEventStructMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EmbeddedLoggerMock.NewEventStruct with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewEventStructMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewEventStructCounter) < 1 {
		if m.NewEventStructMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EmbeddedLoggerMock.NewEventStruct")
		} else {
			m.t.Errorf("Expected call to EmbeddedLoggerMock.NewEventStruct with params: %#v", *m.NewEventStructMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewEventStruct != nil && mm_atomic.LoadUint64(&m.afterNewEventStructCounter) < 1 {
		m.t.Error("Expected call to EmbeddedLoggerMock.NewEventStruct")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *EmbeddedLoggerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCopyInspect()

		m.MinimockEmbeddedFlushInspect()

		m.MinimockFieldsOfInspect()

		m.MinimockIsInspect()

		m.MinimockNewEventInspect()

		m.MinimockNewEventFmtInspect()

		m.MinimockNewEventStructInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *EmbeddedLoggerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *EmbeddedLoggerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCopyDone() &&
		m.MinimockEmbeddedFlushDone() &&
		m.MinimockFieldsOfDone() &&
		m.MinimockIsDone() &&
		m.MinimockNewEventDone() &&
		m.MinimockNewEventFmtDone() &&
		m.MinimockNewEventStructDone()
}
