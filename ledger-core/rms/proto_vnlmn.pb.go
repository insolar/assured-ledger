// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto_vnlmn.proto

package rms

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/insolar/assured-ledger/ledger-core/insproto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type RegistrationFlags int32

const (
	RegistrationFlags_Undefined RegistrationFlags = 0
	RegistrationFlags_Fast      RegistrationFlags = 1
	RegistrationFlags_Safe      RegistrationFlags = 2
	RegistrationFlags_FastSafe  RegistrationFlags = 3
)

var RegistrationFlags_name = map[int32]string{
	0: "Undefined",
	1: "Fast",
	2: "Safe",
	3: "FastSafe",
}

var RegistrationFlags_value = map[string]int32{
	"Undefined": 0,
	"Fast":      1,
	"Safe":      2,
	"FastSafe":  3,
}

func (x RegistrationFlags) String() string {
	return proto.EnumName(RegistrationFlags_name, int32(x))
}

func (RegistrationFlags) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b0afd09ea099d9b9, []int{0}
}

type ReadFlags int32

const (
	ReadFlags_PastToPresent     ReadFlags = 0
	ReadFlags_PresentToPast     ReadFlags = 1
	ReadFlags_StartIsReason     ReadFlags = 2
	ReadFlags_ExcludeStart      ReadFlags = 4
	ReadFlags_ExcludeStop       ReadFlags = 8
	ReadFlags_IncludePrevReport ReadFlags = 16
	ReadFlags_IncludeNextReport ReadFlags = 32
)

var ReadFlags_name = map[int32]string{
	0:  "PastToPresent",
	1:  "PresentToPast",
	2:  "StartIsReason",
	4:  "ExcludeStart",
	8:  "ExcludeStop",
	16: "IncludePrevReport",
	32: "IncludeNextReport",
}

var ReadFlags_value = map[string]int32{
	"PastToPresent":     0,
	"PresentToPast":     1,
	"StartIsReason":     2,
	"ExcludeStart":      4,
	"ExcludeStop":       8,
	"IncludePrevReport": 16,
	"IncludeNextReport": 32,
}

func (x ReadFlags) String() string {
	return proto.EnumName(ReadFlags_name, int32(x))
}

func (ReadFlags) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b0afd09ea099d9b9, []int{1}
}

type LRegisterRequest struct {
	Polymorph     uint32 `protobuf:"varint,16,opt,name=Polymorph,proto3" json:"Polymorph"`
	AnyRecordLazy `protobuf:"bytes,19,opt,name=Record,proto3,embedded=Record" json:"Record"`
	// RegistrationFlags must be zero for LVerifyRequest
	// RegistrationFlags is ignored for a non-first entry of a registration set
	Flags              RegistrationFlags `protobuf:"varint,1800,opt,name=Flags,proto3,enum=rms.RegistrationFlags" json:"Flags"`
	AnticipatedRef     Reference         `protobuf:"bytes,1801,opt,name=AnticipatedRef,proto3" json:"AnticipatedRef"`
	OverrideRecordType uint32            `protobuf:"varint,1816,opt,name=OverrideRecordType,proto3" json:"OverrideRecordType"`
	OverridePrevRef    Reference         `protobuf:"bytes,1824,opt,name=OverridePrevRef,proto3" json:"OverridePrevRef"`
	OverrideRootRef    Reference         `protobuf:"bytes,1825,opt,name=OverrideRootRef,proto3" json:"OverrideRootRef"`
	OverrideReasonRef  Reference         `protobuf:"bytes,1826,opt,name=OverrideReasonRef,proto3" json:"OverrideReasonRef"`
	ProducerSignature  Binary            `protobuf:"bytes,1839,opt,name=ProducerSignature,proto3" json:"ProducerSignature"`
	// ProducedBy can be omitted for a non-first entry of a registration set
	ProducedBy Reference `protobuf:"bytes,1840,opt,name=ProducedBy,proto3" json:"ProducedBy"`
}

func (m *LRegisterRequest) Reset()         { *m = LRegisterRequest{} }
func (m *LRegisterRequest) String() string { return proto.CompactTextString(m) }
func (*LRegisterRequest) ProtoMessage()    {}
func (*LRegisterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0afd09ea099d9b9, []int{0}
}
func (m *LRegisterRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LRegisterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LRegisterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LRegisterRequest.Merge(m, src)
}
func (m *LRegisterRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LRegisterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LRegisterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LRegisterRequest proto.InternalMessageInfo

func (m *LRegisterRequest) GetPolymorph() uint32 {
	if m != nil {
		return m.Polymorph
	}
	return 0
}

func (m *LRegisterRequest) GetFlags() RegistrationFlags {
	if m != nil {
		return m.Flags
	}
	return RegistrationFlags_Undefined
}

func (m *LRegisterRequest) GetAnticipatedRef() Reference {
	if m != nil {
		return m.AnticipatedRef
	}
	return Reference{}
}

func (m *LRegisterRequest) GetOverrideRecordType() uint32 {
	if m != nil {
		return m.OverrideRecordType
	}
	return 0
}

func (m *LRegisterRequest) GetOverridePrevRef() Reference {
	if m != nil {
		return m.OverridePrevRef
	}
	return Reference{}
}

func (m *LRegisterRequest) GetOverrideRootRef() Reference {
	if m != nil {
		return m.OverrideRootRef
	}
	return Reference{}
}

func (m *LRegisterRequest) GetOverrideReasonRef() Reference {
	if m != nil {
		return m.OverrideReasonRef
	}
	return Reference{}
}

func (m *LRegisterRequest) GetProducerSignature() Binary {
	if m != nil {
		return m.ProducerSignature
	}
	return Binary{}
}

func (m *LRegisterRequest) GetProducedBy() Reference {
	if m != nil {
		return m.ProducedBy
	}
	return Reference{}
}

type LRegisterResponse struct {
	Flags              RegistrationFlags `protobuf:"varint,1800,opt,name=Flags,proto3,enum=rms.RegistrationFlags" json:"Flags"`
	AnticipatedRef     Reference         `protobuf:"bytes,1801,opt,name=AnticipatedRef,proto3" json:"AnticipatedRef"`
	RegistrarSignature Binary            `protobuf:"bytes,1805,opt,name=RegistrarSignature,proto3" json:"RegistrarSignature"`
}

func (m *LRegisterResponse) Reset()         { *m = LRegisterResponse{} }
func (m *LRegisterResponse) String() string { return proto.CompactTextString(m) }
func (*LRegisterResponse) ProtoMessage()    {}
func (*LRegisterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0afd09ea099d9b9, []int{1}
}
func (m *LRegisterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LRegisterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LRegisterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LRegisterResponse.Merge(m, src)
}
func (m *LRegisterResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LRegisterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LRegisterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LRegisterResponse proto.InternalMessageInfo

func (m *LRegisterResponse) GetFlags() RegistrationFlags {
	if m != nil {
		return m.Flags
	}
	return RegistrationFlags_Undefined
}

func (m *LRegisterResponse) GetAnticipatedRef() Reference {
	if m != nil {
		return m.AnticipatedRef
	}
	return Reference{}
}

func (m *LRegisterResponse) GetRegistrarSignature() Binary {
	if m != nil {
		return m.RegistrarSignature
	}
	return Binary{}
}

type LReadRequest struct {
	Flags                          ReadFlags   `protobuf:"varint,1800,opt,name=Flags,proto3,enum=rms.ReadFlags" json:"Flags"`
	TargetPulse                    PulseNumber `protobuf:"varint,1801,opt,name=TargetPulse,proto3,casttype=PulseNumber" json:"TargetPulse"`
	TargetRootRef                  Reference   `protobuf:"bytes,1802,opt,name=TargetRootRef,proto3" json:"TargetRootRef"`
	TargetStartRef                 Reference   `protobuf:"bytes,1803,opt,name=TargetStartRef,proto3" json:"TargetStartRef"`
	TargetStopRef                  Reference   `protobuf:"bytes,1804,opt,name=TargetStopRef,proto3" json:"TargetStopRef"`
	LimitSize                      uint32      `protobuf:"varint,1810,opt,name=LimitSize,proto3" json:"LimitSize"`
	LimitCount                     uint32      `protobuf:"varint,1811,opt,name=LimitCount,proto3" json:"LimitCount"`
	LimitRecordWithBodyCount       uint32      `protobuf:"varint,1812,opt,name=LimitRecordWithBodyCount,proto3" json:"LimitRecordWithBodyCount"`
	LimitRecordWithPayloadCount    uint32      `protobuf:"varint,1813,opt,name=LimitRecordWithPayloadCount,proto3" json:"LimitRecordWithPayloadCount"`
	LimitRecordWithExtensionsCount uint32      `protobuf:"varint,1814,opt,name=LimitRecordWithExtensionsCount,proto3" json:"LimitRecordWithExtensionsCount"`
}

func (m *LReadRequest) Reset()         { *m = LReadRequest{} }
func (m *LReadRequest) String() string { return proto.CompactTextString(m) }
func (*LReadRequest) ProtoMessage()    {}
func (*LReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0afd09ea099d9b9, []int{2}
}
func (m *LReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LReadRequest.Merge(m, src)
}
func (m *LReadRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LReadRequest proto.InternalMessageInfo

func (m *LReadRequest) GetFlags() ReadFlags {
	if m != nil {
		return m.Flags
	}
	return ReadFlags_PastToPresent
}

func (m *LReadRequest) GetTargetPulse() PulseNumber {
	if m != nil {
		return m.TargetPulse
	}
	return 0
}

func (m *LReadRequest) GetTargetRootRef() Reference {
	if m != nil {
		return m.TargetRootRef
	}
	return Reference{}
}

func (m *LReadRequest) GetTargetStartRef() Reference {
	if m != nil {
		return m.TargetStartRef
	}
	return Reference{}
}

func (m *LReadRequest) GetTargetStopRef() Reference {
	if m != nil {
		return m.TargetStopRef
	}
	return Reference{}
}

func (m *LReadRequest) GetLimitSize() uint32 {
	if m != nil {
		return m.LimitSize
	}
	return 0
}

func (m *LReadRequest) GetLimitCount() uint32 {
	if m != nil {
		return m.LimitCount
	}
	return 0
}

func (m *LReadRequest) GetLimitRecordWithBodyCount() uint32 {
	if m != nil {
		return m.LimitRecordWithBodyCount
	}
	return 0
}

func (m *LReadRequest) GetLimitRecordWithPayloadCount() uint32 {
	if m != nil {
		return m.LimitRecordWithPayloadCount
	}
	return 0
}

func (m *LReadRequest) GetLimitRecordWithExtensionsCount() uint32 {
	if m != nil {
		return m.LimitRecordWithExtensionsCount
	}
	return 0
}

type LReadResponse struct {
	Entries                []LReadResponse_Entry `protobuf:"bytes,1800,rep,name=Entries,proto3" json:"Entries"`
	NextRecordSize         uint32                `protobuf:"varint,1801,opt,name=NextRecordSize,proto3" json:"NextRecordSize"`
	NextRecordPayloadsSize uint32                `protobuf:"varint,1802,opt,name=NextRecordPayloadsSize,proto3" json:"NextRecordPayloadsSize"`
}

func (m *LReadResponse) Reset()         { *m = LReadResponse{} }
func (m *LReadResponse) String() string { return proto.CompactTextString(m) }
func (*LReadResponse) ProtoMessage()    {}
func (*LReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0afd09ea099d9b9, []int{3}
}
func (m *LReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LReadResponse.Merge(m, src)
}
func (m *LReadResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LReadResponse proto.InternalMessageInfo

func (m *LReadResponse) GetEntries() []LReadResponse_Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *LReadResponse) GetNextRecordSize() uint32 {
	if m != nil {
		return m.NextRecordSize
	}
	return 0
}

func (m *LReadResponse) GetNextRecordPayloadsSize() uint32 {
	if m != nil {
		return m.NextRecordPayloadsSize
	}
	return 0
}

type LReadResponse_Entry struct {
	RecordType        uint32            `protobuf:"varint,16,opt,name=RecordType,proto3" json:"RecordType"`
	Payloads          [][]byte          `protobuf:"bytes,17,rep,name=Payloads,proto3" json:"Payloads,omitempty"`
	RecordBinary      Binary            `protobuf:"bytes,18,opt,name=RecordBinary,proto3" json:"RecordBinary"`
	PayloadDigests    RecordBodyDigests `protobuf:"bytes,19,opt,name=PayloadDigests,proto3" json:"PayloadDigests"`
	RecordRef         Reference         `protobuf:"bytes,20,opt,name=RecordRef,proto3" json:"RecordRef"`
	PrevRef           Reference         `protobuf:"bytes,24,opt,name=PrevRef,proto3" json:"PrevRef"`
	RootRef           Reference         `protobuf:"bytes,25,opt,name=RootRef,proto3" json:"RootRef"`
	ReasonRef         Reference         `protobuf:"bytes,26,opt,name=ReasonRef,proto3" json:"ReasonRef"`
	RedirectRef       Reference         `protobuf:"bytes,27,opt,name=RedirectRef,proto3" json:"RedirectRef"`
	RejoinRef         Reference         `protobuf:"bytes,28,opt,name=RejoinRef,proto3" json:"RejoinRef"`
	ProducerSignature Binary            `protobuf:"bytes,39,opt,name=ProducerSignature,proto3" json:"ProducerSignature"`
	ProducedBy        Reference         `protobuf:"bytes,42,opt,name=ProducedBy,proto3" json:"ProducedBy"`
	// Token ProducerToken = 43;
	RegistrarSignature Binary    `protobuf:"bytes,44,opt,name=RegistrarSignature,proto3" json:"RegistrarSignature"`
	RegisteredBy       Reference `protobuf:"bytes,45,opt,name=RegisteredBy,proto3" json:"RegisteredBy"`
	RecordSize         uint32    `protobuf:"varint,1801,opt,name=RecordSize,proto3" json:"RecordSize"`
	RecordPayloadsSize uint32    `protobuf:"varint,1802,opt,name=RecordPayloadsSize,proto3" json:"RecordPayloadsSize"`
}

func (m *LReadResponse_Entry) Reset()         { *m = LReadResponse_Entry{} }
func (m *LReadResponse_Entry) String() string { return proto.CompactTextString(m) }
func (*LReadResponse_Entry) ProtoMessage()    {}
func (*LReadResponse_Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0afd09ea099d9b9, []int{3, 0}
}
func (m *LReadResponse_Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LReadResponse_Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LReadResponse_Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LReadResponse_Entry.Merge(m, src)
}
func (m *LReadResponse_Entry) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LReadResponse_Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_LReadResponse_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_LReadResponse_Entry proto.InternalMessageInfo

func (m *LReadResponse_Entry) GetRecordType() uint32 {
	if m != nil {
		return m.RecordType
	}
	return 0
}

func (m *LReadResponse_Entry) GetPayloads() [][]byte {
	if m != nil {
		return m.Payloads
	}
	return nil
}

func (m *LReadResponse_Entry) GetRecordBinary() Binary {
	if m != nil {
		return m.RecordBinary
	}
	return Binary{}
}

func (m *LReadResponse_Entry) GetPayloadDigests() RecordBodyDigests {
	if m != nil {
		return m.PayloadDigests
	}
	return RecordBodyDigests{}
}

func (m *LReadResponse_Entry) GetRecordRef() Reference {
	if m != nil {
		return m.RecordRef
	}
	return Reference{}
}

func (m *LReadResponse_Entry) GetPrevRef() Reference {
	if m != nil {
		return m.PrevRef
	}
	return Reference{}
}

func (m *LReadResponse_Entry) GetRootRef() Reference {
	if m != nil {
		return m.RootRef
	}
	return Reference{}
}

func (m *LReadResponse_Entry) GetReasonRef() Reference {
	if m != nil {
		return m.ReasonRef
	}
	return Reference{}
}

func (m *LReadResponse_Entry) GetRedirectRef() Reference {
	if m != nil {
		return m.RedirectRef
	}
	return Reference{}
}

func (m *LReadResponse_Entry) GetRejoinRef() Reference {
	if m != nil {
		return m.RejoinRef
	}
	return Reference{}
}

func (m *LReadResponse_Entry) GetProducerSignature() Binary {
	if m != nil {
		return m.ProducerSignature
	}
	return Binary{}
}

func (m *LReadResponse_Entry) GetProducedBy() Reference {
	if m != nil {
		return m.ProducedBy
	}
	return Reference{}
}

func (m *LReadResponse_Entry) GetRegistrarSignature() Binary {
	if m != nil {
		return m.RegistrarSignature
	}
	return Binary{}
}

func (m *LReadResponse_Entry) GetRegisteredBy() Reference {
	if m != nil {
		return m.RegisteredBy
	}
	return Reference{}
}

func (m *LReadResponse_Entry) GetRecordSize() uint32 {
	if m != nil {
		return m.RecordSize
	}
	return 0
}

func (m *LReadResponse_Entry) GetRecordPayloadsSize() uint32 {
	if m != nil {
		return m.RecordPayloadsSize
	}
	return 0
}

func init() {
	proto.RegisterEnum("rms.RegistrationFlags", RegistrationFlags_name, RegistrationFlags_value)
	proto.RegisterEnum("rms.ReadFlags", ReadFlags_name, ReadFlags_value)
	proto.RegisterType((*LRegisterRequest)(nil), "rms.LRegisterRequest")
	proto.RegisterType((*LRegisterResponse)(nil), "rms.LRegisterResponse")
	proto.RegisterType((*LReadRequest)(nil), "rms.LReadRequest")
	proto.RegisterType((*LReadResponse)(nil), "rms.LReadResponse")
	proto.RegisterType((*LReadResponse_Entry)(nil), "rms.LReadResponse.Entry")
}

func init() { proto.RegisterFile("proto_vnlmn.proto", fileDescriptor_b0afd09ea099d9b9) }

var fileDescriptor_b0afd09ea099d9b9 = []byte{
	// 1155 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x96, 0xc1, 0x4f, 0x1b, 0xc7,
	0x17, 0xc7, 0xbd, 0xc1, 0x0e, 0xf6, 0x33, 0x76, 0xd6, 0x43, 0x12, 0xed, 0x8f, 0xfc, 0xb4, 0x6b,
	0xd1, 0x56, 0x45, 0xb4, 0x80, 0x44, 0x4a, 0xd4, 0xa6, 0x8a, 0x12, 0x1c, 0x48, 0x1b, 0x04, 0xa9,
	0x65, 0x68, 0x7b, 0xac, 0x16, 0xef, 0x78, 0x99, 0xca, 0xde, 0x71, 0x66, 0xc6, 0x08, 0xe7, 0x2f,
	0x48, 0x68, 0x2b, 0x55, 0x69, 0x13, 0x35, 0x9c, 0x92, 0x9e, 0xa2, 0x5e, 0x1a, 0x45, 0xed, 0xbd,
	0x47, 0x8e, 0x1c, 0xe9, 0x05, 0x35, 0x70, 0xe9, 0xdf, 0xc0, 0xa1, 0xaa, 0x76, 0x66, 0x17, 0xaf,
	0x8d, 0xd9, 0x90, 0x53, 0x4f, 0xec, 0xbc, 0xf7, 0x79, 0xdf, 0x37, 0x33, 0xbc, 0x37, 0xcf, 0x50,
	0x68, 0x32, 0x2a, 0xe8, 0x57, 0xeb, 0x5e, 0xbd, 0xe1, 0x4d, 0xca, 0x6f, 0x34, 0xc0, 0x1a, 0x7c,
	0x64, 0xc2, 0x25, 0x62, 0xad, 0xb5, 0x3a, 0x59, 0xa5, 0x8d, 0x29, 0x97, 0xba, 0x74, 0x4a, 0xfa,
	0x56, 0x5b, 0x35, 0xb9, 0x92, 0x0b, 0xf9, 0xa5, 0x62, 0x46, 0x6e, 0x44, 0x70, 0xe2, 0x71, 0x5a,
	0xb7, 0xd9, 0x94, 0xcd, 0x79, 0x8b, 0x61, 0x67, 0xa2, 0x8e, 0x1d, 0x17, 0xb3, 0x29, 0xf5, 0x67,
	0xa2, 0x4a, 0x19, 0xf6, 0x11, 0x25, 0x41, 0x3c, 0x1e, 0x28, 0x64, 0x58, 0x23, 0xf8, 0x1c, 0xfd,
	0x27, 0x09, 0xfa, 0x62, 0x05, 0xbb, 0x84, 0x0b, 0xcc, 0x2a, 0xf8, 0x6e, 0x0b, 0x73, 0x81, 0x46,
	0x21, 0x53, 0xa6, 0xf5, 0x76, 0x83, 0xb2, 0xe6, 0x9a, 0xa1, 0x17, 0xb5, 0xb1, 0x5c, 0x29, 0xb9,
	0xbd, 0x67, 0x25, 0x2a, 0x1d, 0x33, 0x9a, 0x85, 0xb3, 0x15, 0x5c, 0xa5, 0xcc, 0x31, 0x86, 0x8b,
	0xda, 0x58, 0x76, 0x1a, 0x4d, 0xfa, 0xa2, 0xb3, 0x5e, 0x5b, 0x59, 0x17, 0xed, 0x7b, 0xed, 0xd2,
	0x05, 0x3f, 0x68, 0x67, 0xcf, 0xd2, 0x0e, 0x1f, 0x17, 0x33, 0x4b, 0xdc, 0x55, 0xae, 0x4a, 0x10,
	0x88, 0x2e, 0x43, 0xea, 0x56, 0xdd, 0x76, 0xb9, 0x71, 0x3f, 0x5f, 0xd4, 0xc6, 0xf2, 0xd3, 0x17,
	0xa5, 0x84, 0xda, 0x0c, 0xb3, 0x05, 0xa1, 0x9e, 0x74, 0x07, 0xb9, 0x15, 0x8b, 0xae, 0x41, 0x7e,
	0xd6, 0x13, 0xa4, 0x4a, 0x9a, 0xb6, 0xc0, 0x4e, 0x05, 0xd7, 0x8c, 0x07, 0x79, 0xb9, 0x81, 0x7c,
	0x10, 0x5d, 0xc3, 0x0c, 0x7b, 0x55, 0x1c, 0x44, 0xf5, 0xc0, 0x68, 0x06, 0xd0, 0x67, 0xeb, 0x98,
	0x31, 0xe2, 0x60, 0xb5, 0x8b, 0x95, 0x76, 0x13, 0x1b, 0x3f, 0xe5, 0x23, 0x87, 0xec, 0x03, 0xa0,
	0xeb, 0x70, 0x2e, 0xb4, 0x96, 0x19, 0x5e, 0xf7, 0xd3, 0x3e, 0x8d, 0x4b, 0xdb, 0x4b, 0x47, 0x05,
	0x2a, 0x94, 0x0a, 0x5f, 0xe0, 0xd9, 0xa9, 0x04, 0x02, 0x1a, 0xdd, 0x84, 0x42, 0x67, 0x5f, 0x36,
	0xa7, 0x9e, 0x2f, 0xf1, 0x73, 0x9c, 0xc4, 0x71, 0x1e, 0xdd, 0x80, 0x42, 0x99, 0x51, 0xa7, 0x55,
	0xc5, 0x6c, 0x99, 0xb8, 0x9e, 0x2d, 0x5a, 0x0c, 0x1b, 0xbf, 0x2a, 0x91, 0xac, 0x14, 0x29, 0x11,
	0xcf, 0x66, 0xed, 0x50, 0xe1, 0x18, 0x8c, 0x66, 0x00, 0x02, 0xa3, 0x53, 0x6a, 0x1b, 0x2f, 0xe2,
	0xf2, 0x47, 0xc0, 0xab, 0xa9, 0x3f, 0x76, 0xad, 0x17, 0x99, 0x85, 0x64, 0x5a, 0xd3, 0xf5, 0x85,
	0x64, 0xba, 0xa0, 0xa3, 0x85, 0x54, 0xfa, 0xbc, 0x7e, 0x3f, 0x3f, 0xfa, 0xa7, 0x06, 0x85, 0x48,
	0x01, 0xf2, 0x26, 0xf5, 0x38, 0xfe, 0x4f, 0x4a, 0xa3, 0x04, 0x28, 0x4c, 0x10, 0xb9, 0x9d, 0xef,
	0x4e, 0xbc, 0x9d, 0x3e, 0xb4, 0x3c, 0xe7, 0xcb, 0xcc, 0x42, 0x2a, 0xad, 0xf9, 0x67, 0x7b, 0x95,
	0x84, 0xa1, 0xc5, 0x0a, 0xb6, 0x9d, 0xb0, 0xb1, 0xde, 0xeb, 0x39, 0x56, 0xb8, 0x31, 0xdb, 0xe9,
	0x73, 0x9c, 0x2b, 0x90, 0x5d, 0xb1, 0x99, 0x8b, 0x45, 0xb9, 0x55, 0xe7, 0x58, 0x9d, 0x25, 0x57,
	0x1a, 0xf6, 0x91, 0xc3, 0x3d, 0x2b, 0x2b, 0xad, 0x77, 0x5a, 0x8d, 0x55, 0xcc, 0x2a, 0x51, 0x10,
	0x7d, 0x0c, 0x39, 0xb5, 0x0c, 0x0b, 0x6d, 0x33, 0xee, 0x16, 0xba, 0x59, 0xff, 0x0e, 0x95, 0x61,
	0x59, 0xd8, 0x4c, 0x46, 0x7f, 0x13, 0x7b, 0x87, 0xdd, 0x70, 0x27, 0xf7, 0xb2, 0xa0, 0x4d, 0x3f,
	0xfa, 0xdb, 0x53, 0xe4, 0x0e, 0x58, 0xf4, 0x16, 0x64, 0x16, 0x49, 0x83, 0x88, 0x65, 0x72, 0x0f,
	0x1b, 0x0f, 0xa3, 0x2d, 0xd9, 0xb1, 0xa3, 0x77, 0x00, 0xe4, 0xe2, 0x26, 0x6d, 0x79, 0xc2, 0xf8,
	0x21, 0x4a, 0x45, 0x1c, 0x68, 0x16, 0x0c, 0xb9, 0x52, 0x3d, 0xfc, 0x25, 0x11, 0x6b, 0x25, 0xea,
	0xb4, 0x55, 0xd0, 0x8f, 0xd1, 0xa0, 0x13, 0x31, 0xf4, 0x09, 0x5c, 0xea, 0xf1, 0x95, 0xed, 0x76,
	0x9d, 0xda, 0x8e, 0x52, 0x79, 0x14, 0x55, 0x89, 0x23, 0xd1, 0x12, 0x98, 0x3d, 0xee, 0xf9, 0x0d,
	0x81, 0x3d, 0x4e, 0xa8, 0xc7, 0x95, 0xd6, 0xe3, 0xa8, 0xd6, 0x6b, 0x60, 0x59, 0x63, 0xbf, 0x1d,
	0xd5, 0xd8, 0xb3, 0x34, 0xe4, 0x82, 0x1a, 0x0b, 0x7a, 0xe7, 0x23, 0x18, 0x9c, 0xf7, 0x04, 0x23,
	0x58, 0x96, 0xd9, 0xc0, 0x58, 0x76, 0xda, 0x90, 0xb7, 0xdf, 0x45, 0x4d, 0xfa, 0x48, 0x58, 0xc9,
	0x21, 0x8f, 0x26, 0x20, 0x7f, 0x07, 0x6f, 0x04, 0xb9, 0xe5, 0xbf, 0xe1, 0x41, 0x74, 0x67, 0x3d,
	0x4e, 0x74, 0x0d, 0x2e, 0x76, 0x2c, 0xc1, 0x91, 0xb9, 0x0c, 0xdb, 0x8c, 0x86, 0x9d, 0x00, 0x8d,
	0xec, 0x9e, 0x85, 0x94, 0xdc, 0x06, 0x7a, 0x1b, 0x20, 0xf2, 0x1a, 0x47, 0x27, 0x4e, 0xc4, 0x8e,
	0x8a, 0x90, 0x0e, 0xe3, 0x8d, 0x42, 0x71, 0x60, 0x6c, 0x28, 0x60, 0x8e, 0xac, 0x68, 0x06, 0x86,
	0x14, 0xaf, 0x1a, 0xd5, 0x40, 0x27, 0xf5, 0x6e, 0x17, 0x86, 0xe6, 0x20, 0x1f, 0x48, 0xcc, 0x11,
	0x17, 0x73, 0xc1, 0x83, 0x99, 0x16, 0xbe, 0x3a, 0x12, 0xa5, 0x4e, 0x3b, 0xf0, 0x86, 0xb7, 0xd1,
	0x1d, 0x83, 0xa6, 0x21, 0x13, 0x0c, 0x38, 0x5c, 0x33, 0xce, 0xc7, 0x94, 0x7d, 0x07, 0x43, 0x93,
	0x30, 0x18, 0xce, 0x13, 0x23, 0x26, 0x22, 0x84, 0x7c, 0x3e, 0xec, 0xea, 0xff, 0xc5, 0xf1, 0x61,
	0x3b, 0xcb, 0x3d, 0x85, 0xd3, 0x62, 0x24, 0x7e, 0x4f, 0xe1, 0x90, 0xb8, 0x02, 0xd9, 0x0a, 0x76,
	0x08, 0xc3, 0x55, 0x99, 0xe7, 0x52, 0x4c, 0x54, 0x14, 0x54, 0xb9, 0xbe, 0xa6, 0x44, 0xe6, 0xfa,
	0x7f, 0x7c, 0xae, 0x00, 0x43, 0xd7, 0xfb, 0x0d, 0xa4, 0x77, 0xdf, 0x60, 0x1e, 0x7d, 0xd0, 0x35,
	0x8f, 0xc6, 0x4f, 0x37, 0x8e, 0xd0, 0x6c, 0xdf, 0xa7, 0xfe, 0xfd, 0x37, 0x78, 0xe9, 0xd1, 0x87,
	0x7e, 0xa9, 0xa9, 0xa9, 0x25, 0x53, 0x4f, 0xc4, 0xa4, 0xee, 0x22, 0xfd, 0x17, 0xec, 0xa4, 0x06,
	0x8b, 0x38, 0xfc, 0x5f, 0x2a, 0xaf, 0x6b, 0xac, 0x3e, 0xc0, 0xd5, 0xe4, 0xf3, 0x5d, 0x4b, 0x93,
	0x6f, 0xc4, 0xef, 0xe1, 0x1b, 0x31, 0x3e, 0x07, 0x85, 0x63, 0xa3, 0x13, 0xe5, 0x20, 0xf3, 0xb9,
	0xe7, 0xe0, 0x1a, 0xf1, 0xb0, 0xa3, 0x27, 0x50, 0x1a, 0x92, 0xb7, 0x6c, 0x2e, 0x74, 0xcd, 0xff,
	0x5a, 0xb6, 0x6b, 0x58, 0x3f, 0x83, 0x86, 0x20, 0xed, 0xdb, 0xe4, 0x6a, 0x60, 0xfc, 0x91, 0x26,
	0x8b, 0x49, 0x8d, 0x2a, 0x54, 0x80, 0x5c, 0xd9, 0xe6, 0x62, 0x85, 0x96, 0x19, 0xe6, 0xd8, 0x13,
	0x7a, 0x42, 0x9a, 0xd4, 0x62, 0x85, 0x96, 0x95, 0x56, 0x01, 0x72, 0x72, 0x36, 0xdc, 0xe6, 0xaa,
	0xbe, 0xf4, 0x33, 0x48, 0x87, 0xa1, 0xf9, 0x8d, 0x6a, 0xbd, 0xe5, 0x60, 0xe9, 0xd1, 0x93, 0xe8,
	0x1c, 0x64, 0x8f, 0x2c, 0xb4, 0xa9, 0xa7, 0xd1, 0x05, 0x28, 0xdc, 0xf6, 0xa4, 0x41, 0xd5, 0x7d,
	0x93, 0x32, 0xa1, 0xeb, 0x11, 0xb3, 0x7a, 0x50, 0xa4, 0xb9, 0x58, 0xba, 0xbb, 0xfd, 0xca, 0xd4,
	0x9e, 0xef, 0x9b, 0xda, 0xf6, 0xbe, 0xa9, 0xed, 0xec, 0x9b, 0xda, 0xee, 0xbe, 0xa9, 0xfd, 0xb5,
	0x6f, 0x26, 0xbe, 0x3f, 0x30, 0x13, 0x4f, 0x0f, 0x4c, 0x6d, 0xe7, 0xc0, 0x4c, 0xec, 0x1e, 0x98,
	0x89, 0xbf, 0x9f, 0x58, 0xda, 0xe1, 0x13, 0x6b, 0x70, 0x09, 0x73, 0x6e, 0xbb, 0x78, 0x73, 0xcb,
	0x4a, 0x7e, 0x8a, 0x6d, 0xe7, 0xe1, 0x96, 0x95, 0xfa, 0x82, 0x70, 0x22, 0x7e, 0xd9, 0xb2, 0x86,
	0xc3, 0xff, 0x54, 0xc0, 0xf8, 0xef, 0xce, 0xcb, 0x2d, 0x2b, 0x1f, 0x2c, 0x25, 0x46, 0xd9, 0xea,
	0x59, 0xf9, 0xe3, 0xf9, 0xf2, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x26, 0x96, 0xaf, 0xf2, 0xd2,
	0x0b, 0x00, 0x00,
}

func (this *LRegisterRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LRegisterRequest)
	if !ok {
		that2, ok := that.(LRegisterRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Polymorph != that1.Polymorph {
		return false
	}
	if !this.AnyRecordLazy.Equal(&that1.AnyRecordLazy) {
		return false
	}
	if this.Flags != that1.Flags {
		return false
	}
	if !this.AnticipatedRef.Equal(&that1.AnticipatedRef) {
		return false
	}
	if this.OverrideRecordType != that1.OverrideRecordType {
		return false
	}
	if !this.OverridePrevRef.Equal(&that1.OverridePrevRef) {
		return false
	}
	if !this.OverrideRootRef.Equal(&that1.OverrideRootRef) {
		return false
	}
	if !this.OverrideReasonRef.Equal(&that1.OverrideReasonRef) {
		return false
	}
	if !this.ProducerSignature.Equal(&that1.ProducerSignature) {
		return false
	}
	if !this.ProducedBy.Equal(&that1.ProducedBy) {
		return false
	}
	return true
}
func (this *LRegisterResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LRegisterResponse)
	if !ok {
		that2, ok := that.(LRegisterResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Flags != that1.Flags {
		return false
	}
	if !this.AnticipatedRef.Equal(&that1.AnticipatedRef) {
		return false
	}
	if !this.RegistrarSignature.Equal(&that1.RegistrarSignature) {
		return false
	}
	return true
}
func (this *LReadRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LReadRequest)
	if !ok {
		that2, ok := that.(LReadRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Flags != that1.Flags {
		return false
	}
	if this.TargetPulse != that1.TargetPulse {
		return false
	}
	if !this.TargetRootRef.Equal(&that1.TargetRootRef) {
		return false
	}
	if !this.TargetStartRef.Equal(&that1.TargetStartRef) {
		return false
	}
	if !this.TargetStopRef.Equal(&that1.TargetStopRef) {
		return false
	}
	if this.LimitSize != that1.LimitSize {
		return false
	}
	if this.LimitCount != that1.LimitCount {
		return false
	}
	if this.LimitRecordWithBodyCount != that1.LimitRecordWithBodyCount {
		return false
	}
	if this.LimitRecordWithPayloadCount != that1.LimitRecordWithPayloadCount {
		return false
	}
	if this.LimitRecordWithExtensionsCount != that1.LimitRecordWithExtensionsCount {
		return false
	}
	return true
}
func (this *LReadResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LReadResponse)
	if !ok {
		that2, ok := that.(LReadResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Entries) != len(that1.Entries) {
		return false
	}
	for i := range this.Entries {
		if !this.Entries[i].Equal(&that1.Entries[i]) {
			return false
		}
	}
	if this.NextRecordSize != that1.NextRecordSize {
		return false
	}
	if this.NextRecordPayloadsSize != that1.NextRecordPayloadsSize {
		return false
	}
	return true
}
func (this *LReadResponse_Entry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LReadResponse_Entry)
	if !ok {
		that2, ok := that.(LReadResponse_Entry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RecordType != that1.RecordType {
		return false
	}
	if len(this.Payloads) != len(that1.Payloads) {
		return false
	}
	for i := range this.Payloads {
		if !bytes.Equal(this.Payloads[i], that1.Payloads[i]) {
			return false
		}
	}
	if !this.RecordBinary.Equal(&that1.RecordBinary) {
		return false
	}
	if !this.PayloadDigests.Equal(&that1.PayloadDigests) {
		return false
	}
	if !this.RecordRef.Equal(&that1.RecordRef) {
		return false
	}
	if !this.PrevRef.Equal(&that1.PrevRef) {
		return false
	}
	if !this.RootRef.Equal(&that1.RootRef) {
		return false
	}
	if !this.ReasonRef.Equal(&that1.ReasonRef) {
		return false
	}
	if !this.RedirectRef.Equal(&that1.RedirectRef) {
		return false
	}
	if !this.RejoinRef.Equal(&that1.RejoinRef) {
		return false
	}
	if !this.ProducerSignature.Equal(&that1.ProducerSignature) {
		return false
	}
	if !this.ProducedBy.Equal(&that1.ProducedBy) {
		return false
	}
	if !this.RegistrarSignature.Equal(&that1.RegistrarSignature) {
		return false
	}
	if !this.RegisteredBy.Equal(&that1.RegisteredBy) {
		return false
	}
	if this.RecordSize != that1.RecordSize {
		return false
	}
	if this.RecordPayloadsSize != that1.RecordPayloadsSize {
		return false
	}
	return true
}
func (m *LRegisterRequest) Visit(ctx MessageVisitor) error {
	if err := ctx.MsgRecord(m, 19, &m.AnyRecordLazy); err != nil {
		return err
	}
	return ctx.Message(m, 1200)
}

const TypeLRegisterRequestPolymorphID = 1200

func (*LRegisterRequest) GetDefaultPolymorphID() uint64 {
	return 1200
}

func (m *LRegisterRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	if n != size {
		panic("illegal state")
	}
	return dAtA[:n], nil
}

func (m *LRegisterRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LRegisterRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	{
		size, err := m.ProducedBy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x73
			i--
			dAtA[i] = 0x82
		}
	}
	{
		size, err := m.ProducerSignature.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x72
			i--
			dAtA[i] = 0xfa
		}
	}
	{
		size, err := m.OverrideReasonRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x72
			i--
			dAtA[i] = 0x92
		}
	}
	{
		size, err := m.OverrideRootRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x72
			i--
			dAtA[i] = 0x8a
		}
	}
	{
		size, err := m.OverridePrevRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x72
			i--
			dAtA[i] = 0x82
		}
	}
	if m.OverrideRecordType != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.OverrideRecordType))
		i--
		dAtA[i] = 0x71
		i--
		dAtA[i] = 0xc0
	}
	{
		size, err := m.AnticipatedRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x70
			i--
			dAtA[i] = 0xca
		}
	}
	if m.Flags != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x70
		i--
		dAtA[i] = 0xc0
	}
	{
		size, err := m.AnyRecordLazy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if i < len(dAtA) {
		id := uint64(m.Polymorph)
		if id == 0 {
			id = 1200
		}
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(id))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	return len(dAtA) - i, nil
}

func (m *LRegisterResponse) Visit(ctx MessageVisitor) error {
	return ctx.Message(m, 1202)
}

const TypeLRegisterResponsePolymorphID = 1202

func (*LRegisterResponse) GetDefaultPolymorphID() uint64 {
	return 1202
}

func (m *LRegisterResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	if n != size {
		panic("illegal state")
	}
	return dAtA[:n], nil
}

func (m *LRegisterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LRegisterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	{
		size, err := m.RegistrarSignature.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x70
			i--
			dAtA[i] = 0xea
		}
	}
	{
		size, err := m.AnticipatedRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x70
			i--
			dAtA[i] = 0xca
		}
	}
	if m.Flags != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x70
		i--
		dAtA[i] = 0xc0
	}
	i = encodeVarintProtoVnlmn(dAtA, i, uint64(1202))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	return len(dAtA) - i, nil
}

func (m *LReadRequest) Visit(ctx MessageVisitor) error {
	return ctx.Message(m, 1204)
}

const TypeLReadRequestPolymorphID = 1204

func (*LReadRequest) GetDefaultPolymorphID() uint64 {
	return 1204
}

func (m *LReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	if n != size {
		panic("illegal state")
	}
	return dAtA[:n], nil
}

func (m *LReadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LReadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	if m.LimitRecordWithExtensionsCount != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.LimitRecordWithExtensionsCount))
		i--
		dAtA[i] = 0x71
		i--
		dAtA[i] = 0xb0
	}
	if m.LimitRecordWithPayloadCount != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.LimitRecordWithPayloadCount))
		i--
		dAtA[i] = 0x71
		i--
		dAtA[i] = 0xa8
	}
	if m.LimitRecordWithBodyCount != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.LimitRecordWithBodyCount))
		i--
		dAtA[i] = 0x71
		i--
		dAtA[i] = 0xa0
	}
	if m.LimitCount != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.LimitCount))
		i--
		dAtA[i] = 0x71
		i--
		dAtA[i] = 0x98
	}
	if m.LimitSize != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.LimitSize))
		i--
		dAtA[i] = 0x71
		i--
		dAtA[i] = 0x90
	}
	{
		size, err := m.TargetStopRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x70
			i--
			dAtA[i] = 0xe2
		}
	}
	{
		size, err := m.TargetStartRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x70
			i--
			dAtA[i] = 0xda
		}
	}
	{
		size, err := m.TargetRootRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x70
			i--
			dAtA[i] = 0xd2
		}
	}
	if m.TargetPulse != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.TargetPulse))
		i--
		dAtA[i] = 0x70
		i--
		dAtA[i] = 0xc8
	}
	if m.Flags != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x70
		i--
		dAtA[i] = 0xc0
	}
	i = encodeVarintProtoVnlmn(dAtA, i, uint64(1204))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	return len(dAtA) - i, nil
}

func (m *LReadResponse) Visit(ctx MessageVisitor) error {
	return ctx.Message(m, 1205)
}

const TypeLReadResponsePolymorphID = 1205

func (*LReadResponse) GetDefaultPolymorphID() uint64 {
	return 1205
}

func (m *LReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	if n != size {
		panic("illegal state")
	}
	return dAtA[:n], nil
}

func (m *LReadResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LReadResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	if m.NextRecordPayloadsSize != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.NextRecordPayloadsSize))
		i--
		dAtA[i] = 0x70
		i--
		dAtA[i] = 0xd0
	}
	if m.NextRecordSize != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.NextRecordSize))
		i--
		dAtA[i] = 0x70
		i--
		dAtA[i] = 0xc8
	}
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x70
			i--
			dAtA[i] = 0xc2
		}
	}
	i = encodeVarintProtoVnlmn(dAtA, i, uint64(1205))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	return len(dAtA) - i, nil
}

func (m *LReadResponse_Entry) Visit(ctx MessageVisitor) error {
	return ctx.Message(m, 0)
}

func (m *LReadResponse_Entry) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	if n != size {
		panic("illegal state")
	}
	return dAtA[:n], nil
}

func (m *LReadResponse_Entry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LReadResponse_Entry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	if m.RecordPayloadsSize != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.RecordPayloadsSize))
		i--
		dAtA[i] = 0x70
		i--
		dAtA[i] = 0xd0
	}
	if m.RecordSize != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.RecordSize))
		i--
		dAtA[i] = 0x70
		i--
		dAtA[i] = 0xc8
	}
	{
		size, err := m.RegisteredBy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xea
		}
	}
	{
		size, err := m.RegistrarSignature.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xe2
		}
	}
	{
		size, err := m.ProducedBy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xd2
		}
	}
	{
		size, err := m.ProducerSignature.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xba
		}
	}
	{
		size, err := m.RejoinRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	{
		size, err := m.RedirectRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	{
		size, err := m.ReasonRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	{
		size, err := m.RootRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	{
		size, err := m.PrevRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	{
		size, err := m.RecordRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	{
		size, err := m.PayloadDigests.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	{
		size, err := m.RecordBinary.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.Payloads) > 0 {
		for iNdEx := len(m.Payloads) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Payloads[iNdEx])
			copy(dAtA[i:], m.Payloads[iNdEx])
			i--
			dAtA[i] = 132
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(len(m.Payloads[iNdEx])+1))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if i < len(dAtA) {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.RecordType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	return len(dAtA) - i, nil
}

func encodeVarintProtoVnlmn(dAtA []byte, offset int, v uint64) int {
	offset -= sovProtoVnlmn(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}

func init() {
	RegisterMessageType(1200, "", (*LRegisterRequest)(nil))
	RegisterMessageType(1202, "", (*LRegisterResponse)(nil))
	RegisterMessageType(1204, "", (*LReadRequest)(nil))
	RegisterMessageType(1205, "", (*LReadResponse)(nil))
}

func (m *LRegisterRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if l = m.AnyRecordLazy.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if m.Flags != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.Flags))
	}
	if l = m.AnticipatedRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if m.OverrideRecordType != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.OverrideRecordType))
	}
	if l = m.OverridePrevRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.OverrideRootRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.OverrideReasonRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.ProducerSignature.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.ProducedBy.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if n > 0 {
		id := uint64(m.Polymorph)
		if id == 0 {
			id = 1200
		}
		n += 2 + sovProtoVnlmn(id)
	}
	return n
}

func (m *LRegisterResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flags != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.Flags))
	}
	if l = m.AnticipatedRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.RegistrarSignature.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	n += 2 + sovProtoVnlmn(1202)
	return n
}

func (m *LReadRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flags != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.Flags))
	}
	if m.TargetPulse != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.TargetPulse))
	}
	if l = m.TargetRootRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.TargetStartRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.TargetStopRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if m.LimitSize != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.LimitSize))
	}
	if m.LimitCount != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.LimitCount))
	}
	if m.LimitRecordWithBodyCount != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.LimitRecordWithBodyCount))
	}
	if m.LimitRecordWithPayloadCount != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.LimitRecordWithPayloadCount))
	}
	if m.LimitRecordWithExtensionsCount != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.LimitRecordWithExtensionsCount))
	}
	n += 2 + sovProtoVnlmn(1204)
	return n
}

func (m *LReadResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.ProtoSize()
			n += 2 + l + sovProtoVnlmn(uint64(l))
		}
	}
	if m.NextRecordSize != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.NextRecordSize))
	}
	if m.NextRecordPayloadsSize != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.NextRecordPayloadsSize))
	}
	n += 2 + sovProtoVnlmn(1205)
	return n
}

func (m *LReadResponse_Entry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Payloads) > 0 {
		for _, b := range m.Payloads {
			l = len(b)
			if l > 0 {
				l++
			}
			n += 2 + l + sovProtoVnlmn(uint64(l))
		}
	}
	if l = m.RecordBinary.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.PayloadDigests.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.RecordRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.PrevRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.RootRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.ReasonRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.RedirectRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.RejoinRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.ProducerSignature.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.ProducedBy.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.RegistrarSignature.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.RegisteredBy.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if m.RecordSize != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.RecordSize))
	}
	if m.RecordPayloadsSize != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.RecordPayloadsSize))
	}
	if n > 0 {
		n += 2 + sovProtoVnlmn(uint64(m.RecordType))
	}
	return n
}

func sovProtoVnlmn(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProtoVnlmn(x uint64) (n int) {
	return sovProtoVnlmn(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LRegisterRequest) Unmarshal(dAtA []byte) error {
	_, err := m.UnmarshalWithUnknownCallback(dAtA, skipProtoVnlmn)
	return err
}
func (m *LRegisterRequest) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) (int, error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		err := func() error {
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return fmt.Errorf("proto: LRegisterRequest: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return fmt.Errorf("proto: LRegisterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 16:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field Polymorph", wireType)
				}
				m.Polymorph = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.Polymorph |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 19:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field AnyRecordLazy", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.AnyRecordLazy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 1800:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
				}
				m.Flags = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.Flags |= RegistrationFlags(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 1801:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field AnticipatedRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.AnticipatedRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 1816:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field OverrideRecordType", wireType)
				}
				m.OverrideRecordType = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.OverrideRecordType |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 1824:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field OverridePrevRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.OverridePrevRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 1825:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field OverrideRootRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.OverrideRootRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 1826:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field OverrideReasonRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.OverrideReasonRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 1839:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field ProducerSignature", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.ProducerSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 1840:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field ProducedBy", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.ProducedBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := skipFn(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					l = iNdEx
					break
				}
				if skippy == 0 {
					if skippy, err = skipProtoVnlmn(dAtA[iNdEx:]); err != nil {
						return err
					}
				}
				if (iNdEx + skippy) < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += skippy
			}
			return nil
		}()
		if err != nil {
			return preIndex, err
		}
	}

	if iNdEx > l {
		return iNdEx, io.ErrUnexpectedEOF
	}
	return iNdEx, nil
}
func (m *LRegisterResponse) Unmarshal(dAtA []byte) error {
	_, err := m.UnmarshalWithUnknownCallback(dAtA, skipProtoVnlmn)
	return err
}
func (m *LRegisterResponse) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) (int, error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		err := func() error {
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return fmt.Errorf("proto: LRegisterResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return fmt.Errorf("proto: LRegisterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1800:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
				}
				m.Flags = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.Flags |= RegistrationFlags(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 1801:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field AnticipatedRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.AnticipatedRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 1805:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field RegistrarSignature", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.RegistrarSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := skipFn(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					l = iNdEx
					break
				}
				if skippy == 0 {
					if skippy, err = skipProtoVnlmn(dAtA[iNdEx:]); err != nil {
						return err
					}
				}
				if (iNdEx + skippy) < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += skippy
			}
			return nil
		}()
		if err != nil {
			return preIndex, err
		}
	}

	if iNdEx > l {
		return iNdEx, io.ErrUnexpectedEOF
	}
	return iNdEx, nil
}
func (m *LReadRequest) Unmarshal(dAtA []byte) error {
	_, err := m.UnmarshalWithUnknownCallback(dAtA, skipProtoVnlmn)
	return err
}
func (m *LReadRequest) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) (int, error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		err := func() error {
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return fmt.Errorf("proto: LReadRequest: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return fmt.Errorf("proto: LReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1800:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
				}
				m.Flags = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.Flags |= ReadFlags(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 1801:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field TargetPulse", wireType)
				}
				m.TargetPulse = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.TargetPulse |= PulseNumber(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 1802:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field TargetRootRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.TargetRootRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 1803:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field TargetStartRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.TargetStartRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 1804:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field TargetStopRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.TargetStopRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 1810:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field LimitSize", wireType)
				}
				m.LimitSize = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.LimitSize |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 1811:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field LimitCount", wireType)
				}
				m.LimitCount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.LimitCount |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 1812:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field LimitRecordWithBodyCount", wireType)
				}
				m.LimitRecordWithBodyCount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.LimitRecordWithBodyCount |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 1813:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field LimitRecordWithPayloadCount", wireType)
				}
				m.LimitRecordWithPayloadCount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.LimitRecordWithPayloadCount |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 1814:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field LimitRecordWithExtensionsCount", wireType)
				}
				m.LimitRecordWithExtensionsCount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.LimitRecordWithExtensionsCount |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := skipFn(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					l = iNdEx
					break
				}
				if skippy == 0 {
					if skippy, err = skipProtoVnlmn(dAtA[iNdEx:]); err != nil {
						return err
					}
				}
				if (iNdEx + skippy) < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += skippy
			}
			return nil
		}()
		if err != nil {
			return preIndex, err
		}
	}

	if iNdEx > l {
		return iNdEx, io.ErrUnexpectedEOF
	}
	return iNdEx, nil
}
func (m *LReadResponse) Unmarshal(dAtA []byte) error {
	_, err := m.UnmarshalWithUnknownCallback(dAtA, skipProtoVnlmn)
	return err
}
func (m *LReadResponse) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) (int, error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		err := func() error {
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return fmt.Errorf("proto: LReadResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return fmt.Errorf("proto: LReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1800:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				m.Entries = append(m.Entries, LReadResponse_Entry{})
				if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 1801:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field NextRecordSize", wireType)
				}
				m.NextRecordSize = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.NextRecordSize |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 1802:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field NextRecordPayloadsSize", wireType)
				}
				m.NextRecordPayloadsSize = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.NextRecordPayloadsSize |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := skipFn(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					l = iNdEx
					break
				}
				if skippy == 0 {
					if skippy, err = skipProtoVnlmn(dAtA[iNdEx:]); err != nil {
						return err
					}
				}
				if (iNdEx + skippy) < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += skippy
			}
			return nil
		}()
		if err != nil {
			return preIndex, err
		}
	}

	if iNdEx > l {
		return iNdEx, io.ErrUnexpectedEOF
	}
	return iNdEx, nil
}
func (m *LReadResponse_Entry) Unmarshal(dAtA []byte) error {
	_, err := m.UnmarshalWithUnknownCallback(dAtA, skipProtoVnlmn)
	return err
}
func (m *LReadResponse_Entry) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) (int, error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		err := func() error {
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return fmt.Errorf("proto: Entry: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 16:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
				}
				m.RecordType = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.RecordType |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 17:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field Payloads", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if byteLen > 0 {
					if dAtA[iNdEx] != 132 {
						return ErrExpectedBinaryMarkerProtoVnlmn
					}
					iNdEx++
				}
				m.Payloads = append(m.Payloads, make([]byte, postIndex-iNdEx))
				copy(m.Payloads[len(m.Payloads)-1], dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 18:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field RecordBinary", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.RecordBinary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 19:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field PayloadDigests", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.PayloadDigests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 20:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field RecordRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.RecordRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 24:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field PrevRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.PrevRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 25:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field RootRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.RootRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 26:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field ReasonRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.ReasonRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 27:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field RedirectRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.RedirectRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 28:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field RejoinRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.RejoinRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 39:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field ProducerSignature", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.ProducerSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 42:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field ProducedBy", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.ProducedBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 44:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field RegistrarSignature", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.RegistrarSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 45:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field RegisteredBy", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.RegisteredBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 1801:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field RecordSize", wireType)
				}
				m.RecordSize = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.RecordSize |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 1802:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field RecordPayloadsSize", wireType)
				}
				m.RecordPayloadsSize = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoVnlmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.RecordPayloadsSize |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := skipFn(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					l = iNdEx
					break
				}
				if skippy == 0 {
					if skippy, err = skipProtoVnlmn(dAtA[iNdEx:]); err != nil {
						return err
					}
				}
				if (iNdEx + skippy) < 0 {
					return ErrInvalidLengthProtoVnlmn
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += skippy
			}
			return nil
		}()
		if err != nil {
			return preIndex, err
		}
	}

	if iNdEx > l {
		return iNdEx, io.ErrUnexpectedEOF
	}
	return iNdEx, nil
}
func skipProtoVnlmn(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProtoVnlmn
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProtoVnlmn
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProtoVnlmn
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProtoVnlmn
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProtoVnlmn        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProtoVnlmn          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProtoVnlmn = fmt.Errorf("proto: unexpected end of group")
	ErrExpectedBinaryMarkerProtoVnlmn = fmt.Errorf("proto: binary marker was expected")
)
