// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto_vnlmn.proto

package rms

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/insolar/assured-ledger/ledger-core/insproto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type RegistrationFlags int32

const (
	RegistrationFlags_Undefined RegistrationFlags = 0
	RegistrationFlags_Fast      RegistrationFlags = 1
	RegistrationFlags_Safe      RegistrationFlags = 2
	RegistrationFlags_FastSafe  RegistrationFlags = 3
)

var RegistrationFlags_name = map[int32]string{
	0: "Undefined",
	1: "Fast",
	2: "Safe",
	3: "FastSafe",
}

var RegistrationFlags_value = map[string]int32{
	"Undefined": 0,
	"Fast":      1,
	"Safe":      2,
	"FastSafe":  3,
}

func (x RegistrationFlags) String() string {
	return proto.EnumName(RegistrationFlags_name, int32(x))
}

func (RegistrationFlags) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b0afd09ea099d9b9, []int{0}
}

type ReadFlags int32

const (
	ReadFlags_PastToPresent     ReadFlags = 0
	ReadFlags_PresentToPast     ReadFlags = 1
	ReadFlags_StartIsReason     ReadFlags = 2
	ReadFlags_ExcludeStart      ReadFlags = 4
	ReadFlags_ExcludeStop       ReadFlags = 8
	ReadFlags_IncludePrevReport ReadFlags = 16
	ReadFlags_IncludeNextReport ReadFlags = 32
)

var ReadFlags_name = map[int32]string{
	0:  "PastToPresent",
	1:  "PresentToPast",
	2:  "StartIsReason",
	4:  "ExcludeStart",
	8:  "ExcludeStop",
	16: "IncludePrevReport",
	32: "IncludeNextReport",
}

var ReadFlags_value = map[string]int32{
	"PastToPresent":     0,
	"PresentToPast":     1,
	"StartIsReason":     2,
	"ExcludeStart":      4,
	"ExcludeStop":       8,
	"IncludePrevReport": 16,
	"IncludeNextReport": 32,
}

func (x ReadFlags) String() string {
	return proto.EnumName(ReadFlags_name, int32(x))
}

func (ReadFlags) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b0afd09ea099d9b9, []int{1}
}

type LRegisterRequest struct {
	Polymorph     uint32 `protobuf:"varint,16,opt,name=Polymorph,proto3" json:"Polymorph"`
	AnyRecordLazy `protobuf:"bytes,19,opt,name=Record,proto3,embedded=Record" json:"Record"`
	// RegistrationFlags must be zero for LVerifyRequest
	// RegistrationFlags is ignored for a non-first entry of a registration set
	Flags              RegistrationFlags `protobuf:"varint,1800,opt,name=Flags,proto3,enum=rms.RegistrationFlags" json:"Flags"`
	AnticipatedRef     Reference         `protobuf:"bytes,1801,opt,name=AnticipatedRef,proto3" json:"AnticipatedRef"`
	OverrideRecordType uint32            `protobuf:"varint,1816,opt,name=OverrideRecordType,proto3" json:"OverrideRecordType"`
	OverridePrevRef    Reference         `protobuf:"bytes,1824,opt,name=OverridePrevRef,proto3" json:"OverridePrevRef"`
	OverrideRootRef    Reference         `protobuf:"bytes,1825,opt,name=OverrideRootRef,proto3" json:"OverrideRootRef"`
	OverrideReasonRef  Reference         `protobuf:"bytes,1826,opt,name=OverrideReasonRef,proto3" json:"OverrideReasonRef"`
	ProducerSignature  Binary            `protobuf:"bytes,1839,opt,name=ProducerSignature,proto3" json:"ProducerSignature"`
	// ProducedBy can be omitted for a non-first entry of a registration set
	ProducedBy Reference `protobuf:"bytes,1840,opt,name=ProducedBy,proto3" json:"ProducedBy"`
}

func (m *LRegisterRequest) Reset()         { *m = LRegisterRequest{} }
func (m *LRegisterRequest) String() string { return proto.CompactTextString(m) }
func (*LRegisterRequest) ProtoMessage()    {}
func (*LRegisterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0afd09ea099d9b9, []int{0}
}
func (m *LRegisterRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LRegisterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LRegisterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LRegisterRequest.Merge(m, src)
}
func (m *LRegisterRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LRegisterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LRegisterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LRegisterRequest proto.InternalMessageInfo

func (m *LRegisterRequest) GetPolymorph() uint32 {
	if m != nil {
		return m.Polymorph
	}
	return 0
}

func (m *LRegisterRequest) GetFlags() RegistrationFlags {
	if m != nil {
		return m.Flags
	}
	return RegistrationFlags_Undefined
}

func (m *LRegisterRequest) GetAnticipatedRef() Reference {
	if m != nil {
		return m.AnticipatedRef
	}
	return Reference{}
}

func (m *LRegisterRequest) GetOverrideRecordType() uint32 {
	if m != nil {
		return m.OverrideRecordType
	}
	return 0
}

func (m *LRegisterRequest) GetOverridePrevRef() Reference {
	if m != nil {
		return m.OverridePrevRef
	}
	return Reference{}
}

func (m *LRegisterRequest) GetOverrideRootRef() Reference {
	if m != nil {
		return m.OverrideRootRef
	}
	return Reference{}
}

func (m *LRegisterRequest) GetOverrideReasonRef() Reference {
	if m != nil {
		return m.OverrideReasonRef
	}
	return Reference{}
}

func (m *LRegisterRequest) GetProducerSignature() Binary {
	if m != nil {
		return m.ProducerSignature
	}
	return Binary{}
}

func (m *LRegisterRequest) GetProducedBy() Reference {
	if m != nil {
		return m.ProducedBy
	}
	return Reference{}
}

type LRegisterResponse struct {
	Flags              RegistrationFlags `protobuf:"varint,1800,opt,name=Flags,proto3,enum=rms.RegistrationFlags" json:"Flags"`
	AnticipatedRef     Reference         `protobuf:"bytes,1801,opt,name=AnticipatedRef,proto3" json:"AnticipatedRef"`
	RegistrarSignature Binary            `protobuf:"bytes,1805,opt,name=RegistrarSignature,proto3" json:"RegistrarSignature"`
}

func (m *LRegisterResponse) Reset()         { *m = LRegisterResponse{} }
func (m *LRegisterResponse) String() string { return proto.CompactTextString(m) }
func (*LRegisterResponse) ProtoMessage()    {}
func (*LRegisterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0afd09ea099d9b9, []int{1}
}
func (m *LRegisterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LRegisterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LRegisterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LRegisterResponse.Merge(m, src)
}
func (m *LRegisterResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LRegisterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LRegisterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LRegisterResponse proto.InternalMessageInfo

func (m *LRegisterResponse) GetFlags() RegistrationFlags {
	if m != nil {
		return m.Flags
	}
	return RegistrationFlags_Undefined
}

func (m *LRegisterResponse) GetAnticipatedRef() Reference {
	if m != nil {
		return m.AnticipatedRef
	}
	return Reference{}
}

func (m *LRegisterResponse) GetRegistrarSignature() Binary {
	if m != nil {
		return m.RegistrarSignature
	}
	return Binary{}
}

type LReadRequest struct {
	Flags                       ReadFlags   `protobuf:"varint,1800,opt,name=Flags,proto3,enum=rms.ReadFlags" json:"Flags"`
	TargetPulse                 PulseNumber `protobuf:"varint,1801,opt,name=TargetPulse,proto3,casttype=PulseNumber" json:"TargetPulse"`
	TargetRootRef               Reference   `protobuf:"bytes,1802,opt,name=TargetRootRef,proto3" json:"TargetRootRef"`
	TargetStartRef              Reference   `protobuf:"bytes,1803,opt,name=TargetStartRef,proto3" json:"TargetStartRef"`
	TargetStopRef               Reference   `protobuf:"bytes,1804,opt,name=TargetStopRef,proto3" json:"TargetStopRef"`
	LimitSize                   uint32      `protobuf:"varint,1810,opt,name=LimitSize,proto3" json:"LimitSize"`
	LimitCount                  uint32      `protobuf:"varint,1811,opt,name=LimitCount,proto3" json:"LimitCount"`
	LimitRecordWithBodyCount    uint32      `protobuf:"varint,1812,opt,name=LimitRecordWithBodyCount,proto3" json:"LimitRecordWithBodyCount"`
	LimitRecordWithPayloadCount uint32      `protobuf:"varint,1813,opt,name=LimitRecordWithPayloadCount,proto3" json:"LimitRecordWithPayloadCount"`
}

func (m *LReadRequest) Reset()         { *m = LReadRequest{} }
func (m *LReadRequest) String() string { return proto.CompactTextString(m) }
func (*LReadRequest) ProtoMessage()    {}
func (*LReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0afd09ea099d9b9, []int{2}
}
func (m *LReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LReadRequest.Merge(m, src)
}
func (m *LReadRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LReadRequest proto.InternalMessageInfo

func (m *LReadRequest) GetFlags() ReadFlags {
	if m != nil {
		return m.Flags
	}
	return ReadFlags_PastToPresent
}

func (m *LReadRequest) GetTargetPulse() PulseNumber {
	if m != nil {
		return m.TargetPulse
	}
	return 0
}

func (m *LReadRequest) GetTargetRootRef() Reference {
	if m != nil {
		return m.TargetRootRef
	}
	return Reference{}
}

func (m *LReadRequest) GetTargetStartRef() Reference {
	if m != nil {
		return m.TargetStartRef
	}
	return Reference{}
}

func (m *LReadRequest) GetTargetStopRef() Reference {
	if m != nil {
		return m.TargetStopRef
	}
	return Reference{}
}

func (m *LReadRequest) GetLimitSize() uint32 {
	if m != nil {
		return m.LimitSize
	}
	return 0
}

func (m *LReadRequest) GetLimitCount() uint32 {
	if m != nil {
		return m.LimitCount
	}
	return 0
}

func (m *LReadRequest) GetLimitRecordWithBodyCount() uint32 {
	if m != nil {
		return m.LimitRecordWithBodyCount
	}
	return 0
}

func (m *LReadRequest) GetLimitRecordWithPayloadCount() uint32 {
	if m != nil {
		return m.LimitRecordWithPayloadCount
	}
	return 0
}

type LReadResponse struct {
	Entries                []LReadResponse_Entry `protobuf:"bytes,1800,rep,name=Entries,proto3" json:"Entries"`
	NextRecordSize         uint32                `protobuf:"varint,1801,opt,name=NextRecordSize,proto3" json:"NextRecordSize"`
	NextRecordPayloadsSize uint32                `protobuf:"varint,1802,opt,name=NextRecordPayloadsSize,proto3" json:"NextRecordPayloadsSize"`
}

func (m *LReadResponse) Reset()         { *m = LReadResponse{} }
func (m *LReadResponse) String() string { return proto.CompactTextString(m) }
func (*LReadResponse) ProtoMessage()    {}
func (*LReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0afd09ea099d9b9, []int{3}
}
func (m *LReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LReadResponse.Merge(m, src)
}
func (m *LReadResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LReadResponse proto.InternalMessageInfo

func (m *LReadResponse) GetEntries() []LReadResponse_Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *LReadResponse) GetNextRecordSize() uint32 {
	if m != nil {
		return m.NextRecordSize
	}
	return 0
}

func (m *LReadResponse) GetNextRecordPayloadsSize() uint32 {
	if m != nil {
		return m.NextRecordPayloadsSize
	}
	return 0
}

type LReadResponse_Entry struct {
	RecordType        uint32            `protobuf:"varint,16,opt,name=RecordType,proto3" json:"RecordType"`
	Payloads          [][]byte          `protobuf:"bytes,17,rep,name=Payloads,proto3" json:"Payloads,omitempty"`
	RecordBinary      Binary            `protobuf:"bytes,18,opt,name=RecordBinary,proto3" json:"RecordBinary"`
	PayloadDigests    RecordBodyDigests `protobuf:"bytes,19,opt,name=PayloadDigests,proto3" json:"PayloadDigests"`
	RecordRef         Reference         `protobuf:"bytes,20,opt,name=RecordRef,proto3" json:"RecordRef"`
	PrevRef           Reference         `protobuf:"bytes,24,opt,name=PrevRef,proto3" json:"PrevRef"`
	RootRef           Reference         `protobuf:"bytes,25,opt,name=RootRef,proto3" json:"RootRef"`
	ReasonRef         Reference         `protobuf:"bytes,26,opt,name=ReasonRef,proto3" json:"ReasonRef"`
	RedirectRef       Reference         `protobuf:"bytes,27,opt,name=RedirectRef,proto3" json:"RedirectRef"`
	RejoinRef         Reference         `protobuf:"bytes,28,opt,name=RejoinRef,proto3" json:"RejoinRef"`
	ProducerSignature Binary            `protobuf:"bytes,39,opt,name=ProducerSignature,proto3" json:"ProducerSignature"`
	ProducedBy        Reference         `protobuf:"bytes,42,opt,name=ProducedBy,proto3" json:"ProducedBy"`
	// Token ProducerToken = 43;
	RegistrarSignature Binary    `protobuf:"bytes,44,opt,name=RegistrarSignature,proto3" json:"RegistrarSignature"`
	RegisteredBy       Reference `protobuf:"bytes,45,opt,name=RegisteredBy,proto3" json:"RegisteredBy"`
	RecordSize         uint32    `protobuf:"varint,1801,opt,name=RecordSize,proto3" json:"RecordSize"`
	RecordPayloadsSize uint32    `protobuf:"varint,1802,opt,name=RecordPayloadsSize,proto3" json:"RecordPayloadsSize"`
}

func (m *LReadResponse_Entry) Reset()         { *m = LReadResponse_Entry{} }
func (m *LReadResponse_Entry) String() string { return proto.CompactTextString(m) }
func (*LReadResponse_Entry) ProtoMessage()    {}
func (*LReadResponse_Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0afd09ea099d9b9, []int{3, 0}
}
func (m *LReadResponse_Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LReadResponse_Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LReadResponse_Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LReadResponse_Entry.Merge(m, src)
}
func (m *LReadResponse_Entry) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LReadResponse_Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_LReadResponse_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_LReadResponse_Entry proto.InternalMessageInfo

func (m *LReadResponse_Entry) GetRecordType() uint32 {
	if m != nil {
		return m.RecordType
	}
	return 0
}

func (m *LReadResponse_Entry) GetPayloads() [][]byte {
	if m != nil {
		return m.Payloads
	}
	return nil
}

func (m *LReadResponse_Entry) GetRecordBinary() Binary {
	if m != nil {
		return m.RecordBinary
	}
	return Binary{}
}

func (m *LReadResponse_Entry) GetPayloadDigests() RecordBodyDigests {
	if m != nil {
		return m.PayloadDigests
	}
	return RecordBodyDigests{}
}

func (m *LReadResponse_Entry) GetRecordRef() Reference {
	if m != nil {
		return m.RecordRef
	}
	return Reference{}
}

func (m *LReadResponse_Entry) GetPrevRef() Reference {
	if m != nil {
		return m.PrevRef
	}
	return Reference{}
}

func (m *LReadResponse_Entry) GetRootRef() Reference {
	if m != nil {
		return m.RootRef
	}
	return Reference{}
}

func (m *LReadResponse_Entry) GetReasonRef() Reference {
	if m != nil {
		return m.ReasonRef
	}
	return Reference{}
}

func (m *LReadResponse_Entry) GetRedirectRef() Reference {
	if m != nil {
		return m.RedirectRef
	}
	return Reference{}
}

func (m *LReadResponse_Entry) GetRejoinRef() Reference {
	if m != nil {
		return m.RejoinRef
	}
	return Reference{}
}

func (m *LReadResponse_Entry) GetProducerSignature() Binary {
	if m != nil {
		return m.ProducerSignature
	}
	return Binary{}
}

func (m *LReadResponse_Entry) GetProducedBy() Reference {
	if m != nil {
		return m.ProducedBy
	}
	return Reference{}
}

func (m *LReadResponse_Entry) GetRegistrarSignature() Binary {
	if m != nil {
		return m.RegistrarSignature
	}
	return Binary{}
}

func (m *LReadResponse_Entry) GetRegisteredBy() Reference {
	if m != nil {
		return m.RegisteredBy
	}
	return Reference{}
}

func (m *LReadResponse_Entry) GetRecordSize() uint32 {
	if m != nil {
		return m.RecordSize
	}
	return 0
}

func (m *LReadResponse_Entry) GetRecordPayloadsSize() uint32 {
	if m != nil {
		return m.RecordPayloadsSize
	}
	return 0
}

func init() {
	proto.RegisterEnum("rms.RegistrationFlags", RegistrationFlags_name, RegistrationFlags_value)
	proto.RegisterEnum("rms.ReadFlags", ReadFlags_name, ReadFlags_value)
	proto.RegisterType((*LRegisterRequest)(nil), "rms.LRegisterRequest")
	proto.RegisterType((*LRegisterResponse)(nil), "rms.LRegisterResponse")
	proto.RegisterType((*LReadRequest)(nil), "rms.LReadRequest")
	proto.RegisterType((*LReadResponse)(nil), "rms.LReadResponse")
	proto.RegisterType((*LReadResponse_Entry)(nil), "rms.LReadResponse.Entry")
}

func init() { proto.RegisterFile("proto_vnlmn.proto", fileDescriptor_b0afd09ea099d9b9) }

var fileDescriptor_b0afd09ea099d9b9 = []byte{
	// 1132 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x96, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xc0, 0xbd, 0x8d, 0x9d, 0xd8, 0xcf, 0xb1, 0xbb, 0x9e, 0xb4, 0xd5, 0x92, 0x22, 0xaf, 0x15,
	0x40, 0x44, 0x81, 0x24, 0x52, 0x4a, 0x2a, 0x28, 0xaa, 0xda, 0xb8, 0x69, 0xa1, 0x51, 0x5a, 0x2c,
	0x27, 0xc0, 0x11, 0x6d, 0xbc, 0xe3, 0xcd, 0x20, 0x7b, 0xc7, 0x9d, 0x19, 0x47, 0x75, 0x3f, 0x41,
	0x1b, 0x40, 0x42, 0x81, 0x22, 0x9a, 0x53, 0xcb, 0xa9, 0xe2, 0x42, 0x55, 0xc1, 0x9d, 0x63, 0x8e,
	0x39, 0x86, 0x4b, 0x04, 0xc9, 0x85, 0xcf, 0x90, 0x03, 0x42, 0x3b, 0x33, 0x1b, 0xaf, 0x13, 0x67,
	0x49, 0x4f, 0x9c, 0xb2, 0xf3, 0xde, 0xef, 0xfd, 0x99, 0xc9, 0xfb, 0x63, 0x28, 0xb4, 0x18, 0x15,
	0xf4, 0x8b, 0x35, 0xbf, 0xd1, 0xf4, 0xa7, 0xe4, 0x37, 0x1a, 0x60, 0x4d, 0x3e, 0x3a, 0xe9, 0x11,
	0xb1, 0xda, 0x5e, 0x99, 0xaa, 0xd1, 0xe6, 0xb4, 0x47, 0x3d, 0x3a, 0x2d, 0x75, 0x2b, 0xed, 0xba,
	0x3c, 0xc9, 0x83, 0xfc, 0x52, 0x36, 0xa3, 0xd7, 0x23, 0x38, 0xf1, 0x39, 0x6d, 0x38, 0x6c, 0xda,
	0xe1, 0xbc, 0xcd, 0xb0, 0x3b, 0xd9, 0xc0, 0xae, 0x87, 0xd9, 0xb4, 0xfa, 0x33, 0x59, 0xa3, 0x0c,
	0x07, 0x88, 0x72, 0x41, 0x7c, 0xae, 0x3d, 0x64, 0x58, 0x53, 0x7f, 0x8e, 0xfd, 0x93, 0x04, 0x73,
	0xb1, 0x8a, 0x3d, 0xc2, 0x05, 0x66, 0x55, 0x7c, 0xaf, 0x8d, 0xb9, 0x40, 0x63, 0x90, 0xa9, 0xd0,
	0x46, 0xa7, 0x49, 0x59, 0x6b, 0xd5, 0x32, 0x4b, 0xc6, 0x78, 0xae, 0x9c, 0xdc, 0xda, 0xb5, 0x13,
	0xd5, 0xae, 0x18, 0xcd, 0xc1, 0x60, 0x15, 0xd7, 0x28, 0x73, 0xad, 0x91, 0x92, 0x31, 0x9e, 0x9d,
	0x41, 0x53, 0x81, 0xd3, 0x39, 0xbf, 0xa3, 0xa4, 0x8b, 0xce, 0x83, 0x4e, 0xf9, 0x7c, 0x60, 0xb4,
	0xbd, 0x6b, 0x1b, 0x07, 0x3f, 0x94, 0x32, 0x77, 0xb8, 0xa7, 0x54, 0x55, 0x6d, 0x88, 0x2e, 0x41,
	0xea, 0x56, 0xc3, 0xf1, 0xb8, 0xf5, 0x30, 0x5f, 0x32, 0xc6, 0xf3, 0x33, 0x17, 0xa4, 0x0b, 0x95,
	0x0c, 0x73, 0x04, 0xa1, 0xbe, 0x54, 0xeb, 0xd8, 0x8a, 0x45, 0x57, 0x21, 0x3f, 0xe7, 0x0b, 0x52,
	0x23, 0x2d, 0x47, 0x60, 0xb7, 0x8a, 0xeb, 0xd6, 0xa3, 0xbc, 0x4c, 0x20, 0xaf, 0xad, 0xeb, 0x98,
	0x61, 0xbf, 0x86, 0xb5, 0xd5, 0x11, 0x18, 0xcd, 0x02, 0xfa, 0x64, 0x0d, 0x33, 0x46, 0x5c, 0xac,
	0xb2, 0x58, 0xee, 0xb4, 0xb0, 0xf5, 0x63, 0x3e, 0x72, 0xc9, 0x3e, 0x00, 0xba, 0x06, 0x67, 0x43,
	0x69, 0x85, 0xe1, 0xb5, 0x20, 0xec, 0xd3, 0xb8, 0xb0, 0x47, 0xe9, 0xa8, 0x83, 0x2a, 0xa5, 0x22,
	0x70, 0xf0, 0xec, 0x54, 0x0e, 0x34, 0x8d, 0x6e, 0x40, 0xa1, 0x9b, 0x97, 0xc3, 0xa9, 0x1f, 0xb8,
	0xf8, 0x29, 0xce, 0xc5, 0x71, 0x1e, 0x5d, 0x87, 0x42, 0x85, 0x51, 0xb7, 0x5d, 0xc3, 0x6c, 0x89,
	0x78, 0xbe, 0x23, 0xda, 0x0c, 0x5b, 0xbf, 0x28, 0x27, 0x59, 0xe9, 0xa4, 0x4c, 0x7c, 0x87, 0x75,
	0x42, 0x0f, 0xc7, 0x60, 0x34, 0x0b, 0xa0, 0x85, 0x6e, 0xb9, 0x63, 0xbd, 0x88, 0x8b, 0x1f, 0x01,
	0xaf, 0xa4, 0x7e, 0xdf, 0xb1, 0x5f, 0x64, 0x16, 0x92, 0x69, 0xc3, 0x34, 0x17, 0x92, 0xe9, 0x82,
	0x89, 0x16, 0x52, 0xe9, 0x73, 0xe6, 0xc3, 0xfc, 0xd8, 0x1f, 0x06, 0x14, 0x22, 0x05, 0xc8, 0x5b,
	0xd4, 0xe7, 0xf8, 0x7f, 0x29, 0x8d, 0x32, 0xa0, 0x30, 0x40, 0xe4, 0x75, 0xbe, 0x39, 0xf1, 0x75,
	0xfa, 0xd0, 0xf2, 0x9e, 0x2f, 0x33, 0x0b, 0xa9, 0xb4, 0x11, 0xdc, 0x6d, 0x23, 0x09, 0xc3, 0x8b,
	0x55, 0xec, 0xb8, 0x61, 0x63, 0xbd, 0x73, 0xe4, 0x5a, 0x61, 0x62, 0x8e, 0xdb, 0xe7, 0x3a, 0x97,
	0x21, 0xbb, 0xec, 0x30, 0x0f, 0x8b, 0x4a, 0xbb, 0xc1, 0xb1, 0xba, 0x4b, 0xae, 0x3c, 0x12, 0x20,
	0x07, 0xbb, 0x76, 0x56, 0x4a, 0xef, 0xb6, 0x9b, 0x2b, 0x98, 0x55, 0xa3, 0x20, 0xfa, 0x10, 0x72,
	0xea, 0x18, 0x16, 0xda, 0x7a, 0xdc, 0x2b, 0xf4, 0xb2, 0xc1, 0x1b, 0x2a, 0xc1, 0x92, 0x70, 0x98,
	0xb4, 0xfe, 0x2a, 0xf6, 0x0d, 0x7b, 0xe1, 0x6e, 0xec, 0x25, 0x41, 0x5b, 0x81, 0xf5, 0xd7, 0xa7,
	0x88, 0xad, 0x59, 0xf4, 0x06, 0x64, 0x16, 0x49, 0x93, 0x88, 0x25, 0xf2, 0x00, 0x5b, 0x1b, 0xd1,
	0x96, 0xec, 0xca, 0xd1, 0x5b, 0x00, 0xf2, 0x70, 0x83, 0xb6, 0x7d, 0x61, 0x7d, 0x17, 0xa5, 0x22,
	0x0a, 0x34, 0x07, 0x96, 0x3c, 0xa9, 0x1e, 0xfe, 0x9c, 0x88, 0xd5, 0x32, 0x75, 0x3b, 0xca, 0xe8,
	0xfb, 0xa8, 0xd1, 0x89, 0x18, 0xfa, 0x08, 0x2e, 0x1e, 0xd1, 0x55, 0x9c, 0x4e, 0x83, 0x3a, 0xae,
	0xf2, 0xf2, 0x38, 0xea, 0x25, 0x8e, 0x94, 0x45, 0xf1, 0xeb, 0x61, 0x51, 0x3c, 0x4b, 0x43, 0x4e,
	0x17, 0x85, 0x2e, 0xf6, 0x0f, 0x60, 0xe8, 0xa6, 0x2f, 0x18, 0xc1, 0xb2, 0x2e, 0x06, 0xc6, 0xb3,
	0x33, 0x96, 0x7c, 0xae, 0x1e, 0x6a, 0x2a, 0x40, 0xc2, 0xd2, 0x0b, 0x79, 0x34, 0x09, 0xf9, 0xbb,
	0xf8, 0xbe, 0x0e, 0x2c, 0xdf, 0xed, 0x51, 0x34, 0xad, 0x23, 0x4a, 0x74, 0x15, 0x2e, 0x74, 0x25,
	0x3a, 0x47, 0x2e, 0xcd, 0xd6, 0xa3, 0x66, 0x27, 0x40, 0xa3, 0x3b, 0x83, 0x90, 0x92, 0x69, 0xa0,
	0x37, 0x01, 0x22, 0xe3, 0x33, 0xba, 0x22, 0x22, 0x72, 0x54, 0x82, 0x74, 0x68, 0x6f, 0x15, 0x4a,
	0x03, 0xe3, 0xc3, 0x9a, 0x39, 0x94, 0xa2, 0x59, 0x18, 0x56, 0xbc, 0xea, 0x2c, 0x0b, 0x9d, 0xd4,
	0x6c, 0x3d, 0x18, 0x9a, 0x87, 0xbc, 0x76, 0x31, 0x4f, 0x3c, 0xcc, 0x05, 0xd7, 0x4b, 0x28, 0x1c,
	0x13, 0x12, 0xa5, 0x6e, 0x47, 0x6b, 0xc3, 0xd7, 0xe8, 0xb5, 0x41, 0x33, 0x90, 0xd1, 0x1b, 0x09,
	0xd7, 0xad, 0x73, 0x31, 0x75, 0xda, 0xc5, 0xd0, 0x14, 0x0c, 0x85, 0x0b, 0xc0, 0x8a, 0xb1, 0x08,
	0xa1, 0x80, 0x0f, 0xdb, 0xf0, 0xb5, 0x38, 0x3e, 0xec, 0x3f, 0x99, 0x53, 0x38, 0xde, 0x47, 0xe3,
	0x73, 0x0a, 0xa7, 0xfa, 0x65, 0xc8, 0x56, 0xb1, 0x4b, 0x18, 0xae, 0xc9, 0x38, 0x17, 0x63, 0xac,
	0xa2, 0xa0, 0x8a, 0xf5, 0x25, 0x25, 0x32, 0xd6, 0xeb, 0xf1, 0xb1, 0x34, 0x86, 0xae, 0xf5, 0xdb,
	0x20, 0x6f, 0xbf, 0xc2, 0x02, 0x79, 0xaf, 0x67, 0x81, 0x4c, 0x9c, 0x6e, 0x7f, 0xa0, 0xb9, 0xbe,
	0xb3, 0xf9, 0xdd, 0x57, 0x18, 0xcd, 0xe8, 0xfd, 0xa0, 0xd4, 0xd4, 0x9a, 0x91, 0xa1, 0x27, 0x63,
	0x42, 0xf7, 0x90, 0xc1, 0xc8, 0x39, 0xa9, 0xc1, 0x22, 0x8a, 0xe0, 0xa7, 0xc5, 0x7f, 0x35, 0x56,
	0x1f, 0xe0, 0x4a, 0xf2, 0xf9, 0x8e, 0x6d, 0xc8, 0x19, 0xf1, 0x5b, 0x38, 0x23, 0x26, 0xe6, 0xa1,
	0x70, 0x6c, 0xd7, 0xa1, 0x1c, 0x64, 0x3e, 0xf5, 0x5d, 0x5c, 0x27, 0x3e, 0x76, 0xcd, 0x04, 0x4a,
	0x43, 0xf2, 0x96, 0xc3, 0x85, 0x69, 0x04, 0x5f, 0x4b, 0x4e, 0x1d, 0x9b, 0x67, 0xd0, 0x30, 0xa4,
	0x03, 0x99, 0x3c, 0x0d, 0x4c, 0x3c, 0x36, 0x64, 0x31, 0xa9, 0xdd, 0x82, 0x0a, 0x90, 0xab, 0x38,
	0x5c, 0x2c, 0xd3, 0x0a, 0xc3, 0x1c, 0xfb, 0xc2, 0x4c, 0x48, 0x91, 0x3a, 0x2c, 0xd3, 0x8a, 0xf2,
	0x55, 0x80, 0x9c, 0x1c, 0xe6, 0xb7, 0xb9, 0xaa, 0x2f, 0xf3, 0x0c, 0x32, 0x61, 0xf8, 0xe6, 0xfd,
	0x5a, 0xa3, 0xed, 0x62, 0xa9, 0x31, 0x93, 0xe8, 0x2c, 0x64, 0x0f, 0x25, 0xb4, 0x65, 0xa6, 0xd1,
	0x79, 0x28, 0xdc, 0xf6, 0xa5, 0x40, 0xd5, 0x7d, 0x8b, 0x32, 0x61, 0x9a, 0x11, 0xb1, 0x1a, 0x28,
	0x52, 0x5c, 0x2a, 0xdf, 0xdb, 0xfa, 0xab, 0x68, 0x3c, 0xdf, 0x2b, 0x1a, 0x5b, 0x7b, 0x45, 0x63,
	0x7b, 0xaf, 0x68, 0xec, 0xec, 0x15, 0x8d, 0x3f, 0xf7, 0x8a, 0x89, 0x6f, 0xf7, 0x8b, 0x89, 0xa7,
	0xfb, 0x45, 0x63, 0x7b, 0xbf, 0x98, 0xd8, 0xd9, 0x2f, 0x26, 0xfe, 0x7e, 0x62, 0x1b, 0x07, 0x4f,
	0xec, 0xa1, 0x3b, 0x98, 0x73, 0xc7, 0xc3, 0xeb, 0x9b, 0x76, 0xf2, 0x63, 0xec, 0xb8, 0x1b, 0x9b,
	0x76, 0xea, 0x33, 0xc2, 0x89, 0xf8, 0x79, 0xd3, 0x1e, 0x09, 0xff, 0x53, 0x9a, 0x09, 0xe6, 0xce,
	0xcb, 0x4d, 0x3b, 0xaf, 0x8f, 0x12, 0xa3, 0x6c, 0x65, 0x50, 0xfe, 0xda, 0xbd, 0xf4, 0x6f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xd6, 0x6f, 0x89, 0xe8, 0x83, 0x0b, 0x00, 0x00,
}

func (this *LRegisterRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LRegisterRequest)
	if !ok {
		that2, ok := that.(LRegisterRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Polymorph != that1.Polymorph {
		return false
	}
	if !this.AnyRecordLazy.Equal(&that1.AnyRecordLazy) {
		return false
	}
	if this.Flags != that1.Flags {
		return false
	}
	if !this.AnticipatedRef.Equal(&that1.AnticipatedRef) {
		return false
	}
	if this.OverrideRecordType != that1.OverrideRecordType {
		return false
	}
	if !this.OverridePrevRef.Equal(&that1.OverridePrevRef) {
		return false
	}
	if !this.OverrideRootRef.Equal(&that1.OverrideRootRef) {
		return false
	}
	if !this.OverrideReasonRef.Equal(&that1.OverrideReasonRef) {
		return false
	}
	if !this.ProducerSignature.Equal(&that1.ProducerSignature) {
		return false
	}
	if !this.ProducedBy.Equal(&that1.ProducedBy) {
		return false
	}
	return true
}
func (this *LRegisterResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LRegisterResponse)
	if !ok {
		that2, ok := that.(LRegisterResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Flags != that1.Flags {
		return false
	}
	if !this.AnticipatedRef.Equal(&that1.AnticipatedRef) {
		return false
	}
	if !this.RegistrarSignature.Equal(&that1.RegistrarSignature) {
		return false
	}
	return true
}
func (this *LReadRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LReadRequest)
	if !ok {
		that2, ok := that.(LReadRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Flags != that1.Flags {
		return false
	}
	if this.TargetPulse != that1.TargetPulse {
		return false
	}
	if !this.TargetRootRef.Equal(&that1.TargetRootRef) {
		return false
	}
	if !this.TargetStartRef.Equal(&that1.TargetStartRef) {
		return false
	}
	if !this.TargetStopRef.Equal(&that1.TargetStopRef) {
		return false
	}
	if this.LimitSize != that1.LimitSize {
		return false
	}
	if this.LimitCount != that1.LimitCount {
		return false
	}
	if this.LimitRecordWithBodyCount != that1.LimitRecordWithBodyCount {
		return false
	}
	if this.LimitRecordWithPayloadCount != that1.LimitRecordWithPayloadCount {
		return false
	}
	return true
}
func (this *LReadResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LReadResponse)
	if !ok {
		that2, ok := that.(LReadResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Entries) != len(that1.Entries) {
		return false
	}
	for i := range this.Entries {
		if !this.Entries[i].Equal(&that1.Entries[i]) {
			return false
		}
	}
	if this.NextRecordSize != that1.NextRecordSize {
		return false
	}
	if this.NextRecordPayloadsSize != that1.NextRecordPayloadsSize {
		return false
	}
	return true
}
func (this *LReadResponse_Entry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LReadResponse_Entry)
	if !ok {
		that2, ok := that.(LReadResponse_Entry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RecordType != that1.RecordType {
		return false
	}
	if len(this.Payloads) != len(that1.Payloads) {
		return false
	}
	for i := range this.Payloads {
		if !bytes.Equal(this.Payloads[i], that1.Payloads[i]) {
			return false
		}
	}
	if !this.RecordBinary.Equal(&that1.RecordBinary) {
		return false
	}
	if !this.PayloadDigests.Equal(&that1.PayloadDigests) {
		return false
	}
	if !this.RecordRef.Equal(&that1.RecordRef) {
		return false
	}
	if !this.PrevRef.Equal(&that1.PrevRef) {
		return false
	}
	if !this.RootRef.Equal(&that1.RootRef) {
		return false
	}
	if !this.ReasonRef.Equal(&that1.ReasonRef) {
		return false
	}
	if !this.RedirectRef.Equal(&that1.RedirectRef) {
		return false
	}
	if !this.RejoinRef.Equal(&that1.RejoinRef) {
		return false
	}
	if !this.ProducerSignature.Equal(&that1.ProducerSignature) {
		return false
	}
	if !this.ProducedBy.Equal(&that1.ProducedBy) {
		return false
	}
	if !this.RegistrarSignature.Equal(&that1.RegistrarSignature) {
		return false
	}
	if !this.RegisteredBy.Equal(&that1.RegisteredBy) {
		return false
	}
	if this.RecordSize != that1.RecordSize {
		return false
	}
	if this.RecordPayloadsSize != that1.RecordPayloadsSize {
		return false
	}
	return true
}
func (m *LRegisterRequest) Visit(ctx MessageVisitor) error {
	if err := ctx.MsgRecord(m, 19, &m.AnyRecordLazy); err != nil {
		return err
	}
	return ctx.Message(m, 1200)
}

const TypeLRegisterRequestPolymorphID = 1200

func (*LRegisterRequest) GetDefaultPolymorphID() uint64 {
	return 1200
}

func (m *LRegisterRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	if n != size {
		panic("illegal state")
	}
	return dAtA[:n], nil
}

func (m *LRegisterRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LRegisterRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	{
		size, err := m.ProducedBy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x73
			i--
			dAtA[i] = 0x82
		}
	}
	{
		size, err := m.ProducerSignature.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x72
			i--
			dAtA[i] = 0xfa
		}
	}
	{
		size, err := m.OverrideReasonRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x72
			i--
			dAtA[i] = 0x92
		}
	}
	{
		size, err := m.OverrideRootRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x72
			i--
			dAtA[i] = 0x8a
		}
	}
	{
		size, err := m.OverridePrevRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x72
			i--
			dAtA[i] = 0x82
		}
	}
	if m.OverrideRecordType != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.OverrideRecordType))
		i--
		dAtA[i] = 0x71
		i--
		dAtA[i] = 0xc0
	}
	{
		size, err := m.AnticipatedRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x70
			i--
			dAtA[i] = 0xca
		}
	}
	if m.Flags != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x70
		i--
		dAtA[i] = 0xc0
	}
	{
		size, err := m.AnyRecordLazy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if i < len(dAtA) {
		id := uint64(m.Polymorph)
		if id == 0 {
			id = 1200
		}
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(id))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	return len(dAtA) - i, nil
}

func (m *LRegisterResponse) Visit(ctx MessageVisitor) error {
	return ctx.Message(m, 1202)
}

const TypeLRegisterResponsePolymorphID = 1202

func (*LRegisterResponse) GetDefaultPolymorphID() uint64 {
	return 1202
}

func (m *LRegisterResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	if n != size {
		panic("illegal state")
	}
	return dAtA[:n], nil
}

func (m *LRegisterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LRegisterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	{
		size, err := m.RegistrarSignature.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x70
			i--
			dAtA[i] = 0xea
		}
	}
	{
		size, err := m.AnticipatedRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x70
			i--
			dAtA[i] = 0xca
		}
	}
	if m.Flags != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x70
		i--
		dAtA[i] = 0xc0
	}
	i = encodeVarintProtoVnlmn(dAtA, i, uint64(1202))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	return len(dAtA) - i, nil
}

func (m *LReadRequest) Visit(ctx MessageVisitor) error {
	return ctx.Message(m, 1204)
}

const TypeLReadRequestPolymorphID = 1204

func (*LReadRequest) GetDefaultPolymorphID() uint64 {
	return 1204
}

func (m *LReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	if n != size {
		panic("illegal state")
	}
	return dAtA[:n], nil
}

func (m *LReadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LReadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	if m.LimitRecordWithPayloadCount != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.LimitRecordWithPayloadCount))
		i--
		dAtA[i] = 0x71
		i--
		dAtA[i] = 0xa8
	}
	if m.LimitRecordWithBodyCount != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.LimitRecordWithBodyCount))
		i--
		dAtA[i] = 0x71
		i--
		dAtA[i] = 0xa0
	}
	if m.LimitCount != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.LimitCount))
		i--
		dAtA[i] = 0x71
		i--
		dAtA[i] = 0x98
	}
	if m.LimitSize != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.LimitSize))
		i--
		dAtA[i] = 0x71
		i--
		dAtA[i] = 0x90
	}
	{
		size, err := m.TargetStopRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x70
			i--
			dAtA[i] = 0xe2
		}
	}
	{
		size, err := m.TargetStartRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x70
			i--
			dAtA[i] = 0xda
		}
	}
	{
		size, err := m.TargetRootRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x70
			i--
			dAtA[i] = 0xd2
		}
	}
	if m.TargetPulse != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.TargetPulse))
		i--
		dAtA[i] = 0x70
		i--
		dAtA[i] = 0xc8
	}
	if m.Flags != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x70
		i--
		dAtA[i] = 0xc0
	}
	i = encodeVarintProtoVnlmn(dAtA, i, uint64(1204))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	return len(dAtA) - i, nil
}

func (m *LReadResponse) Visit(ctx MessageVisitor) error {
	return ctx.Message(m, 1205)
}

const TypeLReadResponsePolymorphID = 1205

func (*LReadResponse) GetDefaultPolymorphID() uint64 {
	return 1205
}

func (m *LReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	if n != size {
		panic("illegal state")
	}
	return dAtA[:n], nil
}

func (m *LReadResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LReadResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	if m.NextRecordPayloadsSize != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.NextRecordPayloadsSize))
		i--
		dAtA[i] = 0x70
		i--
		dAtA[i] = 0xd0
	}
	if m.NextRecordSize != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.NextRecordSize))
		i--
		dAtA[i] = 0x70
		i--
		dAtA[i] = 0xc8
	}
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x70
			i--
			dAtA[i] = 0xc2
		}
	}
	i = encodeVarintProtoVnlmn(dAtA, i, uint64(1205))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	return len(dAtA) - i, nil
}

func (m *LReadResponse_Entry) Visit(ctx MessageVisitor) error {
	return ctx.Message(m, 0)
}

func (m *LReadResponse_Entry) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	if n != size {
		panic("illegal state")
	}
	return dAtA[:n], nil
}

func (m *LReadResponse_Entry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LReadResponse_Entry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	if m.RecordPayloadsSize != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.RecordPayloadsSize))
		i--
		dAtA[i] = 0x70
		i--
		dAtA[i] = 0xd0
	}
	if m.RecordSize != 0 {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.RecordSize))
		i--
		dAtA[i] = 0x70
		i--
		dAtA[i] = 0xc8
	}
	{
		size, err := m.RegisteredBy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xea
		}
	}
	{
		size, err := m.RegistrarSignature.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xe2
		}
	}
	{
		size, err := m.ProducedBy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xd2
		}
	}
	{
		size, err := m.ProducerSignature.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xba
		}
	}
	{
		size, err := m.RejoinRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	{
		size, err := m.RedirectRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	{
		size, err := m.ReasonRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	{
		size, err := m.RootRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	{
		size, err := m.PrevRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	{
		size, err := m.RecordRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	{
		size, err := m.PayloadDigests.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	{
		size, err := m.RecordBinary.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.Payloads) > 0 {
		for iNdEx := len(m.Payloads) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Payloads[iNdEx])
			copy(dAtA[i:], m.Payloads[iNdEx])
			i--
			dAtA[i] = 132
			i = encodeVarintProtoVnlmn(dAtA, i, uint64(len(m.Payloads[iNdEx])+1))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if i < len(dAtA) {
		i = encodeVarintProtoVnlmn(dAtA, i, uint64(m.RecordType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	return len(dAtA) - i, nil
}

func encodeVarintProtoVnlmn(dAtA []byte, offset int, v uint64) int {
	offset -= sovProtoVnlmn(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}

func init() {
	RegisterMessageType(1200, "", (*LRegisterRequest)(nil))
	RegisterMessageType(1202, "", (*LRegisterResponse)(nil))
	RegisterMessageType(1204, "", (*LReadRequest)(nil))
	RegisterMessageType(1205, "", (*LReadResponse)(nil))
}

func (m *LRegisterRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if l = m.AnyRecordLazy.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if m.Flags != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.Flags))
	}
	if l = m.AnticipatedRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if m.OverrideRecordType != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.OverrideRecordType))
	}
	if l = m.OverridePrevRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.OverrideRootRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.OverrideReasonRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.ProducerSignature.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.ProducedBy.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if n > 0 {
		id := uint64(m.Polymorph)
		if id == 0 {
			id = 1200
		}
		n += 2 + sovProtoVnlmn(id)
	}
	return n
}

func (m *LRegisterResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flags != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.Flags))
	}
	if l = m.AnticipatedRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.RegistrarSignature.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	n += 2 + sovProtoVnlmn(1202)
	return n
}

func (m *LReadRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flags != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.Flags))
	}
	if m.TargetPulse != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.TargetPulse))
	}
	if l = m.TargetRootRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.TargetStartRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.TargetStopRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if m.LimitSize != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.LimitSize))
	}
	if m.LimitCount != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.LimitCount))
	}
	if m.LimitRecordWithBodyCount != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.LimitRecordWithBodyCount))
	}
	if m.LimitRecordWithPayloadCount != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.LimitRecordWithPayloadCount))
	}
	n += 2 + sovProtoVnlmn(1204)
	return n
}

func (m *LReadResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.ProtoSize()
			n += 2 + l + sovProtoVnlmn(uint64(l))
		}
	}
	if m.NextRecordSize != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.NextRecordSize))
	}
	if m.NextRecordPayloadsSize != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.NextRecordPayloadsSize))
	}
	n += 2 + sovProtoVnlmn(1205)
	return n
}

func (m *LReadResponse_Entry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Payloads) > 0 {
		for _, b := range m.Payloads {
			l = len(b)
			if l > 0 {
				l++
			}
			n += 2 + l + sovProtoVnlmn(uint64(l))
		}
	}
	if l = m.RecordBinary.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.PayloadDigests.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.RecordRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.PrevRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.RootRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.ReasonRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.RedirectRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.RejoinRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.ProducerSignature.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.ProducedBy.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.RegistrarSignature.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if l = m.RegisteredBy.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoVnlmn(uint64(l))
	}
	if m.RecordSize != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.RecordSize))
	}
	if m.RecordPayloadsSize != 0 {
		n += 2 + sovProtoVnlmn(uint64(m.RecordPayloadsSize))
	}
	if n > 0 {
		n += 2 + sovProtoVnlmn(uint64(m.RecordType))
	}
	return n
}

func sovProtoVnlmn(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProtoVnlmn(x uint64) (n int) {
	return sovProtoVnlmn(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LRegisterRequest) Unmarshal(dAtA []byte) error {
	return m.UnmarshalWithUnknownCallback(dAtA, skipProtoVnlmn)
}
func (m *LRegisterRequest) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoVnlmn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LRegisterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LRegisterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Polymorph", wireType)
			}
			m.Polymorph = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Polymorph |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyRecordLazy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AnyRecordLazy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1800:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= RegistrationFlags(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1801:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnticipatedRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AnticipatedRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1816:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideRecordType", wireType)
			}
			m.OverrideRecordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverrideRecordType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1824:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverridePrevRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OverridePrevRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1825:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideRootRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OverrideRootRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1826:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideReasonRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OverrideReasonRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1839:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProducerSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1840:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducedBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProducedBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				l = iNdEx
				break
			}
			if skippy == 0 {
				if skippy, err = skipProtoVnlmn(dAtA[iNdEx:]); err != nil {
					return err
				}
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LRegisterResponse) Unmarshal(dAtA []byte) error {
	return m.UnmarshalWithUnknownCallback(dAtA, skipProtoVnlmn)
}
func (m *LRegisterResponse) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoVnlmn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LRegisterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LRegisterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1800:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= RegistrationFlags(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1801:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnticipatedRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AnticipatedRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1805:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistrarSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RegistrarSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				l = iNdEx
				break
			}
			if skippy == 0 {
				if skippy, err = skipProtoVnlmn(dAtA[iNdEx:]); err != nil {
					return err
				}
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LReadRequest) Unmarshal(dAtA []byte) error {
	return m.UnmarshalWithUnknownCallback(dAtA, skipProtoVnlmn)
}
func (m *LReadRequest) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoVnlmn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1800:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= ReadFlags(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1801:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPulse", wireType)
			}
			m.TargetPulse = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetPulse |= PulseNumber(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1802:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetRootRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TargetRootRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1803:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetStartRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TargetStartRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1804:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetStopRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TargetStopRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1810:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitSize", wireType)
			}
			m.LimitSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1811:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitCount", wireType)
			}
			m.LimitCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1812:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitRecordWithBodyCount", wireType)
			}
			m.LimitRecordWithBodyCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitRecordWithBodyCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1813:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitRecordWithPayloadCount", wireType)
			}
			m.LimitRecordWithPayloadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitRecordWithPayloadCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				l = iNdEx
				break
			}
			if skippy == 0 {
				if skippy, err = skipProtoVnlmn(dAtA[iNdEx:]); err != nil {
					return err
				}
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LReadResponse) Unmarshal(dAtA []byte) error {
	return m.UnmarshalWithUnknownCallback(dAtA, skipProtoVnlmn)
}
func (m *LReadResponse) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoVnlmn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1800:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, LReadResponse_Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1801:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextRecordSize", wireType)
			}
			m.NextRecordSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextRecordSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1802:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextRecordPayloadsSize", wireType)
			}
			m.NextRecordPayloadsSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextRecordPayloadsSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				l = iNdEx
				break
			}
			if skippy == 0 {
				if skippy, err = skipProtoVnlmn(dAtA[iNdEx:]); err != nil {
					return err
				}
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LReadResponse_Entry) Unmarshal(dAtA []byte) error {
	return m.UnmarshalWithUnknownCallback(dAtA, skipProtoVnlmn)
}
func (m *LReadResponse_Entry) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoVnlmn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payloads", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if byteLen > 0 {
				if dAtA[iNdEx] != 132 {
					return ErrExpectedBinaryMarkerProtoVnlmn
				}
				iNdEx++
			}
			m.Payloads = append(m.Payloads, make([]byte, postIndex-iNdEx))
			copy(m.Payloads[len(m.Payloads)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordBinary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecordBinary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadDigests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PayloadDigests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecordRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrevRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RootRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReasonRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RedirectRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejoinRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RejoinRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProducerSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducedBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProducedBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistrarSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RegistrarSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RegisteredBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1801:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordSize", wireType)
			}
			m.RecordSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1802:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordPayloadsSize", wireType)
			}
			m.RecordPayloadsSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordPayloadsSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				l = iNdEx
				break
			}
			if skippy == 0 {
				if skippy, err = skipProtoVnlmn(dAtA[iNdEx:]); err != nil {
					return err
				}
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoVnlmn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProtoVnlmn(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProtoVnlmn
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtoVnlmn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProtoVnlmn
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProtoVnlmn
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProtoVnlmn
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProtoVnlmn        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProtoVnlmn          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProtoVnlmn = fmt.Errorf("proto: unexpected end of group")
	ErrExpectedBinaryMarkerProtoVnlmn = fmt.Errorf("proto: binary marker was expected")
)
