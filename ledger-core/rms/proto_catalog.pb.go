// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto_catalog.proto

package rms

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/insolar/assured-ledger/ledger-core/insproto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type RecordExcerptForCatalogEntry struct {
	RecordType     uint32 `protobuf:"varint,16,opt,name=RecordType,proto3" json:"RecordType"`
	RecordBodyHash Binary `protobuf:"bytes,19,opt,name=RecordBodyHash,proto3" json:"RecordBodyHash"`
	// MUST match with Excerpt portion of CatalogEntry
	PrevRef     Reference `protobuf:"bytes,24,opt,name=PrevRef,proto3" json:"PrevRef"`
	RootRef     Reference `protobuf:"bytes,25,opt,name=RootRef,proto3" json:"RootRef"`
	ReasonRef   Reference `protobuf:"bytes,26,opt,name=ReasonRef,proto3" json:"ReasonRef"`
	RedirectRef Reference `protobuf:"bytes,27,opt,name=RedirectRef,proto3" json:"RedirectRef"`
	RejoinRef   Reference `protobuf:"bytes,28,opt,name=RejoinRef,proto3" json:"RejoinRef"`
}

func (m *RecordExcerptForCatalogEntry) Reset()         { *m = RecordExcerptForCatalogEntry{} }
func (m *RecordExcerptForCatalogEntry) String() string { return proto.CompactTextString(m) }
func (*RecordExcerptForCatalogEntry) ProtoMessage()    {}
func (*RecordExcerptForCatalogEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb898eec77add237, []int{0}
}
func (m *RecordExcerptForCatalogEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordExcerptForCatalogEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecordExcerptForCatalogEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordExcerptForCatalogEntry.Merge(m, src)
}
func (m *RecordExcerptForCatalogEntry) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RecordExcerptForCatalogEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordExcerptForCatalogEntry.DiscardUnknown(m)
}

var xxx_messageInfo_RecordExcerptForCatalogEntry proto.InternalMessageInfo

func (m *RecordExcerptForCatalogEntry) GetRecordType() uint32 {
	if m != nil {
		return m.RecordType
	}
	return 0
}

func (m *RecordExcerptForCatalogEntry) GetRecordBodyHash() Binary {
	if m != nil {
		return m.RecordBodyHash
	}
	return Binary{}
}

func (m *RecordExcerptForCatalogEntry) GetPrevRef() Reference {
	if m != nil {
		return m.PrevRef
	}
	return Reference{}
}

func (m *RecordExcerptForCatalogEntry) GetRootRef() Reference {
	if m != nil {
		return m.RootRef
	}
	return Reference{}
}

func (m *RecordExcerptForCatalogEntry) GetReasonRef() Reference {
	if m != nil {
		return m.ReasonRef
	}
	return Reference{}
}

func (m *RecordExcerptForCatalogEntry) GetRedirectRef() Reference {
	if m != nil {
		return m.RedirectRef
	}
	return Reference{}
}

func (m *RecordExcerptForCatalogEntry) GetRejoinRef() Reference {
	if m != nil {
		return m.RejoinRef
	}
	return Reference{}
}

type CatalogEntry struct {
	// Start of fixed-size portion.
	// Use of fixed-size fields allows direct memory mapping for fast access to a few critical fields
	RecordType     uint32      `protobuf:"fixed32,16,opt,name=RecordType,proto3" json:"RecordType"`
	BodyLoc        uint64      `protobuf:"fixed64,17,opt,name=BodyLoc,proto3" json:"BodyLoc"`
	PayloadLoc     uint64      `protobuf:"fixed64,18,opt,name=PayloadLoc,proto3" json:"PayloadLoc"`
	RecordBodyHash Binary      `protobuf:"bytes,19,opt,name=RecordBodyHash,proto3" json:"RecordBodyHash"`
	InDropOrdinal  uint32      `protobuf:"fixed32,20,opt,name=InDropOrdinal,proto3" json:"InDropOrdinal"`
	ExtensionLoc   ExtLocators `protobuf:"bytes,21,opt,name=ExtensionLoc,proto3" json:"ExtensionLoc"`
	// Start of Excerpt portion
	// MUST match with RecordExcerpt
	PrevRef           Reference `protobuf:"bytes,24,opt,name=PrevRef,proto3" json:"PrevRef"`
	RootRef           Reference `protobuf:"bytes,25,opt,name=RootRef,proto3" json:"RootRef"`
	ReasonRef         Reference `protobuf:"bytes,26,opt,name=ReasonRef,proto3" json:"ReasonRef"`
	RedirectRef       Reference `protobuf:"bytes,27,opt,name=RedirectRef,proto3" json:"RedirectRef"`
	RejoinRef         Reference `protobuf:"bytes,28,opt,name=RejoinRef,proto3" json:"RejoinRef"`
	RecapRef          Reference `protobuf:"bytes,40,opt,name=RecapRef,proto3" json:"RecapRef"`
	ProducerSignature Binary    `protobuf:"bytes,41,opt,name=ProducerSignature,proto3" json:"ProducerSignature"`
	ProducedBy        Reference `protobuf:"bytes,42,opt,name=ProducedBy,proto3" json:"ProducedBy"`
	// Token ProducerToken = 43;
	RegistrarSignature Binary `protobuf:"bytes,44,opt,name=RegistrarSignature,proto3" json:"RegistrarSignature"`
}

func (m *CatalogEntry) Reset()         { *m = CatalogEntry{} }
func (m *CatalogEntry) String() string { return proto.CompactTextString(m) }
func (*CatalogEntry) ProtoMessage()    {}
func (*CatalogEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb898eec77add237, []int{1}
}
func (m *CatalogEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CatalogEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CatalogEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogEntry.Merge(m, src)
}
func (m *CatalogEntry) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CatalogEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogEntry.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogEntry proto.InternalMessageInfo

func (m *CatalogEntry) GetRecordType() uint32 {
	if m != nil {
		return m.RecordType
	}
	return 0
}

func (m *CatalogEntry) GetBodyLoc() uint64 {
	if m != nil {
		return m.BodyLoc
	}
	return 0
}

func (m *CatalogEntry) GetPayloadLoc() uint64 {
	if m != nil {
		return m.PayloadLoc
	}
	return 0
}

func (m *CatalogEntry) GetRecordBodyHash() Binary {
	if m != nil {
		return m.RecordBodyHash
	}
	return Binary{}
}

func (m *CatalogEntry) GetInDropOrdinal() uint32 {
	if m != nil {
		return m.InDropOrdinal
	}
	return 0
}

func (m *CatalogEntry) GetExtensionLoc() ExtLocators {
	if m != nil {
		return m.ExtensionLoc
	}
	return ExtLocators{}
}

func (m *CatalogEntry) GetPrevRef() Reference {
	if m != nil {
		return m.PrevRef
	}
	return Reference{}
}

func (m *CatalogEntry) GetRootRef() Reference {
	if m != nil {
		return m.RootRef
	}
	return Reference{}
}

func (m *CatalogEntry) GetReasonRef() Reference {
	if m != nil {
		return m.ReasonRef
	}
	return Reference{}
}

func (m *CatalogEntry) GetRedirectRef() Reference {
	if m != nil {
		return m.RedirectRef
	}
	return Reference{}
}

func (m *CatalogEntry) GetRejoinRef() Reference {
	if m != nil {
		return m.RejoinRef
	}
	return Reference{}
}

func (m *CatalogEntry) GetRecapRef() Reference {
	if m != nil {
		return m.RecapRef
	}
	return Reference{}
}

func (m *CatalogEntry) GetProducerSignature() Binary {
	if m != nil {
		return m.ProducerSignature
	}
	return Binary{}
}

func (m *CatalogEntry) GetProducedBy() Reference {
	if m != nil {
		return m.ProducedBy
	}
	return Reference{}
}

func (m *CatalogEntry) GetRegistrarSignature() Binary {
	if m != nil {
		return m.RegistrarSignature
	}
	return Binary{}
}

type ExtLocators struct {
}

func (m *ExtLocators) Reset()         { *m = ExtLocators{} }
func (m *ExtLocators) String() string { return proto.CompactTextString(m) }
func (*ExtLocators) ProtoMessage()    {}
func (*ExtLocators) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb898eec77add237, []int{2}
}
func (m *ExtLocators) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtLocators) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExtLocators) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtLocators.Merge(m, src)
}
func (m *ExtLocators) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExtLocators) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtLocators.DiscardUnknown(m)
}

var xxx_messageInfo_ExtLocators proto.InternalMessageInfo

func init() {
	proto.RegisterType((*RecordExcerptForCatalogEntry)(nil), "rms.RecordExcerptForCatalogEntry")
	proto.RegisterType((*CatalogEntry)(nil), "rms.CatalogEntry")
	proto.RegisterType((*ExtLocators)(nil), "rms.ExtLocators")
}

func init() { proto.RegisterFile("proto_catalog.proto", fileDescriptor_cb898eec77add237) }

var fileDescriptor_cb898eec77add237 = []byte{
	// 563 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x94, 0xb1, 0x6f, 0xd3, 0x4e,
	0x14, 0xc7, 0xed, 0x5f, 0xa3, 0x24, 0xbd, 0xb4, 0x95, 0x73, 0xf9, 0x21, 0x99, 0x50, 0x9c, 0x28,
	0x62, 0x30, 0x55, 0x93, 0xa0, 0x82, 0x90, 0xe8, 0x02, 0x04, 0x82, 0x20, 0xaa, 0x44, 0x64, 0xd8,
	0xd1, 0xc5, 0xbe, 0xb8, 0x46, 0x89, 0x5f, 0xf4, 0x7c, 0x41, 0xf1, 0x96, 0x3f, 0x81, 0xa5, 0x03,
	0x1b, 0x23, 0x7f, 0x06, 0x63, 0xc6, 0x8e, 0x99, 0x10, 0x24, 0x0b, 0x7f, 0x06, 0xf2, 0xd9, 0x2d,
	0x2e, 0xb4, 0x66, 0x60, 0x64, 0xca, 0xbd, 0xf7, 0x3e, 0xdf, 0xf7, 0x7d, 0xba, 0x77, 0x31, 0xa9,
	0x4c, 0x10, 0x04, 0xbc, 0xb1, 0x99, 0x60, 0x23, 0x70, 0x5b, 0x32, 0xa2, 0x1b, 0x38, 0x0e, 0xaa,
	0x4d, 0xd7, 0x13, 0xc7, 0xd3, 0x41, 0xcb, 0x86, 0x71, 0xdb, 0x05, 0x17, 0xda, 0xb2, 0x36, 0x98,
	0x0e, 0x65, 0x24, 0x03, 0x79, 0x8a, 0x35, 0xd5, 0x47, 0x29, 0xdc, 0xf3, 0x03, 0x18, 0x31, 0x6c,
	0xb3, 0x20, 0x98, 0x22, 0x77, 0x9a, 0x23, 0xee, 0xb8, 0x1c, 0xdb, 0xf1, 0x4f, 0xd3, 0x06, 0xe4,
	0x11, 0x12, 0xb7, 0xf0, 0xfc, 0x20, 0xe9, 0xb0, 0x89, 0xe3, 0xe4, 0xd8, 0x38, 0xd9, 0x20, 0xbb,
	0x16, 0xb7, 0x01, 0x9d, 0xee, 0xcc, 0xe6, 0x38, 0x11, 0xcf, 0x00, 0x9f, 0xc4, 0x23, 0x76, 0x7d,
	0x81, 0x21, 0xbd, 0x45, 0x48, 0x5c, 0x7f, 0x1d, 0x4e, 0xb8, 0xae, 0xd5, 0x55, 0x73, 0xbb, 0x93,
	0x5b, 0x7c, 0xa9, 0x29, 0x56, 0x2a, 0x4f, 0x1f, 0x90, 0x9d, 0x38, 0xea, 0x80, 0x13, 0x3e, 0x67,
	0xc1, 0xb1, 0x5e, 0xa9, 0xab, 0x66, 0xe9, 0xa0, 0xd4, 0x8a, 0xac, 0x3a, 0x9e, 0xcf, 0x30, 0x4c,
	0x64, 0xbf, 0x80, 0xb4, 0x45, 0x0a, 0x7d, 0xe4, 0xef, 0x2c, 0x3e, 0xd4, 0x75, 0xa9, 0xd9, 0x91,
	0x1a, 0x8b, 0x0f, 0x39, 0x72, 0xdf, 0xe6, 0x89, 0xec, 0x0c, 0x8a, 0x78, 0x0b, 0x40, 0x44, 0xfc,
	0xf5, 0x2c, 0x3e, 0x81, 0xe8, 0x01, 0xd9, 0xb4, 0x38, 0x0b, 0xc0, 0x8f, 0x14, 0xd5, 0x0c, 0xc5,
	0x4f, 0x8c, 0xde, 0x27, 0x25, 0x8b, 0x3b, 0x1e, 0x72, 0x5b, 0xfa, 0xdc, 0xc8, 0x50, 0xa5, 0xc1,
	0xd8, 0xeb, 0x2d, 0x78, 0xd2, 0x6b, 0x37, 0xdb, 0x2b, 0xc1, 0x7a, 0xb9, 0xa2, 0xaa, 0x69, 0xbd,
	0x5c, 0xb1, 0xac, 0x55, 0x7a, 0xc5, 0xa2, 0xa9, 0xcd, 0xe7, 0xf3, 0xf9, 0x7f, 0x8d, 0x93, 0x3c,
	0xd9, 0xfa, 0xc3, 0x1e, 0x0a, 0x97, 0xec, 0xc1, 0x20, 0x85, 0xe8, 0x62, 0x8f, 0xc0, 0xd6, 0xcb,
	0x75, 0xd5, 0xcc, 0x9f, 0x5d, 0x46, 0x92, 0x8c, 0xba, 0xf4, 0x59, 0x38, 0x02, 0xe6, 0x44, 0x08,
	0x4d, 0x21, 0xa9, 0xfc, 0xdf, 0x6c, 0x73, 0x8f, 0x6c, 0xbf, 0xf0, 0x9f, 0x22, 0x4c, 0x5e, 0xa2,
	0xe3, 0xf9, 0x6c, 0xa4, 0xff, 0x9f, 0x9a, 0xf4, 0x62, 0x89, 0x1e, 0x92, 0xad, 0xee, 0x4c, 0x70,
	0x3f, 0xf0, 0xc0, 0x8f, 0xc6, 0xb9, 0x26, 0x4d, 0x34, 0x69, 0xd2, 0x9d, 0x89, 0x23, 0xb0, 0x99,
	0x00, 0x0c, 0x12, 0xf1, 0x05, 0xf6, 0x5f, 0x7f, 0x35, 0xf4, 0x0e, 0x29, 0x5a, 0xdc, 0x66, 0x93,
	0x48, 0x62, 0x66, 0x48, 0xce, 0x29, 0xfa, 0x90, 0x94, 0xfb, 0x08, 0xce, 0xd4, 0xe6, 0xf8, 0xca,
	0x73, 0x7d, 0x26, 0xa6, 0xc8, 0xf5, 0xdb, 0x57, 0xed, 0xf5, 0x77, 0x96, 0xde, 0x23, 0x24, 0x49,
	0x3a, 0x9d, 0x50, 0xdf, 0xcb, 0x30, 0x4d, 0x71, 0xf4, 0x31, 0xa1, 0x16, 0x77, 0xbd, 0x40, 0x20,
	0x4b, 0xf9, 0xee, 0x5f, 0xe5, 0x7b, 0x09, 0x7c, 0xfe, 0x0f, 0xb9, 0xa9, 0x99, 0x8d, 0x0a, 0x29,
	0xa5, 0x9e, 0xc6, 0x61, 0xee, 0xf3, 0xb2, 0xa6, 0x74, 0xf6, 0x17, 0xdf, 0x0c, 0xf5, 0xd3, 0xca,
	0x50, 0x17, 0x2b, 0x43, 0x3d, 0x5d, 0x19, 0xea, 0x72, 0x65, 0xa8, 0x5f, 0x57, 0x86, 0xf2, 0x7e,
	0x6d, 0x28, 0x1f, 0xd7, 0x86, 0x7a, 0xba, 0x36, 0x94, 0xe5, 0xda, 0x50, 0xbe, 0x7f, 0xa8, 0xa9,
	0x83, 0xbc, 0xfc, 0xf2, 0xdd, 0xfd, 0x11, 0x00, 0x00, 0xff, 0xff, 0x60, 0x95, 0x83, 0xbb, 0x91,
	0x05, 0x00, 0x00,
}

func (this *RecordExcerptForCatalogEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RecordExcerptForCatalogEntry)
	if !ok {
		that2, ok := that.(RecordExcerptForCatalogEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RecordType != that1.RecordType {
		return false
	}
	if !this.RecordBodyHash.Equal(&that1.RecordBodyHash) {
		return false
	}
	if !this.PrevRef.Equal(&that1.PrevRef) {
		return false
	}
	if !this.RootRef.Equal(&that1.RootRef) {
		return false
	}
	if !this.ReasonRef.Equal(&that1.ReasonRef) {
		return false
	}
	if !this.RedirectRef.Equal(&that1.RedirectRef) {
		return false
	}
	if !this.RejoinRef.Equal(&that1.RejoinRef) {
		return false
	}
	return true
}
func (this *CatalogEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CatalogEntry)
	if !ok {
		that2, ok := that.(CatalogEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RecordType != that1.RecordType {
		return false
	}
	if this.BodyLoc != that1.BodyLoc {
		return false
	}
	if this.PayloadLoc != that1.PayloadLoc {
		return false
	}
	if !this.RecordBodyHash.Equal(&that1.RecordBodyHash) {
		return false
	}
	if this.InDropOrdinal != that1.InDropOrdinal {
		return false
	}
	if !this.ExtensionLoc.Equal(&that1.ExtensionLoc) {
		return false
	}
	if !this.PrevRef.Equal(&that1.PrevRef) {
		return false
	}
	if !this.RootRef.Equal(&that1.RootRef) {
		return false
	}
	if !this.ReasonRef.Equal(&that1.ReasonRef) {
		return false
	}
	if !this.RedirectRef.Equal(&that1.RedirectRef) {
		return false
	}
	if !this.RejoinRef.Equal(&that1.RejoinRef) {
		return false
	}
	if !this.RecapRef.Equal(&that1.RecapRef) {
		return false
	}
	if !this.ProducerSignature.Equal(&that1.ProducerSignature) {
		return false
	}
	if !this.ProducedBy.Equal(&that1.ProducedBy) {
		return false
	}
	if !this.RegistrarSignature.Equal(&that1.RegistrarSignature) {
		return false
	}
	return true
}
func (this *ExtLocators) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExtLocators)
	if !ok {
		that2, ok := that.(ExtLocators)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (m *RecordExcerptForCatalogEntry) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordExcerptForCatalogEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordExcerptForCatalogEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	{
		size, err := m.RejoinRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	{
		size, err := m.RedirectRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	{
		size, err := m.ReasonRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	{
		size, err := m.RootRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	{
		size, err := m.PrevRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	{
		size, err := m.RecordBodyHash.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if i < len(dAtA) {
		i = encodeVarintProtoCatalog(dAtA, i, uint64(m.RecordType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	return len(dAtA) - i, nil
}

func (m *CatalogEntry) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CatalogEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CatalogEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	{
		size, err := m.RegistrarSignature.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xe2
		}
	}
	{
		size, err := m.ProducedBy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xd2
		}
	}
	{
		size, err := m.ProducerSignature.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xca
		}
	}
	{
		size, err := m.RecapRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xc2
		}
	}
	{
		size, err := m.RejoinRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	{
		size, err := m.RedirectRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	{
		size, err := m.ReasonRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	{
		size, err := m.RootRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	{
		size, err := m.PrevRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	{
		size, err := m.ExtensionLoc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.InDropOrdinal != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.InDropOrdinal))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa5
	}
	{
		size, err := m.RecordBodyHash.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.PayloadLoc != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PayloadLoc))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x91
	}
	if m.BodyLoc != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.BodyLoc))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x89
	}
	if i < len(dAtA) {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RecordType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x85
	}
	return len(dAtA) - i, nil
}

func (m *ExtLocators) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtLocators) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtLocators) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	if i < len(dAtA) {
		i = encodeVarintProtoCatalog(dAtA, i, uint64(0))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	return len(dAtA) - i, nil
}

func encodeVarintProtoCatalog(dAtA []byte, offset int, v uint64) int {
	offset -= sovProtoCatalog(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}

func (m *RecordExcerptForCatalogEntry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if l = m.RecordBodyHash.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.PrevRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RootRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.ReasonRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RedirectRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RejoinRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if n > 0 {
		n += 2 + sovProtoCatalog(uint64(m.RecordType))
	}
	return n
}

func (m *CatalogEntry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BodyLoc != 0 {
		n += 10
	}
	if m.PayloadLoc != 0 {
		n += 10
	}
	if l = m.RecordBodyHash.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if m.InDropOrdinal != 0 {
		n += 6
	}
	if l = m.ExtensionLoc.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.PrevRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RootRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.ReasonRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RedirectRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RejoinRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RecapRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.ProducerSignature.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.ProducedBy.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RegistrarSignature.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if n > 0 {
		n += 2 + 4
	}
	return n
}

func (m *ExtLocators) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if n > 0 {
		n += 2 + sovProtoCatalog(0)
	}
	return n
}

func sovProtoCatalog(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProtoCatalog(x uint64) (n int) {
	return sovProtoCatalog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RecordExcerptForCatalogEntry) Unmarshal(dAtA []byte) error {
	return m.UnmarshalWithUnknownCallback(dAtA, skipProtoCatalog)
}
func (m *RecordExcerptForCatalogEntry) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordExcerptForCatalogEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordExcerptForCatalogEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordBodyHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecordBodyHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrevRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RootRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReasonRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RedirectRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejoinRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RejoinRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				l = iNdEx
				break
			}
			if skippy == 0 {
				if skippy, err = skipProtoCatalog(dAtA[iNdEx:]); err != nil {
					return err
				}
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CatalogEntry) Unmarshal(dAtA []byte) error {
	return m.UnmarshalWithUnknownCallback(dAtA, skipProtoCatalog)
}
func (m *CatalogEntry) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CatalogEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CatalogEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordType = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyLoc", wireType)
			}
			m.BodyLoc = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.BodyLoc = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 18:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadLoc", wireType)
			}
			m.PayloadLoc = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.PayloadLoc = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordBodyHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecordBodyHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field InDropOrdinal", wireType)
			}
			m.InDropOrdinal = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.InDropOrdinal = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtensionLoc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExtensionLoc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrevRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RootRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReasonRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RedirectRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejoinRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RejoinRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecapRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecapRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProducerSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducedBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProducedBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistrarSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RegistrarSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				l = iNdEx
				break
			}
			if skippy == 0 {
				if skippy, err = skipProtoCatalog(dAtA[iNdEx:]); err != nil {
					return err
				}
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtLocators) Unmarshal(dAtA []byte) error {
	return m.UnmarshalWithUnknownCallback(dAtA, skipProtoCatalog)
}
func (m *ExtLocators) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtLocators: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtLocators: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				l = iNdEx
				break
			}
			if skippy == 0 {
				if skippy, err = skipProtoCatalog(dAtA[iNdEx:]); err != nil {
					return err
				}
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProtoCatalog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProtoCatalog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProtoCatalog
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProtoCatalog
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProtoCatalog
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProtoCatalog        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProtoCatalog          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProtoCatalog = fmt.Errorf("proto: unexpected end of group")
	ErrExpectedBinaryMarkerProtoCatalog = fmt.Errorf("proto: binary marker was expected")
)
