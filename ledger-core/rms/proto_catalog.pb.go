// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto_catalog.proto

package rms

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/insolar/assured-ledger/ledger-core/insproto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type RecordExcerptForCatalogEntry struct {
	RecordType     uint32 `protobuf:"varint,16,opt,name=RecordType,proto3" json:"RecordType"`
	RecordBodyHash Binary `protobuf:"bytes,19,opt,name=RecordBodyHash,proto3" json:"RecordBodyHash"`
	// MUST match with Excerpt portion of CatalogEntry
	PrevRef     Reference `protobuf:"bytes,24,opt,name=PrevRef,proto3" json:"PrevRef"`
	RootRef     Reference `protobuf:"bytes,25,opt,name=RootRef,proto3" json:"RootRef"`
	ReasonRef   Reference `protobuf:"bytes,26,opt,name=ReasonRef,proto3" json:"ReasonRef"`
	RedirectRef Reference `protobuf:"bytes,27,opt,name=RedirectRef,proto3" json:"RedirectRef"`
	RejoinRef   Reference `protobuf:"bytes,28,opt,name=RejoinRef,proto3" json:"RejoinRef"`
}

func (m *RecordExcerptForCatalogEntry) Reset()         { *m = RecordExcerptForCatalogEntry{} }
func (m *RecordExcerptForCatalogEntry) String() string { return proto.CompactTextString(m) }
func (*RecordExcerptForCatalogEntry) ProtoMessage()    {}
func (*RecordExcerptForCatalogEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb898eec77add237, []int{0}
}
func (m *RecordExcerptForCatalogEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordExcerptForCatalogEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecordExcerptForCatalogEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordExcerptForCatalogEntry.Merge(m, src)
}
func (m *RecordExcerptForCatalogEntry) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RecordExcerptForCatalogEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordExcerptForCatalogEntry.DiscardUnknown(m)
}

var xxx_messageInfo_RecordExcerptForCatalogEntry proto.InternalMessageInfo

func (m *RecordExcerptForCatalogEntry) GetRecordType() uint32 {
	if m != nil {
		return m.RecordType
	}
	return 0
}

func (m *RecordExcerptForCatalogEntry) GetRecordBodyHash() Binary {
	if m != nil {
		return m.RecordBodyHash
	}
	return Binary{}
}

func (m *RecordExcerptForCatalogEntry) GetPrevRef() Reference {
	if m != nil {
		return m.PrevRef
	}
	return Reference{}
}

func (m *RecordExcerptForCatalogEntry) GetRootRef() Reference {
	if m != nil {
		return m.RootRef
	}
	return Reference{}
}

func (m *RecordExcerptForCatalogEntry) GetReasonRef() Reference {
	if m != nil {
		return m.ReasonRef
	}
	return Reference{}
}

func (m *RecordExcerptForCatalogEntry) GetRedirectRef() Reference {
	if m != nil {
		return m.RedirectRef
	}
	return Reference{}
}

func (m *RecordExcerptForCatalogEntry) GetRejoinRef() Reference {
	if m != nil {
		return m.RejoinRef
	}
	return Reference{}
}

type RecordBodyForLazy struct {
	RecordBody RecordBody `protobuf:"bytes,19,opt,name=RecordBody,proto3" json:"RecordBody"`
}

func (m *RecordBodyForLazy) Reset()         { *m = RecordBodyForLazy{} }
func (m *RecordBodyForLazy) String() string { return proto.CompactTextString(m) }
func (*RecordBodyForLazy) ProtoMessage()    {}
func (*RecordBodyForLazy) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb898eec77add237, []int{1}
}
func (m *RecordBodyForLazy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordBodyForLazy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecordBodyForLazy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordBodyForLazy.Merge(m, src)
}
func (m *RecordBodyForLazy) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RecordBodyForLazy) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordBodyForLazy.DiscardUnknown(m)
}

var xxx_messageInfo_RecordBodyForLazy proto.InternalMessageInfo

func (m *RecordBodyForLazy) GetRecordBody() RecordBody {
	if m != nil {
		return m.RecordBody
	}
	return RecordBody{}
}

type CatalogEntry struct {
	// Start of fixed-size portion.
	// Use of fixed-size fields allows direct memory mapping for fast access to a few critical fields
	RecordType     uint32         `protobuf:"fixed32,16,opt,name=RecordType,proto3" json:"RecordType"`
	BodyLoc        StorageLocator `protobuf:"fixed64,17,opt,name=BodyLoc,proto3,casttype=StorageLocator" json:"BodyLoc"`
	PayloadLoc     StorageLocator `protobuf:"fixed64,18,opt,name=PayloadLoc,proto3,casttype=StorageLocator" json:"PayloadLoc"`
	Ordinal        CatalogOrdinal `protobuf:"fixed32,19,opt,name=Ordinal,proto3,casttype=CatalogOrdinal" json:"Ordinal"`
	ExtensionLoc   ExtLocators    `protobuf:"bytes,20,opt,name=ExtensionLoc,proto3" json:"ExtensionLoc"`
	RecordBodyHash Binary         `protobuf:"bytes,21,opt,name=RecordBodyHash,proto3" json:"RecordBodyHash"`
	// Start of Excerpt portion
	// MUST match with RecordExcerpt
	PrevRef           Reference `protobuf:"bytes,24,opt,name=PrevRef,proto3" json:"PrevRef"`
	RootRef           Reference `protobuf:"bytes,25,opt,name=RootRef,proto3" json:"RootRef"`
	ReasonRef         Reference `protobuf:"bytes,26,opt,name=ReasonRef,proto3" json:"ReasonRef"`
	RedirectRef       Reference `protobuf:"bytes,27,opt,name=RedirectRef,proto3" json:"RedirectRef"`
	RejoinRef         Reference `protobuf:"bytes,28,opt,name=RejoinRef,proto3" json:"RejoinRef"`
	ProducerSignature Binary    `protobuf:"bytes,39,opt,name=ProducerSignature,proto3" json:"ProducerSignature"`
	RecapRef          Reference `protobuf:"bytes,40,opt,name=RecapRef,proto3" json:"RecapRef"`
	ProducedBy        Reference `protobuf:"bytes,42,opt,name=ProducedBy,proto3" json:"ProducedBy"`
	// Token ProducerToken = 43;
	RegistrarSignature Binary    `protobuf:"bytes,44,opt,name=RegistrarSignature,proto3" json:"RegistrarSignature"`
	RegisteredBy       Reference `protobuf:"bytes,45,opt,name=RegisteredBy,proto3" json:"RegisteredBy"`
}

func (m *CatalogEntry) Reset()         { *m = CatalogEntry{} }
func (m *CatalogEntry) String() string { return proto.CompactTextString(m) }
func (*CatalogEntry) ProtoMessage()    {}
func (*CatalogEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb898eec77add237, []int{2}
}
func (m *CatalogEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CatalogEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CatalogEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogEntry.Merge(m, src)
}
func (m *CatalogEntry) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CatalogEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogEntry.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogEntry proto.InternalMessageInfo

func (m *CatalogEntry) GetRecordType() uint32 {
	if m != nil {
		return m.RecordType
	}
	return 0
}

func (m *CatalogEntry) GetBodyLoc() StorageLocator {
	if m != nil {
		return m.BodyLoc
	}
	return 0
}

func (m *CatalogEntry) GetPayloadLoc() StorageLocator {
	if m != nil {
		return m.PayloadLoc
	}
	return 0
}

func (m *CatalogEntry) GetOrdinal() CatalogOrdinal {
	if m != nil {
		return m.Ordinal
	}
	return 0
}

func (m *CatalogEntry) GetExtensionLoc() ExtLocators {
	if m != nil {
		return m.ExtensionLoc
	}
	return ExtLocators{}
}

func (m *CatalogEntry) GetRecordBodyHash() Binary {
	if m != nil {
		return m.RecordBodyHash
	}
	return Binary{}
}

func (m *CatalogEntry) GetPrevRef() Reference {
	if m != nil {
		return m.PrevRef
	}
	return Reference{}
}

func (m *CatalogEntry) GetRootRef() Reference {
	if m != nil {
		return m.RootRef
	}
	return Reference{}
}

func (m *CatalogEntry) GetReasonRef() Reference {
	if m != nil {
		return m.ReasonRef
	}
	return Reference{}
}

func (m *CatalogEntry) GetRedirectRef() Reference {
	if m != nil {
		return m.RedirectRef
	}
	return Reference{}
}

func (m *CatalogEntry) GetRejoinRef() Reference {
	if m != nil {
		return m.RejoinRef
	}
	return Reference{}
}

func (m *CatalogEntry) GetProducerSignature() Binary {
	if m != nil {
		return m.ProducerSignature
	}
	return Binary{}
}

func (m *CatalogEntry) GetRecapRef() Reference {
	if m != nil {
		return m.RecapRef
	}
	return Reference{}
}

func (m *CatalogEntry) GetProducedBy() Reference {
	if m != nil {
		return m.ProducedBy
	}
	return Reference{}
}

func (m *CatalogEntry) GetRegistrarSignature() Binary {
	if m != nil {
		return m.RegistrarSignature
	}
	return Binary{}
}

func (m *CatalogEntry) GetRegisteredBy() Reference {
	if m != nil {
		return m.RegisteredBy
	}
	return Reference{}
}

type ExtLocators struct {
	Ext []ExtLocator `protobuf:"bytes,17,rep,name=Ext,proto3" json:"Ext"`
}

func (m *ExtLocators) Reset()         { *m = ExtLocators{} }
func (m *ExtLocators) String() string { return proto.CompactTextString(m) }
func (*ExtLocators) ProtoMessage()    {}
func (*ExtLocators) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb898eec77add237, []int{3}
}
func (m *ExtLocators) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtLocators) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExtLocators) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtLocators.Merge(m, src)
}
func (m *ExtLocators) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExtLocators) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtLocators.DiscardUnknown(m)
}

var xxx_messageInfo_ExtLocators proto.InternalMessageInfo

func (m *ExtLocators) GetExt() []ExtLocator {
	if m != nil {
		return m.Ext
	}
	return nil
}

type ExtLocator struct {
	ExtensionID ExtensionID    `protobuf:"fixed32,17,opt,name=ExtensionID,proto3,casttype=ExtensionID" json:"ExtensionID"`
	PayloadLoc  StorageLocator `protobuf:"fixed64,18,opt,name=PayloadLoc,proto3,casttype=StorageLocator" json:"PayloadLoc"`
}

func (m *ExtLocator) Reset()         { *m = ExtLocator{} }
func (m *ExtLocator) String() string { return proto.CompactTextString(m) }
func (*ExtLocator) ProtoMessage()    {}
func (*ExtLocator) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb898eec77add237, []int{4}
}
func (m *ExtLocator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtLocator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExtLocator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtLocator.Merge(m, src)
}
func (m *ExtLocator) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExtLocator) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtLocator.DiscardUnknown(m)
}

var xxx_messageInfo_ExtLocator proto.InternalMessageInfo

func (m *ExtLocator) GetExtensionID() ExtensionID {
	if m != nil {
		return m.ExtensionID
	}
	return 0
}

func (m *ExtLocator) GetPayloadLoc() StorageLocator {
	if m != nil {
		return m.PayloadLoc
	}
	return 0
}

func init() {
	proto.RegisterType((*RecordExcerptForCatalogEntry)(nil), "rms.RecordExcerptForCatalogEntry")
	proto.RegisterType((*RecordBodyForLazy)(nil), "rms.RecordBodyForLazy")
	proto.RegisterType((*CatalogEntry)(nil), "rms.CatalogEntry")
	proto.RegisterType((*ExtLocators)(nil), "rms.ExtLocators")
	proto.RegisterType((*ExtLocator)(nil), "rms.ExtLocator")
}

func init() { proto.RegisterFile("proto_catalog.proto", fileDescriptor_cb898eec77add237) }

var fileDescriptor_cb898eec77add237 = []byte{
	// 681 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x95, 0xb1, 0x6f, 0xd3, 0x4e,
	0x14, 0xc7, 0xed, 0x5f, 0xa2, 0x26, 0xbd, 0xf4, 0x57, 0x9c, 0x0b, 0x20, 0x53, 0x8a, 0x13, 0x45,
	0x48, 0x8d, 0x50, 0x93, 0x54, 0x85, 0x56, 0xd0, 0x85, 0x62, 0x48, 0x05, 0x55, 0x25, 0xa2, 0x2b,
	0x3b, 0xba, 0xda, 0x57, 0xd7, 0x28, 0xf5, 0x45, 0xe7, 0x0b, 0x8a, 0x99, 0xc2, 0x7f, 0xc0, 0xc2,
	0xc0, 0xc6, 0xd8, 0x3f, 0x83, 0xb1, 0x63, 0xc7, 0x4c, 0x15, 0x24, 0x0b, 0xff, 0x02, 0x4c, 0xe8,
	0xce, 0x97, 0xc6, 0x85, 0xd6, 0x20, 0x66, 0xa6, 0xf8, 0xee, 0x7d, 0xbe, 0xef, 0x7b, 0x7e, 0xf7,
	0x5e, 0x0c, 0x4a, 0x5d, 0x46, 0x39, 0x7d, 0xe9, 0x60, 0x8e, 0x3b, 0xd4, 0x6b, 0xc8, 0x15, 0xcc,
	0xb0, 0xc3, 0x70, 0xa1, 0xee, 0xf9, 0xfc, 0xa0, 0xb7, 0xd7, 0x70, 0xe8, 0x61, 0xd3, 0xa3, 0x1e,
	0x6d, 0xca, 0xd8, 0x5e, 0x6f, 0x5f, 0xae, 0xe4, 0x42, 0x3e, 0xc5, 0x9a, 0x85, 0xcd, 0x04, 0xee,
	0x07, 0x21, 0xed, 0x60, 0xd6, 0xc4, 0x61, 0xd8, 0x63, 0xc4, 0xad, 0x77, 0x88, 0xeb, 0x11, 0xd6,
	0x8c, 0x7f, 0xea, 0x0e, 0x65, 0x44, 0x20, 0x71, 0x0a, 0x3f, 0x08, 0x55, 0x86, 0x59, 0x76, 0xa8,
	0x1e, 0xab, 0xef, 0x33, 0x60, 0x11, 0x11, 0x87, 0x32, 0xb7, 0xd5, 0x77, 0x08, 0xeb, 0xf2, 0x2d,
	0xca, 0x1e, 0xc7, 0x47, 0x6c, 0x05, 0x9c, 0x45, 0xf0, 0x36, 0x00, 0x71, 0xfc, 0x45, 0xd4, 0x25,
	0xa6, 0x51, 0xd1, 0x6b, 0xff, 0xdb, 0xd9, 0xe3, 0xd3, 0xb2, 0x86, 0x12, 0xfb, 0xf0, 0x01, 0x98,
	0x8f, 0x57, 0x36, 0x75, 0xa3, 0xa7, 0x38, 0x3c, 0x30, 0x4b, 0x15, 0xbd, 0x56, 0x58, 0x2d, 0x34,
	0x84, 0x95, 0xed, 0x07, 0x98, 0x45, 0x4a, 0xf6, 0x13, 0x08, 0x1b, 0x20, 0xd7, 0x66, 0xe4, 0x35,
	0x22, 0xfb, 0xa6, 0x29, 0x35, 0xf3, 0x52, 0x83, 0xc8, 0x3e, 0x61, 0x24, 0x70, 0x88, 0x92, 0x4d,
	0x20, 0xc1, 0x23, 0x4a, 0xb9, 0xe0, 0x6f, 0xa4, 0xf1, 0x0a, 0x82, 0xab, 0x60, 0x16, 0x11, 0x1c,
	0xd2, 0x40, 0x28, 0x16, 0x52, 0x14, 0x53, 0x0c, 0xae, 0x83, 0x02, 0x22, 0xae, 0xcf, 0x88, 0x23,
	0x7d, 0x6e, 0xa6, 0xa8, 0x92, 0x60, 0xec, 0xf5, 0x8a, 0xfa, 0xd2, 0x6b, 0x31, 0xdd, 0x4b, 0x61,
	0xdb, 0xd9, 0xbc, 0x6e, 0x18, 0xdb, 0xd9, 0x7c, 0xd1, 0x28, 0x6d, 0xe7, 0xf3, 0x35, 0x63, 0x30,
	0x18, 0x0c, 0xfe, 0xab, 0xb6, 0x41, 0x71, 0x5a, 0xa7, 0x2d, 0xca, 0x76, 0xf0, 0x9b, 0x08, 0xae,
	0x4d, 0xee, 0x42, 0x6c, 0xaa, 0x0a, 0x5f, 0x51, 0xf9, 0x27, 0xdb, 0xe7, 0x2f, 0x47, 0xec, 0x6c,
	0x64, 0x3f, 0x0d, 0xcb, 0x5a, 0xf5, 0xdb, 0x0c, 0x98, 0xfb, 0xcd, 0xcd, 0xe6, 0x2e, 0xb8, 0xd9,
	0x15, 0x90, 0x13, 0x49, 0x76, 0xa8, 0x63, 0x16, 0x2b, 0x7a, 0x6d, 0xc6, 0xbe, 0x2e, 0x90, 0xef,
	0xa7, 0xe5, 0xf9, 0x5d, 0x4e, 0x19, 0xf6, 0xc8, 0x0e, 0x75, 0x30, 0xa7, 0x0c, 0x4d, 0x30, 0xb8,
	0x0e, 0x40, 0x1b, 0x47, 0x1d, 0x8a, 0x5d, 0x21, 0x82, 0xa9, 0xa2, 0x04, 0x29, 0x9c, 0x9e, 0x33,
	0xd7, 0x0f, 0x70, 0x47, 0xbe, 0x5a, 0x6e, 0x2a, 0x52, 0xc7, 0x56, 0x51, 0x34, 0xc1, 0xe0, 0x06,
	0x98, 0x6b, 0xf5, 0x39, 0x09, 0x42, 0x9f, 0x06, 0xc2, 0xeb, 0xaa, 0xac, 0x88, 0x21, 0x2b, 0xd2,
	0xea, 0x73, 0x65, 0x12, 0xaa, 0xb7, 0x3a, 0xc7, 0x5e, 0xd0, 0xb1, 0xd7, 0xfe, 0x75, 0xec, 0x1f,
	0x75, 0x2c, 0x7c, 0x08, 0x8a, 0x6d, 0x46, 0xdd, 0x9e, 0x43, 0xd8, 0xae, 0xef, 0x05, 0x98, 0xf7,
	0x18, 0x31, 0x97, 0x2e, 0xab, 0xde, 0xaf, 0x2c, 0x5c, 0x01, 0x79, 0x44, 0x1c, 0xdc, 0x15, 0x9e,
	0xb5, 0x14, 0xcf, 0x33, 0x0a, 0xde, 0x03, 0x40, 0xa5, 0x71, 0xed, 0xc8, 0xbc, 0x93, 0xa2, 0x49,
	0x70, 0xf0, 0x11, 0x80, 0x88, 0x78, 0x7e, 0xc8, 0x19, 0x4e, 0x9c, 0x74, 0xf9, 0xb2, 0x93, 0x5e,
	0x00, 0xc3, 0xfb, 0x60, 0x2e, 0xde, 0x25, 0x4c, 0x5a, 0xd7, 0x53, 0xac, 0xcf, 0x91, 0x67, 0x73,
	0x7d, 0xcb, 0x58, 0xaa, 0x6e, 0x82, 0x42, 0xa2, 0x1f, 0xe1, 0x12, 0xc8, 0xb4, 0xfa, 0xdc, 0x2c,
	0x56, 0x32, 0x67, 0x03, 0x3c, 0x0d, 0xab, 0x64, 0x82, 0xd8, 0xc8, 0x1f, 0x0d, 0xcb, 0x9a, 0x9c,
	0xde, 0xb7, 0x3a, 0x00, 0x53, 0x06, 0xae, 0xc9, 0x84, 0x71, 0x37, 0x3f, 0x7b, 0x22, 0x27, 0x33,
	0x67, 0x97, 0xd4, 0xbc, 0x24, 0x43, 0x28, 0xb9, 0xf8, 0xdb, 0xd1, 0x8c, 0xff, 0x41, 0xec, 0xe5,
	0xe3, 0x2f, 0x96, 0x7e, 0x34, 0xb2, 0xf4, 0xe3, 0x91, 0xa5, 0x9f, 0x8c, 0x2c, 0x7d, 0x38, 0xb2,
	0xf4, 0xcf, 0x23, 0x4b, 0x7b, 0x37, 0xb6, 0xb4, 0x8f, 0x63, 0x4b, 0x3f, 0x19, 0x5b, 0xda, 0x70,
	0x6c, 0x69, 0x5f, 0x3f, 0x94, 0xf5, 0xbd, 0x19, 0xf9, 0x81, 0xb9, 0xfb, 0x23, 0x00, 0x00, 0xff,
	0xff, 0x3a, 0xf2, 0x15, 0x2b, 0xf8, 0x06, 0x00, 0x00,
}

func (this *RecordExcerptForCatalogEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RecordExcerptForCatalogEntry)
	if !ok {
		that2, ok := that.(RecordExcerptForCatalogEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RecordType != that1.RecordType {
		return false
	}
	if !this.RecordBodyHash.Equal(&that1.RecordBodyHash) {
		return false
	}
	if !this.PrevRef.Equal(&that1.PrevRef) {
		return false
	}
	if !this.RootRef.Equal(&that1.RootRef) {
		return false
	}
	if !this.ReasonRef.Equal(&that1.ReasonRef) {
		return false
	}
	if !this.RedirectRef.Equal(&that1.RedirectRef) {
		return false
	}
	if !this.RejoinRef.Equal(&that1.RejoinRef) {
		return false
	}
	return true
}
func (this *RecordBodyForLazy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RecordBodyForLazy)
	if !ok {
		that2, ok := that.(RecordBodyForLazy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RecordBody.Equal(&that1.RecordBody) {
		return false
	}
	return true
}
func (this *CatalogEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CatalogEntry)
	if !ok {
		that2, ok := that.(CatalogEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RecordType != that1.RecordType {
		return false
	}
	if this.BodyLoc != that1.BodyLoc {
		return false
	}
	if this.PayloadLoc != that1.PayloadLoc {
		return false
	}
	if this.Ordinal != that1.Ordinal {
		return false
	}
	if !this.ExtensionLoc.Equal(&that1.ExtensionLoc) {
		return false
	}
	if !this.RecordBodyHash.Equal(&that1.RecordBodyHash) {
		return false
	}
	if !this.PrevRef.Equal(&that1.PrevRef) {
		return false
	}
	if !this.RootRef.Equal(&that1.RootRef) {
		return false
	}
	if !this.ReasonRef.Equal(&that1.ReasonRef) {
		return false
	}
	if !this.RedirectRef.Equal(&that1.RedirectRef) {
		return false
	}
	if !this.RejoinRef.Equal(&that1.RejoinRef) {
		return false
	}
	if !this.ProducerSignature.Equal(&that1.ProducerSignature) {
		return false
	}
	if !this.RecapRef.Equal(&that1.RecapRef) {
		return false
	}
	if !this.ProducedBy.Equal(&that1.ProducedBy) {
		return false
	}
	if !this.RegistrarSignature.Equal(&that1.RegistrarSignature) {
		return false
	}
	if !this.RegisteredBy.Equal(&that1.RegisteredBy) {
		return false
	}
	return true
}
func (this *ExtLocators) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExtLocators)
	if !ok {
		that2, ok := that.(ExtLocators)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ext) != len(that1.Ext) {
		return false
	}
	for i := range this.Ext {
		if !this.Ext[i].Equal(&that1.Ext[i]) {
			return false
		}
	}
	return true
}
func (this *ExtLocator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExtLocator)
	if !ok {
		that2, ok := that.(ExtLocator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExtensionID != that1.ExtensionID {
		return false
	}
	if this.PayloadLoc != that1.PayloadLoc {
		return false
	}
	return true
}
func (m *RecordExcerptForCatalogEntry) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordExcerptForCatalogEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordExcerptForCatalogEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	{
		size, err := m.RejoinRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	{
		size, err := m.RedirectRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	{
		size, err := m.ReasonRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	{
		size, err := m.RootRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	{
		size, err := m.PrevRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	{
		size, err := m.RecordBodyHash.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if i < len(dAtA) {
		i = encodeVarintProtoCatalog(dAtA, i, uint64(m.RecordType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	return len(dAtA) - i, nil
}

func (m *RecordBodyForLazy) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordBodyForLazy) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordBodyForLazy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	{
		size, err := m.RecordBody.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if i < len(dAtA) {
		i = encodeVarintProtoCatalog(dAtA, i, uint64(0))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	return len(dAtA) - i, nil
}

func (m *CatalogEntry) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CatalogEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CatalogEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	{
		size, err := m.RegisteredBy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xea
		}
	}
	{
		size, err := m.RegistrarSignature.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xe2
		}
	}
	{
		size, err := m.ProducedBy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xd2
		}
	}
	{
		size, err := m.RecapRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xc2
		}
	}
	{
		size, err := m.ProducerSignature.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xba
		}
	}
	{
		size, err := m.RejoinRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	{
		size, err := m.RedirectRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	{
		size, err := m.ReasonRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	{
		size, err := m.RootRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	{
		size, err := m.PrevRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	{
		size, err := m.RecordBodyHash.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	{
		size, err := m.ExtensionLoc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Ordinal != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.Ordinal))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9d
	}
	if m.PayloadLoc != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PayloadLoc))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x91
	}
	if m.BodyLoc != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.BodyLoc))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x89
	}
	if i < len(dAtA) {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RecordType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x85
	}
	return len(dAtA) - i, nil
}

func (m *ExtLocators) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtLocators) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtLocators) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	if len(m.Ext) > 0 {
		for iNdEx := len(m.Ext) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ext[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	return len(dAtA) - i, nil
}

func (m *ExtLocator) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtLocator) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtLocator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	if m.PayloadLoc != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PayloadLoc))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x91
	}
	if m.ExtensionID != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.ExtensionID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8d
	}
	if i < len(dAtA) {
		i = encodeVarintProtoCatalog(dAtA, i, uint64(0))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	return len(dAtA) - i, nil
}

func encodeVarintProtoCatalog(dAtA []byte, offset int, v uint64) int {
	offset -= sovProtoCatalog(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}

func (m *RecordExcerptForCatalogEntry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if l = m.RecordBodyHash.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.PrevRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RootRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.ReasonRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RedirectRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RejoinRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if n > 0 {
		n += 2 + sovProtoCatalog(uint64(m.RecordType))
	}
	return n
}

func (m *RecordBodyForLazy) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if l = m.RecordBody.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if n > 0 {
		n += 2 + sovProtoCatalog(0)
	}
	return n
}

func (m *CatalogEntry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BodyLoc != 0 {
		n += 10
	}
	if m.PayloadLoc != 0 {
		n += 10
	}
	if m.Ordinal != 0 {
		n += 6
	}
	if l = m.ExtensionLoc.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RecordBodyHash.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.PrevRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RootRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.ReasonRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RedirectRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RejoinRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.ProducerSignature.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RecapRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.ProducedBy.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RegistrarSignature.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RegisteredBy.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if n > 0 {
		n += 2 + 4
	}
	return n
}

func (m *ExtLocators) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ext) > 0 {
		for _, e := range m.Ext {
			l = e.ProtoSize()
			n += 2 + l + sovProtoCatalog(uint64(l))
		}
	}
	return n
}

func (m *ExtLocator) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExtensionID != 0 {
		n += 6
	}
	if m.PayloadLoc != 0 {
		n += 10
	}
	if n > 0 {
		n += 2 + sovProtoCatalog(0)
	}
	return n
}

func sovProtoCatalog(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProtoCatalog(x uint64) (n int) {
	return sovProtoCatalog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RecordExcerptForCatalogEntry) Unmarshal(dAtA []byte) error {
	return m.UnmarshalWithUnknownCallback(dAtA, skipProtoCatalog)
}
func (m *RecordExcerptForCatalogEntry) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordExcerptForCatalogEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordExcerptForCatalogEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordBodyHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecordBodyHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrevRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RootRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReasonRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RedirectRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejoinRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RejoinRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				l = iNdEx
				break
			}
			if skippy == 0 {
				if skippy, err = skipProtoCatalog(dAtA[iNdEx:]); err != nil {
					return err
				}
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordBodyForLazy) Unmarshal(dAtA []byte) error {
	return m.UnmarshalWithUnknownCallback(dAtA, skipProtoCatalog)
}
func (m *RecordBodyForLazy) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordBodyForLazy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordBodyForLazy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordBody", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecordBody.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				l = iNdEx
				break
			}
			if skippy == 0 {
				if skippy, err = skipProtoCatalog(dAtA[iNdEx:]); err != nil {
					return err
				}
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CatalogEntry) Unmarshal(dAtA []byte) error {
	return m.UnmarshalWithUnknownCallback(dAtA, skipProtoCatalog)
}
func (m *CatalogEntry) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CatalogEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CatalogEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordType = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyLoc", wireType)
			}
			m.BodyLoc = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.BodyLoc = StorageLocator(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 18:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadLoc", wireType)
			}
			m.PayloadLoc = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.PayloadLoc = StorageLocator(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 19:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordinal", wireType)
			}
			m.Ordinal = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.Ordinal = CatalogOrdinal(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtensionLoc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExtensionLoc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordBodyHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecordBodyHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrevRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RootRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReasonRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RedirectRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejoinRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RejoinRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProducerSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecapRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecapRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducedBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProducedBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistrarSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RegistrarSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RegisteredBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				l = iNdEx
				break
			}
			if skippy == 0 {
				if skippy, err = skipProtoCatalog(dAtA[iNdEx:]); err != nil {
					return err
				}
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtLocators) Unmarshal(dAtA []byte) error {
	return m.UnmarshalWithUnknownCallback(dAtA, skipProtoCatalog)
}
func (m *ExtLocators) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtLocators: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtLocators: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ext = append(m.Ext, ExtLocator{})
			if err := m.Ext[len(m.Ext)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				l = iNdEx
				break
			}
			if skippy == 0 {
				if skippy, err = skipProtoCatalog(dAtA[iNdEx:]); err != nil {
					return err
				}
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtLocator) Unmarshal(dAtA []byte) error {
	return m.UnmarshalWithUnknownCallback(dAtA, skipProtoCatalog)
}
func (m *ExtLocator) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtLocator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtLocator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 17:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtensionID", wireType)
			}
			m.ExtensionID = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtensionID = ExtensionID(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 18:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadLoc", wireType)
			}
			m.PayloadLoc = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.PayloadLoc = StorageLocator(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipFn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				l = iNdEx
				break
			}
			if skippy == 0 {
				if skippy, err = skipProtoCatalog(dAtA[iNdEx:]); err != nil {
					return err
				}
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProtoCatalog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProtoCatalog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProtoCatalog
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProtoCatalog
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProtoCatalog
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProtoCatalog        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProtoCatalog          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProtoCatalog = fmt.Errorf("proto: unexpected end of group")
	ErrExpectedBinaryMarkerProtoCatalog = fmt.Errorf("proto: binary marker was expected")
)
