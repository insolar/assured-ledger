// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto_catalog.proto

package rms

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/insolar/assured-ledger/ledger-core/insproto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type RecordExcerptForCatalogEntry struct {
	RecordType     uint32            `protobuf:"varint,16,opt,name=RecordType,proto3" json:"RecordType"`
	PayloadDigests RecordBodyDigests `protobuf:"bytes,19,opt,name=PayloadDigests,proto3" json:"PayloadDigests"`
	// MUST match with Excerpt portion of CatalogEntryData
	PrevRef     Reference `protobuf:"bytes,24,opt,name=PrevRef,proto3" json:"PrevRef"`
	RootRef     Reference `protobuf:"bytes,25,opt,name=RootRef,proto3" json:"RootRef"`
	ReasonRef   Reference `protobuf:"bytes,26,opt,name=ReasonRef,proto3" json:"ReasonRef"`
	RedirectRef Reference `protobuf:"bytes,27,opt,name=RedirectRef,proto3" json:"RedirectRef"`
	RejoinRef   Reference `protobuf:"bytes,28,opt,name=RejoinRef,proto3" json:"RejoinRef"`
}

func (m *RecordExcerptForCatalogEntry) Reset()         { *m = RecordExcerptForCatalogEntry{} }
func (m *RecordExcerptForCatalogEntry) String() string { return proto.CompactTextString(m) }
func (*RecordExcerptForCatalogEntry) ProtoMessage()    {}
func (*RecordExcerptForCatalogEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb898eec77add237, []int{0}
}
func (m *RecordExcerptForCatalogEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordExcerptForCatalogEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecordExcerptForCatalogEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordExcerptForCatalogEntry.Merge(m, src)
}
func (m *RecordExcerptForCatalogEntry) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RecordExcerptForCatalogEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordExcerptForCatalogEntry.DiscardUnknown(m)
}

var xxx_messageInfo_RecordExcerptForCatalogEntry proto.InternalMessageInfo

func (m *RecordExcerptForCatalogEntry) GetRecordType() uint32 {
	if m != nil {
		return m.RecordType
	}
	return 0
}

func (m *RecordExcerptForCatalogEntry) GetPayloadDigests() RecordBodyDigests {
	if m != nil {
		return m.PayloadDigests
	}
	return RecordBodyDigests{}
}

func (m *RecordExcerptForCatalogEntry) GetPrevRef() Reference {
	if m != nil {
		return m.PrevRef
	}
	return Reference{}
}

func (m *RecordExcerptForCatalogEntry) GetRootRef() Reference {
	if m != nil {
		return m.RootRef
	}
	return Reference{}
}

func (m *RecordExcerptForCatalogEntry) GetReasonRef() Reference {
	if m != nil {
		return m.ReasonRef
	}
	return Reference{}
}

func (m *RecordExcerptForCatalogEntry) GetRedirectRef() Reference {
	if m != nil {
		return m.RedirectRef
	}
	return Reference{}
}

func (m *RecordExcerptForCatalogEntry) GetRejoinRef() Reference {
	if m != nil {
		return m.RejoinRef
	}
	return Reference{}
}

type RecordBodyForLazy struct {
	RecordBody RecordBody `protobuf:"bytes,19,opt,name=RecordBody,proto3" json:"RecordBody"`
}

func (m *RecordBodyForLazy) Reset()         { *m = RecordBodyForLazy{} }
func (m *RecordBodyForLazy) String() string { return proto.CompactTextString(m) }
func (*RecordBodyForLazy) ProtoMessage()    {}
func (*RecordBodyForLazy) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb898eec77add237, []int{1}
}
func (m *RecordBodyForLazy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordBodyForLazy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecordBodyForLazy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordBodyForLazy.Merge(m, src)
}
func (m *RecordBodyForLazy) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RecordBodyForLazy) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordBodyForLazy.DiscardUnknown(m)
}

var xxx_messageInfo_RecordBodyForLazy proto.InternalMessageInfo

func (m *RecordBodyForLazy) GetRecordBody() RecordBody {
	if m != nil {
		return m.RecordBody
	}
	return RecordBody{}
}

type CatalogEntry struct {
	DropOrdinal      DropOrdinal      `protobuf:"fixed64,16,opt,name=DropOrdinal,proto3,casttype=DropOrdinal" json:"DropOrdinal"`
	BodyLoc          StorageLocator   `protobuf:"fixed64,17,opt,name=BodyLoc,proto3,casttype=StorageLocator" json:"BodyLoc"`
	PayloadLoc       StorageLocator   `protobuf:"fixed64,18,opt,name=PayloadLoc,proto3,casttype=StorageLocator" json:"PayloadLoc"`
	BodyPayloadSizes uint64           `protobuf:"fixed64,19,opt,name=BodyPayloadSizes,proto3" json:"BodyPayloadSizes"`
	ExtensionLoc     ExtLocators      `protobuf:"bytes,20,opt,name=ExtensionLoc,proto3" json:"ExtensionLoc"`
	EntryData        CatalogEntryData `protobuf:"bytes,21,opt,name=EntryData,proto3" json:"EntryData"`
}

func (m *CatalogEntry) Reset()         { *m = CatalogEntry{} }
func (m *CatalogEntry) String() string { return proto.CompactTextString(m) }
func (*CatalogEntry) ProtoMessage()    {}
func (*CatalogEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb898eec77add237, []int{2}
}
func (m *CatalogEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CatalogEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CatalogEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogEntry.Merge(m, src)
}
func (m *CatalogEntry) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CatalogEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogEntry.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogEntry proto.InternalMessageInfo

func (m *CatalogEntry) GetDropOrdinal() DropOrdinal {
	if m != nil {
		return m.DropOrdinal
	}
	return 0
}

func (m *CatalogEntry) GetBodyLoc() StorageLocator {
	if m != nil {
		return m.BodyLoc
	}
	return 0
}

func (m *CatalogEntry) GetPayloadLoc() StorageLocator {
	if m != nil {
		return m.PayloadLoc
	}
	return 0
}

func (m *CatalogEntry) GetBodyPayloadSizes() uint64 {
	if m != nil {
		return m.BodyPayloadSizes
	}
	return 0
}

func (m *CatalogEntry) GetExtensionLoc() ExtLocators {
	if m != nil {
		return m.ExtensionLoc
	}
	return ExtLocators{}
}

func (m *CatalogEntry) GetEntryData() CatalogEntryData {
	if m != nil {
		return m.EntryData
	}
	return CatalogEntryData{}
}

type CatalogEntryData struct {
	RecordType     uint32            `protobuf:"varint,16,opt,name=RecordType,proto3" json:"RecordType"`
	BodyDigest     Binary            `protobuf:"bytes,18,opt,name=BodyDigest,proto3" json:"BodyDigest"`
	PayloadDigests RecordBodyDigests `protobuf:"bytes,19,opt,name=PayloadDigests,proto3" json:"PayloadDigests"`
	// Start of Excerpt portion
	// Fields below MUST be identical with RecordExcerptForCatalogEntry
	PrevRef           Reference `protobuf:"bytes,24,opt,name=PrevRef,proto3" json:"PrevRef"`
	RootRef           Reference `protobuf:"bytes,25,opt,name=RootRef,proto3" json:"RootRef"`
	ReasonRef         Reference `protobuf:"bytes,26,opt,name=ReasonRef,proto3" json:"ReasonRef"`
	RedirectRef       Reference `protobuf:"bytes,27,opt,name=RedirectRef,proto3" json:"RedirectRef"`
	RejoinRef         Reference `protobuf:"bytes,28,opt,name=RejoinRef,proto3" json:"RejoinRef"`
	RecordRef         Reference `protobuf:"bytes,40,opt,name=RecordRef,proto3" json:"RecordRef"`
	ProducerSignature Binary    `protobuf:"bytes,41,opt,name=ProducerSignature,proto3" json:"ProducerSignature"`
	ProducedBy        Reference `protobuf:"bytes,42,opt,name=ProducedBy,proto3" json:"ProducedBy"`
	// Token ProducerToken = 43;
	RegistrarSignature Binary    `protobuf:"bytes,44,opt,name=RegistrarSignature,proto3" json:"RegistrarSignature"`
	RegisteredBy       Reference `protobuf:"bytes,45,opt,name=RegisteredBy,proto3" json:"RegisteredBy"`
	RecapRef           Reference `protobuf:"bytes,50,opt,name=RecapRef,proto3" json:"RecapRef"`
}

func (m *CatalogEntryData) Reset()         { *m = CatalogEntryData{} }
func (m *CatalogEntryData) String() string { return proto.CompactTextString(m) }
func (*CatalogEntryData) ProtoMessage()    {}
func (*CatalogEntryData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb898eec77add237, []int{3}
}
func (m *CatalogEntryData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CatalogEntryData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CatalogEntryData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogEntryData.Merge(m, src)
}
func (m *CatalogEntryData) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CatalogEntryData) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogEntryData.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogEntryData proto.InternalMessageInfo

func (m *CatalogEntryData) GetRecordType() uint32 {
	if m != nil {
		return m.RecordType
	}
	return 0
}

func (m *CatalogEntryData) GetBodyDigest() Binary {
	if m != nil {
		return m.BodyDigest
	}
	return Binary{}
}

func (m *CatalogEntryData) GetPayloadDigests() RecordBodyDigests {
	if m != nil {
		return m.PayloadDigests
	}
	return RecordBodyDigests{}
}

func (m *CatalogEntryData) GetPrevRef() Reference {
	if m != nil {
		return m.PrevRef
	}
	return Reference{}
}

func (m *CatalogEntryData) GetRootRef() Reference {
	if m != nil {
		return m.RootRef
	}
	return Reference{}
}

func (m *CatalogEntryData) GetReasonRef() Reference {
	if m != nil {
		return m.ReasonRef
	}
	return Reference{}
}

func (m *CatalogEntryData) GetRedirectRef() Reference {
	if m != nil {
		return m.RedirectRef
	}
	return Reference{}
}

func (m *CatalogEntryData) GetRejoinRef() Reference {
	if m != nil {
		return m.RejoinRef
	}
	return Reference{}
}

func (m *CatalogEntryData) GetRecordRef() Reference {
	if m != nil {
		return m.RecordRef
	}
	return Reference{}
}

func (m *CatalogEntryData) GetProducerSignature() Binary {
	if m != nil {
		return m.ProducerSignature
	}
	return Binary{}
}

func (m *CatalogEntryData) GetProducedBy() Reference {
	if m != nil {
		return m.ProducedBy
	}
	return Reference{}
}

func (m *CatalogEntryData) GetRegistrarSignature() Binary {
	if m != nil {
		return m.RegistrarSignature
	}
	return Binary{}
}

func (m *CatalogEntryData) GetRegisteredBy() Reference {
	if m != nil {
		return m.RegisteredBy
	}
	return Reference{}
}

func (m *CatalogEntryData) GetRecapRef() Reference {
	if m != nil {
		return m.RecapRef
	}
	return Reference{}
}

type ExtLocators struct {
	Ext []ExtLocator `protobuf:"bytes,17,rep,name=Ext,proto3" json:"Ext"`
}

func (m *ExtLocators) Reset()         { *m = ExtLocators{} }
func (m *ExtLocators) String() string { return proto.CompactTextString(m) }
func (*ExtLocators) ProtoMessage()    {}
func (*ExtLocators) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb898eec77add237, []int{4}
}
func (m *ExtLocators) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtLocators) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExtLocators) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtLocators.Merge(m, src)
}
func (m *ExtLocators) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExtLocators) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtLocators.DiscardUnknown(m)
}

var xxx_messageInfo_ExtLocators proto.InternalMessageInfo

func (m *ExtLocators) GetExt() []ExtLocator {
	if m != nil {
		return m.Ext
	}
	return nil
}

type ExtLocator struct {
	ExtensionID ExtensionID    `protobuf:"varint,17,opt,name=ExtensionID,proto3,casttype=ExtensionID" json:"ExtensionID"`
	PayloadLoc  StorageLocator `protobuf:"fixed64,18,opt,name=PayloadLoc,proto3,casttype=StorageLocator" json:"PayloadLoc"`
	PayloadSize uint32         `protobuf:"varint,20,opt,name=PayloadSize,proto3" json:"PayloadSize"`
}

func (m *ExtLocator) Reset()         { *m = ExtLocator{} }
func (m *ExtLocator) String() string { return proto.CompactTextString(m) }
func (*ExtLocator) ProtoMessage()    {}
func (*ExtLocator) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb898eec77add237, []int{5}
}
func (m *ExtLocator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtLocator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExtLocator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtLocator.Merge(m, src)
}
func (m *ExtLocator) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExtLocator) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtLocator.DiscardUnknown(m)
}

var xxx_messageInfo_ExtLocator proto.InternalMessageInfo

func (m *ExtLocator) GetExtensionID() ExtensionID {
	if m != nil {
		return m.ExtensionID
	}
	return 0
}

func (m *ExtLocator) GetPayloadLoc() StorageLocator {
	if m != nil {
		return m.PayloadLoc
	}
	return 0
}

func (m *ExtLocator) GetPayloadSize() uint32 {
	if m != nil {
		return m.PayloadSize
	}
	return 0
}

func init() {
	proto.RegisterType((*RecordExcerptForCatalogEntry)(nil), "rms.RecordExcerptForCatalogEntry")
	proto.RegisterType((*RecordBodyForLazy)(nil), "rms.RecordBodyForLazy")
	proto.RegisterType((*CatalogEntry)(nil), "rms.CatalogEntry")
	proto.RegisterType((*CatalogEntryData)(nil), "rms.CatalogEntryData")
	proto.RegisterType((*ExtLocators)(nil), "rms.ExtLocators")
	proto.RegisterType((*ExtLocator)(nil), "rms.ExtLocator")
}

func init() { proto.RegisterFile("proto_catalog.proto", fileDescriptor_cb898eec77add237) }

var fileDescriptor_cb898eec77add237 = []byte{
	// 778 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x95, 0x31, 0x4f, 0xdb, 0x5a,
	0x14, 0xc7, 0x63, 0x12, 0x05, 0xe7, 0x06, 0xf2, 0x9c, 0x1b, 0x40, 0x7e, 0x3c, 0x9e, 0x83, 0xa2,
	0xa7, 0x47, 0x5a, 0x91, 0x84, 0xa6, 0x05, 0xb5, 0x2c, 0xa5, 0x69, 0x82, 0xd4, 0x08, 0xa9, 0x91,
	0xe9, 0x5e, 0x5d, 0xec, 0x8b, 0xeb, 0x2a, 0xf8, 0x46, 0xd7, 0x4e, 0x95, 0x30, 0x65, 0xec, 0xd8,
	0xb5, 0x1b, 0x23, 0x4b, 0xbf, 0x43, 0x47, 0x46, 0xc6, 0x4c, 0xa8, 0x4d, 0x3a, 0xf4, 0x33, 0x74,
	0xaa, 0xee, 0xf5, 0x4d, 0xec, 0x40, 0xb1, 0xaa, 0xaa, 0x63, 0x27, 0x7c, 0xcf, 0xf9, 0xfd, 0xef,
	0xdf, 0x9c, 0xe3, 0x73, 0x02, 0x72, 0x1d, 0x4a, 0x3c, 0xf2, 0xd2, 0x40, 0x1e, 0x6a, 0x13, 0xab,
	0xcc, 0x4f, 0x30, 0x4e, 0x4f, 0xdc, 0xd5, 0x92, 0x65, 0x7b, 0xaf, 0xba, 0x47, 0x65, 0x83, 0x9c,
	0x54, 0x2c, 0x62, 0x91, 0x0a, 0xcf, 0x1d, 0x75, 0x8f, 0xf9, 0x89, 0x1f, 0xf8, 0x93, 0xaf, 0x59,
	0xdd, 0x0b, 0xe1, 0xb6, 0xe3, 0x92, 0x36, 0xa2, 0x15, 0xe4, 0xba, 0x5d, 0x8a, 0xcd, 0x52, 0x1b,
	0x9b, 0x16, 0xa6, 0x15, 0xff, 0x4f, 0xc9, 0x20, 0x14, 0x33, 0xc4, 0xbf, 0xc2, 0x76, 0x5c, 0x71,
	0x43, 0x8a, 0x9e, 0x88, 0xc7, 0xc2, 0x59, 0x1c, 0xac, 0xe9, 0xd8, 0x20, 0xd4, 0x6c, 0xf4, 0x0c,
	0x4c, 0x3b, 0xde, 0x3e, 0xa1, 0x4f, 0xfd, 0x57, 0x6c, 0x38, 0x1e, 0xed, 0xc3, 0xff, 0x00, 0xf0,
	0xf3, 0x2f, 0xfa, 0x1d, 0xac, 0x2a, 0xeb, 0x52, 0x71, 0xb1, 0x96, 0xb8, 0xb8, 0xca, 0xc7, 0xf4,
	0x50, 0x1c, 0xd6, 0x41, 0xa6, 0x85, 0xfa, 0x6d, 0x82, 0xcc, 0xba, 0x6d, 0x61, 0xd7, 0x73, 0xd5,
	0xdc, 0xba, 0x54, 0x4c, 0x57, 0x57, 0xca, 0xcc, 0xca, 0x07, 0x6b, 0xc4, 0xec, 0x8b, 0xac, 0xb8,
	0xe1, 0x9a, 0x06, 0x96, 0xc1, 0x7c, 0x8b, 0xe2, 0x37, 0x3a, 0x3e, 0x56, 0x55, 0x2e, 0xcf, 0x08,
	0xf9, 0x31, 0xa6, 0xd8, 0x31, 0xb0, 0x90, 0x4d, 0x20, 0xc6, 0xeb, 0x84, 0x78, 0x8c, 0xff, 0x3b,
	0x8a, 0x17, 0x10, 0xac, 0x82, 0x94, 0x8e, 0x91, 0x4b, 0x1c, 0xa6, 0x58, 0x8d, 0x50, 0x04, 0x18,
	0xdc, 0x01, 0x69, 0x1d, 0x9b, 0x36, 0xc5, 0x06, 0xf7, 0xf9, 0x27, 0x42, 0x15, 0x06, 0x7d, 0xaf,
	0xd7, 0xc4, 0xe6, 0x5e, 0x6b, 0xd1, 0x5e, 0x02, 0x6b, 0x26, 0x64, 0x49, 0x51, 0x9a, 0x09, 0x39,
	0xab, 0xe4, 0x9a, 0xb2, 0x5c, 0x54, 0x06, 0x83, 0xc1, 0x60, 0xae, 0xd0, 0x02, 0xd9, 0xa0, 0x80,
	0xfb, 0x84, 0x1e, 0xa0, 0xd3, 0x3e, 0xdc, 0x9e, 0xb4, 0x85, 0x05, 0x45, 0xb1, 0xff, 0xba, 0x56,
	0xec, 0xd9, 0x3e, 0xb1, 0xc8, 0x6e, 0xe2, 0xe3, 0x30, 0x1f, 0x2b, 0x7c, 0x99, 0x03, 0x0b, 0x33,
	0x4d, 0xde, 0x06, 0xe9, 0x3a, 0x25, 0x9d, 0xe7, 0xd4, 0xb4, 0x1d, 0xd4, 0xe6, 0x5d, 0x4e, 0xd6,
	0x72, 0x4c, 0xfd, 0xed, 0x2a, 0x1f, 0x4e, 0xe9, 0xe1, 0x03, 0xdc, 0x02, 0xf3, 0xec, 0xd6, 0x03,
	0x62, 0xa8, 0x59, 0x2e, 0x59, 0x11, 0x92, 0xcc, 0xa1, 0x47, 0x28, 0xb2, 0xf0, 0x01, 0x31, 0x90,
	0x47, 0xa8, 0x3e, 0xc1, 0xe0, 0x0e, 0x00, 0xa2, 0xe7, 0x4c, 0x04, 0x23, 0x45, 0x21, 0x12, 0x6e,
	0x01, 0x85, 0x5d, 0x21, 0x22, 0x87, 0xf6, 0x29, 0xf6, 0xbf, 0xb0, 0xa4, 0xf8, 0x1f, 0x6f, 0x64,
	0xe1, 0x2e, 0x58, 0x68, 0xf4, 0x3c, 0xec, 0xb8, 0x36, 0x71, 0x98, 0xd7, 0x12, 0x2f, 0x91, 0xc2,
	0x4b, 0xd4, 0xe8, 0x79, 0xc2, 0x64, 0xf2, 0x25, 0xce, 0xb0, 0xf0, 0x11, 0x48, 0xf1, 0xba, 0xd4,
	0x91, 0x87, 0xd4, 0x65, 0x2e, 0x5c, 0xe6, 0xc2, 0x70, 0xd1, 0x58, 0x72, 0xd2, 0xc2, 0x69, 0x60,
	0xda, 0xc2, 0x7f, 0x95, 0x8d, 0xc2, 0x79, 0x12, 0x28, 0xd7, 0x15, 0x3f, 0x39, 0x4f, 0xf7, 0x00,
	0x08, 0xc6, 0x85, 0xd7, 0x29, 0x5d, 0x4d, 0xf3, 0x57, 0xa8, 0xd9, 0x0e, 0xa2, 0xd3, 0xd6, 0x06,
	0xd0, 0x9f, 0x11, 0xfc, 0x1d, 0x23, 0xe8, 0x6b, 0x58, 0xa9, 0x98, 0xa6, 0x18, 0xad, 0x11, 0x18,
	0x7c, 0x0c, 0xb2, 0x2d, 0x4a, 0xcc, 0xae, 0x81, 0xe9, 0xa1, 0x6d, 0x39, 0xc8, 0xeb, 0x52, 0xac,
	0xde, 0xb9, 0xad, 0x67, 0x37, 0x59, 0xf8, 0x00, 0x00, 0x11, 0x34, 0x6b, 0x7d, 0xf5, 0x6e, 0x84,
	0x6b, 0x88, 0x83, 0x4f, 0x00, 0xd4, 0xb1, 0x65, 0xbb, 0x1e, 0x45, 0x21, 0xdf, 0xcd, 0xdb, 0x7c,
	0x7f, 0x00, 0xc3, 0x87, 0x60, 0xc1, 0x8f, 0x62, 0xca, 0xad, 0x4b, 0x11, 0xd6, 0x33, 0x24, 0xdc,
	0x02, 0xb2, 0x8e, 0x0d, 0xd4, 0x61, 0x65, 0xaa, 0x46, 0xa8, 0xa6, 0x54, 0x68, 0xb9, 0xc1, 0x66,
	0x42, 0x5e, 0x52, 0xd4, 0x66, 0x4a, 0x7e, 0x9b, 0x11, 0x3b, 0x6e, 0x0f, 0xa4, 0x43, 0x43, 0x09,
	0x37, 0x40, 0xbc, 0xd1, 0xf3, 0xd4, 0xec, 0x7a, 0x7c, 0xba, 0xd6, 0x82, 0xb4, 0xb8, 0x99, 0x11,
	0xbb, 0xf2, 0xf9, 0x30, 0x1f, 0xe3, 0x3b, 0xed, 0x83, 0x04, 0x40, 0xc0, 0xb0, 0x8d, 0x36, 0x1d,
	0xe9, 0x67, 0x75, 0xbe, 0x9e, 0x16, 0x83, 0x8d, 0x16, 0x4a, 0xe9, 0xe1, 0xc3, 0x2f, 0xef, 0xa7,
	0xff, 0x41, 0x3a, 0xb4, 0x7d, 0xf8, 0xb2, 0x99, 0x8c, 0x75, 0x38, 0x11, 0xbc, 0x6f, 0x6d, 0xf3,
	0xe2, 0xb3, 0x26, 0x9d, 0x8f, 0x34, 0xe9, 0x62, 0xa4, 0x49, 0x97, 0x23, 0x4d, 0x1a, 0x8e, 0x34,
	0xe9, 0xd3, 0x48, 0x8b, 0xbd, 0x1b, 0x6b, 0xb1, 0xb3, 0xb1, 0x26, 0x5d, 0x8e, 0xb5, 0xd8, 0x70,
	0xac, 0xc5, 0xbe, 0xbe, 0xcf, 0x4b, 0x47, 0x49, 0xfe, 0x6b, 0x7d, 0xff, 0x7b, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x60, 0xc6, 0x5b, 0xc1, 0x45, 0x08, 0x00, 0x00,
}

func (this *RecordExcerptForCatalogEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RecordExcerptForCatalogEntry)
	if !ok {
		that2, ok := that.(RecordExcerptForCatalogEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RecordType != that1.RecordType {
		return false
	}
	if !this.PayloadDigests.Equal(&that1.PayloadDigests) {
		return false
	}
	if !this.PrevRef.Equal(&that1.PrevRef) {
		return false
	}
	if !this.RootRef.Equal(&that1.RootRef) {
		return false
	}
	if !this.ReasonRef.Equal(&that1.ReasonRef) {
		return false
	}
	if !this.RedirectRef.Equal(&that1.RedirectRef) {
		return false
	}
	if !this.RejoinRef.Equal(&that1.RejoinRef) {
		return false
	}
	return true
}
func (this *RecordBodyForLazy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RecordBodyForLazy)
	if !ok {
		that2, ok := that.(RecordBodyForLazy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RecordBody.Equal(&that1.RecordBody) {
		return false
	}
	return true
}
func (this *CatalogEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CatalogEntry)
	if !ok {
		that2, ok := that.(CatalogEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DropOrdinal != that1.DropOrdinal {
		return false
	}
	if this.BodyLoc != that1.BodyLoc {
		return false
	}
	if this.PayloadLoc != that1.PayloadLoc {
		return false
	}
	if this.BodyPayloadSizes != that1.BodyPayloadSizes {
		return false
	}
	if !this.ExtensionLoc.Equal(&that1.ExtensionLoc) {
		return false
	}
	if !this.EntryData.Equal(&that1.EntryData) {
		return false
	}
	return true
}
func (this *CatalogEntryData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CatalogEntryData)
	if !ok {
		that2, ok := that.(CatalogEntryData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RecordType != that1.RecordType {
		return false
	}
	if !this.BodyDigest.Equal(&that1.BodyDigest) {
		return false
	}
	if !this.PayloadDigests.Equal(&that1.PayloadDigests) {
		return false
	}
	if !this.PrevRef.Equal(&that1.PrevRef) {
		return false
	}
	if !this.RootRef.Equal(&that1.RootRef) {
		return false
	}
	if !this.ReasonRef.Equal(&that1.ReasonRef) {
		return false
	}
	if !this.RedirectRef.Equal(&that1.RedirectRef) {
		return false
	}
	if !this.RejoinRef.Equal(&that1.RejoinRef) {
		return false
	}
	if !this.RecordRef.Equal(&that1.RecordRef) {
		return false
	}
	if !this.ProducerSignature.Equal(&that1.ProducerSignature) {
		return false
	}
	if !this.ProducedBy.Equal(&that1.ProducedBy) {
		return false
	}
	if !this.RegistrarSignature.Equal(&that1.RegistrarSignature) {
		return false
	}
	if !this.RegisteredBy.Equal(&that1.RegisteredBy) {
		return false
	}
	if !this.RecapRef.Equal(&that1.RecapRef) {
		return false
	}
	return true
}
func (this *ExtLocators) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExtLocators)
	if !ok {
		that2, ok := that.(ExtLocators)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ext) != len(that1.Ext) {
		return false
	}
	for i := range this.Ext {
		if !this.Ext[i].Equal(&that1.Ext[i]) {
			return false
		}
	}
	return true
}
func (this *ExtLocator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExtLocator)
	if !ok {
		that2, ok := that.(ExtLocator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExtensionID != that1.ExtensionID {
		return false
	}
	if this.PayloadLoc != that1.PayloadLoc {
		return false
	}
	if this.PayloadSize != that1.PayloadSize {
		return false
	}
	return true
}
func (m *RecordExcerptForCatalogEntry) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	if n != size {
		panic("illegal state")
	}
	return dAtA[:n], nil
}

func (m *RecordExcerptForCatalogEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordExcerptForCatalogEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	{
		size, err := m.RejoinRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	{
		size, err := m.RedirectRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	{
		size, err := m.ReasonRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	{
		size, err := m.RootRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	{
		size, err := m.PrevRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	{
		size, err := m.PayloadDigests.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if i < len(dAtA) {
		i = encodeVarintProtoCatalog(dAtA, i, uint64(m.RecordType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	return len(dAtA) - i, nil
}

func (m *RecordBodyForLazy) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	if n != size {
		panic("illegal state")
	}
	return dAtA[:n], nil
}

func (m *RecordBodyForLazy) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordBodyForLazy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	{
		size, err := m.RecordBody.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if i < len(dAtA) {
		i = encodeVarintProtoCatalog(dAtA, i, uint64(0))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	return len(dAtA) - i, nil
}

func (m *CatalogEntry) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	if n != size {
		panic("illegal state")
	}
	return dAtA[:n], nil
}

func (m *CatalogEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CatalogEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	{
		size, err := m.EntryData.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	{
		size, err := m.ExtensionLoc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.BodyPayloadSizes != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.BodyPayloadSizes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x99
	}
	if m.PayloadLoc != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PayloadLoc))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x91
	}
	if m.BodyLoc != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.BodyLoc))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x89
	}
	if i < len(dAtA) {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.DropOrdinal))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x81
	}
	return len(dAtA) - i, nil
}

func (m *CatalogEntryData) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	if n != size {
		panic("illegal state")
	}
	return dAtA[:n], nil
}

func (m *CatalogEntryData) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CatalogEntryData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	{
		size, err := m.RecapRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x92
		}
	}
	{
		size, err := m.RegisteredBy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xea
		}
	}
	{
		size, err := m.RegistrarSignature.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xe2
		}
	}
	{
		size, err := m.ProducedBy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xd2
		}
	}
	{
		size, err := m.ProducerSignature.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xca
		}
	}
	{
		size, err := m.RecordRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xc2
		}
	}
	{
		size, err := m.RejoinRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	{
		size, err := m.RedirectRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	{
		size, err := m.ReasonRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	{
		size, err := m.RootRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	{
		size, err := m.PrevRef.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	{
		size, err := m.PayloadDigests.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	{
		size, err := m.BodyDigest.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		if size > 0 {
			i -= size
			i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if i < len(dAtA) {
		i = encodeVarintProtoCatalog(dAtA, i, uint64(m.RecordType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	return len(dAtA) - i, nil
}

func (m *ExtLocators) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	if n != size {
		panic("illegal state")
	}
	return dAtA[:n], nil
}

func (m *ExtLocators) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtLocators) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	if len(m.Ext) > 0 {
		for iNdEx := len(m.Ext) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ext[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtoCatalog(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	return len(dAtA) - i, nil
}

func (m *ExtLocator) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	if n != size {
		panic("illegal state")
	}
	return dAtA[:n], nil
}

func (m *ExtLocator) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtLocator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l, fieldEnd int
	_, _ = l, fieldEnd
	if m.PayloadSize != 0 {
		i = encodeVarintProtoCatalog(dAtA, i, uint64(m.PayloadSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.PayloadLoc != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PayloadLoc))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x91
	}
	if m.ExtensionID != 0 {
		i = encodeVarintProtoCatalog(dAtA, i, uint64(m.ExtensionID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	return len(dAtA) - i, nil
}

func encodeVarintProtoCatalog(dAtA []byte, offset int, v uint64) int {
	offset -= sovProtoCatalog(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}

func (m *RecordExcerptForCatalogEntry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if l = m.PayloadDigests.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.PrevRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RootRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.ReasonRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RedirectRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RejoinRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if n > 0 {
		n += 2 + sovProtoCatalog(uint64(m.RecordType))
	}
	return n
}

func (m *RecordBodyForLazy) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if l = m.RecordBody.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if n > 0 {
		n += 2 + sovProtoCatalog(0)
	}
	return n
}

func (m *CatalogEntry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BodyLoc != 0 {
		n += 10
	}
	if m.PayloadLoc != 0 {
		n += 10
	}
	if m.BodyPayloadSizes != 0 {
		n += 10
	}
	if l = m.ExtensionLoc.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.EntryData.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if n > 0 {
		n += 2 + 8
	}
	return n
}

func (m *CatalogEntryData) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if l = m.BodyDigest.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.PayloadDigests.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.PrevRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RootRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.ReasonRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RedirectRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RejoinRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RecordRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.ProducerSignature.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.ProducedBy.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RegistrarSignature.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RegisteredBy.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if l = m.RecapRef.ProtoSize(); l > 0 {
		n += 2 + l + sovProtoCatalog(uint64(l))
	}
	if n > 0 {
		n += 2 + sovProtoCatalog(uint64(m.RecordType))
	}
	return n
}

func (m *ExtLocators) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ext) > 0 {
		for _, e := range m.Ext {
			l = e.ProtoSize()
			n += 2 + l + sovProtoCatalog(uint64(l))
		}
	}
	return n
}

func (m *ExtLocator) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExtensionID != 0 {
		n += 2 + sovProtoCatalog(uint64(m.ExtensionID))
	}
	if m.PayloadLoc != 0 {
		n += 10
	}
	if m.PayloadSize != 0 {
		n += 2 + sovProtoCatalog(uint64(m.PayloadSize))
	}
	return n
}

func sovProtoCatalog(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProtoCatalog(x uint64) (n int) {
	return sovProtoCatalog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RecordExcerptForCatalogEntry) Unmarshal(dAtA []byte) error {
	_, err := m.UnmarshalWithUnknownCallback(dAtA, skipProtoCatalog)
	return err
}
func (m *RecordExcerptForCatalogEntry) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) (int, error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		err := func() error {
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return fmt.Errorf("proto: RecordExcerptForCatalogEntry: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return fmt.Errorf("proto: RecordExcerptForCatalogEntry: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 16:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
				}
				m.RecordType = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.RecordType |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 19:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field PayloadDigests", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.PayloadDigests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 24:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field PrevRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.PrevRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 25:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field RootRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.RootRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 26:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field ReasonRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.ReasonRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 27:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field RedirectRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.RedirectRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 28:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field RejoinRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.RejoinRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := skipFn(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					l = iNdEx
					break
				}
				if skippy == 0 {
					if skippy, err = skipProtoCatalog(dAtA[iNdEx:]); err != nil {
						return err
					}
				}
				if (iNdEx + skippy) < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += skippy
			}
			return nil
		}()
		if err != nil {
			return preIndex, err
		}
	}

	if iNdEx > l {
		return iNdEx, io.ErrUnexpectedEOF
	}
	return iNdEx, nil
}
func (m *RecordBodyForLazy) Unmarshal(dAtA []byte) error {
	_, err := m.UnmarshalWithUnknownCallback(dAtA, skipProtoCatalog)
	return err
}
func (m *RecordBodyForLazy) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) (int, error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		err := func() error {
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return fmt.Errorf("proto: RecordBodyForLazy: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return fmt.Errorf("proto: RecordBodyForLazy: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 19:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field RecordBody", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.RecordBody.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := skipFn(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					l = iNdEx
					break
				}
				if skippy == 0 {
					if skippy, err = skipProtoCatalog(dAtA[iNdEx:]); err != nil {
						return err
					}
				}
				if (iNdEx + skippy) < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += skippy
			}
			return nil
		}()
		if err != nil {
			return preIndex, err
		}
	}

	if iNdEx > l {
		return iNdEx, io.ErrUnexpectedEOF
	}
	return iNdEx, nil
}
func (m *CatalogEntry) Unmarshal(dAtA []byte) error {
	_, err := m.UnmarshalWithUnknownCallback(dAtA, skipProtoCatalog)
	return err
}
func (m *CatalogEntry) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) (int, error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		err := func() error {
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return fmt.Errorf("proto: CatalogEntry: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return fmt.Errorf("proto: CatalogEntry: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 16:
				if wireType != 1 {
					return fmt.Errorf("proto: wrong wireType = %d for field DropOrdinal", wireType)
				}
				m.DropOrdinal = 0
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				m.DropOrdinal = DropOrdinal(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
			case 17:
				if wireType != 1 {
					return fmt.Errorf("proto: wrong wireType = %d for field BodyLoc", wireType)
				}
				m.BodyLoc = 0
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				m.BodyLoc = StorageLocator(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
			case 18:
				if wireType != 1 {
					return fmt.Errorf("proto: wrong wireType = %d for field PayloadLoc", wireType)
				}
				m.PayloadLoc = 0
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				m.PayloadLoc = StorageLocator(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
			case 19:
				if wireType != 1 {
					return fmt.Errorf("proto: wrong wireType = %d for field BodyPayloadSizes", wireType)
				}
				m.BodyPayloadSizes = 0
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				m.BodyPayloadSizes = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
			case 20:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field ExtensionLoc", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.ExtensionLoc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 21:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field EntryData", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.EntryData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := skipFn(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					l = iNdEx
					break
				}
				if skippy == 0 {
					if skippy, err = skipProtoCatalog(dAtA[iNdEx:]); err != nil {
						return err
					}
				}
				if (iNdEx + skippy) < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += skippy
			}
			return nil
		}()
		if err != nil {
			return preIndex, err
		}
	}

	if iNdEx > l {
		return iNdEx, io.ErrUnexpectedEOF
	}
	return iNdEx, nil
}
func (m *CatalogEntryData) Unmarshal(dAtA []byte) error {
	_, err := m.UnmarshalWithUnknownCallback(dAtA, skipProtoCatalog)
	return err
}
func (m *CatalogEntryData) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) (int, error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		err := func() error {
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return fmt.Errorf("proto: CatalogEntryData: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return fmt.Errorf("proto: CatalogEntryData: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 16:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
				}
				m.RecordType = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.RecordType |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 18:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field BodyDigest", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.BodyDigest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 19:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field PayloadDigests", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.PayloadDigests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 24:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field PrevRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.PrevRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 25:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field RootRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.RootRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 26:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field ReasonRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.ReasonRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 27:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field RedirectRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.RedirectRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 28:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field RejoinRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.RejoinRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 40:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field RecordRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.RecordRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 41:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field ProducerSignature", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.ProducerSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 42:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field ProducedBy", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.ProducedBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 44:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field RegistrarSignature", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.RegistrarSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 45:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field RegisteredBy", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.RegisteredBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			case 50:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field RecapRef", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if err := m.RecapRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := skipFn(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					l = iNdEx
					break
				}
				if skippy == 0 {
					if skippy, err = skipProtoCatalog(dAtA[iNdEx:]); err != nil {
						return err
					}
				}
				if (iNdEx + skippy) < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += skippy
			}
			return nil
		}()
		if err != nil {
			return preIndex, err
		}
	}

	if iNdEx > l {
		return iNdEx, io.ErrUnexpectedEOF
	}
	return iNdEx, nil
}
func (m *ExtLocators) Unmarshal(dAtA []byte) error {
	_, err := m.UnmarshalWithUnknownCallback(dAtA, skipProtoCatalog)
	return err
}
func (m *ExtLocators) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) (int, error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		err := func() error {
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return fmt.Errorf("proto: ExtLocators: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return fmt.Errorf("proto: ExtLocators: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 17:
				if wireType != 2 {
					return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				m.Ext = append(m.Ext, ExtLocator{})
				if err := m.Ext[len(m.Ext)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := skipFn(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					l = iNdEx
					break
				}
				if skippy == 0 {
					if skippy, err = skipProtoCatalog(dAtA[iNdEx:]); err != nil {
						return err
					}
				}
				if (iNdEx + skippy) < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += skippy
			}
			return nil
		}()
		if err != nil {
			return preIndex, err
		}
	}

	if iNdEx > l {
		return iNdEx, io.ErrUnexpectedEOF
	}
	return iNdEx, nil
}
func (m *ExtLocator) Unmarshal(dAtA []byte) error {
	_, err := m.UnmarshalWithUnknownCallback(dAtA, skipProtoCatalog)
	return err
}
func (m *ExtLocator) UnmarshalWithUnknownCallback(dAtA []byte, skipFn func([]byte) (int, error)) (int, error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		err := func() error {
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return fmt.Errorf("proto: ExtLocator: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return fmt.Errorf("proto: ExtLocator: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 17:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field ExtensionID", wireType)
				}
				m.ExtensionID = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.ExtensionID |= ExtensionID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 18:
				if wireType != 1 {
					return fmt.Errorf("proto: wrong wireType = %d for field PayloadLoc", wireType)
				}
				m.PayloadLoc = 0
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				m.PayloadLoc = StorageLocator(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
			case 20:
				if wireType != 0 {
					return fmt.Errorf("proto: wrong wireType = %d for field PayloadSize", wireType)
				}
				m.PayloadSize = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoCatalog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					m.PayloadSize |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := skipFn(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					l = iNdEx
					break
				}
				if skippy == 0 {
					if skippy, err = skipProtoCatalog(dAtA[iNdEx:]); err != nil {
						return err
					}
				}
				if (iNdEx + skippy) < 0 {
					return ErrInvalidLengthProtoCatalog
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += skippy
			}
			return nil
		}()
		if err != nil {
			return preIndex, err
		}
	}

	if iNdEx > l {
		return iNdEx, io.ErrUnexpectedEOF
	}
	return iNdEx, nil
}
func skipProtoCatalog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProtoCatalog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtoCatalog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProtoCatalog
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProtoCatalog
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProtoCatalog
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProtoCatalog        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProtoCatalog          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProtoCatalog = fmt.Errorf("proto: unexpected end of group")
	ErrExpectedBinaryMarkerProtoCatalog = fmt.Errorf("proto: binary marker was expected")
)
