// Copyright 2020 Insolar Network Ltd.
// All rights reserved.
// This material is licensed under the Insolar License version 1.0,
// available at https://github.com/insolar/assured-ledger/blob/master/LICENSE.md.

// This version is a modified by Insolar Network Ltd.

/*
The size plugin generates a Size or ProtoSize method for each message.
This is useful with the MarshalTo method generated by the marshalto plugin and the
gogoproto.marshaler and gogoproto.marshaler_all extensions.

It is enabled by the following extensions:

  - sizer
  - sizer_all
  - protosizer
  - protosizer_all
*/

// This version was modified by Insolar Network Ltd.

//nolint // the most of code is reused from gogo-proto
package gogobased

import (
	"fmt"
	"sort"
	"strconv"
	"strings"

	"github.com/gogo/protobuf/gogoproto"
	"github.com/gogo/protobuf/proto"
	"github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	"github.com/gogo/protobuf/protoc-gen-gogo/generator"
	"github.com/gogo/protobuf/vanity"

	"github.com/insolar/assured-ledger/ledger-core/cmd/protoc-gen-ins/plugins/extra"
	"github.com/insolar/assured-ledger/ledger-core/insproto"
)

type size struct {
	*generator.Generator
	generator.PluginImports
	atleastOne bool
	localName  string
	typesPkg   generator.Single
	bitsPkg    generator.Single
}

func NewSize() *size {
	return &size{}
}

func (p *size) Name() string {
	return "size"
}

func (p *size) Init(g *generator.Generator) {
	p.Generator = g
}

func wireToType(wire string) int {
	switch wire {
	case "fixed64":
		return proto.WireFixed64
	case "fixed32":
		return proto.WireFixed32
	case "varint":
		return proto.WireVarint
	case "bytes":
		return proto.WireBytes
	case "group":
		return proto.WireBytes
	case "zigzag32":
		return proto.WireVarint
	case "zigzag64":
		return proto.WireVarint
	}
	panic("unreachable")
}

func keySize(fieldNumber int32, wireType int) int {
	x := uint32(fieldNumber)<<3 | uint32(wireType)
	size := 0
	for size = 0; x > 127; size++ {
		x >>= 7
	}
	size++
	return size
}

func (p *size) sizeVarint() {
	p.P(`
	func sov`, p.localName, `(x uint64) (n int) {
                return (`, p.bitsPkg.Use(), `.Len64(x | 1) + 6)/ 7
	}`)
}

func (p *size) sizeZigZag() {
	p.P(`func soz`, p.localName, `(x uint64) (n int) {
		return sov`, p.localName, `(uint64((x << 1) ^ uint64((int64(x) >> 63))))
	}`)
}

func (p *size) std(field *descriptor.FieldDescriptorProto, name string) (string, bool) {
	ptr := ""
	if gogoproto.IsNullable(field) {
		ptr = "*"
	}
	if gogoproto.IsStdTime(field) {
		return p.typesPkg.Use() + `.SizeOfStdTime(` + ptr + name + `)`, true
	} else if gogoproto.IsStdDuration(field) {
		return p.typesPkg.Use() + `.SizeOfStdDuration(` + ptr + name + `)`, true
	} else if gogoproto.IsStdDouble(field) {
		return p.typesPkg.Use() + `.SizeOfStdDouble(` + ptr + name + `)`, true
	} else if gogoproto.IsStdFloat(field) {
		return p.typesPkg.Use() + `.SizeOfStdFloat(` + ptr + name + `)`, true
	} else if gogoproto.IsStdInt64(field) {
		return p.typesPkg.Use() + `.SizeOfStdInt64(` + ptr + name + `)`, true
	} else if gogoproto.IsStdUInt64(field) {
		return p.typesPkg.Use() + `.SizeOfStdUInt64(` + ptr + name + `)`, true
	} else if gogoproto.IsStdInt32(field) {
		return p.typesPkg.Use() + `.SizeOfStdInt32(` + ptr + name + `)`, true
	} else if gogoproto.IsStdUInt32(field) {
		return p.typesPkg.Use() + `.SizeOfStdUInt32(` + ptr + name + `)`, true
	} else if gogoproto.IsStdBool(field) {
		return p.typesPkg.Use() + `.SizeOfStdBool(` + ptr + name + `)`, true
	} else if gogoproto.IsStdString(field) {
		return p.typesPkg.Use() + `.SizeOfStdString(` + ptr + name + `)`, true
	} else if gogoproto.IsStdBytes(field) {
		return p.typesPkg.Use() + `.SizeOfStdBytes(` + ptr + name + `)`, true
	}
	return "", false
}

func (p *size) generateField(proto3, notation, zeroableDefault, mustBeIncluded bool, message *generator.Descriptor, field *descriptor.FieldDescriptorProto, sizeName string) {
	fieldname := p.GetOneOfFieldName(message, field)
	nullable := gogoproto.IsNullable(field)
	repeated := field.IsRepeated()
	required := field.IsRequired()

	doNilCheck := gogoproto.NeedsNilCheck(proto3, field)
	if repeated {
		p.P(`if len(m.`, fieldname, `) > 0 {`)
		p.In()
	} else if doNilCheck {
		p.P(`if m.`, fieldname, ` != nil {`)
		p.In()
	}
	packed := field.IsPacked() || (proto3 && field.IsPacked3())
	_, wire := p.GoType(message, field)
	wireType := wireToType(wire)
	fieldNumber := field.GetNumber()

	if packed {
		wireType = proto.WireBytes
	}
	key := keySize(fieldNumber, wireType)

	switch *field.Type {
	case descriptor.FieldDescriptorProto_TYPE_DOUBLE,
		descriptor.FieldDescriptorProto_TYPE_FIXED64,
		descriptor.FieldDescriptorProto_TYPE_SFIXED64:
		if packed {
			p.P(`n+=`, strconv.Itoa(key), `+sov`, p.localName, `(uint64(len(m.`, fieldname, `)*8))`, `+len(m.`, fieldname, `)*8`)
		} else if repeated {
			p.P(`n+=`, strconv.Itoa(key+8), `*len(m.`, fieldname, `)`)
		} else if proto3 && !mustBeIncluded {
			p.P(`if m.`, fieldname, ` != 0 {`)
			p.In()
			p.P(`n+=`, strconv.Itoa(key+8))
			p.Out()
			p.P(`}`)
		} else if nullable {
			p.P(`n+=`, strconv.Itoa(key+8))
		} else {
			p.P(`n+=`, strconv.Itoa(key+8))
		}
	case descriptor.FieldDescriptorProto_TYPE_FLOAT,
		descriptor.FieldDescriptorProto_TYPE_FIXED32,
		descriptor.FieldDescriptorProto_TYPE_SFIXED32:
		if packed {
			p.P(`n+=`, strconv.Itoa(key), `+sov`, p.localName, `(uint64(len(m.`, fieldname, `)*4))`, `+len(m.`, fieldname, `)*4`)
		} else if repeated {
			p.P(`n+=`, strconv.Itoa(key+4), `*len(m.`, fieldname, `)`)
		} else if proto3 && !mustBeIncluded {
			p.P(`if m.`, fieldname, ` != 0 {`)
			p.In()
			p.P(`n+=`, strconv.Itoa(key+4))
			p.Out()
			p.P(`}`)
		} else if nullable {
			p.P(`n+=`, strconv.Itoa(key+4))
		} else {
			p.P(`n+=`, strconv.Itoa(key+4))
		}
	case descriptor.FieldDescriptorProto_TYPE_INT64,
		descriptor.FieldDescriptorProto_TYPE_UINT64,
		descriptor.FieldDescriptorProto_TYPE_UINT32,
		descriptor.FieldDescriptorProto_TYPE_ENUM,
		descriptor.FieldDescriptorProto_TYPE_INT32:
		if packed {
			p.P(`l = 0`)
			p.P(`for _, e := range m.`, fieldname, ` {`)
			p.In()
			p.P(`l+=sov`, p.localName, `(uint64(e))`)
			p.Out()
			p.P(`}`)
			p.P(`n+=`, strconv.Itoa(key), `+sov`, p.localName, `(uint64(l))+l`)
		} else if repeated {
			p.P(`for _, e := range m.`, fieldname, ` {`)
			p.In()
			p.P(`n+=`, strconv.Itoa(key), `+sov`, p.localName, `(uint64(e))`)
			p.Out()
			p.P(`}`)
		} else if proto3 && !mustBeIncluded {
			p.P(`if m.`, fieldname, ` != 0 {`)
			p.In()
			p.P(`n+=`, strconv.Itoa(key), `+sov`, p.localName, `(uint64(m.`, fieldname, `))`)
			p.Out()
			p.P(`}`)
		} else if nullable {
			p.P(`n+=`, strconv.Itoa(key), `+sov`, p.localName, `(uint64(*m.`, fieldname, `))`)
		} else {
			p.P(`n+=`, strconv.Itoa(key), `+sov`, p.localName, `(uint64(m.`, fieldname, `))`)
		}
	case descriptor.FieldDescriptorProto_TYPE_BOOL:
		if packed {
			p.P(`n+=`, strconv.Itoa(key), `+sov`, p.localName, `(uint64(len(m.`, fieldname, `)))`, `+len(m.`, fieldname, `)*1`)
		} else if repeated {
			p.P(`n+=`, strconv.Itoa(key+1), `*len(m.`, fieldname, `)`)
		} else if proto3 && !mustBeIncluded {
			p.P(`if m.`, fieldname, ` {`)
			p.In()
			p.P(`n+=`, strconv.Itoa(key+1))
			p.Out()
			p.P(`}`)
		} else if nullable {
			p.P(`n+=`, strconv.Itoa(key+1))
		} else {
			p.P(`n+=`, strconv.Itoa(key+1))
		}
	case descriptor.FieldDescriptorProto_TYPE_STRING:
		isRaw := insproto.IsRawBytes(field, true)
		if repeated {
			p.P(`for _, s := range m.`, fieldname, ` { `)
			p.In()
			p.P(`l = len(s)`)
			if !isRaw {
				p.P(`if l > 0 { l++ }`)
			}
			p.P(`n+=`, strconv.Itoa(key), `+l+sov`, p.localName, `(uint64(l))`)
			p.Out()
			p.P(`}`)
		} else if proto3 && !mustBeIncluded {
			p.P(`l=len(m.`, fieldname, `)`)
			p.P(`if l > 0 {`)
			p.In()
			if !isRaw {
				p.P(`l++`)
			}
			p.P(`n+=`, strconv.Itoa(key), `+l+sov`, p.localName, `(uint64(l))`)
			p.Out()
			p.P(`}`)
		} else if nullable {
			p.P(`l=len(*m.`, fieldname, `)`)
			if !isRaw {
				p.P(`if l > 0 { l++ }`)
			}
			p.P(`n+=`, strconv.Itoa(key), `+l+sov`, p.localName, `(uint64(l))`)
		} else {
			p.P(`l=len(m.`, fieldname, `)`)
			if !isRaw {
				p.P(`if l > 0 { l++ }`)
			}
			p.P(`n+=`, strconv.Itoa(key), `+l+sov`, p.localName, `(uint64(l))`)
		}
	case descriptor.FieldDescriptorProto_TYPE_GROUP:
		panic(fmt.Errorf("size does not support group %v", fieldname))
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		if p.IsMap(field) {
			m := p.GoMapType(nil, field)
			_, keywire := p.GoType(nil, m.KeyAliasField)
			valuegoTyp, _ := p.GoType(nil, m.ValueField)
			valuegoAliasTyp, valuewire := p.GoType(nil, m.ValueAliasField)
			_, fieldwire := p.GoType(nil, field)

			nullable, valuegoTyp, valuegoAliasTyp = generator.GoMapValueTypes(field, m.ValueField, valuegoTyp, valuegoAliasTyp)

			fieldKeySize := keySize(field.GetNumber(), wireToType(fieldwire))
			keyKeySize := keySize(1, wireToType(keywire))
			valueKeySize := keySize(2, wireToType(valuewire))
			p.P(`for k, v := range m.`, fieldname, ` { `)
			p.In()
			p.P(`_ = k`)
			p.P(`_ = v`)
			sum := []string{strconv.Itoa(keyKeySize)}
			switch m.KeyField.GetType() {
			case descriptor.FieldDescriptorProto_TYPE_DOUBLE,
				descriptor.FieldDescriptorProto_TYPE_FIXED64,
				descriptor.FieldDescriptorProto_TYPE_SFIXED64:
				sum = append(sum, `8`)
			case descriptor.FieldDescriptorProto_TYPE_FLOAT,
				descriptor.FieldDescriptorProto_TYPE_FIXED32,
				descriptor.FieldDescriptorProto_TYPE_SFIXED32:
				sum = append(sum, `4`)
			case descriptor.FieldDescriptorProto_TYPE_INT64,
				descriptor.FieldDescriptorProto_TYPE_UINT64,
				descriptor.FieldDescriptorProto_TYPE_UINT32,
				descriptor.FieldDescriptorProto_TYPE_ENUM,
				descriptor.FieldDescriptorProto_TYPE_INT32:
				sum = append(sum, `sov`+p.localName+`(uint64(k))`)
			case descriptor.FieldDescriptorProto_TYPE_BOOL:
				sum = append(sum, `1`)
			case descriptor.FieldDescriptorProto_TYPE_STRING,
				descriptor.FieldDescriptorProto_TYPE_BYTES:
				sum = append(sum, `len(k)+sov`+p.localName+`(uint64(len(k)))`)
			case descriptor.FieldDescriptorProto_TYPE_SINT32,
				descriptor.FieldDescriptorProto_TYPE_SINT64:
				sum = append(sum, `soz`+p.localName+`(uint64(k))`)
			}
			switch m.ValueField.GetType() {
			case descriptor.FieldDescriptorProto_TYPE_DOUBLE,
				descriptor.FieldDescriptorProto_TYPE_FIXED64,
				descriptor.FieldDescriptorProto_TYPE_SFIXED64:
				sum = append(sum, strconv.Itoa(valueKeySize))
				sum = append(sum, `8`)
			case descriptor.FieldDescriptorProto_TYPE_FLOAT,
				descriptor.FieldDescriptorProto_TYPE_FIXED32,
				descriptor.FieldDescriptorProto_TYPE_SFIXED32:
				sum = append(sum, strconv.Itoa(valueKeySize))
				sum = append(sum, `4`)
			case descriptor.FieldDescriptorProto_TYPE_INT64,
				descriptor.FieldDescriptorProto_TYPE_UINT64,
				descriptor.FieldDescriptorProto_TYPE_UINT32,
				descriptor.FieldDescriptorProto_TYPE_ENUM,
				descriptor.FieldDescriptorProto_TYPE_INT32:
				sum = append(sum, strconv.Itoa(valueKeySize))
				sum = append(sum, `sov`+p.localName+`(uint64(v))`)
			case descriptor.FieldDescriptorProto_TYPE_BOOL:
				sum = append(sum, strconv.Itoa(valueKeySize))
				sum = append(sum, `1`)
			case descriptor.FieldDescriptorProto_TYPE_STRING:
				sum = append(sum, strconv.Itoa(valueKeySize))
				sum = append(sum, `len(v)+sov`+p.localName+`(uint64(len(v)))`)
			case descriptor.FieldDescriptorProto_TYPE_BYTES:
				if gogoproto.IsCustomType(field) {
					p.P(`l = 0`)
					if nullable {
						p.P(`if v != nil {`)
						p.In()
					}
					p.P(`l = v.`, sizeName, `()`)
					p.P(`l += `, strconv.Itoa(valueKeySize), ` + sov`+p.localName+`(uint64(l))`)
					if nullable {
						p.Out()
						p.P(`}`)
					}
					sum = append(sum, `l`)
				} else {
					p.P(`l = 0`)
					if proto3 {
						p.P(`if len(v) > 0 {`)
					} else {
						p.P(`if v != nil {`)
					}
					p.In()
					p.P(`l = `, strconv.Itoa(valueKeySize), ` + len(v)+sov`+p.localName+`(uint64(len(v)))`)
					p.Out()
					p.P(`}`)
					sum = append(sum, `l`)
				}
			case descriptor.FieldDescriptorProto_TYPE_SINT32,
				descriptor.FieldDescriptorProto_TYPE_SINT64:
				sum = append(sum, strconv.Itoa(valueKeySize))
				sum = append(sum, `soz`+p.localName+`(uint64(v))`)
			case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
				stdSizeCall, stdOk := p.std(m.ValueAliasField, "v")
				if nullable {
					p.P(`l = 0`)
					p.P(`if v != nil {`)
					p.In()
					if stdOk {
						p.P(`l = `, stdSizeCall)
					} else if valuegoTyp != valuegoAliasTyp {
						p.P(`l = ((`, valuegoTyp, `)(v)).`, sizeName, `()`)
					} else {
						p.P(`l = v.`, sizeName, `()`)
					}
					p.P(`l += `, strconv.Itoa(valueKeySize), ` + sov`+p.localName+`(uint64(l))`)
					p.Out()
					p.P(`}`)
					sum = append(sum, `l`)
				} else {
					if stdOk {
						p.P(`l = `, stdSizeCall)
					} else if valuegoTyp != valuegoAliasTyp {
						p.P(`l = ((*`, valuegoTyp, `)(&v)).`, sizeName, `()`)
					} else {
						p.P(`l = v.`, sizeName, `()`)
					}
					sum = append(sum, strconv.Itoa(valueKeySize))
					sum = append(sum, `l+sov`+p.localName+`(uint64(l))`)
				}
			}
			p.P(`mapEntrySize := `, strings.Join(sum, "+"))
			p.P(`n+=mapEntrySize+`, fieldKeySize, `+sov`, p.localName, `(uint64(mapEntrySize))`)
			p.Out()
			p.P(`}`)
		} else if repeated {
			p.P(`for _, e := range m.`, fieldname, ` { `)
			p.In()
			stdSizeCall, stdOk := p.std(field, "e")
			if stdOk {
				p.P(`l=`, stdSizeCall)
			} else {
				p.P(`l=e.`, sizeName, `()`)
			}
			p.P(`n+=`, strconv.Itoa(key), `+l+sov`, p.localName, `(uint64(l))`)
			p.Out()
			p.P(`}`)
		} else {
			stdSizeCall, stdOk := p.std(field, "m."+fieldname)
			if stdOk {
				p.P(`l=`, stdSizeCall)
			} else {
				if !required && !mustBeIncluded && insproto.IsZeroable(field, zeroableDefault) {
					p.P(`if l = m.`, fieldname, `.`, sizeName, `(); l > 0 {`)
					p.In()
					p.P(`n+=`, strconv.Itoa(key), `+l+sov`, p.localName, `(uint64(l))`)
					p.Out()
					p.P("}")
					break
				}
				p.P(`l=m.`, fieldname, `.`, sizeName, `()`)
			}
			p.P(`n+=`, strconv.Itoa(key), `+l+sov`, p.localName, `(uint64(l))`)
		}
	case descriptor.FieldDescriptorProto_TYPE_BYTES:
		if !gogoproto.IsCustomType(field) {
			isRaw := insproto.IsRawBytes(field, !notation)
			if repeated {
				p.P(`for _, b := range m.`, fieldname, ` { `)
				p.In()
				p.P(`l = len(b)`)
				if !isRaw {
					p.P(`if l > 0 { l++ }`)
				}
				p.P(`n+=`, strconv.Itoa(key), `+l+sov`, p.localName, `(uint64(l))`)
				p.Out()
				p.P(`}`)
			} else if proto3 && !mustBeIncluded {
				p.P(`l=len(m.`, fieldname, `)`)
				p.P(`if l > 0 {`)
				p.In()
				if !isRaw {
					p.P(`l++`)
				}
				p.P(`n+=`, strconv.Itoa(key), `+l+sov`, p.localName, `(uint64(l))`)
				p.Out()
				p.P(`}`)
			} else {
				p.P(`l=len(m.`, fieldname, `)`)
				if !isRaw {
					p.P(`if l > 0 { l++ }`)
				}
				p.P(`n+=`, strconv.Itoa(key), `+l+sov`, p.localName, `(uint64(l))`)
			}
		} else {
			isRaw := insproto.IsRawBytes(field, true)
			if repeated {
				p.P(`for _, e := range m.`, fieldname, ` { `)
				p.In()
				p.P(`l=e.`, sizeName, `()`)
				if !isRaw {
					p.P(`if l > 0 { l++ }`)
				}
				p.P(`n+=`, strconv.Itoa(key), `+l+sov`, p.localName, `(uint64(l))`)
				p.Out()
				p.P(`}`)
			} else {
				p.P(`l=m.`, fieldname, `.`, sizeName, `()`)
				if !isRaw {
					p.P(`if l > 0 { l++ }`)
				}
				p.P(`n+=`, strconv.Itoa(key), `+l+sov`, p.localName, `(uint64(l))`)
			}
		}
	case descriptor.FieldDescriptorProto_TYPE_SINT32,
		descriptor.FieldDescriptorProto_TYPE_SINT64:
		if packed {
			p.P(`l = 0`)
			p.P(`for _, e := range m.`, fieldname, ` {`)
			p.In()
			p.P(`l+=soz`, p.localName, `(uint64(e))`)
			p.Out()
			p.P(`}`)
			p.P(`n+=`, strconv.Itoa(key), `+sov`, p.localName, `(uint64(l))+l`)
		} else if repeated {
			p.P(`for _, e := range m.`, fieldname, ` {`)
			p.In()
			p.P(`n+=`, strconv.Itoa(key), `+soz`, p.localName, `(uint64(e))`)
			p.Out()
			p.P(`}`)
		} else if proto3 && !mustBeIncluded {
			p.P(`if m.`, fieldname, ` != 0 {`)
			p.In()
			p.P(`n+=`, strconv.Itoa(key), `+soz`, p.localName, `(uint64(m.`, fieldname, `))`)
			p.Out()
			p.P(`}`)
		} else if nullable {
			p.P(`n+=`, strconv.Itoa(key), `+soz`, p.localName, `(uint64(*m.`, fieldname, `))`)
		} else {
			p.P(`n+=`, strconv.Itoa(key), `+soz`, p.localName, `(uint64(m.`, fieldname, `))`)
		}
	default:
		panic("not implemented")
	}
	if repeated || doNilCheck {
		p.Out()
		p.P(`}`)
	}
}

func (p *size) Generate(file *generator.FileDescriptor) {
	p.PluginImports = generator.NewPluginImports(p.Generator)
	p.atleastOne = false
	p.localName = generator.FileName(file)
	p.typesPkg = p.NewImport("github.com/gogo/protobuf/types")
	protoPkg := p.NewImport("github.com/gogo/protobuf/proto")
	p.bitsPkg = p.NewImport("math/bits")
	if !gogoproto.ImportsGoGoProto(file.FileDescriptorProto) {
		protoPkg = p.NewImport("github.com/golang/protobuf/proto")
	}
	for _, message := range file.Messages() {
		sizeName := ""
		switch {
		case gogoproto.IsProtoSizer(file.FileDescriptorProto, message.DescriptorProto):
			sizeName = "ProtoSize"
		case gogoproto.IsSizer(file.FileDescriptorProto, message.DescriptorProto):
			sizeName = "Size"
		default:
			continue
		}
		if message.DescriptorProto.GetOptions().GetMapEntry() {
			continue
		}

		notation := insproto.IsNotation(file.FileDescriptorProto, message.DescriptorProto)
		zeroableDefault := insproto.IsZeroableDefault(file.FileDescriptorProto, message.DescriptorProto)

		p.atleastOne = true
		ccTypeName := generator.CamelCaseSlice(message.TypeName())
		p.P(`func (m *`, ccTypeName, `) `, sizeName, `() (n int) {`)
		p.In()
		p.P(`if m == nil {`)
		p.In()
		p.P(`return 0`)
		p.Out()
		p.P(`}`)
		p.P(`var l int`)
		p.P(`_ = l`)
		oneofs := make(map[string]struct{})
		proto3 := gogoproto.IsProto3(file.FileDescriptorProto)

		fields := message.GetField()

		mustBeIncluded := false
		addMissingPolymorph := false
		var polymorphField *descriptor.FieldDescriptorProto

		if notation {
			fields = append([]*descriptor.FieldDescriptorProto(nil), fields...)
			sort.Sort(extra.OrderedFields(fields))

			switch {
			case len(fields) == 0 || fields[0].GetNumber() > 19:
				addMissingPolymorph = true
			case fields[0].GetNumber() < 16:
				panic("unexpected field number")
			case fields[0].GetNumber() == 16:
				polymorphField = fields[0]
				fields = fields[1:]
			case insproto.HasPolymorphID(message.DescriptorProto):
				addMissingPolymorph = true
			default:
				mustBeIncluded = !extra.IsMessageProjection(file.FileDescriptorProto, message)
			}
		}

		for _, field := range fields {
			switch {
			case field.GetTypeName() == insproto.FieldMapFQN:
				continue
			case field.OneofIndex == nil:
				p.generateField(proto3, notation, zeroableDefault, mustBeIncluded, message, field, sizeName)
				mustBeIncluded = false
				continue
			}

			fieldname := p.GetFieldName(message, field)
			if _, ok := oneofs[fieldname]; ok {
				continue
			}
			oneofs[fieldname] = struct{}{}
			p.P(`if m.`, fieldname, ` != nil {`)
			p.In()
			p.P(`n+=m.`, fieldname, `.`, sizeName, `()`)
			p.Out()
			p.P(`}`)
		}

		if addMissingPolymorph || polymorphField != nil {
			p.generatePolymorphField(zeroableDefault, message, polymorphField)
		}

		if message.DescriptorProto.HasExtension() {
			if gogoproto.HasExtensionsMap(file.FileDescriptorProto, message.DescriptorProto) {
				p.P(`n += `, protoPkg.Use(), `.SizeOfInternalExtension(m)`)
			} else {
				p.P(`if m.XXX_extensions != nil {`)
				p.In()
				p.P(`n+=len(m.XXX_extensions)`)
				p.Out()
				p.P(`}`)
			}
		}
		if gogoproto.HasUnrecognized(file.FileDescriptorProto, message.DescriptorProto) {
			p.P(`if m.XXX_unrecognized != nil {`)
			p.In()
			p.P(`n+=len(m.XXX_unrecognized)`)
			p.Out()
			p.P(`}`)
		}
		p.P(`return n`)
		p.Out()
		p.P(`}`)
		p.P()

		if len(oneofs) > 0 {
			// Generate Size methods for oneof fields
			m := proto.Clone(message.DescriptorProto).(*descriptor.DescriptorProto)
			for _, f := range m.Field {
				oneof := f.OneofIndex != nil
				if !oneof {
					continue
				}
				ccTypeName := p.OneOfTypeName(message, f)
				p.P(`func (m *`, ccTypeName, `) `, sizeName, `() (n int) {`)
				p.In()
				p.P(`if m == nil {`)
				p.In()
				p.P(`return 0`)
				p.Out()
				p.P(`}`)
				p.P(`var l int`)
				p.P(`_ = l`)
				vanity.TurnOffNullableForNativeTypes(f)
				p.generateField(false, notation, zeroableDefault, false, message, f, sizeName)
				p.P(`return n`)
				p.Out()
				p.P(`}`)
			}
		}
	}

	if !p.atleastOne {
		return
	}

	p.sizeVarint()
	p.sizeZigZag()
}

func (p *size) generatePolymorphField(zeroableDefault bool, message *generator.Descriptor, field *descriptor.FieldDescriptorProto) {
	polymorphID := insproto.GetPolymorphID(message.DescriptorProto)
	if field == nil {
		if polymorphID == 0 {
			p.P(`if n > 0 {`)
			p.In()
		}
		p.P(`n+=2 + sov`, p.localName, `(`, strconv.FormatUint(polymorphID, 10), `)`)
		if polymorphID == 0 {
			p.Out()
			p.P(`}`)
		}
		return
	}

	fieldName := `uint64(m.` + p.GetOneOfFieldName(message, field) + `)`

	hasIf := false
	if insproto.IsZeroable(field, zeroableDefault) {
		p.P(`if n > 0 {`)
		p.In()
		hasIf = true
	}

	funcName := `sov`
	switch field.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_DOUBLE,
		descriptor.FieldDescriptorProto_TYPE_FIXED64,
		descriptor.FieldDescriptorProto_TYPE_SFIXED64:

		p.P(`n+=2 + `, 8)

	case descriptor.FieldDescriptorProto_TYPE_FLOAT,
		descriptor.FieldDescriptorProto_TYPE_FIXED32,
		descriptor.FieldDescriptorProto_TYPE_SFIXED32:

		p.P(`n+=2 + `, 4)

	case descriptor.FieldDescriptorProto_TYPE_SINT32,
		descriptor.FieldDescriptorProto_TYPE_SINT64:

		funcName = `soz`
		fallthrough

	case descriptor.FieldDescriptorProto_TYPE_INT64,
		descriptor.FieldDescriptorProto_TYPE_UINT64,
		descriptor.FieldDescriptorProto_TYPE_INT32,
		descriptor.FieldDescriptorProto_TYPE_UINT32,
		descriptor.FieldDescriptorProto_TYPE_ENUM:

		if polymorphID != 0 {
			if !hasIf {
				p.P(`{`)
				p.In()
				hasIf = true
			}
			p.P(`id := `, fieldName)
			p.P(`if id == 0 { id = `, strconv.FormatUint(polymorphID, 10), ` }`)
			fieldName = `id`
		}

		p.P(`n+=2 + `, funcName, p.localName, `(`, fieldName, `)`)

	default:
		panic(fmt.Errorf("marshaler does not support type (%d) for %v", field.GetType(), fieldName))
	}

	if hasIf {
		p.Out()
		p.P(`}`)
	}
}
